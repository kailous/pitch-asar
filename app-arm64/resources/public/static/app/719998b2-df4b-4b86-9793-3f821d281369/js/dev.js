(function(){
shadow$provide[948]=function(W,A,la,v){function t(E,G){function N(){this.constructor=E}Cd(E,G);E.prototype=null===G?Object.create(G):(N.prototype=G.prototype,new N)}function r(E,G,N,Y){return new (N||(N=Promise))(function(ra,Ha){function ob(hc){try{Eb(Y.next(hc))}catch(Fc){Ha(Fc)}}function qb(hc){try{Eb(Y["throw"](hc))}catch(Fc){Ha(Fc)}}function Eb(hc){hc.done?ra(hc.value):(new N(function(Fc){Fc(hc.value)})).then(ob,qb)}Eb((Y=Y.apply(E,G||[])).next())})}function u(E,G){function N(hc){return function(Fc){return Y([hc,
Fc])}}function Y(hc){if(Ha)throw new TypeError("Generator is already executing.");for(;ra;)try{if(Ha=1,ob&&(qb=hc[0]&2?ob["return"]:hc[0]?ob["throw"]||((qb=ob["return"])&&qb.call(ob),0):ob.next)&&!(qb=qb.call(ob,hc[1])).done)return qb;if(ob=0,qb)hc=[hc[0]&2,qb.value];switch(hc[0]){case 0:case 1:qb=hc;break;case 4:return ra.label++,{value:hc[1],done:!1};case 5:ra.label++;ob=hc[1];hc=[0];continue;case 7:hc=ra.ops.pop();ra.trys.pop();continue;default:if(!(qb=ra.trys,qb=0<qb.length&&qb[qb.length-1])&&
(6===hc[0]||2===hc[0])){ra=0;continue}if(3===hc[0]&&(!qb||hc[1]>qb[0]&&hc[1]<qb[3]))ra.label=hc[1];else if(6===hc[0]&&ra.label<qb[1])ra.label=qb[1],qb=hc;else if(qb&&ra.label<qb[2])ra.label=qb[2],ra.ops.push(hc);else{qb[2]&&ra.ops.pop();ra.trys.pop();continue}}hc=G.call(E,ra)}catch(Fc){hc=[6,Fc],ob=0}finally{Ha=qb=0}if(hc[0]&5)throw hc[1];return{value:hc[0]?hc[1]:void 0,done:!0}}var ra={label:0,sent:function(){if(qb[0]&1)throw qb[1];return qb[1]},trys:[],ops:[]},Ha,ob,qb,Eb;return Eb={next:N(0),"throw":N(1),
"return":N(2)},"function"===typeof Symbol&&(Eb[Symbol.iterator]=function(){return this}),Eb}function f(E){throw Error("'"+E+"' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen");}function a(E){for(var G=E.length,N,Y;0<G;)Y=Math.random()*G|0,G--,N=E[G],E[G]=E[Y],E[Y]=N}function b(E,G,N){return Math.max(E,Math.min(G,N))}function e(E,G){if(!E)throw Error("string"===typeof G?G:G());}function g(E,G,N){void 0===N&&(N="");e(l(E,G),function(){return N+
(" Shapes "+E+" and "+G+" must match")})}function d(E){e(null!=E,function(){return"The input to the tensor constructor must be a non-null value."})}function h(E,G,N){void 0===G&&(G=[]);void 0===N&&(N=!1);null==G&&(G=[]);if(Array.isArray(E)||J(E)&&!N)for(var Y=0;Y<E.length;++Y)h(E[Y],G,N);else G.push(E);return G}function c(E){if(0===E.length)return 1;for(var G=E[0],N=1;N<E.length;N++)G*=E[N];return G}function l(E,G){if(E===G)return!0;if(null==E||null==G||E.length!==G.length)return!1;for(var N=0;N<
E.length;N++)if(E[N]!==G[N])return!1;return!0}function m(E){return 0===E%1}function n(E,G){return G<=E.length?E:E+" ".repeat(G-E.length)}function k(E,G){for(var N=1,Y=-1,ra=0;ra<E.length;++ra)if(0<=E[ra])N*=E[ra];else if(-1===E[ra]){if(-1!==Y)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+(Y+" and dim "+ra));Y=ra}else if(0>E[ra])throw Error("Shapes can not be \x3c 0. Found "+E[ra]+" at dim "+ra);if(-1===Y){if(0<G&&G!==N)throw Error("Size("+G+") must match the product of shape "+
E);return E}if(0===N)throw Error("Cannot infer the missing size in ["+E+"] when there are 0 elements");if(0!==G%N)throw Error("The implicit shape can't be a fractional number. Got "+(G+" / "+N));E=E.slice();E[Y]=G/N;return E}function p(E,G){var N=G.length;E=null==E?G.map(function(Y,ra){return ra}):[].concat(E);e(E.every(function(Y){return Y>=-N&&Y<N}),function(){return"All values in axis param must be in range [-"+N+", "+N+") but got axis "+E});e(E.every(function(Y){return m(Y)}),function(){return"All values in axis param must be integers but got axis "+
E});return E.map(function(Y){return 0>Y?N+Y:Y})}function q(E,G){var N=[],Y=[],ra=null!=G&&Array.isArray(G)&&0===G.length;G=null==G||ra?null:p(G,E).sort();for(var Ha=ra=0;Ha<E.length;++Ha){if(null!=G){if(G[ra]===Ha&&1!==E[Ha])throw Error("Can't squeeze axis "+Ha+" since its dim '"+E[Ha]+"' is not 1");(null==G[ra]||G[ra]>Ha)&&1===E[Ha]&&(N.push(E[Ha]),Y.push(Ha));G[ra]<=Ha&&ra++}1!==E[Ha]&&(N.push(E[Ha]),Y.push(Ha))}return{newShape:N,keptDims:Y}}function w(E,G){if(null==E||"float32"===E)E=new Float32Array(G);
else if("int32"===E)E=new Int32Array(G);else if("bool"===E)E=new Uint8Array(G);else throw Error("Unknown data type "+E);return E}function y(E,G){if(null==E||"float32"===E)E=new Float32Array(G);else if("int32"===E)E=new Int32Array(G);else if("bool"===E)E=new Uint8Array(G);else if("string"===E)E=Array(G);else throw Error("Unknown data type "+E);return E}function C(E,G){for(var N=0;N<E.length;N++){var Y=E[N];if(isNaN(Y)||!isFinite(Y))throw Error("A tensor of type "+G+" being uploaded contains "+Y+".");
}}function z(E){return"bool"===E||"complex64"===E||"float32"===E||"int32"===E||"string"===E}function K(E,G){return"complex64"===G||"float32"===G&&"complex64"!==E||"int32"===G&&"float32"!==E&&"complex64"!==E||"bool"===G&&"bool"===E?!1:!0}function J(E){return E instanceof Float32Array||E instanceof Int32Array||E instanceof Uint8Array}function B(E){if("float32"===E||"int32"===E)return 4;if("complex64"===E)return 8;if("bool"===E)return 1;throw Error("Unknown dtype "+E);}function O(E){if(null==E)return 0;
var G=0;E.forEach(function(N){return G+=N.length});return G}function Q(E){return"string"===typeof E||E instanceof String}function V(E){return"boolean"===typeof E}function M(E){return"number"===typeof E}function F(E){if(Array.isArray(E))return F(E[0]);if(!(E instanceof Float32Array)){if(E instanceof Int32Array||E instanceof Uint8Array)return"int32";if(!M(E)){if(Q(E))return"string";if(V(E))return"bool"}}return"float32"}function D(E){return!!(E&&E.constructor&&E.call&&E.apply)}function H(E,G){for(;G<
E;++G)if(0===E%G)return G;return E}function U(E){var G=E.length;if(2>G)return[];var N=Array(G-1);N[G-2]=E[G-1];for(G-=3;0<=G;--G)N[G]=N[G+1]*E[G+1];return N}function L(E,G,N){var Y=[];if(1===G.length){var ra=G[0];for(G=0;G<ra;G++)Y[G]=N[E+G]}else{ra=G[0];var Ha=G.slice(1),ob=Ha.reduce(function(qb,Eb){return qb*Eb});for(G=0;G<ra;G++)Y[G]=L(E+G*ob,Ha,N)}return Y}function I(E,G){if(0===E.length)return G[0];var N=E.reduce(function(Y,ra){return Y*ra});if(0===N)return[];if(N!==G.length)throw Error("["+
E+"] does not match the input size "+G.length+".");return L(0,E,G)}function T(E,G){E=aa(E,G);for(G=0;G<E.length;G++)E[G]=1;return E}function aa(E,G){if(null==G||"float32"===G||"complex64"===G)return new Float32Array(E);if("int32"===G)return new Int32Array(E);if("bool"===G)return new Uint8Array(E);throw Error("Unknown data type "+G);}function ba(E){E.forEach(function(G){e(Number.isInteger(G)&&0<=G,function(){return"Tensor must have a shape comprised of positive integers but got shape ["+(E+"].")})})}
function Z(E){return E&&E.then&&"function"===typeof E.then}function da(E){var G={};E.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(N){for(var Y=[],ra=1;ra<arguments.length;ra++)Y[ra-1]=arguments[ra];ra=Y[1];G[decodeURIComponent(Y[0])]=decodeURIComponent(ra||"");return Y.join("\x3d")});return G}function pa(){return v.ENV}function fa(){if(null==Qf){if("undefined"!==typeof window)var E=window;else if("undefined"!==typeof W)E=W;else if("undefined"!==typeof Hc)E=Hc;else if("undefined"!==typeof self)E=
self;else throw Error("Could not find a global object");Qf=E}return Qf}function ta(E,G){var N=fa();null==N._tfGlobals&&(N._tfGlobals=new Map);N=N._tfGlobals;N.has(E)||(G=G(),N.set(E,G));return N.get(E)}function ma(E,G){return Zf.get(G+"_"+E)}function ja(E){return Df.get(E)}function qa(E){for(var G=Zf.entries(),N=[];;){var Y=G.next(),ra=Y.value;if(Y.done)break;Y=ra[1];ra[0].split("_")[0]===E&&N.push(Y)}return N}function Fa(E){var G=E.kernelName,N=E.backendName,Y=N+"_"+G;Zf.has(Y)&&console.warn("The kernel '"+
G+"' for backend '"+(N+"' is already registered"));Zf.set(Y,E)}function ua(E){var G=E.kernelName;Df.has(G)&&pa().getBool("DEBUG")&&console.warn("Overriding the gradient for '"+G+"'");Df.set(G,E)}function Ra(E,G){if("string"===G)throw Error("Cannot convert a string[] to a TypedArray");Array.isArray(E)&&(E=h(E));pa().getBool("DEBUG")&&C(E,G);if(E instanceof Float32Array&&"float32"===G||E instanceof Int32Array&&"int32"===G||E instanceof Uint8Array&&"bool"===G)return E;if(null==G||"float32"===G||"complex64"===
G)return new Float32Array(E);if("int32"===G)return new Int32Array(E);if("bool"===G){G=new Uint8Array(E.length);for(var N=0;N<G.length;++N)0!==Math.round(E[N])&&(G[N]=1);return G}throw Error("Unknown data type "+G);}function Ia(){return pa().platform.now()}function oa(E,G){void 0===G&&(G="utf-8");G=G||"utf-8";return pa().platform.encode(E,G)}function Ba(E,G){void 0===G&&(G="utf-8");G=G||"utf-8";return pa().platform.decode(E,G)}function gb(E,G,N){for(var Y={},ra={},Ha=0;Ha<G.length;Ha++)Y[G[Ha].id]=
!0;for(Ha=0;Ha<E.length;Ha++){var ob=E[Ha],qb=ob.inputs,Eb;for(Eb in qb){for(var hc=qb[Eb],Fc=!1,Oc=0;Oc<G.length;Oc++)if(Y[hc.id]){ob.outputs.forEach(function(td){return Y[td.id]=!0});Fc=!0;ra[ob.id]=!0;break}if(Fc)break}}G={};G[N.id]=!0;N={};for(Ha=E.length-1;0<=Ha;Ha--)for(ob=E[Ha],qb=ob.inputs,Oc=0;Oc<ob.outputs.length;Oc++)if(G[ob.outputs[Oc].id]){for(Eb in qb)G[qb[Eb].id]=!0,N[ob.id]=!0;break}qb=[];for(Ha=0;Ha<E.length;Ha++)if(ob=E[Ha],ra[ob.id]&&N[ob.id]){Oc={};for(Eb in ob.inputs)G=ob.inputs[Eb],
Y[G.id]&&(Oc[Eb]=G);G=Object.assign({},ob);G.inputs=Oc;G.outputs=ob.outputs;qb.push(G)}return qb}function Va(E,G,N,Y){var ra=function(ob){var qb=G[ob],Eb=[];qb.outputs.forEach(function(Oc){Oc=E[Oc.id];null!=Oc?Eb.push(Oc):Eb.push(null)});if(null==qb.gradient)throw Error("Cannot compute gradient: gradient function not found for "+(qb.kernelName+"."));var hc=qb.gradient(Eb);ob=function(Oc){if(!(Oc in hc))throw Error("Cannot backprop through input "+Oc+". Available gradients found: "+(Object.keys(hc)+
"."));var td=N(function(){return hc[Oc]()});if("float32"!==td.dtype)throw Error("Error in gradient for op "+qb.kernelName+". The gradient of input "+(Oc+" must have 'float32' dtype, but has '"+td.dtype+"'"));var be=qb.inputs[Oc];if(!l(td.shape,be.shape))throw Error("Error in gradient for op "+qb.kernelName+". The gradient of input '"+(Oc+"' has shape '"+td.shape+"', which does not match the shape of the input '")+(be.shape+"'"));if(null==E[be.id])E[be.id]=td;else{var Fe=E[be.id];E[be.id]=Y(Fe,td);
Fe.dispose()}};for(var Fc in qb.inputs)ob(Fc)},Ha=G.length-1;for(;0<=Ha;Ha--)ra(Ha)}function Ma(E,G,N,Y){var ra=U(G),Ha=ib(E,G,N,ra),ob=G.length;E=Sa(E,G,N,ra,Ha);ra=["Tensor"];Y&&(ra.push("  dtype: "+N),ra.push("  rank: "+ob),ra.push("  shape: ["+G+"]"),ra.push("  values:"));ra.push(E.map(function(qb){return"    "+qb}).join("\n"));return ra.join("\n")}function ib(E,G,N,Y){var ra=c(G);Y=Y[Y.length-1];var Ha=Array(Y).fill(0);G=G.length;E="complex64"===N?S(E):E;if(1<G)for(G=0;G<ra/Y;G++)for(var ob=
G*Y,qb=0;qb<Y;qb++)Ha[qb]=Math.max(Ha[qb],Ja(E[ob+qb],0,N).length);return Ha}function Ja(E,G,N){E=Array.isArray(E)?parseFloat(E[0].toFixed(7))+" + "+(parseFloat(E[1].toFixed(7))+"j"):Q(E)?"'"+E+"'":"bool"===N?0===E?"false":"true":parseFloat(E.toFixed(7)).toString();return n(E,G)}function Sa(E,G,N,Y,ra,Ha){void 0===Ha&&(Ha=!0);var ob="complex64"===N?2:1,qb=G[0],Eb=G.length;if(0===Eb)return"complex64"===N?(Ha=S(E),[Ja(Ha[0],0,N)]):"bool"===N?[0===E[0]?"false":"true"]:[E[0].toString()];if(1===Eb)return 20<
qb?(Ha=Array.from(E.slice(0,3*ob)),Eb=Array.from(E.slice((qb-3)*ob,qb*ob)),"complex64"===N&&(Ha=S(Ha),Eb=S(Eb)),["["+Ha.map(function(be,Fe){return Ja(be,ra[Fe],N)}).join(", ")+", ..., "+Eb.map(function(be,Fe){return Ja(be,ra[qb-3+Fe],N)}).join(", ")+"]"]):["["+("complex64"===N?S(E):Array.from(E)).map(function(be,Fe){return Ja(be,ra[Fe],N)}).join(", ")+"]"];G=G.slice(1);var hc=Y.slice(1),Fc=Y[0]*ob;ob=[];if(20<qb){for(Y=0;3>Y;Y++){var Oc=Y*Fc,td=Oc+Fc;ob.push.apply(ob,Sa(E.slice(Oc,td),G,N,hc,ra,!1))}ob.push("...");
Y=qb-3}else Y=0;for(;Y<qb;Y++)Oc=Y*Fc,td=Oc+Fc,ob.push.apply(ob,Sa(E.slice(Oc,td),G,N,hc,ra,Y===qb-1));E=2===Eb?",":"";ob[0]="["+ob[0]+E;for(Y=1;Y<ob.length-1;Y++)ob[Y]=" "+ob[Y]+E;E=",\n";for(Y=2;Y<Eb;Y++)E+="\n";ob[ob.length-1]=" "+ob[ob.length-1]+"]"+(Ha?"":E);return ob}function S(E){for(var G=[],N=0;N<E.length;N+=2)G.push([E[N],E[N+1]]);return G}function ha(E,G){if("string"===E||"string"===G){if("string"===E&&"string"===G)return"string";throw Error("Can not upcast "+E+" with "+G);}return Zc[E][G]}
function ya(E,G){if(E.dtype===G.dtype)return[E,G];var N=ha(E.dtype,G.dtype);return[E.cast(N),G.cast(N)]}function Qa(E,G){e(E.dtype===G.dtype,function(){return"The dtypes of the first("+E.dtype+") and second("+(G.dtype+") input must match")})}function $a(E){var G=[],N=new Set;cb(E,G,N);return G}function cb(E,G,N){if(null!=E)if(E instanceof Da)G.push(E);else if(Array.isArray(E)||"object"===typeof E)for(var Y in E){var ra=E[Y];N.has(ra)||(N.add(ra),cb(ra,G,N))}}function wa(E){var G=T(c(E),"float32");
return Ic.makeTensor(G,E,"float32")}function Aa(){var E=fa();if(null==E._tfengine){var G=new ef(E);E._tfengine=new id(G)}v.ENV=E._tfengine.ENV;xa=function(){return E._tfengine};return E._tfengine}function lb(E,G){return Ic.runKernelFunc(function(N,Y){N=N.add(E,G);Y([E,G]);return N},{a:E,b:G},null,"Add")}function Ya(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}function Pb(E,G){var N=E;if(J(E))return"string"===G?[]:[E.length];if(!Array.isArray(E))return[];
for(var Y=[];Array.isArray(N)||J(N)&&"string"!==G;)Y.push(N.length),N=N[0];Array.isArray(E)&&pa().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&tb(E,Y,[]);return Y}function tb(E,G,N){N=N||[];if(Array.isArray(E)||J(E)){e(0<G.length,function(){return"Element arr["+N.join("][")+"] should be a primitive, but is an array of "+(E.length+" elements")});e(E.length===G[0],function(){return"Element arr["+N.join("][")+"] should have "+G[0]+" elements, but has "+(E.length+" elements")});for(var Y=G.slice(1),
ra=0;ra<E.length;++ra)tb(E[ra],Y,N.concat(ra))}else e(0===G.length,function(){return"Element arr["+N.join("][")+"] is a primitive, but should be an array/TypedArray of "+(G[0]+" elements")})}function bb(E,G,N,Y){if(null!=E&&("numeric"!==E&&E!==G||"numeric"===E&&"string"===G))throw Error("Argument '"+N+"' passed to '"+Y+"' must be "+(E+" tensor, but got "+G+" tensor"));}function La(E,G,N,Y){void 0===Y&&(Y="numeric");if(E instanceof Da)return bb(Y,E.dtype,G,N),E;var ra=F(E);"string"!==ra&&0<=["bool",
"int32","float32"].indexOf(Y)&&(ra=Y);bb(Y,ra,G,N);if(null==E||!J(E)&&!Array.isArray(E)&&"number"!==typeof E&&"boolean"!==typeof E&&"string"!==typeof E)throw Error("Argument '"+G+"' passed to '"+N+"' must be a Tensor or TensorLike, but got '"+((null==E?"null":E.constructor.name)+"'"));G=Pb(E,ra);J(E)||Array.isArray(E)||(E=[E]);E="string"!==ra?Ra(E,ra):h(E,[],!0);return Ic.makeTensor(E,G,ra)}function Fb(E,G,N,Y){void 0===Y&&(Y="numeric");if(!Array.isArray(E))throw Error("Argument "+G+" passed to "+
N+" must be a `Tensor[]` or `TensorLike[]`");return E.map(function(ra,Ha){return La(ra,G+"["+Ha+"]",N)},Y)}function vb(E){var G=Object.keys(E);if(1!==G.length)throw Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+(G.length+" keys."));var N=G[0],Y=E[N];N.endsWith("_")&&(N=N.substring(0,N.length-1));N+="__op";E=function(){for(var ra=[],Ha=0;Ha<arguments.length;Ha++)ra[Ha]=arguments[Ha];Ic.startScope(N);try{var ob=Y.apply(void 0,ra);Z(ob)&&
console.error("Cannot return a Promise inside of tidy.");Ic.endScope(ob);return ob}catch(qb){throw Ic.endScope(null),qb;}};Object.defineProperty(E,"name",{value:N,configurable:!0});return E}function Xb(E,G,N,Y){null==Y&&(Y=F(E));if("complex64"===Y)throw Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!J(E)&&!Array.isArray(E)&&"number"!==typeof E&&"boolean"!==typeof E&&"string"!==typeof E)throw Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
if(null!=G){ba(G);var ra=c(G),Ha=c(N);e(ra===Ha,function(){return"Based on the provided shape, ["+G+"], the tensor should have "+(ra+" values but has "+Ha)});for(var ob=0;ob<N.length;++ob){var qb=N[ob];qb=ob===N.length-1?qb!==c(G.slice(ob)):!0;e(N[ob]===G[ob]||!qb,function(){return"Error creating a new Tensor. Inferred shape ("+(N+") does not match the provided shape (")+(G+"). ")})}}J(E)||Array.isArray(E)||(E=[E]);G=G||N;E="string"!==Y?Ra(E,Y):h(E,[],!0);return Ic.makeTensor(E,G,Y)}function Mc(E,
G,N){var Y=Pb(E,N);return Xb(E,G,Y,N)}function Yc(E,G){for(var N={},Y,ra=0,Ha=0;Ha<G.length;Ha++){var ob=G[Ha],qb=ob.name,Eb=ob.dtype,hc=ob.shape,Fc=c(hc);if("quantization"in ob){var Oc=ob.quantization;if("uint8"===Oc.dtype||"uint16"===Oc.dtype){if(!("min"in Oc&&"scale"in Oc))throw Error("Weight "+ob.name+" with quantization "+Oc.dtype+" doesn't have corresponding metadata min and scale.");}else if("float16"===Oc.dtype){if("float32"!==Eb)throw Error("Weight "+ob.name+" is quantized with "+Oc.dtype+
" which only supports weights of type float32 not "+(Eb+"."));}else throw Error("Weight "+ob.name+" has unknown quantization dtype "+(Oc.dtype+". Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'."));var td=Nd[Oc.dtype];ob=E.slice(ra,ra+Fc*td);var be="uint8"===Oc.dtype?new Uint8Array(ob):new Uint16Array(ob);if("float32"===Eb)if("uint8"===Oc.dtype||"uint16"===Oc.dtype){ob=new Float32Array(be.length);for(var Fe=0;Fe<be.length;Fe++){var fe=be[Fe];ob[Fe]=fe*Oc.scale+Oc.min}}else if("float16"===
Oc.dtype)void 0===Y&&(Y=Ta()),ob=Y(be);else throw Error("Unsupported quantization type "+Oc.dtype+" for weight type float32.");else if("int32"===Eb){if("uint8"!==Oc.dtype&&"uint16"!==Oc.dtype)throw Error("Unsupported quantization type "+Oc.dtype+" for weight type int32.");ob=new Int32Array(be.length);for(Fe=0;Fe<be.length;Fe++)fe=be[Fe],ob[Fe]=Math.round(fe*Oc.scale+Oc.min)}else throw Error("Unsupported dtype in weight '"+qb+"': "+Eb);ra+=Fc*td}else if("string"===Eb)for(Fc=c(ob.shape),ob=[],Fe=0;Fe<
Fc;Fe++)Oc=(new Uint32Array(E.slice(ra,ra+4)))[0],ra+=4,td=new Uint8Array(E.slice(ra,ra+Oc)),ob.push(td),ra+=Oc;else{Oc=Nd[Eb];ob=E.slice(ra,ra+Fc*Oc);if("float32"===Eb)ob=new Float32Array(ob);else if("int32"===Eb)ob=new Int32Array(ob);else if("bool"===Eb)ob=new Uint8Array(ob);else if("complex64"===Eb){ob=new Float32Array(ob);be=new Float32Array(ob.length/2);td=new Float32Array(ob.length/2);for(Fe=0;Fe<be.length;Fe++)be[Fe]=ob[2*Fe],td[Fe]=ob[2*Fe+1];Fe=Mc(be,hc,"float32");td=Mc(td,hc,"float32");
N[qb]=vd(Fe,td);Fe.dispose();td.dispose()}else throw Error("Unsupported dtype in weight '"+qb+"': "+Eb);ra+=Fc*Oc}"complex64"!==Eb&&(N[qb]=Mc(ob,hc,Eb))}return N}function yd(E){if(null===E)throw Error("Invalid input value: "+JSON.stringify(E));var G=0,N=[];E.forEach(function(Ha){G+=Ha.byteLength;N.push(Ha.byteLength===Ha.buffer.byteLength?Ha:new Ha.constructor(Ha));if(!(Ha instanceof Float32Array||Ha instanceof Int32Array||Ha instanceof Uint8Array))throw Error("Unsupported TypedArray subtype: "+Ha.constructor.name);
});var Y=new Uint8Array(G),ra=0;N.forEach(function(Ha){Y.set(new Uint8Array(Ha.buffer),ra);ra+=Ha.byteLength});return Y.buffer}function pd(E){return de?md.byteLength(E):(new Blob([E])).size}function sc(E){if(1===E.length)return E[0];var G=0;E.forEach(function(ra){G+=ra.byteLength});var N=new Uint8Array(G),Y=0;E.forEach(function(ra){N.set(new Uint8Array(ra),Y);Y+=ra.byteLength});return N.buffer}function tc(E){for(E=E.trim();E.endsWith("/");)E=E.slice(0,E.length-1);E=E.split("/");return E[E.length-
1]}function vc(E){if(E.modelTopology instanceof ArrayBuffer)throw Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==E.modelTopology?0:pd(JSON.stringify(E.modelTopology)),weightSpecsBytes:null==E.weightSpecs?0:pd(JSON.stringify(E.weightSpecs)),weightDataBytes:null==E.weightData?0:E.weightData.byteLength}}function $c(){var E=new Uint32Array(2048);E[0]=0;for(var G=1;1024>G;G++){for(var N=G,Y=G<<13,ra=0;0===(Y&8388608);)ra-=
8388608,Y<<=1;E[N]=Y&-8388609|ra+947912704}for(G=1024;2048>G;G++)E[G]=939524096+(G-1024<<13);return E}function xd(){var E=new Uint32Array(64);E[0]=0;E[31]=1199570944;E[32]=2147483648;E[63]=3347054592;for(var G=1;31>G;G++)E[G]=G<<23;for(G=33;63>G;G++)E[G]=2147483648+(G-32<<23);return E}function ab(){for(var E=new Uint32Array(64),G=0;64>G;G++)E[G]=1024;E[0]=E[32]=0;return E}function Ta(){var E=$c(),G=xd(),N=ab();return function(Y){for(var ra=new ArrayBuffer(4*Y.length),Ha=new Uint32Array(ra),ob=0;ob<
Y.length;ob++){var qb=Y[ob];Ha[ob]=E[N[qb>>10]+(qb&1023)]+G[qb>>10]}return new Float32Array(ra)}}function jb(){if(!pa().getBool("IS_BROWSER"))throw Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");var E="undefined"===typeof window?self:window;E=E.indexedDB||E.mozIndexedDB||E.webkitIndexedDB||E.msIndexedDB||E.shimIndexedDB;if(null==E)throw Error("The current browser does not appear to support IndexedDB.");return E}function Wb(E){E=E.result;E.createObjectStore("models_store",
{keyPath:"modelPath"});E.createObjectStore("model_info_store",{keyPath:"modelPath"})}function xc(E){return E.startsWith(xe.URL_SCHEME)?E.slice(xe.URL_SCHEME.length):E}function Ec(E){return{info:["tensorflowjs_models",E,"info"].join("/"),topology:["tensorflowjs_models",E,"model_topology"].join("/"),weightSpecs:["tensorflowjs_models",E,"weight_specs"].join("/"),weightData:["tensorflowjs_models",E,"weight_data"].join("/"),modelMetadata:["tensorflowjs_models",E,"model_metadata"].join("/")}}function dd(E){if(-1===
E.indexOf("://"))throw Error("The url string provided does not contain a scheme. Supported schemes are: "+yb.getSchemes().join(","));return{scheme:E.split("://")[0],path:E.split("://")[1]}}function Dc(E,G,N){void 0===N&&(N=!1);return r(this,void 0,void 0,function(){var Y,ra,Ha,ob,qb,Eb,hc,Fc,Oc;return u(this,function(td){switch(td.label){case 0:return e(E!==G,function(){return"Old path and new path are the same: '"+E+"'"}),Y=ne.getLoadHandlers(E),e(0<Y.length,function(){return"Copying failed because no load handler is found for source URL "+
E+"."}),e(2>Y.length,function(){return"Copying failed because more than one ("+Y.length+") load handlers for source URL "+(E+".")}),ra=Y[0],Ha=ne.getSaveHandlers(G),e(0<Ha.length,function(){return"Copying failed because no save handler is found for destination URL "+(G+".")}),e(2>Ha.length,function(){return"Copying failed because more than one ("+Y.length+") save handlers for destination URL "+(G+".")}),ob=Ha[0],qb=dd(E).scheme,Eb=dd(E).path,hc=qb===dd(E).scheme,[4,ra.load()];case 1:return Fc=td.sent(),
N&&hc?[4,yb.getManager(qb).removeModel(Eb)]:[3,3];case 2:td.sent(),td.label=3;case 3:return[4,ob.save(Fc)];case 4:return Oc=td.sent(),!N||hc?[3,6]:[4,yb.getManager(qb).removeModel(Eb)];case 5:td.sent(),td.label=6;case 6:return[2,Oc.modelArtifactsInfo]}})})}function kd(E,G,N){void 0===G&&(G="float32");G=G||"float32";ba(E);return new Ua(E,G,N)}function ld(E,G){void 0===G&&(G=!1);console.log(E.toString(G))}function Nb(E){return(new Promise(function(G){return setTimeout(G)})).then(E)}function Sb(E,G,
N,Y){(function(Ha){e(null!=Ha&&Array.isArray(Ha)&&0<Ha.length,function(){return"promises must be a none empty array"})})(E);N=null==N?0:N;Y=null==Y?1:Y;(function(Ha,ob){e(0<=Ha&&1>=Ha,function(){return"Progress fraction must be in range [0, 1], but got startFraction "+Ha});e(0<=ob&&1>=ob,function(){return"Progress fraction must be in range [0, 1], but got endFraction "+ob});e(ob>=Ha,function(){return"startFraction must be no more than endFraction, but got startFraction "+(Ha+" and endFraction ")+
ob})})(N,Y);var ra=0;return Promise.all(E.map(function(Ha){Ha.then(function(ob){var qb=N+ ++ra/E.length*(Y-N);G(qb);return ob});return Ha}))}function Tb(E,G){return r(this,void 0,void 0,function(){var N,Y,ra,Ha,ob,qb,Eb,hc,Fc,Oc,td;return u(this,function(be){switch(be.label){case 0:return null==G&&(G={}),N=null==G.fetchFunc?pa().platform.fetch:G.fetchFunc,Y=E.map(function(Fe){return N(Fe,G.requestInit,{isBinary:!0})}),ra=0,Ha=.5,null!=G.onProgress?[3,2]:[4,Promise.all(Y)];case 1:return qb=be.sent(),
[3,4];case 2:return[4,Sb(Y,G.onProgress,ra,Ha)];case 3:qb=be.sent(),be.label=4;case 4:return ob=qb,Eb=ob.map(function(Fe){return Fe.arrayBuffer()}),hc=.5,Fc=1,null!=G.onProgress?[3,6]:[4,Promise.all(Eb)];case 5:return td=be.sent(),[3,8];case 6:return[4,Sb(Eb,G.onProgress,hc,Fc)];case 7:td=be.sent(),be.label=8;case 8:return Oc=td,[2,Oc]}})})}function Ac(E){var G=this;return function(N,Y,ra){void 0===Y&&(Y="");return r(G,void 0,void 0,function(){var Ha,ob,qb,Eb,hc,Fc,Oc,td,be,Fe;return u(this,function(fe){switch(fe.label){case 0:Ha=
N.map(function(){return!1});ob={};qb=null!=ra?ra.map(function(){return!1}):[];Eb=[];N.forEach(function(Be,Me){var hf=0;Be.weights.forEach(function(Se){var Hf=Nd["quantization"in Se?Se.quantization.dtype:Se.dtype]*c(Se.shape),yf=function(){Ha[Me]=!0;null==ob[Me]&&(ob[Me]=[]);ob[Me].push({manifestEntry:Se,groupOffset:hf,sizeBytes:Hf})};null!=ra?ra.forEach(function(Sf,af){Sf===Se.name&&(yf(),qb[af]=!0)}):yf();Eb.push(Se.name);hf+=Hf})});if(!qb.every(function(Be){return Be}))throw hc=ra.filter(function(Be,
Me){return!qb[Me]}),Error("Could not find weights in manifest with names: "+(hc.join(", ")+". \nManifest JSON has weights with names: ")+(Eb.join(", ")+"."));Fc=Ha.reduce(function(Be,Me,hf){Me&&Be.push(hf);return Be},[]);Oc=[];Fc.forEach(function(Be){N[Be].paths.forEach(function(Me){Me=Y+(Y.endsWith("/")?"":"/")+Me;Oc.push(Me)})});return[4,E(Oc)];case 1:return td=fe.sent(),be={},Fe=0,Fc.forEach(function(Be){for(var Me=N[Be].paths.length,hf=0,Se=0;Se<Me;Se++)hf+=td[Fe+Se].byteLength;var Hf=new ArrayBuffer(hf);
hf=new Uint8Array(Hf);for(var yf=Se=0;yf<Me;yf++){var Sf=new Uint8Array(td[Fe+yf]);hf.set(Sf,Se);Se+=Sf.byteLength}ob[Be].forEach(function(af){var tf=Hf.slice(af.groupOffset,af.groupOffset+af.sizeBytes);af=Yc(tf,[af.manifestEntry]);for(var zf in af)be[zf]=af[zf]});Fe+=Me}),[2,be]}})})}}function Kc(E){return null!=E.match(pf.URL_SCHEME_REGEX)}function Vc(E,G){return new pf(E,G)}function Pc(E,G,N){d(E);if(null!=G&&3!==G.length)throw Error("tensor3d() requires shape to have three numbers");var Y=Pb(E,
N);if(3!==Y.length&&1!==Y.length)throw Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===Y.length&&null==G)throw Error("tensor3d() requires shape to be provided when `values` are a flat array");return Xb(E,G,Y,N)}function gd(E,G){if(1>E.rank)throw Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+(E.rank+"."));if(1>G.rank)throw Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+(G.rank+"."));if("int32"!==
G.dtype)throw Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+(G.dtype+"."));if(G.shape[G.rank-1]>E.rank)throw Error("index innermost dimension length must be \x3c\x3d tensor rank; saw: "+(G.shape[G.rank-1]+" vs. "+E.rank));if(0===E.size)throw Error("Requested more than 0 entries, but input is empty. Input shape: "+(E.shape+"."));var N=G.shape,Y=N[N.length-1];G=1;for(var ra=0;ra<N.length-1;++ra)G*=N[ra];var Ha=E.shape;N=N.slice();N.pop();var ob=1;for(ra=Y;ra<E.rank;++ra)ob*=
Ha[ra],N.push(Ha[ra]);E=U(E.shape).map(function(qb){return qb/ob}).concat([1]).slice(0,Y);return[N,G,ob,E]}function Dd(E,G,N){var Y=1<G.rank?G.shape[G.rank-1]:1,ra=1<G.rank?G.rank-1:1,Ha="Must have updates.shape \x3d indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+N.shape+(", indices.shape: "+G.shape+", shape: "+E)+(", sliceDim: "+Y+", and batchDim: "+ra+".");if(N.rank<ra)throw Error(Ha+(" update.rank \x3c "+ra+". "));if(E.length<Y+(N.rank-ra))throw Error(Ha+(" Output shape length \x3c "+
(Y+(N.rank-ra))));if(N.rank!==ra+E.length-Y)throw Error(Ha+(" update.rank !\x3d "+(ra+E.length-Y)));for(var ob=0;ob<ra;++ob)if(N.shape[ob]!==G.shape[ob])throw Error(Ha+(" updates.shape["+ob+"] ("+N.shape[ob]+") !\x3d indices.shape["+ob+"] ("+G.shape[ob]+")."));for(ob=0;ob<N.rank-ra;++ob)if(N.shape[ob+ra]!==E[ob+Y])throw Error(Ha+(" updates.shape["+(ob+ra)+"] ("+N.shape[ob+ra]+") !\x3d shape["+(ob+ra)+"] ("+E[ob+ra]+")"));}function Jd(E,G,N){if(1>G.rank)throw Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+
(G.rank+"."));if(1>E.rank)throw Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+(E.rank+"."));if("int32"!==G.dtype)throw Error("The dtype of 'indices' should be int32, but got dtype: "+G.dtype);if(1>N.length)throw Error("Output rank must be greater or equal to 1, but got shape: "+N);if(0===N.length){if(0===G.size)throw Error("Indices specified for empty output. indices shape: "+G.shape);if(0===E.size)throw Error("Updates specified for empty output. updates shape: "+
E.shape);}Dd(N,G,E)}function we(E,G,N){E=G.shape.length;E=1<E?G.shape[E-1]:1;for(var Y=N.length,ra=1,Ha=E;Ha<Y;++Ha)ra*=N[Ha];Y=1>E?1:E;G=c(G.shape)/Y;Y=U(N.slice(0,E)).concat([1]);N=c(N);return{sliceRank:E,numUpdates:G,sliceSize:ra,strides:Y,outputSize:N}}function Ne(E,G,N){var Y=E.shape.length;e(Y===G.length,function(){return"Error in slice"+Y+"D: Length of begin "+G+" must match the rank of the array ("+(Y+").")});e(Y===N.length,function(){return"Error in slice"+Y+"D: Length of size "+N+" must match the rank of the array ("+
(Y+").")});for(var ra=function(ob){e(G[ob]+N[ob]<=E.shape[ob],function(){return"Error in slice"+Y+"D: begin["+ob+"] + size["+ob+"] ("+(G[ob]+N[ob]+") would overflow input.shape["+ob+"] ("+E.shape[ob]+")")})},Ha=0;Ha<Y;++Ha)ra(Ha)}function Je(E){for(var G=[],N=0;0<E;)E&1&&G.push(N),E/=2,N++;return G}function Qe(E,G,N){for(var Y=[],ra=0;ra<E.length;ra++)Y[ra]=Math.ceil((G[ra]-E[ra])/N[ra]);return Y}function Ce(E,G,N,Y){E=E.slice();for(var ra=E.length;ra<Y.length;ra++)E.push(1);for(ra=0;ra<N;ra++)0===
ra?E[G]=1:(E.splice(G,0,1),E.pop());return E}function Oe(E,G){for(var N=[],Y=0;Y<E;Y++)N.push(G+Y);return N}function od(E,G,N,Y,ra,Ha,ob,qb,Eb){var hc=E.length,Fc=Array(hc),Oc=Array(hc),td=Array(hc);if(G.length&&0<N)Eb=G[0],N+=1,Fc=Ud(ob,Eb,N,Y,E),Oc=Rd(qb,Eb,N,ra,E),td=Ce(Ha,Eb,N,E);else for(N=0;N<hc;N++)Fc[N]=Ue(ob,Y,Ha,E,N,Eb),Oc[N]=lc(qb,ra,Ha,E,N,Eb),td[N]=pc(Ha,N,Eb);return{begin:Fc,end:Oc,strides:td}}function Ud(E,G,N,Y,ra){ra=ra.slice();for(var Ha=Oe(N,G),ob=0;ob<ra.length;ob++)if(-1<Ha.indexOf(ob))ra[ob]=
0;else{var qb=ob<=G?ob:ob-(N-1),Eb=Y[qb];E&1<<qb&&(Eb=0);ra[ob]=Eb}return ra}function Rd(E,G,N,Y,ra){for(var Ha=ra.slice(),ob=Oe(N,G),qb=0;qb<Ha.length;qb++)if(-1<ob.indexOf(qb))Ha[qb]=Number.MAX_SAFE_INTEGER;else{var Eb=qb<=G?qb:qb-(N-1),hc=Y[Eb];E&1<<Eb&&(hc=Number.MAX_SAFE_INTEGER);Ha[qb]=hc}for(E=0;E<Ha.length;E++)G=ra[E],0>Ha[E]&&(Ha[E]+=G),Ha[E]=b(0,Ha[E],ra[E]);return Ha}function pc(E,G,N){E=E[G];if(N&1<<G||null==E)E=1;return E}function Ue(E,G,N,Y,ra,Ha){G=G[ra];N=N[ra]||1;if(E&1<<ra||Ha&1<<
ra||null==G)G=0<N?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER;E=Y[ra];0>G&&(G+=E);return G=b(0,G,E-1)}function lc(E,G,N,Y,ra,Ha){G=G[ra];N=N[ra]||1;if(E&1<<ra||Ha&1<<ra||null==G)G=0<N?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER;E=Y[ra];0>G&&(G+=E);return G=0<N?b(0,G,E):b(-1,G,E-1)}function pe(E,G,N){var Y=E.shape.length;var ra="number"===typeof G?[G].concat(Array(Y-1).fill(0)):G.length<Y?G.concat(Array(Y-G.length).fill(0)):G.slice();ra.forEach(function(Ha){e(-1!==Ha,function(){return"slice() does not support negative begin indexing."})});
G=null==N?Array(Y).fill(-1):"number"===typeof N?[N].concat(Array(Y-1).fill(-1)):N.length<Y?N.concat(Array(Y-N.length).fill(-1)):N;G=G.map(function(Ha,ob){if(0<=Ha)return Ha;e(-1===Ha,function(){return"Negative size values should be exactly -1 but got "+(Ha+" for the slice() size at index "+ob+".")});return E.shape[ob]-ra[ob]});return[ra,G]}function rc(E){e(null!=E.className,function(){return"Class being registered does not have the static className property defined."});e("string"===typeof E.className,
function(){return"className is required to be a string, but got type "+typeof E.className});e(0<E.className.length,function(){return"Class being registered has an empty-string as its className, which is disallowed."});gh.register(E)}function qc(){return 32===Ic.backend.floatPrecision()?.001:.1}function Ib(E,G,N){var Y=!0;if(J(E)||J(G))Y=!1;J(E)&&J(G)&&(Y=!0);if(Y){Y=E.constructor.name;var ra=G.constructor.name;if(Y!==ra)throw Error("Arrays are of different type. Actual: "+Y+". Expected: "+ra);}if(Array.isArray(E)&&
Array.isArray(G)&&(Y=Pb(E),ra=Pb(G),!l(Y,ra)))throw Error("Arrays have different shapes. Actual: ["+(Y+"]. Expected: ["+ra+"]"));E=J(E)?E:h(E);G=J(G)?G:h(G);if(E.length!==G.length)throw Error("Arrays have different lengths actual: "+E.length+" vs expected: "+(G.length+".\nActual:   ")+(E+".\nExpected: ")+(G+"."));for(Y=0;Y<G.length;++Y){ra=E[Y];var Ha=G[Y];if(!N(ra,Ha))throw Error("Arrays differ: actual["+Y+"] \x3d "+ra+", expected["+Y+"] \x3d "+Ha+".\nActual:   "+(E+".\nExpected: ")+(G+"."));}}function Ga(E,
G,N){return isFinite(E)||isFinite(G)?isNaN(E)||isNaN(G)||Math.abs(E-G)>N?!1:!0:!0}function hb(E){pa().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(E+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Rb(E,G){return Ic.tidy(E,G)}function mc(E){$a(E).forEach(function(G){return G.dispose()})}function Ub(E){return Ic.keep(E)}function ic(E,G){for(var N=0;N<E.length;++N)if(E[E.length-N-1]!==G-1-N)return!1;return!0}function jc(E,G,N){for(var Y=E.length+G.length,
ra=[],Ha=0,ob=0,qb=0;qb<Y;qb++)-1===N.indexOf(qb)?ra.push(E[Ha++]):ra.push(G[ob++]);return ra}function Ob(E,G){for(var N=[],Y=E.length,ra=0;ra<Y;ra++)-1===G.indexOf(ra)&&N.push(E[ra]);G=G.map(function(Ha){return E[Ha]});return[N,G]}function fc(E,G){var N=G.map(function(Y){return 1});return jc(E,N,G)}function yc(E,G){if(ic(E,G))return null;for(var N=[],Y=0;Y<G;++Y)-1===E.indexOf(Y)&&N.push(Y);E.forEach(function(ra){return N.push(ra)});return N}function fd(E){return E.map(function(G,N){return[N,G]}).sort(function(G,
N){return G[1]-N[1]}).map(function(G){return G[0]})}function Ad(E,G){var N=[];for(E=G-E;E<G;++E)N.push(E);return N}function Gd(E,G,N,Y,ra,Ha,ob){void 0===ob&&(ob="channelsLast");var qb=Lb(G);G=qb[0];qb=qb[1];if("channelsLast"===ob)G=[G,qb,E[3],E[3]];else if("channelsFirst"===ob)G=[G,qb,E[1],E[1]];else throw Error("Unknown dataFormat "+ob);return Re(E,G,N,Y,ra,Ha,!1,ob)}function Ge(E,G,N,Y,ra,Ha,ob){void 0===ob&&(ob="NDHWC");var qb=oc(G);G=qb[0];var Eb=qb[1];qb=qb[2];if("NDHWC"===ob)ob="channelsLast",
G=[G,Eb,qb,E[4],E[4]];else if("NCDHW"===ob)ob="channelsFirst",G=[G,Eb,qb,E[1],E[1]];else throw Error("Unknown dataFormat "+ob);return mf(E,G,N,Y,ra,!1,ob,Ha)}function Re(E,G,N,Y,ra,Ha,ob,qb){void 0===ob&&(ob=!1);void 0===qb&&(qb="channelsLast");if("channelsLast"===qb){var Eb=E[0];var hc=E[1];var Fc=E[2];var Oc=E[3]}else if("channelsFirst"===qb)Eb=E[0],Oc=E[1],hc=E[2],Fc=E[3];else throw Error("Unknown dataFormat "+qb);var td=G[0],be=G[1],Fe=G[3],fe=Lb(N);N=fe[0];fe=fe[1];var Be=Lb(Y);Y=Be[0];Be=Be[1];
var Me=Lc(td,Y),hf=Lc(be,Be),Se=hc,Hf=Fc,yf=qb;if("number"===typeof ra)yf={top:ra,bottom:ra,left:ra,right:ra,type:0===ra?"VALID":"NUMBER"},Ha=Ze([Se,Hf],Me,N,ra,Ha),ra=Ha[0],Ha=Ha[1];else if("same"===ra){ra=Math.ceil(Se/N);Ha=Math.ceil(Hf/fe);yf=Math.max(0,(ra-1)*N+Me-Se);Hf=Math.max(0,(Ha-1)*fe+hf-Hf);Se=Math.floor(yf/2);var Sf=Math.floor(Hf/2);yf={top:Se,bottom:yf-Se,left:Sf,right:Hf-Sf,type:"SAME"}}else if("valid"===ra)yf={top:0,bottom:0,left:0,right:0,type:"VALID"},ra=Math.ceil((Se-Me+1)/N),Ha=
Math.ceil((Hf-hf+1)/fe);else if("object"===typeof ra){var af="channelsLast"===yf?ra[1][0]:ra[2][0];var tf="channelsLast"===yf?ra[1][1]:ra[2][1];Sf="channelsLast"===yf?ra[2][0]:ra[3][0];var zf="channelsLast"===yf?ra[2][1]:ra[3][1];yf={top:af,bottom:tf,left:Sf,right:zf,type:0===af&&0===tf&&0===Sf&&0===zf?"VALID":"EXPLICIT"};ra=ed((Se-Me+af+tf)/N+1,Ha);Ha=ed((Hf-hf+Sf+zf)/fe+1,Ha)}else throw Error("Unknown padding parameter: "+ra);Sf=ra;ob=ob?Fe*Oc:Fe;var ig;"channelsFirst"===qb?ig=[Eb,ob,Sf,Ha]:"channelsLast"===
qb&&(ig=[Eb,Sf,Ha,ob]);return{batchSize:Eb,dataFormat:qb,inHeight:hc,inWidth:Fc,inChannels:Oc,outHeight:Sf,outWidth:Ha,outChannels:ob,padInfo:yf,strideHeight:N,strideWidth:fe,filterHeight:td,filterWidth:be,effectiveFilterHeight:Me,effectiveFilterWidth:hf,dilationHeight:Y,dilationWidth:Be,inShape:E,outShape:ig,filterShape:G}}function mf(E,G,N,Y,ra,Ha,ob,qb){void 0===Ha&&(Ha=!1);void 0===ob&&(ob="channelsLast");if("channelsLast"===ob){var Eb=E[0];var hc=E[1];var Fc=E[2];var Oc=E[3];var td=E[4]}else if("channelsFirst"===
ob)Eb=E[0],td=E[1],hc=E[2],Fc=E[3],Oc=E[4];else throw Error("Unknown dataFormat "+ob);var be=G[0],Fe=G[1],fe=G[2],Be=G[4],Me=oc(N);N=Me[0];var hf=Me[1];Me=Me[2];var Se=oc(Y);Y=Se[0];var Hf=Se[1];Se=Se[2];var yf=Lc(be,Y),Sf=Lc(Fe,Hf),af=Lc(fe,Se),tf=hc,zf=Fc,ig=Oc;if("number"===typeof ra){var Mg={top:ra,bottom:ra,left:ra,right:ra,front:ra,back:ra,type:0===ra?"VALID":"NUMBER"};qb=Jb([tf,zf,ig,1],yf,1,N,ra,qb);var Qh=qb[0];ra=qb[1];qb=qb[2]}else if("same"===ra){Qh=Math.ceil(tf/N);ra=Math.ceil(zf/hf);
qb=Math.ceil(ig/Me);Mg=(Qh-1)*N+yf-tf;zf=(ra-1)*hf+Sf-zf;ig=(qb-1)*Me+af-ig;tf=Math.floor(Mg/2);var xh=Math.floor(zf/2),wj=Math.floor(ig/2);Mg={top:xh,bottom:zf-xh,left:wj,right:ig-wj,front:tf,back:Mg-tf,type:"SAME"}}else if("valid"===ra)Mg={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},Qh=Math.ceil((tf-yf+1)/N),ra=Math.ceil((zf-Sf+1)/hf),qb=Math.ceil((ig-af+1)/Me);else throw Error("Unknown padding parameter: "+ra);Ha=Ha?Be*td:Be;var vi;"channelsFirst"===ob?vi=[Eb,Ha,Qh,ra,qb]:"channelsLast"===
ob&&(vi=[Eb,Qh,ra,qb,Ha]);return{batchSize:Eb,dataFormat:ob,inDepth:hc,inHeight:Fc,inWidth:Oc,inChannels:td,outDepth:Qh,outHeight:ra,outWidth:qb,outChannels:Ha,padInfo:Mg,strideDepth:N,strideHeight:hf,strideWidth:Me,filterDepth:be,filterHeight:Fe,filterWidth:fe,effectiveFilterDepth:yf,effectiveFilterHeight:Sf,effectiveFilterWidth:af,dilationDepth:Y,dilationHeight:Hf,dilationWidth:Se,inShape:E,outShape:vi,filterShape:G}}function Ze(E,G,N,Y,ra){null==Y&&(Y=wb(E,G,N));var Ha=E[1],ob=ed((E[0]-G+2*Y)/
N+1,ra);e(m(ob),function(){return"The output # of rows ("+ob+") must be an integer. Change the stride and/or zero pad parameters"});var qb=ed((Ha-G+2*Y)/N+1,ra);e(m(qb),function(){return"The output # of columns ("+qb+") must be an integer. Change the stride and/or zero pad parameters"});return[ob,qb]}function Jb(E,G,N,Y,ra,Ha){null==ra&&(ra=wb(E,G,Y));var ob=E[1],qb=E[2],Eb=ed((E[0]-G+2*ra)/Y+1,Ha);e(m(Eb),function(){return"The output # of depths ("+Eb+") must be an integer. Change the stride and/or zero pad parameters"});
var hc=ed((ob-G+2*ra)/Y+1,Ha);e(m(hc),function(){return"The output # of rows ("+hc+") must be an integer. Change the stride and/or zero pad parameters"});var Fc=ed((qb-G+2*ra)/Y+1,Ha);e(m(Fc),function(){return"The output # of columns ("+Fc+") must be an integer. Change the stride and/or zero pad parameters"});return[Eb,hc,Fc,N]}function wb(E,G,N,Y){void 0===Y&&(Y=1);G=Lc(G,Y);return Math.floor((E[0]*(N-1)-N+G)/2)}function Lb(E){return"number"===typeof E?[E,E,E]:2===E.length?[E[0],E[1],1]:E}function oc(E){return"number"===
typeof E?[E,E,E]:E}function Lc(E,G){return 1>=G?E:E+(E-1)*(G-1)}function ed(E,G){if(!G)return E;switch(G){case "round":return Math.round(E);case "ceil":return Math.ceil(E);case "floor":return Math.floor(E);default:throw Error("Unknown roundingMode "+G);}}function ge(E){E=Lb(E);var G=E[1],N=E[2];return 1===E[0]&&1===G&&1===N}function he(E,G){return ge(E)||ge(G)}function bf(E){if("NHWC"===E)return"channelsLast";if("NCHW"===E)return"channelsFirst";throw Error("Unknown dataFormat "+E);}function cf(E,
G){var N=E[0].length;E.forEach(function(ra,Ha){e(ra.length===N,function(){return"Error in concat"+N+"D: rank of tensors["+Ha+"] must be the same as the rank of the rest ("+(N+")")})});e(0<=G&&G<N,function(){return"Error in concat"+N+"D: axis must be between 0 and "+(N-1)+"."});var Y=E[0];E.forEach(function(ra,Ha){for(var ob=0;ob<N;ob++)e(ob===G||ra[ob]===Y[ob],function(){return"Error in concat"+N+"D: Shape of tensors["+Ha+"] ("+ra+") does not match the shape of the rest ("+(Y+") along the non-concatenated axis ")+
(Ha+".")})})}function qe(E,G){for(var N=E[0].slice(),Y=1;Y<E.length;Y++)N[G]+=E[Y][G];return N}function ie(E){return 0===E.rank||1===E.rank?zd(E,[1,1,1,E.size]):2===E.rank?zd(E,[1,1,E.shape[0],E.shape[1]]):3===E.rank?zd(E,[1,E.shape[0],E.shape[1],E.shape[2]]):E}function Za(E){if(null==E)return null;if(0===E.rank)return zd(E,[E.size]);if(1!==E.rank){if(2===E.rank)return zd(E,[1,1,E.shape[0],E.shape[1]]);if(3===E.rank)return zd(E,[1,E.shape[0],E.shape[1],E.shape[2]])}return E}function nb(E,G){for(var N=
[],Y=0;Y<G.length;Y++){var ra=E[E.length-Y-1],Ha=G.length-Y-1,ob=G[Ha];(null==ra||1===ra&&1<ob)&&N.unshift(Ha)}return N}function Db(E,G){for(var N=[],Y=Math.max(E.length,G.length),ra=0;ra<Y;ra++){var Ha=E[E.length-ra-1];null==Ha&&(Ha=1);var ob=G[G.length-ra-1];null==ob&&(ob=1);if(1===Ha)N.unshift(ob);else{if(1!==ob&&Ha!==ob)throw Error("Operands could not be broadcast together with shapes "+(E+" and "+G+"."));N.unshift(Ha)}}return N}function dc(E,G,N){return Ic.runKernelFunc(function(Y){return Y.fill(E,
G,N)},{},null,"Fill",{shape:E,value:G,dtype:N})}function uc(E,G,N){for(var Y=E.shape[N],ra=[],Ha=1,ob=1,qb=0;qb<N;qb++)ra.push(E.shape[qb]),Ha*=E.shape[qb];for(qb=0;qb<G.rank;qb++)ra.push(G.shape[qb]);for(qb=N+1;qb<E.rank;qb++)ra.push(E.shape[qb]),ob*=E.shape[qb];return{batchSize:Ha,sliceSize:ob,dimSize:Y,outputShape:ra}}function Qc(E,G){if((J(E)&&"string"!==G||Array.isArray(E))&&"complex64"!==G)throw Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===
G&&J(E)&&!(E instanceof Uint8Array))throw Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Xb(E,[],[],G)}function ud(E,G){e(D(E),function(){return"The f passed in variableGrads(f) must be a function"});e(null==G||Array.isArray(G)&&G.every(function(Eb){return Eb instanceof mb}),function(){return"The varList passed in variableGrads(f, varList) must be an array of variables"});var N=null!=G;if(!N){G=[];for(var Y in Ic.registeredVariables)G.push(Ic.registeredVariables[Y])}N=
N?G.filter(function(Eb){return!Eb.trainable}):null;var ra=G.length;G=G.filter(function(Eb){return Eb.trainable});e(0<G.length,function(){return"variableGrads() expects at least one of the input variables to be trainable, but none of the "+(ra+" variables is trainable.")});E=Ic.gradients(E,G,null,!0);var Ha=E.value,ob=E.grads;e(ob.some(function(Eb){return null!=Eb}),function(){return"Cannot find a connection between any variable and the result of the loss function y\x3df(x). Please make sure the operations that use variables are inside the function f passed to minimize()."});
e(0===Ha.rank,function(){return"The f passed in variableGrads(f) must return a scalar, but it returned a rank-"+(Ha.rank+" tensor")});var qb={};G.forEach(function(Eb,hc){null!=ob[hc]&&(qb[Eb.name]=ob[hc])});null!=N&&N.forEach(function(Eb){return qb[Eb.name]=null});return{value:Ha,grads:qb}}function Fd(E){return Ic.customGrad(E)}function je(E){if(0<E.filter(function(G){return null==G}).length)throw Error("Cannot compute gradient of y\x3df(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
}function sd(E,G){void 0===G&&(G="float32");if("complex64"===G)return G=sd(E,"float32"),E=sd(E,"float32"),vd(G,E);var N=aa(c(E),G);return Ic.makeTensor(N,E,G)}function wd(E,G){void 0===G&&(G="float32");if("complex64"===G)return G=wd(E,"float32"),E=sd(E,"float32"),vd(G,E);var N=T(c(E),G);return Ic.makeTensor(N,E,G)}function Zd(E,G,N){var Y=N.map(function(qb){return qb[0]});N=N.map(function(qb){return qb[1]});var ra=E.concat(Y,N),Ha=G.map(function(qb,Eb){return(qb-ra[Eb]%qb)%qb}),ob=N.map(function(qb,
Eb){return qb+Ha[Eb]});E=G.map(function(qb,Eb){return[Y[Eb],ob[Eb]]});G=G.map(function(qb,Eb){return[0,Ha[Eb]]});return[E,G]}function Te(E,G){E=E.map(function(ra,Ha){return ra+(ra-1)*(G[Ha]-1)}).map(function(ra){return ra-1});var N=E.map(function(ra){return Math.floor(ra/2)}),Y=E.map(function(ra,Ha){return ra-N[Ha]});return E.map(function(ra,Ha){return[N[Ha],Y[Ha]]})}function re(E,G){return G={exports:{}},E(G,G.exports),G.exports}function We(E,G){d(E);var N=Pb(E,G);if(1!==N.length)throw Error("tensor1d() requires values to be a flat/TypedArray");
return Xb(E,null,N,G)}function nf(E,G,N,Y){void 0===N&&(N=1);void 0===Y&&(Y="float32");if(0===N)throw Error("Cannot have a step of zero");return Ic.runKernelFunc(function(){var ra=E<G&&0>N,Ha=G<E&&1<N;if(E===G||ra||Ha)return sd([0],Y);ra=aa(Math.abs(Math.ceil((G-E)/N)),Y);G<E&&1===N&&(N=-1);ra[0]=E;for(Ha=1;Ha<ra.length;Ha++)ra[Ha]=ra[Ha-1]+N;return We(ra,Y)},{},null,"Range",{start:E,stop:G,step:N,dtype:Y})}function bg(E,G,N){void 0===N&&(N=0);var Y=[];if("number"===typeof G)e(0===E.shape[N]%G,function(){return"Number of splits must evenly divide the axis."}),
Y=Array(G).fill(E.shape[N]/G);else{Y=G.reduce(function(Ha,ob){-1===ob&&(Ha+=1);return Ha},0);e(1>=Y,function(){return"There should be only one negative value in split array."});Y=G.indexOf(-1);if(-1!==Y){var ra=G.reduce(function(Ha,ob){return 0<ob?Ha+ob:Ha});G[Y]=E.shape[N]-ra}e(E.shape[N]===G.reduce(function(Ha,ob){return Ha+ob}),function(){return"The sum of sizes must match the size of the axis dimension."});Y=G}return Y}function Lf(E,G,N){d(E);if(null!=G&&2!==G.length)throw Error("tensor2d() requires shape to have two numbers");
var Y=Pb(E,N);if(2!==Y.length&&1!==Y.length)throw Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===Y.length&&null==G)throw Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Xb(E,G,Y,N)}function Wf(E,G){for(var N=[],Y=0;Y<G.length;Y++)G[Y]&&N.push(Y);G=kd(E,"int32");var ra=kd([N.length,E.length],"int32");for(Y=0;Y<N.length;Y++){var Ha=G.indexToLoc(N[Y]);ra.values.set(Ha,Y*E.length)}return ra.toTensor()}function Pf(E,G,N){void 0===
N&&(N=null);if(0===E.rank)return sg(E);if(1!==E.rank&&null===N)return Pf(zd(E,[-1]),G,N);if(1===E.rank||"number"===typeof N||Array.isArray(N)&&1===N.length){if(1===G)return Yb(sg(E),N);if(Infinity===G)return Mb(sg(E),N);if(-Infinity===G)return kf(sg(E),N);if("euclidean"===G||2===G)return Bh(Yb(ph(sg(E),Qc(2,"int32")),N));throw Error("Error in norm: invalid ord value: "+G);}if(Array.isArray(N)&&2===N.length){if(1===G)return Mb(Yb(sg(E),N[0]),N[1]-1);if(Infinity===G)return Mb(Yb(sg(E),N[1]),N[0]);if(-Infinity===
G)return kf(Yb(sg(E),N[1]),N[0]);if("fro"===G||"euclidean"===G)return Bh(Yb(Bf(E),N));throw Error("Error in norm: invalid ord value: "+G);}throw Error("Error in norm: invalid axis: "+N);}function Bg(E,G,N,Y){if("int32"!==E.dtype)throw Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was "+(E.dtype+"."));if(2<E.rank)throw Error("sparseIndices should be a scalar, vector, or matrix, but got shape "+(E.shape+"."));var ra=0<E.rank?E.shape[0]:1;E=1<E.rank?E.shape[1]:1;if(N.length!==
E)throw Error("outputShape has incorrect number of elements:, "+(N.length+", should be: "+E+"."));N=G.size;if(0!==G.rank&&(1!==G.rank||N!==ra))throw Error("sparseValues has incorrect shape "+(G.shape+", should be [] or ["+ra+"]"));if(G.dtype!==Y.dtype)throw Error("sparseValues.dtype must match defaultValues.dtype");}function Uf(E,G){if(null==G)return E.shape.slice();if(l(E.shape,G))return G;if(E.shape.length===G.length){for(var N=[],Y=0;Y<E.shape.length;Y++)null==G[Y]&&null!=E.shape[Y]?N.push(E.shape[Y]):
N.push(G[Y]);return N}return G}function Kb(E){return Math.floor(Math.pow(2,Math.ceil(Math.log(E)/Math.log(2))))}function ug(E,G,N){for(var Y=1-E%2,ra=new Float32Array(E),Ha=0;Ha<E;++Ha)ra[Ha]=G-N*Math.cos(2*Math.PI*Ha/(E+Y-1));return We(ra,"float32")}function sf(E,G,N){if(null==N||"linear"===N)return E;if("relu"===N)return se(E,ji(G));throw Error("Cannot compute gradient for fused activation "+N+".");}function Cf(E,G){var N=G;G=nb(E.shape,G.shape);0<G.length&&(N=Yb(N,G));return zd(N,E.shape)}function gf(E,
G,N){if("linear"===G)return E;if("relu"===G)return Lh(E);if("elu"===G)return gg(E);if("relu6"===G)return Wh(E);if("prelu"===G)return Li(E,N);throw Error("Unknown fused activation "+G+".");}function Gf(E,G,N,Y,ra,Ha){null==Y&&(Y=.5);null==ra&&(ra=Number.NEGATIVE_INFINITY);null==Ha&&(Ha=0);var ob=E.shape[0];N=Math.min(N,ob);e(0<=Y&&1>=Y,function(){return"iouThreshold must be in [0, 1], but was '"+Y+"'"});e(2===E.rank,function(){return"boxes must be a 2D tensor, but was of rank '"+E.rank+"'"});e(4===
E.shape[1],function(){return"boxes must have 4 columns, but 2nd dimension was "+E.shape[1]});e(1===G.rank,function(){return"scores must be a 1D tensor"});e(G.shape[0]===ob,function(){return"scores has incompatible shape with boxes. Expected "+ob+", but was "+G.shape[0]});e(0<=Ha&&1>=Ha,function(){return"softNmsSigma must be in [0, 1], but was '"+Ha+"'"});return{maxOutputSize:N,iouThreshold:Y,scoreThreshold:ra,softNmsSigma:Ha}}function ad(E,G){return E>G?1:E<G?-1:0}function $e(E,G,N,Y,ra){return ub(E,
G,N,Y,ra,0).selectedIndices}function va(E,G,N,Y,ra,Ha){return ub(E,G,N,Y,ra,0,!1,Ha,!0)}function eb(E,G,N,Y,ra,Ha){return ub(E,G,N,Y,ra,Ha,!0)}function ub(E,G,N,Y,ra,Ha,ob,qb,Eb){void 0===ob&&(ob=!1);void 0===qb&&(qb=!1);void 0===Eb&&(Eb=!1);for(var hc=[],Fc=0;Fc<G.length;Fc++)G[Fc]>ra&&hc.push({score:G[Fc],boxIndex:Fc,suppressBeginIndex:0});hc.sort(pb);Fc=0<Ha?-.5/Ha:0;Ha=[];for(G=[];Ha.length<N&&0<hc.length;){var Oc=hc.pop(),td=Oc.score,be=Oc.boxIndex,Fe=Oc.suppressBeginIndex;if(td<ra)break;for(var fe=
!1,Be=Ha.length-1;Be>=Fe;--Be){var Me=E;var hf=Ha[Be],Se=Me.subarray(4*be,4*be+4),Hf=Me.subarray(4*hf,4*hf+4);Me=Math.min(Se[0],Se[2]);hf=Math.min(Se[1],Se[3]);var yf=Math.max(Se[0],Se[2]);Se=Math.max(Se[1],Se[3]);var Sf=Math.min(Hf[0],Hf[2]),af=Math.min(Hf[1],Hf[3]),tf=Math.max(Hf[0],Hf[2]),zf=Math.max(Hf[1],Hf[3]);Hf=(yf-Me)*(Se-hf);var ig=(tf-Sf)*(zf-af);0>=Hf||0>=ig?Me=0:(Me=Math.max(Math.min(yf,tf)-Math.max(Me,Sf),0)*Math.max(Math.min(Se,zf)-Math.max(hf,af),0),Me/=Hf+ig-Me);if(Me>=Y){fe=!0;break}hf=
Math.exp(Fc*Me*Me);Oc.score*=Me<=Y?hf:0;if(Oc.score<=ra)break}Oc.suppressBeginIndex=Ha.length;if(!fe)if(Oc.score===td)Ha.push(be),G.push(Oc.score);else if(Oc.score>ra){Fe=td=hc;fe=Oc;Be=pb||ad;Me=0;hf=Fe.length;for(yf=!1;Me<hf;)be=Me+(hf-Me>>>1),Se=Be(fe,Fe[be]),0<Se?Me=be+1:(hf=be,yf=!Se);be=yf?Me:-Me-1;td.splice(0>be?-(be+1):be,0,Oc)}}E=Ha.length;N-=E;qb&&0<N&&(Ha.push.apply(Ha,Array(N).fill(0)),G.push.apply(G,Array(N).fill(0)));qb={selectedIndices:We(Ha,"int32")};ob&&(qb.selectedScores=We(G,"float32"));
Eb&&(qb.validOutputs=Qc(E,"int32"));return qb}function pb(E,G){return E.score-G.score||E.score===G.score&&G.boxIndex-E.boxIndex}function Ea(E,G){void 0===G&&(G=!1);return Ic.tidy(function(){e(2===E.shape.length,function(){return"qr2d() requires a 2D Tensor, but got a "+E.shape.length+"D Tensor."});for(var N=E.shape[0],Y=E.shape[1],ra=Fh(N),Ha=Ed(E),ob=Lf([[1]],[1,1]),qb=Ed(ob),Eb=N>=Y?Y:N,hc=function(Oc){var td=Ha,be=qb,Fe=ra;var fe=Ic.tidy(function(){var Be=Qb(Ha,[Oc,Oc],[N-Oc,1]),Me=Qi(Be),hf=Qb(Ha,
[Oc,Oc],[1,1]),Se=cg(Ug(hf,0),Lf([[-1]]),Lf([[1]]));hf=Zb(hf,se(Se,Me));Be=xf(Be,hf);qb=1===Be.shape[0]?Ed(ob):Pa([ob,Qb(Be,[1,0],[Be.shape[0]-1,Be.shape[1]])],0);Se=ca(xf(uf(Se,hf),Me));Me=Qb(Ha,[Oc,0],[N-Oc,Y]);Se=se(Se,qb);Be=hg(qb);0===Oc?Ha=Zb(Me,uf(Se,uf(Be,Me))):(Me=Zb(Me,uf(Se,uf(Be,Me))),Ha=Pa([Qb(Ha,[0,0],[Oc,Y]),Me],0));Me=hg(Se);Se=Qb(ra,[0,Oc],[N,ra.shape[1]-Oc]);0===Oc?ra=Zb(Se,uf(uf(Se,qb),Me)):(Me=Zb(Se,uf(uf(Se,qb),Me)),ra=Pa([Qb(ra,[0,0],[N,Oc]),Me],1));return[qb,Ha,ra]});qb=fe[0];
Ha=fe[1];ra=fe[2];mc([td,be,Fe])},Fc=0;Fc<Eb;++Fc)hc(Fc);!G&&N>Y&&(ra=Qb(ra,[0,0],[N,Y]),Ha=Qb(Ha,[0,0],[Y,Y]));return[ra,Ha]})}function db(E,G,N){void 0===N&&(N=-1);-1===N&&(N=G.rank-1);if(N!==G.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank "+(G.rank+" and dim was ")+N);return Fd(function(Y,ra,Ha){var ob=cd(ra,[N],!0);ra=Zb(Uc(ra,"float32"),ob);Ha([Y,ra]);Y=ca(se(ra,Y));return{value:Yb(Y,[N]),gradFunc:function(qb,Eb){var hc=Eb[0];
Eb=Eb[1];var Fc=fc(qb.shape,[N]);return[se(zd(qb,Fc),Zb(Uc(hc,"float32"),Xg(Eb))),se(zd(qb,Fc),Zb(Xg(Eb),Uc(hc,"float32")))]}}})(E,G)}function fb(E,G){for(var N=[];E<G;++E)N.push(E);return N}function Gb(E){for(var G=[],N=0;N<E.length;++N)for(var Y=0;Y<E[N].length;++Y)G.push(E[N][Y]);return G}function Vb(E,G,N,Y){G.rank<N.rank&&(G=zd(G,fc(G.shape,Y)));E.rank<N.rank&&(E=zd(E,fc(E.shape,Y)));return{x:function(){return se(E,Uc(ye(N,G),E.dtype))}}}var Hc=A(25),md=A(5).Buffer;"use strict";Object.defineProperty(v,
"__esModule",{value:!0});var Cd=function(E,G){Cd=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(N,Y){N.__proto__=Y}||function(N,Y){for(var ra in Y)Y.hasOwnProperty(ra)&&(N[ra]=Y[ra])};return Cd(E,G)},ae=function(){function E(G,N){this.backend=G;this.dataMover=N;this.data=new WeakMap;this.dataIdsCount=0}E.prototype.get=function(G){this.data.has(G)||this.dataMover.moveData(this.backend,G);return this.data.get(G)};E.prototype.set=function(G,N){this.dataIdsCount++;this.data.set(G,N)};
E.prototype.has=function(G){return this.data.has(G)};E.prototype.delete=function(G){this.dataIdsCount--;return this.data.delete(G)};E.prototype.numDataIds=function(){return this.dataIdsCount};return E}(),ze=function(){function E(){}E.prototype.time=function(G){return f("time")};E.prototype.read=function(G){return f("read")};E.prototype.readSync=function(G){return f("readSync")};E.prototype.numDataIds=function(){return f("numDataIds")};E.prototype.disposeData=function(G){return f("disposeData")};E.prototype.write=
function(G,N,Y){return f("write")};E.prototype.move=function(G,N,Y,ra){return f("move")};E.prototype.memory=function(){return f("memory")};E.prototype.floatPrecision=function(){return f("floatPrecision")};E.prototype.epsilon=function(){return 32===this.floatPrecision()?1E-7:1E-4};E.prototype.batchMatMul=function(G,N,Y,ra){return f("batchMatMul")};E.prototype.fusedBatchMatMul=function(G){return f("fusedBatchMatMul")};E.prototype.slice=function(G,N,Y){return f("slice")};E.prototype.stridedSlice=function(G,
N,Y,ra){return f("stridedSlice")};E.prototype.unstack=function(G,N){return f("unstack")};E.prototype.reverse=function(G,N){return f("reverse")};E.prototype.concat=function(G,N){return f("concat")};E.prototype.neg=function(G){return f("neg")};E.prototype.add=function(G,N){return f("add")};E.prototype.addN=function(G){return f("addN")};E.prototype.subtract=function(G,N){return f("subtract")};E.prototype.multiply=function(G,N){return f("multiply")};E.prototype.realDivide=function(G,N){return f("realDivide")};
E.prototype.floorDiv=function(G,N){return f("floorDiv")};E.prototype.sum=function(G,N){return f("sum")};E.prototype.prod=function(G,N){return f("prod")};E.prototype.unsortedSegmentSum=function(G,N,Y){return f("unsortedSegmentSum")};E.prototype.argMin=function(G,N){return f("argMin")};E.prototype.argMax=function(G,N){return f("argMax")};E.prototype.equal=function(G,N){return f("equal")};E.prototype.notEqual=function(G,N){return f("notEqual")};E.prototype.less=function(G,N){return f("less")};E.prototype.lessEqual=
function(G,N){return f("lessEqual")};E.prototype.greater=function(G,N){return f("greater")};E.prototype.greaterEqual=function(G,N){return f("greaterEqual")};E.prototype.logicalNot=function(G){return f("logicalNot")};E.prototype.logicalAnd=function(G,N){return f("logicalAnd")};E.prototype.logicalOr=function(G,N){return f("logicalOr")};E.prototype.where=function(G){return f("where")};E.prototype.select=function(G,N,Y){return f("select")};E.prototype.topk=function(G,N,Y){return f("topk")};E.prototype.min=
function(G,N){return f("min")};E.prototype.minimum=function(G,N){return f("minimum")};E.prototype.mod=function(G,N){return f("mod")};E.prototype.max=function(G,N){return f("max")};E.prototype.maximum=function(G,N){return f("maximum")};E.prototype.all=function(G,N){return f("all")};E.prototype.any=function(G,N){return f("any")};E.prototype.squaredDifference=function(G,N){return f("squaredDifference")};E.prototype.ceil=function(G){return f("ceil")};E.prototype.floor=function(G){return f("floor")};E.prototype.round=
function(G){return f("round")};E.prototype.sign=function(G){return f("sign")};E.prototype.isNaN=function(G){return f("isNaN")};E.prototype.isInf=function(G){return f("isInf")};E.prototype.isFinite=function(G){return f("isFinite")};E.prototype.pow=function(G,N){return f("pow")};E.prototype.exp=function(G){return f("exp")};E.prototype.expm1=function(G){return f("expm1")};E.prototype.softmax=function(G,N){return f("softmax")};E.prototype.log=function(G){return f("log")};E.prototype.log1p=function(G){return f("log1p")};
E.prototype.sqrt=function(G){return f("sqrt")};E.prototype.rsqrt=function(G){return f("rsqrt")};E.prototype.square=function(G){return f("square")};E.prototype.reciprocal=function(G){return f("reciprocal")};E.prototype.relu=function(G){return f("relu")};E.prototype.relu6=function(G){return f("relu6")};E.prototype.prelu=function(G,N){return f("prelu")};E.prototype.elu=function(G){return f("elu")};E.prototype.eluDer=function(G,N){return f("eluDer")};E.prototype.selu=function(G){return f("selu")};E.prototype.int=
function(G){return f("int")};E.prototype.clip=function(G,N,Y){return f("clip")};E.prototype.abs=function(G){return f("abs")};E.prototype.complexAbs=function(G){return f("complexAbs")};E.prototype.sigmoid=function(G){return f("sigmoid")};E.prototype.softplus=function(G){return f("softplus")};E.prototype.sin=function(G){return f("sin")};E.prototype.cos=function(G){return f("cos")};E.prototype.tan=function(G){return f("tan")};E.prototype.asin=function(G){return f("asin")};E.prototype.acos=function(G){return f("acos")};
E.prototype.atan=function(G){return f("atan")};E.prototype.atan2=function(G,N){return f("atan2")};E.prototype.sinh=function(G){return f("sinh")};E.prototype.cosh=function(G){return f("cosh")};E.prototype.tanh=function(G){return f("tanh")};E.prototype.asinh=function(G){return f("asinh")};E.prototype.acosh=function(G){return f("acosh")};E.prototype.atanh=function(G){return f("atanh")};E.prototype.erf=function(G){return f("erf")};E.prototype.step=function(G,N){return f("step")};E.prototype.fusedConv2d=
function(G){return f("fusedConv2d")};E.prototype.conv2d=function(G,N,Y){return f("conv2d")};E.prototype.conv2dDerInput=function(G,N,Y){return f("conv2dDerInput")};E.prototype.conv2dDerFilter=function(G,N,Y){return f("conv2dDerFilter")};E.prototype.fusedDepthwiseConv2D=function(G){return f("fusedDepthwiseConv2D")};E.prototype.depthwiseConv2D=function(G,N,Y){return f("depthwiseConv2D")};E.prototype.depthwiseConv2DDerInput=function(G,N,Y){return f("depthwiseConv2DDerInput")};E.prototype.depthwiseConv2DDerFilter=
function(G,N,Y){return f("depthwiseConv2DDerFilter")};E.prototype.conv3d=function(G,N,Y){return f("conv3d")};E.prototype.conv3dDerInput=function(G,N,Y){return f("conv3dDerInput")};E.prototype.conv3dDerFilter=function(G,N,Y){return f("conv3dDerFilter")};E.prototype.maxPool=function(G,N){return f("maxPool")};E.prototype.maxPoolBackprop=function(G,N,Y,ra){return f("maxPoolBackprop")};E.prototype.avgPool=function(G,N){return f("avgPool")};E.prototype.avgPoolBackprop=function(G,N,Y){return f("avgPoolBackprop")};
E.prototype.avgPool3d=function(G,N){return f("avgPool3d")};E.prototype.avgPool3dBackprop=function(G,N,Y){return f("avgPool3dBackprop")};E.prototype.maxPool3d=function(G,N){return f("maxPool3d")};E.prototype.maxPool3dBackprop=function(G,N,Y,ra){return f("maxPool3dBackprop")};E.prototype.reshape=function(G,N){return f("reshape")};E.prototype.cast=function(G,N){return f("cast")};E.prototype.tile=function(G,N){return f("tile")};E.prototype.pad=function(G,N,Y){return f("pad")};E.prototype.transpose=function(G,
N){return f("transpose")};E.prototype.gather=function(G,N,Y){return f("gather")};E.prototype.gatherND=function(G,N){return f("gatherND")};E.prototype.scatterND=function(G,N,Y){return f("scatterND")};E.prototype.batchToSpaceND=function(G,N,Y){return f("batchToSpaceND")};E.prototype.spaceToBatchND=function(G,N,Y){return f("spaceToBatchND")};E.prototype.resizeBilinear=function(G,N,Y,ra){return f("resizeBilinear")};E.prototype.resizeBilinearBackprop=function(G,N,Y){return f("resizeBilinearBackprop")};
E.prototype.resizeNearestNeighbor=function(G,N,Y,ra){return f("resizeNearestNeighbor")};E.prototype.resizeNearestNeighborBackprop=function(G,N,Y){return f("resizeNearestNeighborBackprop")};E.prototype.batchNorm=function(G,N,Y,ra,Ha,ob){return f("batchNorm")};E.prototype.localResponseNormalization4D=function(G,N,Y,ra,Ha){return f("localResponseNormalization4D")};E.prototype.LRNGrad=function(G,N,Y,ra,Ha,ob,qb){return f("LRNGrad")};E.prototype.multinomial=function(G,N,Y,ra){return f("multinomial")};
E.prototype.oneHot=function(G,N,Y,ra){return f("oneHot")};E.prototype.cumsum=function(G,N,Y,ra){return f("cumsum")};E.prototype.nonMaxSuppression=function(G,N,Y,ra,Ha){return f("nonMaxSuppression")};E.prototype.fft=function(G){return f("fft")};E.prototype.ifft=function(G){return f("ifft")};E.prototype.complex=function(G,N){return f("complex")};E.prototype.real=function(G){return f("real")};E.prototype.imag=function(G){return f("imag")};E.prototype.cropAndResize=function(G,N,Y,ra,Ha,ob){return f("cropAndResize")};
E.prototype.depthToSpace=function(G,N,Y){return f("depthToSpace")};E.prototype.split=function(G,N,Y){return f("split")};E.prototype.sparseToDense=function(G,N,Y,ra){return f("sparseToDense")};E.prototype.diag=function(G){return f("diag")};E.prototype.fill=function(G,N,Y){return f("fill")};E.prototype.onesLike=function(G){return f("onesLike")};E.prototype.zerosLike=function(G){return f("zerosLike")};E.prototype.linspace=function(G,N,Y){return f("linspace")};E.prototype.dispose=function(){return f("dispose")};
return E}(),ef=function(){function E(G){this.global=G;this.flags={};this.flagRegistry={};this.urlFlags={};this.populateURLFlags()}E.prototype.setPlatform=function(G,N){null!=this.platform&&console.warn("Platform "+this.platformName+" has already been set. Overwriting the platform with "+(N+"."));this.platformName=G;this.platform=N};E.prototype.registerFlag=function(G,N,Y){this.flagRegistry[G]={evaluationFn:N,setHook:Y};null!=this.urlFlags[G]&&(N=this.urlFlags[G],console.warn("Setting feature override from URL "+
G+": "+N+"."),this.set(G,N))};E.prototype.getAsync=function(G){return r(this,void 0,void 0,function(){var N,Y;return u(this,function(ra){switch(ra.label){case 0:if(G in this.flags)return[2,this.flags[G]];N=this.flags;Y=G;return[4,this.evaluateFlag(G)];case 1:return N[Y]=ra.sent(),[2,this.flags[G]]}})})};E.prototype.get=function(G){if(G in this.flags)return this.flags[G];var N=this.evaluateFlag(G);if(Z(N))throw Error("Flag "+G+" cannot be synchronously evaluated. Please use getAsync() instead.");this.flags[G]=
N;return this.flags[G]};E.prototype.getNumber=function(G){return this.get(G)};E.prototype.getBool=function(G){return this.get(G)};E.prototype.getFlags=function(){return this.flags};Object.defineProperty(E.prototype,"features",{get:function(){return this.flags},enumerable:!0,configurable:!0});E.prototype.set=function(G,N){if(null==this.flagRegistry[G])throw Error("Cannot set flag "+G+" as it has not been registered.");this.flags[G]=N;null!=this.flagRegistry[G].setHook&&this.flagRegistry[G].setHook(N)};
E.prototype.evaluateFlag=function(G){if(null==this.flagRegistry[G])throw Error("Cannot evaluate flag '"+G+"': no evaluation function found.");return this.flagRegistry[G].evaluationFn()};E.prototype.setFlags=function(G){this.flags=Object.assign({},G)};E.prototype.reset=function(){this.flags={};this.urlFlags={};this.populateURLFlags()};E.prototype.populateURLFlags=function(){var G=this;if("undefined"!==typeof this.global&&"undefined"!==typeof this.global.location&&"undefined"!==typeof this.global.location.search){var N=
da(this.global.location.search);"tfjsflags"in N&&N.tfjsflags.split(",").forEach(function(Y){var ra=Y.split(":");Y=ra[0];var Ha=G.urlFlags;ra=ra[1];ra=ra.toLowerCase();if("true"===ra||"false"===ra)ra="true"===ra;else if(""+ +ra===ra)ra=+ra;else throw Error("Could not parse value flag value "+ra+" for flag "+Y+".");Ha[Y]=ra})}};return E}();v.ENV=null;var Qf,Zf=ta("kernelRegistry",function(){return new Map}),Df=ta("gradRegistry",function(){return new Map}),rg={__proto__:null,createScalarValue:function(E,
G){return"string"===G?oa(E):Ra([E],G)},toTypedArray:Ra,now:Ia,fetch:function(E,G){return pa().platform.fetch(E,G)},encodeString:oa,decodeString:Ba,shuffle:a,clamp:b,nearestLargerEven:function(E){return 0===E%2?E:E+1},sum:function(E){for(var G=0,N=0;N<E.length;N++)G+=E[N];return G},randUniform:function(E,G){var N=Math.random();return G*N+(1-N)*E},distSquared:function(E,G){for(var N=0,Y=0;Y<E.length;Y++){var ra=Number(E[Y])-Number(G[Y]);N+=ra*ra}return N},assert:e,assertShapesMatch:g,assertNonNull:d,
flatten:h,sizeFromShape:c,isScalarShape:function(E){return 0===E.length},arraysEqual:l,isInt:m,tanh:function(E){if(null!=Math.tanh)return Math.tanh(E);if(Infinity===E)return 1;if(-Infinity===E)return-1;E=Math.exp(2*E);return(E-1)/(E+1)},sizeToSquarishShape:function(E){var G=Math.ceil(Math.sqrt(E));return[G,Math.ceil(E/G)]},createShuffledIndices:function(E){for(var G=new Uint32Array(E),N=0;N<E;++N)G[N]=N;a(G);return G},rightPad:n,repeatedTry:function(E,G,N){void 0===G&&(G=function(Y){return 0});return new Promise(function(Y,
ra){var Ha=0,ob=function(){if(E())Y();else{Ha++;var qb=G(Ha);null!=N&&Ha>=N?ra():setTimeout(ob,qb)}};ob()})},inferFromImplicitShape:k,parseAxisParam:p,squeezeShape:q,getTypedArrayFromDType:w,getArrayFromDType:y,checkConversionForErrors:C,isValidDtype:z,hasEncodingLoss:K,isTypedArray:J,bytesPerElement:B,bytesFromStringArray:O,isString:Q,isBoolean:V,isNumber:M,inferDtype:F,isFunction:D,nearestDivisor:H,computeStrides:U,toNestedArray:I,makeOnesTypedArray:T,makeZerosTypedArray:aa,makeZerosNestedTypedArray:function(E,
G){var N=E.reduce(function(Y,ra){return Y*ra},1);if(null==G||"float32"===G)return I(E,new Float32Array(N));if("int32"===G)return I(E,new Int32Array(N));if("bool"===G)return I(E,new Uint8Array(N));throw Error("Unknown data type "+G);},assertNonNegativeIntegerDimensions:ba,locToIndex:function(E,G,N){if(0===G)return 0;if(1===G)return E[0];G=E[E.length-1];for(var Y=0;Y<E.length-1;++Y)G+=N[Y]*E[Y];return G},indexToLoc:function(E,G,N){if(0===G)return[];if(1===G)return[E];G=Array(G);for(var Y=0;Y<G.length-
1;++Y)G[Y]=Math.floor(E/N[Y]),E-=G[Y]*N[Y];G[G.length-1]=E;return G},isPromise:Z},If=function(){function E(G,N){this.backendTimer=G;this.logger=N;null==N&&(this.logger=new ag)}E.prototype.profileKernel=function(G,N,Y){for(var ra,Ha=this.backendTimer.time(function(){ra=Y()}),ob=function(Eb){var hc=ra[Eb];hc.data().then(function(Fc){a:if("float32"===hc.dtype)for(var Oc=0;Oc<Fc.length;Oc++){var td=Fc[Oc];if(isNaN(td)||!isFinite(td)){console.warn("Found "+td+" in the result of '"+G+"'");break a}}})},
qb=0;qb<ra.length;qb++)ob(qb);return{kernelName:G,outputs:ra,inputs:N,timeMs:Ha.then(function(Eb){return Eb.kernelMs}),extraInfo:Ha.then(function(Eb){return null!=Eb.getExtraProfileInfo?Eb.getExtraProfileInfo():""})}};E.prototype.logKernelProfile=function(G){var N=this,Y=G.kernelName,ra=G.timeMs,Ha=G.inputs,ob=G.extraInfo;G.outputs.forEach(function(qb){Promise.all([qb.data(),ra,ob]).then(function(Eb){N.logger.logKernelProfile(Y,qb,Eb[0],Eb[1],Ha,Eb[2])})})};return E}(),ag=function(){function E(){}
E.prototype.logKernelProfile=function(G,N,Y,ra,Ha,ob){Y="number"===typeof ra?n(ra+"ms",9):ra.error;G=n(G,25);ra=N.rank;var qb=N.size,Eb=n(N.shape.toString(),14),hc="",Fc;for(Fc in Ha){var Oc=Ha[Fc];if(null!=Oc){Oc=Oc.shape||N.shape;var td=Oc.length;hc+=Fc+": "+td+"D "+(0<td?Oc:"")+" "}}console.log("%c"+G+"\t%c"+Y+"\t%c"+ra+"D "+Eb+"\t%c"+qb+"\t%c"+hc+"\t%c"+ob,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")};return E}(),Ua=function(){function E(G,N,Y){var ra=
this;this.dtype=N;this.shape=G.slice();this.size=c(G);if(null!=Y){var Ha=Y.length;e(Ha===this.size,function(){return"Length of values '"+Ha+"' does not match the size inferred by the shape '"+(ra.size+"'.")})}if("complex64"===N)throw Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=Y||y(N,this.size);this.strides=U(G)}E.prototype.set=function(G){for(var N=this,Y=[],ra=1;ra<
arguments.length;ra++)Y[ra-1]=arguments[ra];0===Y.length&&(Y=[0]);e(Y.length===this.rank,function(){return"The number of provided coordinates ("+Y.length+") must match the rank ("+(N.rank+")")});ra=this.locToIndex(Y);this.values[ra]=G};E.prototype.get=function(){for(var G=[],N=0;N<arguments.length;N++)G[N]=arguments[N];0===G.length&&(G=[0]);for(var Y=N=0,ra=G;Y<ra.length;Y++){var Ha=ra[Y];if(0>Ha||Ha>=this.shape[N])throw Error("Requested out of range element at "+G+".   Buffer shape\x3d"+this.shape);
N++}N=G[G.length-1];for(Y=0;Y<G.length-1;++Y)N+=this.strides[Y]*G[Y];return this.values[N]};E.prototype.locToIndex=function(G){if(0===this.rank)return 0;if(1===this.rank)return G[0];for(var N=G[G.length-1],Y=0;Y<G.length-1;++Y)N+=this.strides[Y]*G[Y];return N};E.prototype.indexToLoc=function(G){if(0===this.rank)return[];if(1===this.rank)return[G];for(var N=Array(this.shape.length),Y=0;Y<N.length-1;++Y)N[Y]=Math.floor(G/this.strides[Y]),G-=N[Y]*this.strides[Y];N[N.length-1]=G;return N};Object.defineProperty(E.prototype,
"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0});E.prototype.toTensor=function(){return xa().makeTensor(this.values,this.shape,this.dtype)};return E}(),xa=null,Wa=null,Da=function(){function E(G,N,Y,ra){this.isDisposedInternal=this.kept=!1;this.shape=G.slice();this.dtype=N||"float32";this.size=c(G);this.strides=U(G);this.dataId=Y;this.id=ra;this.rankType=5>this.rank?this.rank.toString():"higher"}Object.defineProperty(E.prototype,"rank",{get:function(){return this.shape.length},
enumerable:!0,configurable:!0});E.prototype.buffer=function(){return r(this,void 0,void 0,function(){var G;return u(this,function(N){switch(N.label){case 0:return[4,this.data()];case 1:return G=N.sent(),[2,Wa.buffer(this.shape,this.dtype,G)]}})})};E.prototype.bufferSync=function(){return Wa.buffer(this.shape,this.dtype,this.dataSync())};E.prototype.array=function(){return r(this,void 0,void 0,function(){var G;return u(this,function(N){switch(N.label){case 0:return[4,this.data()];case 1:return G=N.sent(),
[2,I(this.shape,G)]}})})};E.prototype.arraySync=function(){return I(this.shape,this.dataSync())};E.prototype.data=function(){return r(this,void 0,void 0,function(){var G,N;return u(this,function(Y){switch(Y.label){case 0:return this.throwIfDisposed(),G=xa().read(this.dataId),"string"!==this.dtype?[3,2]:[4,G];case 1:N=Y.sent();try{return[2,N.map(function(ra){return Ba(ra)})]}catch(ra){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");}case 2:return[2,
G]}})})};E.prototype.dataSync=function(){this.throwIfDisposed();var G=xa().readSync(this.dataId);if("string"===this.dtype)try{return G.map(function(N){return Ba(N)})}catch(N){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");}return G};E.prototype.bytes=function(){return r(this,void 0,void 0,function(){var G;return u(this,function(N){switch(N.label){case 0:return this.throwIfDisposed(),[4,xa().read(this.dataId)];case 1:return G=N.sent(),"string"===
this.dtype?[2,G]:[2,new Uint8Array(G.buffer)]}})})};E.prototype.dispose=function(){this.isDisposed||(xa().disposeTensor(this),this.isDisposedInternal=!0)};Object.defineProperty(E.prototype,"isDisposed",{get:function(){return this.isDisposedInternal},enumerable:!0,configurable:!0});E.prototype.throwIfDisposed=function(){if(this.isDisposed)throw Error("Tensor is disposed.");};E.prototype.print=function(G){void 0===G&&(G=!1);return Wa.print(this,G)};E.prototype.clone=function(){this.throwIfDisposed();
return Wa.clone(this)};E.prototype.toString=function(G){void 0===G&&(G=!1);var N=this.dataSync();return Ma(N,this.shape,this.dtype,G)};E.prototype.cast=function(G){this.throwIfDisposed();return Wa.cast(this,G)};E.prototype.variable=function(G,N,Y){void 0===G&&(G=!0);this.throwIfDisposed();return xa().makeVariable(this,G,N,Y)};return E}();Object.defineProperty(Da,Symbol.hasInstance,{value:function(E){return!!E&&null!=E.data&&null!=E.dataSync&&null!=E.throwIfDisposed}});var mb=function(E){function G(N,
Y,ra,Ha){N=E.call(this,N.shape,N.dtype,N.dataId,Ha)||this;N.trainable=Y;N.name=ra;return N}t(G,E);G.prototype.assign=function(N){if(N.dtype!==this.dtype)throw Error("dtype of the new value ("+N.dtype+") and previous value ("+(this.dtype+") must match"));if(!l(N.shape,this.shape))throw Error("shape of the new value ("+N.shape+") and previous value ("+(this.shape+") must match"));xa().disposeTensor(this);this.dataId=N.dataId;xa().incRef(this,null)};G.prototype.dispose=function(){xa().disposeVariable(this);
this.isDisposedInternal=!0};return G}(Da);Object.defineProperty(mb,Symbol.hasInstance,{value:function(E){return E instanceof Da&&null!=E.assign&&E.assign instanceof Function}});(function(E){E.R0="R0";E.R1="R1";E.R2="R2";E.R3="R3";E.R4="R4";E.R5="R5";E.R6="R6"})(v.Rank||(v.Rank={}));var Bb;(function(E){E.float32="float32";E.int32="int32";E.bool="int32";E.complex64="complex64"})(Bb||(Bb={}));var $b;(function(E){E.float32="float32";E.int32="int32";E.bool="bool";E.complex64="complex64"})($b||($b={}));
var wc;(function(E){E.float32="float32";E.int32="float32";E.bool="float32";E.complex64="complex64"})(wc||(wc={}));var Rc;(function(E){E.float32="complex64";E.int32="complex64";E.bool="complex64";E.complex64="complex64"})(Rc||(Rc={}));var Zc={float32:wc,int32:Bb,bool:$b,complex64:Rc},Xc={__proto__:null,makeTypesMatch:ya,assertTypesMatch:Qa,isTensorInList:function(E,G){return G.some(function(N){return N.id===E.id})},getTensorsInContainer:$a},bd=function(){function E(){this.registeredVariables={};this.kernelDepth=
this.gradientDepth=this.numDataBuffers=this.numStringTensors=this.numTensors=this.numBytes=this.nextTapeNodeId=0;this.scopeStack=[];this.numDataMovesStack=[];this.nextScopeId=0;this.tensorInfo=new WeakMap;this.profiling=!1;this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}E.prototype.dispose=function(){for(var G in this.registeredVariables)this.registeredVariables[G].dispose()};return E}(),id=function(){function E(G){this.ENV=G;this.registry={};this.registryFactory={};
this.pendingBackendInitId=0;this.state=new bd}E.prototype.ready=function(){return r(this,void 0,void 0,function(){var G,N,Y,ra;return u(this,function(Ha){switch(Ha.label){case 0:if(null!=this.pendingBackendInit)return[2,this.pendingBackendInit.then(function(){})];if(null!=this.backendInstance)return[2];G=this.getSortedBackends();N=0;Ha.label=1;case 1:if(!(N<G.length))return[3,5];Y=G[N];return[4,this.initializeBackend(Y).success];case 2:return(ra=Ha.sent())?[4,this.setBackend(Y)]:[3,4];case 3:return Ha.sent(),
[2];case 4:return N++,[3,1];case 5:throw Error("Could not initialize any backends, all backend initializations failed.");}})})};Object.defineProperty(E.prototype,"backend",{get:function(){if(null!=this.pendingBackendInit)throw Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){var G=this.initializeBackendsAndReturnBest(),N=G.name;if(G.asyncInit)throw Error("The highest priority backend '"+
N+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(N)}return this.backendInstance},enumerable:!0,configurable:!0});E.prototype.backendNames=function(){return Object.keys(this.registryFactory)};E.prototype.findBackend=function(G){if(!(G in this.registry))if(G in this.registryFactory){if(this.initializeBackend(G).asyncInit)return null}else return null;return this.registry[G]};E.prototype.findBackendFactory=function(G){return G in
this.registryFactory?this.registryFactory[G].factory:null};E.prototype.registerBackend=function(G,N,Y){void 0===Y&&(Y=1);if(G in this.registryFactory)return console.warn(G+" backend was already registered. Reusing existing backend factory."),!1;this.registryFactory[G]={factory:N,priority:Y};return!0};E.prototype.setBackend=function(G){return r(this,void 0,void 0,function(){var N,Y,ra,Ha,ob;return u(this,function(qb){switch(qb.label){case 0:if(null==this.registryFactory[G])throw Error("Backend name '"+
G+"' not found in registry");this.backendName=G;if(null!=this.registry[G])return[3,4];this.backendInstance=null;N=this.initializeBackend(G);Y=N.success;return(ra=N.asyncInit)?[4,Y]:[3,2];case 1:return ob=qb.sent(),[3,3];case 2:ob=Y,qb.label=3;case 3:Ha=ob;if(!Ha)return[2,!1];qb.label=4;case 4:return this.backendInstance=this.registry[G],this.setupRegisteredKernels(),this.profiler=new If(this.backendInstance),[2,!0]}})})};E.prototype.setupRegisteredKernels=function(){var G=this;qa(this.backendName).forEach(function(N){null!=
N.setupFunc&&N.setupFunc(G.backendInstance)})};E.prototype.disposeRegisteredKernels=function(G){var N=this;qa(G).forEach(function(Y){null!=Y.disposeFunc&&Y.disposeFunc(N.registry[G])})};E.prototype.initializeBackend=function(G){var N=this,Y=this.registryFactory[G];if(null==Y)throw Error("Cannot initialize backend "+G+", no registration found.");try{var ra=Y.factory();if(!ra||ra instanceof ze||"function"!==typeof ra.then)return this.registry[G]=ra,{success:!0,asyncInit:!1};var Ha=++this.pendingBackendInitId,
ob=ra.then(function(qb){if(Ha<N.pendingBackendInitId)return!1;N.registry[G]=qb;N.pendingBackendInit=null;return!0}).catch(function(qb){if(Ha<N.pendingBackendInitId)return!1;N.pendingBackendInit=null;console.warn("Initialization of backend "+G+" failed");console.warn(qb.stack||qb.message);return!1});this.pendingBackendInit=ob;return{success:ob,asyncInit:!0}}catch(qb){return console.warn("Initialization of backend "+G+" failed"),console.warn(qb.stack||qb.message),{success:!1,asyncInit:!1}}};E.prototype.removeBackend=
function(G){if(!(G in this.registryFactory))throw Error(G+" backend not found in registry");this.backendName===G&&null!=this.pendingBackendInit&&this.pendingBackendInitId++;G in this.registry&&(this.disposeRegisteredKernels(G),this.registry[G].dispose(),delete this.registry[G]);delete this.registryFactory[G];this.backendName===G&&(this.backendInstance=this.backendName=this.pendingBackendInit=null)};E.prototype.getSortedBackends=function(){var G=this;if(0===Object.keys(this.registryFactory).length)throw Error("No backend found in registry.");
return Object.keys(this.registryFactory).sort(function(N,Y){return G.registryFactory[Y].priority-G.registryFactory[N].priority})};E.prototype.initializeBackendsAndReturnBest=function(){for(var G=this.getSortedBackends(),N=0;N<G.length;N++){var Y=G[N],ra=this.initializeBackend(Y),Ha=ra.success;if((ra=ra.asyncInit)||Ha)return{name:Y,asyncInit:ra}}throw Error("Could not initialize any backends, all backend initializations failed.");};E.prototype.moveData=function(G,N){var Y=this.state.tensorInfo.get(N),
ra=Y.backend,Ha=this.readSync(N);ra.disposeData(N);Y.backend=G;G.move(N,Ha,Y.shape,Y.dtype);this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++};E.prototype.tidy=function(G,N){var Y=this,ra=null;if(null==N){if("function"!==typeof G)throw Error("Please provide a function to tidy()");N=G}else{if("string"!==typeof G&&!(G instanceof String))throw Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof N)throw Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
ra=G}var Ha;return this.scopedRun(function(){return Y.startScope(ra)},function(){return Y.endScope(Ha)},function(){Ha=N();Ha instanceof Promise&&console.error("Cannot return a Promise inside of tidy.");return Ha})};E.prototype.scopedRun=function(G,N,Y){G();try{var ra=Y();N();return ra}catch(Ha){throw N(),Ha;}};E.prototype.nextTensorId=function(){return E.nextTensorId++};E.prototype.nextVariableId=function(){return E.nextVariableId++};E.prototype.clone=function(G){var N=this.makeTensorFromDataId(G.dataId,
G.shape,G.dtype);this.addTapeNode(this.state.activeScope.name,{x:G},[N],function(Y){return{x:function(){return Ic.runKernelFunc(function(ra){return ra.cast(Y,"float32")},{x:Y},null,"Cast",{dtype:"float32"})}}},[],{});return N};E.prototype.runKernel=function(G,N,Y,ra,Ha){return this.runKernelFunc(null,N,null,G,Y,ra,Ha)};E.prototype.shouldCheckForMemLeaks=function(){return this.ENV.getBool("IS_TEST")};E.prototype.checkKernelForMemLeak=function(G,N,Y){var ra=this.backend.numDataIds(),Ha=0;Y.forEach(function(ob){Ha+=
"complex64"===ob.dtype?3:1});N=ra-N-Ha-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(0<N)throw Error("Backend '"+this.backendName+"' has an internal memory leak ("+(N+" data ids) after running '"+G+"'"));};E.prototype.runKernelFunc=function(G,N,Y,ra,Ha,ob,qb){var Eb=this,hc,Fc=[],Oc=this.isTapeOn();null==ra&&(ra=null!=this.state.activeScope?this.state.activeScope.name:"");var td=this.state.numBytes,be=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);
var Fe=ma(ra,this.backendName),fe;if(null!=Fe)var Be=function(){var Se=Eb.backend.numDataIds();fe=Fe.kernelFunc({inputs:N,attrs:Ha,backend:Eb.backend});var Hf=Array.isArray(fe)?fe:[fe];Eb.shouldCheckForMemLeaks()&&Eb.checkKernelForMemLeak(ra,Se,Hf);Se=Hf.map(function(yf){return Eb.makeTensorFromDataId(yf.dataId,yf.shape,yf.dtype)});Oc&&(Hf=Eb.getTensorsForGradient(ra,N,Se),null==Hf&&(null==qb&&(qb=[]),Hf=Se.filter(function(yf,Sf){return qb[Sf]}),Hf=(ob||[]).slice().concat(Hf)),Fc=Eb.saveTensorsForBackwardMode(Hf));
return Se};else{var Me=function(Se){Oc&&(Fc=Se.map(function(Hf){return Eb.keep(Eb.clone(Hf))}))};Be=function(){var Se=Eb.backend.numDataIds();fe=Eb.tidy(function(){return G(Eb.backend,Me)});var Hf=Array.isArray(fe)?fe:[fe];Eb.shouldCheckForMemLeaks()&&Eb.checkKernelForMemLeak(ra,Se,Hf);return Hf}}var hf;this.scopedRun(function(){return Eb.state.kernelDepth++},function(){return Eb.state.kernelDepth--},function(){Eb.ENV.getBool("DEBUG")||Eb.state.profiling?(hf=Eb.profiler.profileKernel(ra,N,function(){return Be()}),
Eb.ENV.getBool("DEBUG")&&Eb.profiler.logKernelProfile(hf),hc=hf.outputs):hc=Be()});Oc&&this.addTapeNode(ra,N,hc,Y,Fc,Ha);this.state.profiling&&this.state.activeProfile.kernels.push({name:ra,bytesAdded:this.state.numBytes-td,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-be,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(N).map(function(Se){return null!=N[Se]?N[Se].shape:null}),outputShapes:hc.map(function(Se){return Se.shape}),kernelTimeMs:hf.timeMs,extraInfo:hf.extraInfo});
return Array.isArray(fe)?hc:hc[0]};E.prototype.saveTensorsForBackwardMode=function(G){var N=this;return G.map(function(Y){return N.keep(N.clone(Y))})};E.prototype.getTensorsForGradient=function(G,N,Y){var ra=ja(G);if(null!=ra){var Ha=ra.inputsToSave||[],ob=ra.outputsToSave||[];G=void 0;ra.saveAllInputs?(e(Array.isArray(N),function(){return"saveAllInputs is true, expected inputs to be an array."}),G=Object.keys(N).map(function(qb){return N[qb]})):G=Ha.map(function(qb){return N[qb]});Y=Y.filter(function(qb,
Eb){return ob[Eb]});return G.concat(Y)}return null};E.prototype.makeTensor=function(G,N,Y,ra){if(null==G)throw Error("Values passed to engine.makeTensor() are null");Y=Y||"float32";ra=ra||this.backend;var Ha=G;"string"===Y&&Q(G[0])&&(Ha=G.map(function(ob){return oa(ob)}));G=ra.write(Ha,N,Y);N=new Da(N,Y,G,this.nextTensorId());this.incRef(N,ra);"string"===Y&&(Y=this.state.tensorInfo.get(G),Ha=O(Ha),this.state.numBytes+=Ha-Y.bytes,Y.bytes=Ha);return N};E.prototype.makeTensorFromDataId=function(G,N,
Y,ra){G=new Da(N,Y||"float32",G,this.nextTensorId());this.incRef(G,ra);return G};E.prototype.makeVariable=function(G,N,Y,ra){void 0===N&&(N=!0);Y=Y||this.nextVariableId().toString();null!=ra&&ra!==G.dtype&&(G=G.cast(ra));G=new mb(G,N,Y,this.nextTensorId());if(null!=this.state.registeredVariables[G.name])throw Error("Variable with name "+G.name+" was already registered");this.state.registeredVariables[G.name]=G;this.incRef(G,this.backend);return G};E.prototype.incRef=function(G,N){var Y=this.state.tensorInfo.has(G.dataId)?
this.state.tensorInfo.get(G.dataId).refCount:0;this.state.numTensors++;"string"===G.dtype&&this.state.numStringTensors++;0===Y&&(this.state.numDataBuffers++,Y=0,"complex64"!==G.dtype&&"string"!==G.dtype&&(Y=G.size*B(G.dtype)),this.state.tensorInfo.set(G.dataId,{backend:N||this.backend,dtype:G.dtype,shape:G.shape,bytes:Y,refCount:0}),this.state.numBytes+=Y);this.state.tensorInfo.get(G.dataId).refCount++;G instanceof mb||this.track(G)};E.prototype.disposeTensor=function(G){if(this.state.tensorInfo.has(G.dataId)){this.state.numTensors--;
"string"===G.dtype&&this.state.numStringTensors--;var N=this.state.tensorInfo.get(G.dataId);1>=N.refCount?("complex64"!==G.dtype&&(this.state.numBytes-=N.bytes),this.state.numDataBuffers--,N.backend.disposeData(G.dataId),this.state.tensorInfo.delete(G.dataId)):this.state.tensorInfo.get(G.dataId).refCount--}};E.prototype.disposeVariables=function(){for(var G in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[G])};E.prototype.disposeVariable=function(G){this.disposeTensor(G);
null!=this.state.registeredVariables[G.name]&&delete this.state.registeredVariables[G.name]};E.prototype.memory=function(){var G=this.backend.memory();G.numTensors=this.state.numTensors;G.numDataBuffers=this.state.numDataBuffers;G.numBytes=this.state.numBytes;0<this.state.numStringTensors&&(G.unreliable=!0,null==G.reasons&&(G.reasons=[]),G.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)"));return G};E.prototype.profile=function(G){return r(this,void 0,void 0,function(){var N,
Y,ra,Ha,ob,qb,Eb,hc;return u(this,function(Fc){switch(Fc.label){case 0:return this.state.profiling=!0,N=this.state.numBytes,Y=this.state.numTensors,this.state.activeProfile.kernels=[],ra=this.state.activeProfile,[4,G()];case 1:ra.result=Fc.sent(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max.apply(Math,this.state.activeProfile.kernels.map(function(Oc){return Oc.totalBytesSnapshot})),this.state.activeProfile.newBytes=this.state.numBytes-N,this.state.activeProfile.newTensors=this.state.numTensors-
Y,Ha=0,ob=this.state.activeProfile.kernels,Fc.label=2;case 2:if(!(Ha<ob.length))return[3,6];Eb=qb=ob[Ha];return[4,qb.kernelTimeMs];case 3:return Eb.kernelTimeMs=Fc.sent(),hc=qb,[4,qb.extraInfo];case 4:hc.extraInfo=Fc.sent(),Fc.label=5;case 5:return Ha++,[3,2];case 6:return[2,this.state.activeProfile]}})})};E.prototype.isTapeOn=function(){return 0<this.state.gradientDepth&&0===this.state.kernelDepth};E.prototype.addTapeNode=function(G,N,Y,ra,Ha,ob){var qb=this;N={id:this.state.nextTapeNodeId++,kernelName:G,
inputs:N,outputs:Y,saved:Ha};G=ja(G);null!=G&&(ra=G.gradFunc);null!=ra&&(N.gradient=function(Eb){Eb=Eb.map(function(hc,Fc){return null==hc?(hc=Y[Fc],Fc=aa(hc.size,hc.dtype),qb.makeTensor(Fc,hc.shape,hc.dtype)):hc});return ra(1<Eb.length?Eb:Eb[0],Ha,ob)});this.state.activeTape.push(N)};E.prototype.keep=function(G){G.kept=!0;return G};E.prototype.startTape=function(){0===this.state.gradientDepth&&(this.state.activeTape=[]);this.state.gradientDepth++};E.prototype.endTape=function(){this.state.gradientDepth--};
E.prototype.startScope=function(G){var N={track:[],name:"unnamed scope",id:this.state.nextScopeId++};G&&(N.name=G);this.state.scopeStack.push(N);this.state.activeScope=N};E.prototype.endScope=function(G){var N=this;G=$a(G);for(var Y=new Set(G.map(function(qb){return qb.id})),ra=0;ra<this.state.activeScope.track.length;ra++){var Ha=this.state.activeScope.track[ra];Ha.kept||Y.has(Ha.id)||Ha.dispose()}var ob=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-
1];G.forEach(function(qb){qb.kept||qb.scopeId!==ob.id||N.track(qb)})};E.prototype.gradients=function(G,N,Y,ra){var Ha=this;void 0===ra&&(ra=!1);e(0<N.length,function(){return"gradients() received an empty list of xs."});if(null!=Y&&"float32"!==Y.dtype)throw Error("dy must have 'float32' dtype, but has '"+Y.dtype+"'");var ob=this.scopedRun(function(){return Ha.startTape()},function(){return Ha.endTape()},function(){return Ha.tidy("forward",G)});e(ob instanceof Da,function(){return"The result y returned by f() must be a tensor."});
var qb=gb(this.state.activeTape,N,ob);if(!ra&&0===qb.length&&0<N.length)throw Error("Cannot compute gradient of y\x3df(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",function(){var Eb={};Eb[ob.id]=null==Y?wa(ob.shape):Y;Va(Eb,qb,function(Fc){return Ha.tidy(Fc)},lb);var hc=N.map(function(Fc){return Eb[Fc.id]});0===Ha.state.gradientDepth&&(Ha.state.activeTape.forEach(function(Fc){var Oc=0;for(Fc=Fc.saved;Oc<Fc.length;Oc++)Fc[Oc].dispose()}),
Ha.state.activeTape=null);return{value:ob,grads:hc}})};E.prototype.customGrad=function(G){var N=this;e(D(G),function(){return"The f passed in customGrad(f) must be a function."});return function(){for(var Y=[],ra=0;ra<arguments.length;ra++)Y[ra]=arguments[ra];e(Y.every(function(qb){return qb instanceof Da}),function(){return"The args passed in customGrad(f)(x1, x2,...) must all be tensors"});var Ha,ob={};Y.forEach(function(qb,Eb){ob[Eb]=qb});return N.runKernelFunc(function(qb,Eb){Ha=G.apply(void 0,
Y.concat([Eb]));e(Ha.value instanceof Da,function(){return"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"});e(D(Ha.gradFunc),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."});return Ha.value},ob,function(qb,Eb){qb=Ha.gradFunc(qb,Eb);qb=Array.isArray(qb)?qb:[qb];e(qb.length===Y.length,function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."});
e(qb.every(function(Fc){return Fc instanceof Da}),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."});var hc={};qb.forEach(function(Fc,Oc){hc[Oc]=function(){return Fc}});return hc})}};E.prototype.readSync=function(G){return this.state.tensorInfo.get(G).backend.readSync(G)};E.prototype.read=function(G){return this.state.tensorInfo.get(G).backend.read(G)};E.prototype.time=function(G){return r(this,
void 0,void 0,function(){var N,Y;return u(this,function(ra){switch(ra.label){case 0:return N=Ia(),[4,this.backend.time(G)];case 1:return Y=ra.sent(),Y.wallMs=Ia()-N,[2,Y]}})})};E.prototype.track=function(G){null!=this.state.activeScope&&(G.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(G));return G};Object.defineProperty(E.prototype,"registeredVariables",{get:function(){return this.state.registeredVariables},enumerable:!0,configurable:!0});E.prototype.reset=function(){this.pendingBackendInitId++;
this.state.dispose();this.ENV.reset();this.state=new bd;for(var G in this.registry)this.disposeRegisteredKernels(G),this.registry[G].dispose(),delete this.registry[G];this.pendingBackendInit=this.backendInstance=this.backendName=null};E.nextTensorId=0;E.nextVariableId=0;return E}(),Ic=Aa(),Kd={__proto__:null,isMobile:function(){if("undefined"!==typeof navigator&&null!=navigator){var E=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(E)||
/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(E.substr(0,
4))}return!1},isBrowser:Ya},Bd=pa();Bd.registerFlag("DEBUG",function(){return!1},function(E){E&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Bd.registerFlag("IS_BROWSER",function(){return Ya()});Bd.registerFlag("IS_NODE",function(){return"undefined"!==typeof Hc&&"undefined"!==typeof Hc.versions&&"undefined"!==typeof Hc.versions.node});Bd.registerFlag("IS_CHROME",function(){return"undefined"!==
typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)});Bd.registerFlag("PROD",function(){return!1});Bd.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",function(){return Bd.getBool("DEBUG")});Bd.registerFlag("DEPRECATION_WARNINGS_ENABLED",function(){return!0});Bd.registerFlag("IS_TEST",function(){return!1});var vd=vb({complex_:function(E,G){var N=La(E,"real","complex"),Y=La(G,"imag","complex");g(N.shape,Y.shape,"real and imag shapes, "+
N.shape+" and "+Y.shape+", must match in call to tf.complex().");return Ic.runKernelFunc(function(ra){return ra.complex(N,Y)},{real:N,imag:Y},null,"Complex")}}),Nd={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},de="undefined"!==typeof md&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa),ne=function(){function E(){this.saveRouters=[];this.loadRouters=[]}E.getInstance=function(){null==E.instance&&(E.instance=new E);return E.instance};E.registerSaveRouter=
function(G){E.getInstance().saveRouters.push(G)};E.registerLoadRouter=function(G){E.getInstance().loadRouters.push(G)};E.getSaveHandlers=function(G){return E.getHandlers(G,"save")};E.getLoadHandlers=function(G,N){return E.getHandlers(G,"load",N)};E.getHandlers=function(G,N,Y){var ra=[];("load"===N?E.getInstance().loadRouters:E.getInstance().saveRouters).forEach(function(Ha){Ha=Ha(G,Y);null!==Ha&&ra.push(Ha)});return ra};return E}(),xe=function(){function E(G){this.indexedDB=jb();if(null==G||!G)throw Error("For IndexedDB, modelPath must not be null, undefined or empty.");
this.modelPath=G}E.prototype.save=function(G){return r(this,void 0,void 0,function(){return u(this,function(N){if(G.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return[2,this.databaseAction(this.modelPath,G)]})})};E.prototype.load=function(){return r(this,void 0,void 0,function(){return u(this,function(G){return[2,this.databaseAction(this.modelPath)]})})};E.prototype.databaseAction=function(G,N){var Y=
this;return new Promise(function(ra,Ha){var ob=Y.indexedDB.open("tensorflowjs",1);ob.onupgradeneeded=function(){return Wb(ob)};ob.onsuccess=function(){var qb=ob.result;if(null==N){var Eb=qb.transaction("models_store","readonly"),hc=Eb.objectStore("models_store").get(Y.modelPath);hc.onsuccess=function(){if(null==hc.result)return qb.close(),Ha(Error("Cannot find model with path '"+Y.modelPath+"' in IndexedDB."));ra(hc.result.modelArtifacts)};hc.onerror=function(fe){qb.close();return Ha(hc.error)};Eb.oncomplete=
function(){return qb.close()}}else{var Fc=vc(N),Oc=qb.transaction("model_info_store","readwrite"),td=Oc.objectStore("model_info_store"),be=td.put({modelPath:Y.modelPath,modelArtifactsInfo:Fc}),Fe;be.onsuccess=function(){Fe=qb.transaction("models_store","readwrite");var fe=Fe.objectStore("models_store").put({modelPath:Y.modelPath,modelArtifacts:N,modelArtifactsInfo:Fc});fe.onsuccess=function(){return ra({modelArtifactsInfo:Fc})};fe.onerror=function(Be){td=Oc.objectStore("model_info_store");Be=td.delete(Y.modelPath);
Be.onsuccess=function(){qb.close();return Ha(fe.error)};Be.onerror=function(Me){qb.close();return Ha(fe.error)}}};be.onerror=function(fe){qb.close();return Ha(be.error)};Oc.oncomplete=function(){null==Fe?qb.close():Fe.oncomplete=function(){return qb.close()}}}};ob.onerror=function(qb){return Ha(ob.error)}})};E.URL_SCHEME="indexeddb://";return E}(),Vd=function(E){return pa().getBool("IS_BROWSER")?!Array.isArray(E)&&E.startsWith(xe.URL_SCHEME)?new xe(E.slice(xe.URL_SCHEME.length)):null:null};ne.registerSaveRouter(Vd);
ne.registerLoadRouter(Vd);var le=function(){function E(){this.indexedDB=jb()}E.prototype.listModels=function(){return r(this,void 0,void 0,function(){var G=this;return u(this,function(N){return[2,new Promise(function(Y,ra){var Ha=G.indexedDB.open("tensorflowjs",1);Ha.onupgradeneeded=function(){return Wb(Ha)};Ha.onsuccess=function(){var ob=Ha.result,qb=ob.transaction("model_info_store","readonly"),Eb=qb.objectStore("model_info_store").getAll();Eb.onsuccess=function(){for(var hc={},Fc=0,Oc=Eb.result;Fc<
Oc.length;Fc++){var td=Oc[Fc];hc[td.modelPath]=td.modelArtifactsInfo}Y(hc)};Eb.onerror=function(hc){ob.close();return ra(Eb.error)};qb.oncomplete=function(){return ob.close()}};Ha.onerror=function(ob){return ra(Ha.error)}})]})})};E.prototype.removeModel=function(G){return r(this,void 0,void 0,function(){var N=this;return u(this,function(Y){G=xc(G);return[2,new Promise(function(ra,Ha){var ob=N.indexedDB.open("tensorflowjs",1);ob.onupgradeneeded=function(){return Wb(ob)};ob.onsuccess=function(){var qb=
ob.result,Eb=qb.transaction("model_info_store","readwrite"),hc=Eb.objectStore("model_info_store"),Fc=hc.get(G),Oc;Fc.onsuccess=function(){if(null==Fc.result)return qb.close(),Ha(Error("Cannot find model with path '"+G+"' in IndexedDB."));var td=hc.delete(G),be=function(){Oc=qb.transaction("models_store","readwrite");var Fe=Oc.objectStore("models_store").delete(G);Fe.onsuccess=function(){return ra(Fc.result.modelArtifactsInfo)};Fe.onerror=function(fe){return Ha(Fc.error)}};td.onsuccess=be;td.onerror=
function(Fe){be();qb.close();return Ha(Fc.error)}};Fc.onerror=function(td){qb.close();return Ha(Fc.error)};Eb.oncomplete=function(){null==Oc?qb.close():Oc.oncomplete=function(){return qb.close()}}};ob.onerror=function(qb){return Ha(ob.error)}})]})})};return E}(),ue=function(){function E(G){if(!pa().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw Error("The current environment does not support local storage.");this.LS=window.localStorage;if(null==
G||!G)throw Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=G;this.keys=Ec(this.modelPath)}E.prototype.save=function(G){return r(this,void 0,void 0,function(){var N,Y,ra;return u(this,function(Ha){if(G.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");N=JSON.stringify(G.modelTopology);Y=JSON.stringify(G.weightSpecs);ra=vc(G);try{this.LS.setItem(this.keys.info,JSON.stringify(ra));
this.LS.setItem(this.keys.topology,N);this.LS.setItem(this.keys.weightSpecs,Y);var ob=this.LS,qb=ob.setItem,Eb=this.keys.weightData;var hc=G.weightData;if(de)var Fc=md.from(hc).toString("base64");else{var Oc=new Uint8Array(hc);Ha="";hc=0;for(var td=Oc.length;hc<td;hc++)Ha+=String.fromCharCode(Oc[hc]);Fc=btoa(Ha)}qb.call(ob,Eb,Fc);this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:G.format,generatedBy:G.generatedBy,convertedBy:G.convertedBy,userDefinedMetadata:G.userDefinedMetadata}));
return[2,{modelArtifactsInfo:ra}]}catch(be){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes\x3d"+(ra.modelTopologyBytes+", weightSpecsBytes\x3d")+(ra.weightSpecsBytes+", weightDataBytes\x3d")+(ra.weightDataBytes+
"."));}})})};E.prototype.load=function(){return r(this,void 0,void 0,function(){var G,N,Y,ra,Ha,ob,qb;return u(this,function(Eb){G=JSON.parse(this.LS.getItem(this.keys.info));if(null==G)throw Error("In local storage, there is no model with name '"+this.modelPath+"'");if("JSON"!==G.modelTopologyType)throw Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");N={};Y=JSON.parse(this.LS.getItem(this.keys.topology));if(null==Y)throw Error("In local storage, the topology of model '"+
this.modelPath+"' is missing.");N.modelTopology=Y;ra=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==ra)throw Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");N.weightSpecs=ra;Ha=this.LS.getItem(this.keys.modelMetadata);null!=Ha&&(ob=JSON.parse(Ha),N.format=ob.format,N.generatedBy=ob.generatedBy,N.convertedBy=ob.convertedBy,N.userDefinedMetadata=ob.userDefinedMetadata);qb=this.LS.getItem(this.keys.weightData);if(null==qb)throw Error("In local storage, the binary weight values of model '"+
(this.modelPath+"' are missing."));Eb=N;var hc=qb;if(de)hc=md.from(hc,"base64"),hc=hc.buffer.slice(hc.byteOffset,hc.byteOffset+hc.byteLength);else{hc=atob(hc);for(var Fc=new Uint8Array(hc.length),Oc=0;Oc<hc.length;++Oc)Fc.set([hc.charCodeAt(Oc)],Oc);hc=Fc.buffer}Eb.weightData=hc;return[2,N]})})};E.URL_SCHEME="localstorage://";return E}(),Ae=function(E){return pa().getBool("IS_BROWSER")?!Array.isArray(E)&&E.startsWith(ue.URL_SCHEME)?new ue(E.slice(ue.URL_SCHEME.length)):null:null};ne.registerSaveRouter(Ae);
ne.registerLoadRouter(Ae);var kb=function(){function E(){e(pa().getBool("IS_BROWSER"),function(){return"Current environment is not a web browser"});e("undefined"===typeof window||"undefined"!==typeof window.localStorage,function(){return"Current browser does not appear to support localStorage"});this.LS=window.localStorage}E.prototype.listModels=function(){return r(this,void 0,void 0,function(){var G,N,Y,ra;return u(this,function(Ha){G={};for(N=0;N<this.LS.length;++N)if(Y=this.LS.key(N),Y.startsWith("tensorflowjs_models/")&&
Y.endsWith("/info")){Ha=Y;var ob=Ha.split("/");if(3>ob.length)throw Error("Invalid key format: "+Ha);ra=ob.slice(1,ob.length-1).join("/");G[ra]=JSON.parse(this.LS.getItem(Y))}return[2,G]})})};E.prototype.removeModel=function(G){return r(this,void 0,void 0,function(){var N,Y;return u(this,function(ra){ra=G;G=ra.startsWith(ue.URL_SCHEME)?ra.slice(ue.URL_SCHEME.length):ra;N=Ec(G);if(null==this.LS.getItem(N.info))throw Error("Cannot find model at path '"+G+"'");Y=JSON.parse(this.LS.getItem(N.info));this.LS.removeItem(N.info);
this.LS.removeItem(N.topology);this.LS.removeItem(N.weightSpecs);this.LS.removeItem(N.weightData);return[2,Y]})})};return E}(),yb=function(){function E(){this.managers={}}E.getInstance=function(){null==E.instance&&(E.instance=new E);return E.instance};E.registerManager=function(G,N){e(null!=G,function(){return"scheme must not be undefined or null."});G.endsWith("://")&&(G=G.slice(0,G.indexOf("://")));e(0<G.length,function(){return"scheme must not be an empty string."});var Y=E.getInstance();e(null==
Y.managers[G],function(){return"A model store manager is already registered for scheme '"+G+"'."});Y.managers[G]=N};E.getManager=function(G){var N=this.getInstance().managers[G];if(null==N)throw Error("Cannot find model manager for scheme '"+G+"'");return N};E.getSchemes=function(){return Object.keys(this.getInstance().managers)};return E}(),Hb=function(){function E(){}E.prototype.fetch=function(G,N){return fetch(G,N)};E.prototype.now=function(){return performance.now()};E.prototype.encode=function(G,
N){if("utf-8"!==N&&"utf8"!==N)throw Error("Browser's encoder only supports utf-8, but got "+N);null==this.textEncoder&&(this.textEncoder=new TextEncoder);return this.textEncoder.encode(G)};E.prototype.decode=function(G,N){return(new TextDecoder(N)).decode(G)};return E}();if(pa().get("IS_BROWSER")){pa().setPlatform("browser",new Hb);try{yb.registerManager(ue.URL_SCHEME,new kb)}catch(E){}try{yb.registerManager(xe.URL_SCHEME,new le)}catch(E){}}var ec={importFetch:function(){return A(35)}},Bc,Sc=function(){function E(){this.util=
A(35);this.textEncoder=new this.util.TextEncoder}E.prototype.fetch=function(G,N){if(null!=pa().global.fetch)return pa().global.fetch(G,N);null==Bc&&(Bc=ec.importFetch());return Bc(G,N)};E.prototype.now=function(){var G=Hc.hrtime();return 1E3*G[0]+G[1]/1E6};E.prototype.encode=function(G,N){if("utf-8"!==N&&"utf8"!==N)throw Error("Node built-in encoder only supports utf-8, but got "+N);return this.textEncoder.encode(G)};E.prototype.decode=function(G,N){return 0===G.length?"":(new this.util.TextDecoder(N)).decode(G)};
return E}();pa().get("IS_NODE")&&pa().setPlatform("node",new Sc);var Uc=vb({cast_:function(E,G){var N=La(E,"x","cast");if(!z(G))throw Error("Failed to cast to unknown dtype "+G);if("string"===G&&"string"!==N.dtype||"string"!==G&&"string"===N.dtype)throw Error("Only strings can be casted to strings");return Ic.runKernelFunc(function(Y){return Y.cast(N,G)},{x:N},null,"Cast",{dtype:G})}}),Ed=vb({clone_:function(E){var G=La(E,"x","clone",null);return Ic.runKernelFunc(function(){return Ic.makeTensorFromDataId(G.dataId,
G.shape,G.dtype)},{x:G},null,"Identity")}});Aa();Wa={buffer:kd,cast:Uc,clone:Ed,print:ld};var Sd=function(){function E(G){if(!pa().getBool("IS_BROWSER"))throw Error("browserDownloads() cannot proceed because the current environment is not a browser.");G.startsWith(E.URL_SCHEME)&&(G=G.slice(E.URL_SCHEME.length));if(null==G||0===G.length)G="model";this.modelTopologyFileName=G+".json";this.weightDataFileName=G+".weights.bin"}E.prototype.save=function(G){return r(this,void 0,void 0,function(){var N,Y,
ra,Ha,ob,qb;return u(this,function(Eb){switch(Eb.label){case 0:if("undefined"===typeof document)throw Error("Browser downloads are not supported in this environment since `document` is not present");N=window.URL.createObjectURL(new Blob([G.weightData],{type:"application/octet-stream"}));if(!(G.modelTopology instanceof ArrayBuffer))return[3,1];throw Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");case 1:return Y=[{paths:["./"+this.weightDataFileName],
weights:G.weightSpecs}],ra={modelTopology:G.modelTopology,format:G.format,generatedBy:G.generatedBy,convertedBy:G.convertedBy,weightsManifest:Y},Ha=window.URL.createObjectURL(new Blob([JSON.stringify(ra)],{type:"application/json"})),ob=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor,ob.download=this.modelTopologyFileName,ob.href=Ha,[4,Nb(function(){return ob.dispatchEvent(new MouseEvent("click"))})];case 2:Eb.sent();if(null==G.weightData)return[3,4];qb=null==this.weightDataAnchor?
document.createElement("a"):this.weightDataAnchor;qb.download=this.weightDataFileName;qb.href=N;return[4,Nb(function(){return qb.dispatchEvent(new MouseEvent("click"))})];case 3:Eb.sent(),Eb.label=4;case 4:return[2,{modelArtifactsInfo:vc(G)}]}})})};E.URL_SCHEME="downloads://";return E}(),Xe=function(){function E(G){if(null==G||1>G.length)throw Error("When calling browserFiles, at least 1 file is required, but received "+G);this.files=G}E.prototype.load=function(){return r(this,void 0,void 0,function(){var G,
N,Y=this;return u(this,function(ra){G=this.files[0];N=this.files.slice(1);return[2,new Promise(function(Ha,ob){var qb=new FileReader;qb.onload=function(Eb){var hc=JSON.parse(Eb.target.result),Fc=hc.modelTopology;if(null==Fc)ob(Error("modelTopology field is missing from file "+G.name));else if(0===N.length&&Ha({modelTopology:Fc}),Eb=hc.weightsManifest,null==Eb)ob(Error("weightManifest field is missing from file "+G.name));else{try{var Oc=Y.checkManifestAndWeightFiles(Eb,N)}catch(fe){ob(fe);return}var td=
[],be=[],Fe=[];Eb.forEach(function(fe){fe.paths.forEach(function(Be){be.push(Be);Fe.push(null)});td.push.apply(td,fe.weights)});Eb.forEach(function(fe){fe.paths.forEach(function(Be){var Me=new FileReader;Me.onload=function(hf){hf=hf.target.result;var Se=be.indexOf(Be);Fe[Se]=hf;-1===Fe.indexOf(null)&&Ha({modelTopology:Fc,weightSpecs:td,weightData:sc(Fe),format:hc.format,generatedBy:hc.generatedBy,convertedBy:hc.convertedBy,userDefinedMetadata:hc.userDefinedMetadata})};Me.onerror=function(hf){return ob("Failed to weights data from file of path '"+
Be+"'.")};Me.readAsArrayBuffer(Oc[Be])})})}};qb.onerror=function(Eb){return ob("Failed to read model topology and weights manifest JSON from file '"+(G.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only."))};qb.readAsText(G)})]})})};E.prototype.checkManifestAndWeightFiles=function(G,N){for(var Y=[],ra=N.map(function(qb){return tc(qb.name)}),Ha={},ob=0;ob<G.length;ob++)G[ob].paths.forEach(function(qb){var Eb=tc(qb);if(-1!==Y.indexOf(Eb))throw Error("Duplicate file basename found in weights manifest: '"+
(Eb+"'"));Y.push(Eb);if(-1===ra.indexOf(Eb))throw Error("Weight file with basename '"+Eb+"' is not provided.");Ha[qb]=N[ra.indexOf(Eb)]});if(Y.length!==N.length)throw Error("Mismatch in the number of files in weights manifest ("+(Y.length+") and the number of weight files provided (")+(N.length+")."));return Ha};return E}();ne.registerSaveRouter(function(E){return pa().getBool("IS_BROWSER")&&!Array.isArray(E)&&E.startsWith(Sd.URL_SCHEME)?(E=E.slice(Sd.URL_SCHEME.length),void 0===E&&(E="model"),new Sd(E)):
null});var pf=function(){function E(G,N){this.DEFAULT_METHOD="POST";null==N&&(N={});this.weightPathPrefix=N.weightPathPrefix;this.onProgress=N.onProgress;this.weightUrlConverter=N.weightUrlConverter;null!=N.fetchFunc?(e("function"===typeof N.fetchFunc,function(){return"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"}),this.fetch=N.fetchFunc):this.fetch=pa().platform.fetch;e(null!=G&&0<G.length,function(){return"URL path for http must not be null, undefined or empty."});
Array.isArray(G)&&e(2===G.length,function(){return"URL paths for http must have a length of 2, (actual length is "+(G.length+").")});this.path=G;if(null!=N.requestInit&&null!=N.requestInit.body)throw Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=N.requestInit||{}}E.prototype.save=function(G){return r(this,void 0,void 0,function(){var N,Y,ra,Ha;return u(this,function(ob){switch(ob.label){case 0:if(G.modelTopology instanceof ArrayBuffer)throw Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
N=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);N.body=new FormData;Y=[{paths:["./model.weights.bin"],weights:G.weightSpecs}];ra={modelTopology:G.modelTopology,format:G.format,generatedBy:G.generatedBy,convertedBy:G.convertedBy,userDefinedMetadata:G.userDefinedMetadata,weightsManifest:Y};N.body.append("model.json",new Blob([JSON.stringify(ra)],{type:"application/json"}),"model.json");null!=G.weightData&&N.body.append("model.weights.bin",new Blob([G.weightData],{type:"application/octet-stream"}),
"model.weights.bin");return[4,this.fetch(this.path,N)];case 1:Ha=ob.sent();if(Ha.ok)return[2,{modelArtifactsInfo:vc(G),responses:[Ha]}];throw Error("BrowserHTTPRequest.save() failed due to HTTP response status "+(Ha.status+"."));}})})};E.prototype.load=function(){return r(this,void 0,void 0,function(){var G,N,Y,ra,Ha,ob,qb,Eb,hc,Fc,Oc,td,be,Fe;return u(this,function(fe){switch(fe.label){case 0:return[4,this.fetch(this.path,this.requestInit)];case 1:G=fe.sent();if(!G.ok)throw Error("Request to "+this.path+
" failed with status code "+(G.status+". Please verify this URL points to the model JSON of the model to load."));fe.label=2;case 2:return fe.trys.push([2,4,,5]),[4,G.json()];case 3:return N=fe.sent(),[3,5];case 4:throw fe.sent(),Y="Failed to parse model JSON of response from "+this.path+".",Y=this.path.endsWith(".pb")?Y+" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":
Y+" Please make sure the server is serving valid JSON for this request.",Error(Y);case 5:ra=N.modelTopology;Ha=N.weightsManifest;ob=N.generatedBy;qb=N.convertedBy;Eb=N.format;hc=N.userDefinedMetadata;if(null==ra&&null==Ha)throw Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return null==Ha?[3,7]:[4,this.loadWeights(Ha)];case 6:td=fe.sent(),Fc=td[0],Oc=td[1],fe.label=7;case 7:be={modelTopology:ra,weightSpecs:Fc,weightData:Oc,userDefinedMetadata:hc,
generatedBy:ob,convertedBy:qb,format:Eb};if(Fe=N.modelInitializer)be.modelInitializer=Fe;return[2,be]}})})};E.prototype.loadWeights=function(G){return r(this,void 0,void 0,function(){var N,Y,ra,Ha,ob,qb,Eb,hc,Fc,Oc,td,be,Fe,fe,Be,Me,hf,Se,Hf,yf,Sf;return u(this,function(af){switch(af.label){case 0:var tf=N=Array.isArray(this.path)?this.path[1]:this.path,zf=tf.lastIndexOf("/"),ig=tf.lastIndexOf("?");af=tf.substring(0,zf);tf=ig>zf?tf.substring(ig):"";Y=[af+"/",tf];ra=Y[0];Ha=Y[1];ob=this.weightPathPrefix||
ra;qb=[];Eb=0;for(hc=G;Eb<hc.length;Eb++)Fc=hc[Eb],qb.push.apply(qb,Fc.weights);Oc=[];td=[];be=0;for(Fe=G;be<Fe.length;be++)for(fe=Fe[be],Be=0,Me=fe.paths;Be<Me.length;Be++)hf=Me[Be],null!=this.weightUrlConverter?td.push(this.weightUrlConverter(hf)):Oc.push(ob+hf+Ha);if(!this.weightUrlConverter)return[3,2];Hf=(Se=Oc.push).apply;yf=[Oc];return[4,Promise.all(td)];case 1:Hf.apply(Se,yf.concat([af.sent()])),af.label=2;case 2:return[4,Tb(Oc,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress})];
case 3:return Sf=af.sent(),[2,[qb,sc(Sf)]]}})})};E.URL_SCHEME_REGEX=/^https?:\/\//;return E}(),wf=function(E,G){if("undefined"!==typeof fetch||null!=G&&null!=G.fetchFunc){var N=!0;if(N=Array.isArray(E)?E.every(function(Y){return Kc(Y)}):Kc(E))return Vc(E,G)}return null};ne.registerSaveRouter(wf);ne.registerLoadRouter(wf);var Yf=function(){function E(G){this.modelArtifacts=G}E.prototype.load=function(){return r(this,void 0,void 0,function(){return u(this,function(G){return[2,this.modelArtifacts]})})};
return E}(),of=function(){function E(G){this.saveHandler=G}E.prototype.save=function(G){return r(this,void 0,void 0,function(){return u(this,function(N){return[2,this.saveHandler(G)]})})};return E}(),fg={__proto__:null,browserFiles:function(E){return new Xe(E)},browserHTTPRequest:function(E,G){return Vc(E,G)},concatenateArrayBuffers:sc,decodeWeights:Yc,encodeWeights:function(E,G){return r(this,void 0,void 0,function(){var N,Y,ra,Ha,ob,qb,Eb=this;return u(this,function(hc){switch(hc.label){case 0:N=
[];Y=[];ra=Array.isArray(E)?E.map(function(Fc){return Fc.name}):Object.keys(E);Ha=function(Fc){var Oc=ra[Fc],td=Array.isArray(E)?E[Fc].tensor:E[Oc];if("float32"!==td.dtype&&"int32"!==td.dtype&&"bool"!==td.dtype&&"string"!==td.dtype&&"complex64"!==td.dtype)throw Error("Unsupported dtype in weight '"+Oc+"': "+td.dtype);Fc={name:Oc,shape:td.shape,dtype:td.dtype};"string"===td.dtype?(Oc=new Promise(function(be){return r(Eb,void 0,void 0,function(){var Fe,fe,Be,Me,hf,Se,Hf;return u(this,function(yf){switch(yf.label){case 0:return[4,
td.bytes()];case 1:Fe=yf.sent();fe=Fe.reduce(function(Sf,af){return Sf+af.length},0)+4*Fe.length;Be=new Uint8Array(fe);for(hf=Me=0;hf<Fe.length;hf++)Se=Fe[hf],Hf=new Uint8Array((new Uint32Array([Se.length])).buffer),Be.set(Hf,Me),Me+=4,Be.set(Se,Me),Me+=Se.length;be(Be);return[2]}})})}),Y.push(Oc)):Y.push(td.data());null!=G&&(Fc.group=G);N.push(Fc)};for(ob=0;ob<ra.length;++ob)Ha(ob);return[4,Promise.all(Y)];case 1:return qb=hc.sent(),[2,{data:yd(qb),specs:N}]}})})},fromMemory:function(E,G,N,Y){if(1===
arguments.length){if(null!=E.modelTopology||null!=E.weightSpecs)return new Yf(E);console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");return new Yf({modelTopology:E})}console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
return new Yf({modelTopology:E,weightSpecs:G,weightData:N,trainingConfig:Y})},getLoadHandlers:function(E,G){return ne.getLoadHandlers(E,G)},getModelArtifactsInfoForJSON:vc,getSaveHandlers:function(E){return ne.getSaveHandlers(E)},http:Vc,isHTTPScheme:Kc,loadWeights:function(E,G,N,Y){void 0===G&&(G="");return r(this,void 0,void 0,function(){var ra,Ha;return u(this,function(ob){ra=function(qb){return Tb(qb,{requestInit:Y})};Ha=Ac(ra);return[2,Ha(E,G,N)]})})},registerLoadRouter:function(E){return ne.registerLoadRouter(E)},
registerSaveRouter:function(E){return ne.registerSaveRouter(E)},weightsLoaderFactory:Ac,withSaveHandler:function(E){return new of(E)},copyModel:function(E,G){return r(this,void 0,void 0,function(){return u(this,function(N){return[2,Dc(E,G,!1)]})})},listModels:function(){return r(this,void 0,void 0,function(){var E,G,N,Y,ra,Ha,ob,qb;return u(this,function(Eb){switch(Eb.label){case 0:E=yb.getSchemes(),G={},N=0,Y=E,Eb.label=1;case 1:if(!(N<Y.length))return[3,4];ra=Y[N];return[4,yb.getManager(ra).listModels()];
case 2:Ha=Eb.sent();for(ob in Ha)qb=ra+"://"+ob,G[qb]=Ha[ob];Eb.label=3;case 3:return N++,[3,1];case 4:return[2,G]}})})},moveModel:function(E,G){return r(this,void 0,void 0,function(){return u(this,function(N){return[2,Dc(E,G,!0)]})})},removeModel:function(E){return r(this,void 0,void 0,function(){var G,N;return u(this,function(Y){G=dd(E);N=yb.getManager(G.scheme);return[2,N.removeModel(G.path)]})})}},zd=vb({reshape_:function(E,G){var N=La(E,"x","reshape",null);return Ic.runKernelFunc(function(Y,
ra){G=k(G,N.size);e(N.size===c(G),function(){return"new shape and old shape must have the same number of elements."});ra([N]);return Y.reshape(N,G)},{x:N},null,"Reshape",{shape:G})}}),uf=vb({matMul_:function(E,G,N,Y){void 0===N&&(N=!1);void 0===Y&&(Y=!1);var ra=La(E,"a","matMul"),Ha=La(G,"b","matMul");E=ya(ra,Ha);ra=E[0];Ha=E[1];return Ic.runKernelFunc(function(ob,qb){qb([ra,Ha]);var Eb=N?ra.shape[ra.rank-2]:ra.shape[ra.rank-1],hc=Y?Ha.shape[Ha.rank-1]:Ha.shape[Ha.rank-2],Fc=N?ra.shape[ra.rank-1]:
ra.shape[ra.rank-2],Oc=Y?Ha.shape[Ha.rank-2]:Ha.shape[Ha.rank-1],td=ra.shape.slice(0,-2),be=Ha.shape.slice(0,-2),Fe=c(td),fe=c(be);e(2<=ra.rank&&2<=Ha.rank&&(Fe===fe||1===Fe||1===fe),function(){return"Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of ("+(td+") and ("+be+").")});e(Eb===hc,function(){return"Error in matMul: inner shapes ("+Eb+") and ("+(hc+") of Tensors with shapes "+ra.shape+" and ")+(Ha.shape+
" and transposeA\x3d"+N)+(" and transposeB\x3d"+Y+" must match.")});qb=(Fe>fe?td:be).concat([Fc,Oc]);Fc=N?zd(ra,[Fe,Eb,Fc]):zd(ra,[Fe,Fc,Eb]);Oc=Y?zd(Ha,[fe,Oc,hc]):zd(Ha,[fe,hc,Oc]);ob=ob.batchMatMul(Fc,Oc,N,Y);return zd(ob,qb)},{a:ra,b:Ha},null,"BatchMatMul",{transposeA:N,transposeB:Y})}}),ng=vb({oneHot_:function(E,G,N,Y){void 0===N&&(N=1);void 0===Y&&(Y=0);if(2>G)throw Error("Error in oneHot: depth must be \x3e\x3d2, but it is "+G);var ra=La(E,"indices","oneHot","int32"),Ha=ra.shape.concat([G]);
return Ic.runKernelFunc(function(ob,qb){qb([ra]);return zd(ob.oneHot(zd(ra,[ra.size]),G,N,Y),Ha)},{indices:ra},null,"OneHot",{depth:G,onValue:N,offValue:Y})}}),hg=vb({transpose_:function(E,G){var N=La(E,"x","transpose");null==G&&(G=N.shape.map(function(Y,ra){return ra}).reverse());e(N.rank===G.length,function(){return"Error in transpose: rank of input "+N.rank+" must match length of perm "+(G+".")});G.forEach(function(Y){e(0<=Y&&Y<N.rank,function(){return"All entries in 'perm' must be between 0 and "+
(N.rank-1)+(" but got "+G)})});return 1>=N.rank?N.clone():Ic.runKernelFunc(function(Y){return Y.transpose(N,G)},{x:N},null,"Transpose",{perm:G})}}),Ng={__proto__:null,confusionMatrix:vb({confusionMatrix_:function(E,G,N){var Y=La(E,"labels","confusionMatrix"),ra=La(G,"predictions","confusionMatrix");e(null==N||0<N&&Number.isInteger(N),function(){return"If provided, numClasses must be a positive integer, but got "+N});e(1===Y.rank,function(){return"Expected the rank of labels to be 1, but got "+Y.rank});
e(1===ra.rank,function(){return"Expected the rank of predictions to be 1, but got "+ra.rank});e(Y.shape[0]===ra.shape[0],function(){return"Mismatch in the number of examples: "+(Y.shape[0]+" vs. "+ra.shape[0]+". Labels and predictions should have the same number of elements.")});e(0<N&&Number.isInteger(N),function(){return"numClasses is required to be a positive integer, but got "+N});G=ng(Uc(Y,"int32"),N);E=ng(Uc(ra,"int32"),N);G=hg(G);E=uf(G,E);return Uc(E,"int32")}})},Ig,Og={__proto__:null,toPixels:function(E,
G){return r(this,void 0,void 0,function(){var N,Y,ra,Ha,ob,qb,Eb,hc,Fc,Oc,td,be,Fe,fe,Be,Me;return u(this,function(hf){switch(hf.label){case 0:N=La(E,"img","toPixels");E instanceof Da||(Y=N,N=Uc(Y,"int32"),Y.dispose());if(2!==N.rank&&3!==N.rank)throw Error("toPixels only supports rank 2 or 3 tensors, got rank "+N.rank+".");ra=N.shape.slice(0,2);Ha=ra[0];ob=ra[1];qb=2===N.rank?1:N.shape[2];if(4<qb||2===qb)throw Error("toPixels only supports depth of size 1, 3 or 4 but got "+qb);if("float32"!==N.dtype&&
"int32"!==N.dtype)throw Error("Unsupported type for toPixels: "+N.dtype+". Please use float32 or int32 tensors.");return[4,N.data()];case 1:Eb=hf.sent();hc="float32"===N.dtype?255:1;Fc=new Uint8ClampedArray(ob*Ha*4);for(Oc=0;Oc<Ha*ob;++Oc){td=[0,0,0,255];for(be=0;be<qb;be++){Fe=Eb[Oc*qb+be];if("float32"===N.dtype){if(0>Fe||1<Fe)throw Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered "+(Fe+"."));}else if("int32"===N.dtype&&(0>Fe||255<Fe))throw Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered "+
(Fe+"."));1===qb?(td[0]=Fe*hc,td[1]=Fe*hc,td[2]=Fe*hc):td[be]=Fe*hc}fe=4*Oc;Fc[fe+0]=Math.round(td[0]);Fc[fe+1]=Math.round(td[1]);Fc[fe+2]=Math.round(td[2]);Fc[fe+3]=Math.round(td[3])}null!=G&&(G.width=ob,G.height=Ha,Be=G.getContext("2d"),Me=new ImageData(Fc,ob,Ha),Be.putImageData(Me,0,0));N!==E&&N.dispose();return[2,Fc]}})})},fromPixels:vb({fromPixels_:function(E,G){void 0===G&&(G=3);if(4<G)throw Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==E)throw Error("pixels passed to tf.browser.fromPixels() can not be null");
var N=!1,Y=!1,ra=!1,Ha=!1,ob=!1;if(E.data instanceof Uint8Array)N=!0;else if("undefined"!==typeof ImageData&&E instanceof ImageData)Y=!0;else if("undefined"!==typeof HTMLVideoElement&&E instanceof HTMLVideoElement)ra=!0;else if("undefined"!==typeof HTMLImageElement&&E instanceof HTMLImageElement)Ha=!0;else if(null!=E.getContext)ob=!0;else throw Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+
E.constructor.name);if(ra&&ra&&2>E.readyState)throw Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the \x3cvideo\x3e element.");if(null!=ma("FromPixels",Ic.backendName))return Ic.runKernel("FromPixels",{pixels:E},{numChannels:G});var qb=ra?[E.videoWidth,E.videoHeight]:[E.width,E.height],Eb=qb[0];qb=qb[1];if(ob)var hc=E.getContext("2d").getImageData(0,0,Eb,qb).data;else if(Y||N)hc=E.data;else if(Ha||ra)null==Ig&&(Ig=document.createElement("canvas").getContext("2d")),
Ig.canvas.width=Eb,Ig.canvas.height=qb,Ig.drawImage(E,0,0,Eb,qb),hc=Ig.getImageData(0,0,Eb,qb).data;if(4===G)E=new Int32Array(hc);else for(N=Eb*qb,E=new Int32Array(N*G),Y=0;Y<N;Y++)for(ra=0;ra<G;++ra)E[Y*G+ra]=hc[4*Y+ra];return Pc(E,[qb,Eb,G],"int32")}})},Dg={__proto__:null,prepareAndValidate:gd},fh={__proto__:null,validateUpdateShape:Dd,validateInput:Jd,calculateShapes:we},Kg={__proto__:null,assertParamsValid:Ne,maskToAxes:Je,computeOutShape:Qe,stridesWithElidedDims:Ce,getNormalizedAxes:od,startIndicesWithElidedDims:Ud,
stopIndicesWithElidedDims:Rd,stridesForAxis:pc,startForAxis:Ue,stopForAxis:lc,isSliceContinous:function(E,G,N){for(var Y=N.length,ra=0;ra<N.length;ra++)if(1<N[ra]){Y=ra;break}for(ra=Y+1;ra<N.length;ra++)if(0<G[ra]||N[ra]!==E[ra])return!1;return!0},computeFlatOffset:function(E,G){for(var N=0<E.length?E[E.length-1]:1,Y=0;Y<E.length-1;Y++)N+=E[Y]*G[Y];return N},parseSliceParams:pe},Pg=function(){function E(){}E.prototype.getClassName=function(){return this.constructor.className};E.fromConfig=function(G,
N){return new G(N)};return E}(),gh=function(){function E(){this.classNameMap={}}E.getMap=function(){null==E.instance&&(E.instance=new E);return E.instance};E.register=function(G){E.getMap().classNameMap[G.className]=[G,G.fromConfig]};return E}(),bh={__proto__:null,Serializable:Pg,SerializationMap:gh,registerClass:rc},Cg={__proto__:null,TEST_EPSILON_FLOAT16:.1,expectArraysClose:function(E,G,N){null==N&&(N=qc());return Ib(E,G,function(Y,ra){return Ga(Y,ra,N)})},testEpsilon:qc,expectPromiseToFail:function(E,
G){E().then(function(){return G.fail()},function(){return G()})},expectArraysEqual:function(E,G){var N="string"===typeof G||"number"===typeof G||"boolean"===typeof G?[G]:G;return Q(E)||Q(E[0])||Q(G)||Q(G[0])?Ib(E,N,function(Y,ra){return Y==ra}):Ib(E,G,function(Y,ra){return Ga(Y,ra,0)})},expectNumbersClose:function(E,G,N){null==N&&(N=qc());if(!Ga(E,G,N))throw Error("Numbers differ: actual \x3d\x3d\x3d "+E+", expected \x3d\x3d\x3d "+G);},expectValuesInRange:function(E,G,N){for(var Y=0;Y<E.length;Y++)if(E[Y]<
G||E[Y]>N)throw Error("Value out of range:"+E[Y]+" low: "+G+", high: "+N);},expectArrayBuffersEqual:function(E,G){expect(new Float32Array(E)).toEqual(new Float32Array(G))}},vf=vb({add_:function(E,G){var N=La(E,"a","add"),Y=La(G,"b","add");E=ya(N,Y);N=E[0];Y=E[1];return Ic.runKernelFunc(function(ra,Ha){ra=ra.add(N,Y);Ha([N,Y]);return ra},{a:N,b:Y},null,"Add")}}),Qg=vb({floorDiv_:function(E,G){var N=La(E,"a","floorDiv"),Y=La(G,"b","floorDiv");E=ya(N,Y);N=E[0];Y=E[1];return Ic.runKernelFunc(function(ra,
Ha){ra=ra.floorDiv(N,Y);Ha([N,Y]);return ra},{a:N,b:Y},null,"FloorDiv")}}),xf=vb({div_:function(E,G){var N=La(E,"a","div"),Y=La(G,"b","div");E=ya(N,Y);N=E[0];Y=E[1];return"int32"===N.dtype&&"int32"===Y.dtype?Qg(N,Y):Ic.runKernelFunc(function(ra,Ha){ra=ra.realDivide(N,Y);Ha([N,Y]);return ra},{a:N,b:Y},null,"Div",{})}}),se=vb({mul_:function(E,G){var N=La(E,"a","mul"),Y=La(G,"b","mul");E=ya(N,Y);N=E[0];Y=E[1];return Ic.runKernelFunc(function(ra,Ha){ra=ra.multiply(N,Y);Ha([N,Y]);return ra},{a:N,b:Y},
null,"Multiply")}}),sg=vb({abs_:function(E){var G=La(E,"x","abs");return Ic.runKernelFunc(function(N,Y){Y([G]);return"complex64"===G.dtype?N.complexAbs(G):N.abs(G)},{x:G},null,"Abs")}}),Sg=vb({acos_:function(E){var G=La(E,"x","acos");return Ic.runKernelFunc(function(N,Y){N=N.acos(G);Y([G]);return N},{x:G},null,"Acos")}}),Ch=vb({acosh_:function(E){var G=La(E,"x","acosh");return Ic.runKernelFunc(function(N,Y){N=N.acosh(G);Y([G]);return N},{x:G},null,"Acosh")}}),dh=vb({addN_:function(E){e(Array.isArray(E),
function(){return"The argument passed to tf.addN() must be a list of tensors"});e(1<=E.length,function(){return"Must pass at least one tensor to tf.addN(), but got "+E.length});var G=E.map(function(Y,ra){return La(Y,"tensors"+ra,"addN")}),N=G[0];G.forEach(function(Y){if(Y.dtype!==N.dtype)throw Error("All tensors passed to tf.addN() must have the same dtype");});G.forEach(function(Y){if(!l(Y.shape,N.shape))throw Error("All tensors passed to tf.addN() must have the same shape");});return Ic.runKernelFunc(function(Y,
ra){Y=Y.addN(G);ra(G);return Y},G,null,"AddN")}}),ch=vb({all_:function(E,G,N){void 0===G&&(G=null);void 0===N&&(N=!1);var Y=La(E,"x","all","bool");return Ic.runKernelFunc(function(ra){var Ha=p(G,Y.shape),ob=Ha,qb=yc(ob,Y.rank);null!=qb&&(Y=hg(Y,qb),ob=Ad(ob.length,Y.rank));ra=ra.all(Y,ob);return N?(Ha=fc(ra.shape,Ha),zd(ra,Ha)):ra},{x:Y},null,"All",{axis:G,keepDims:N})}}),Dh=vb({any_:function(E,G,N){void 0===G&&(G=null);void 0===N&&(N=!1);var Y=La(E,"x","any","bool");return Ic.runKernelFunc(function(ra){var Ha=
p(G,Y.shape),ob=Ha,qb=yc(ob,Y.rank);null!=qb&&(Y=hg(Y,qb),ob=Ad(ob.length,Y.rank));ra=ra.any(Y,ob);return N?(Ha=fc(ra.shape,Ha),zd(ra,Ha)):ra},{x:Y},null,"Any",{axis:G,keepDims:N})}}),Eh=vb({argMax_:function(E,G){void 0===G&&(G=0);var N=La(E,"x","argMax");return Ic.runKernelFunc(function(Y,ra){ra([N]);ra=p(G,N.shape);var Ha=yc(ra,N.rank);null!=Ha&&(N=hg(N,Ha),ra=Ad(ra.length,N.rank));return Y.argMax(N,ra[0])},{x:N},null,"ArgMax",{axis:G})}}),jh=vb({argMin_:function(E,G){void 0===G&&(G=0);var N=La(E,
"x","argMin");return Ic.runKernelFunc(function(Y,ra){ra([N]);null==G&&(G=0);ra=p(G,N.shape);var Ha=yc(ra,N.rank);null!=Ha&&(N=hg(N,Ha),ra=Ad(ra.length,N.rank));return Y.argMin(N,ra[0])},{x:N},null,"ArgMin",{axis:G})}}),rh=vb({asin_:function(E){var G=La(E,"x","asin");return Ic.runKernelFunc(function(N,Y){N=N.asin(G);Y([G]);return N},{x:G},null,"Asin")}}),yh=vb({asinh_:function(E){var G=La(E,"x","asinh");return Ic.runKernelFunc(function(N,Y){N=N.asinh(G);Y([G]);return N},{x:G},null,"Asinh")}}),kh=vb({atan_:function(E){var G=
La(E,"x","atan");return Ic.runKernelFunc(function(N,Y){N=N.atan(G);Y([G]);return N},{x:G},null,"Atan")}}),nh=vb({atan2_:function(E,G){var N=La(E,"a","atan2"),Y=La(G,"b","atan2");E=ya(N,Y);N=E[0];Y=E[1];return Ic.runKernelFunc(function(ra,Ha){ra=ra.atan2(N,Y);Ha([N,Y]);return ra},{a:N,b:Y},null,"Atan2")}}),sh=vb({atanh_:function(E){var G=La(E,"x","atanh");return Ic.runKernelFunc(function(N,Y){N=N.atanh(G);Y([G]);return N},{x:G},null,"Atanh")}}),Fg=vb({avgPool_:function(E,G,N,Y,ra){E=La(E,"x","avgPool",
"float32");e(he(N,1),function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+(N+" and dilations '1'")});var Ha=E,ob=!1;3===E.rank&&(ob=!0,Ha=zd(E,[1,E.shape[0],E.shape[1],E.shape[2]]));e(4===Ha.rank,function(){return"Error in avgPool: x must be rank 4 but got rank "+Ha.rank+"."});null!=ra&&e(m(Y),function(){return"Error in avgPool: pad must be an integer when using, dimRoundingMode "+(ra+" but got pad "+Y+".")});var qb=Ic.runKernelFunc(function(Eb,hc){var Fc=Gd(Ha.shape,
G,N,1,Y,ra);hc([Ha]);return 1===Fc.filterWidth&&1===Fc.filterHeight&&l(Fc.inShape,Fc.outShape)?Ha.clone():Eb.avgPool(Ha,Fc)},{x:Ha},null,"AvgPool",{filterSize:G,strides:N,pad:Y,dimRoundingMode:ra});qb=Uc(qb,E.dtype);return ob?zd(qb,[qb.shape[1],qb.shape[2],qb.shape[3]]):qb}}),Rg=vb({avgPool3d_:function(E,G,N,Y,ra,Ha,ob){void 0===Ha&&(Ha="NDHWC");null==ob?ob=[1,1,1]:hb("dilations is deprecated, this field will be gone in v3.0.0.");var qb=La(E,"x","avgPool3d","float32"),Eb=qb;E=!1;4===qb.rank&&(E=!0,
Eb=zd(qb,[1,qb.shape[0],qb.shape[1],qb.shape[2],qb.shape[3]]));e(5===Eb.rank,function(){return"Error in avgPool3d: x must be rank 5 but got rank "+Eb.rank+"."});e("NDHWC"===Ha,function(){return"Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of "+Ha});e(he(N,ob),function(){return"Error in avgPool3d: Either strides or dilations must be 1. Got strides "+(N+" and dilations '"+ob+"'")});null!=ra&&e(m(Y),function(){return"Error in avgPool3d: pad must be an integer when using, dimRoundingMode "+
(ra+" but got pad "+Y+".")});qb=Ic.runKernelFunc(function(hc,Fc){null==ob&&(ob=[1,1,1]);var Oc=Ge(Eb.shape,G,N,ob,Y,ra,Ha);Fc([Eb]);return hc.avgPool3d(Eb,Oc)},{x:Eb},null,"AvgPool3D",{filterSize:G,strides:N,pad:Y,dimRoundingMode:ra,dataFormat:Ha,dilations:ob});qb=Uc(qb,Eb.dtype);return E?zd(qb,[qb.shape[1],qb.shape[2],qb.shape[3],qb.shape[4]]):qb}}),Pa=vb({concat_:function(E,G){void 0===G&&(G=0);e(1<=E.length,function(){return"Pass at least one tensor to concat"});var N=Fb(E,"tensors","concat");
"complex64"===N[0].dtype&&N.forEach(function(Y){if("complex64"!==Y.dtype)throw Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype "+Y.dtype+". ");});return Ic.runKernelFunc(function(Y,ra){var Ha=p(G,N[0].shape)[0],ob=qe(N.map(function(qb){return qb.shape}),Ha);if(0===c(ob))return Mc([],ob);N=N.filter(function(qb){return 0<qb.size});if(1===N.length)return N[0];ob=N.map(function(qb){return qb.shape});cf(ob,Ha);Y=Y.concat(N,Ha);ra(N);return Y},N,null,"Concat",{axis:G})}}),
Ab=vb({sigmoid_:function(E){var G=La(E,"x","sigmoid");return Ic.runKernelFunc(function(N,Y){N=N.sigmoid(G);Y([N]);return N},{x:G},null,"Sigmoid")}}),Qb=vb({slice_:function(E,G,N){var Y=La(E,"x","slice");if(0===Y.rank)throw Error("Slicing scalar is not possible");return Ic.runKernelFunc(function(ra,Ha){var ob=pe(Y,G,N),qb=ob[0];ob=ob[1];Ne(Y,qb,ob);Ha([Y]);return ra.slice(Y,qb,ob)},{x:Y},null,"Slice",{begin:G,size:N})}}),cc=vb({tanh_:function(E){var G=La(E,"x","tanh");return Ic.runKernelFunc(function(N,
Y){N=N.tanh(G);Y([N]);return N},{x:G},null,"Tanh")}}),zc=vb({basicLSTMCell_:function(E,G,N,Y,ra,Ha){E=La(E,"forgetBias","basicLSTMCell");G=La(G,"lstmKernel","basicLSTMCell");N=La(N,"lstmBias","basicLSTMCell");Y=La(Y,"data","basicLSTMCell");ra=La(ra,"c","basicLSTMCell");Ha=La(Ha,"h","basicLSTMCell");Ha=Pa([Y,Ha],1);Ha=uf(Ha,G);Y=vf(Ha,N);var ob=Y.shape[1]/4,qb=[Y.shape[0],ob];Ha=Qb(Y,[0,0],qb);G=Qb(Y,[0,ob],qb);N=Qb(Y,[0,2*ob],qb);Y=Qb(Y,[0,3*ob],qb);E=vf(se(Ab(Ha),cc(G)),se(ra,Ab(vf(E,N))));ra=se(cc(E),
Ab(Y));return[E,ra]}}),kc=vb({batchToSpaceND_:function(E,G,N){var Y=La(E,"x","batchToSpaceND"),ra=G.reduce(function(Ha,ob){return Ha*ob});e(Y.rank>=1+G.length,function(){return"input rank is "+Y.rank+" but should be \x3e than blockShape.length "+G.length});e(N.length===G.length,function(){return"crops.length is "+N.length+" but should be equal to blockShape.length  "+G.length});e(0===Y.shape[0]%ra,function(){return"input tensor batch is "+Y.shape[0]+" but is not divisible by the product of the elements of blockShape "+
(G.join(" * ")+" \x3d\x3d\x3d "+ra)});return Ic.runKernelFunc(function(Ha){return Ha.batchToSpaceND(Y,G,N)},{x:Y},null,"BatchToSpaceND",{blockShape:G,crops:N})}}),Nc=vb({batchNorm_:function(E,G,N,Y,ra,Ha){null==Ha&&(Ha=.001);E=La(E,"x","batchNorm");var ob=La(G,"mean","batchNorm"),qb=La(N,"variance","batchNorm"),Eb;null!=ra&&(Eb=La(ra,"scale","batchNorm"));var hc;null!=Y&&(hc=La(Y,"offset","batchNorm"));e(ob.rank===qb.rank,function(){return"Batch normalization gradient requires mean and variance to have equal ranks."});
e(null==hc||ob.rank===hc.rank,function(){return"Batch normalization gradient requires mean and offset to have equal ranks."});e(null==Eb||ob.rank===Eb.rank,function(){return"Batch normalization gradient requires mean and scale to have equal ranks."});var Fc=ie(E);G=Ic.runKernelFunc(function(Oc,td){td([Fc,ob,qb,Eb]);return Oc.batchNorm(Fc,Za(ob),Za(qb),Za(hc),Za(Eb),Ha)},{x:Fc,scale:Eb,offset:hc,mean:ob,variance:qb},null,"FusedBatchNorm",{varianceEpsilon:Ha});return zd(G,E.shape)}}),jd=vb({batchNorm2d_:function(E,
G,N,Y,ra,Ha){var ob=La(E,"x","batchNorm"),qb=La(G,"mean","batchNorm"),Eb=La(N,"variance","batchNorm"),hc;null!=ra&&(hc=La(ra,"scale","batchNorm"));var Fc;null!=Y&&(Fc=La(Y,"offset","batchNorm"));e(2===ob.rank,function(){return"Error in batchNorm2D: x must be rank 2 but got rank "+(ob.rank+".")});e(2===qb.rank||1===qb.rank,function(){return"Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank "+(qb.rank+".")});e(2===Eb.rank||1===Eb.rank,function(){return"Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank "+
(Eb.rank+".")});null!=hc&&e(2===hc.rank||1===hc.rank,function(){return"Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank "+(hc.rank+".")});null!=Fc&&e(2===Fc.rank||1===Fc.rank,function(){return"Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank "+(Fc.rank+".")});return Nc(ob,qb,Eb,Fc,hc,Ha)}}),Td=vb({batchNorm3d_:function(E,G,N,Y,ra,Ha){var ob=La(E,"x","batchNorm"),qb=La(G,"mean","batchNorm"),Eb=La(N,"variance","batchNorm"),hc;null!=ra&&(hc=La(ra,"scale","batchNorm"));
var Fc;null!=Y&&(Fc=La(Y,"offset","batchNorm"));e(3===ob.rank,function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+(ob.rank+".")});e(3===qb.rank||1===qb.rank,function(){return"Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank "+(qb.rank+".")});e(3===Eb.rank||1===Eb.rank,function(){return"Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank "+(Eb.rank+".")});null!=hc&&e(3===hc.rank||1===hc.rank,function(){return"Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank "+
(hc.rank+".")});null!=Fc&&e(3===Fc.rank||1===Fc.rank,function(){return"Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank "+(Fc.rank+".")});return Nc(ob,qb,Eb,Fc,hc,Ha)}}),Wd=vb({batchNorm4d_:function(E,G,N,Y,ra,Ha){var ob=La(E,"x","batchNorm"),qb=La(G,"mean","batchNorm"),Eb=La(N,"variance","batchNorm"),hc;null!=ra&&(hc=La(ra,"scale","batchNorm"));var Fc;null!=Y&&(Fc=La(Y,"offset","batchNorm"));e(4===ob.rank,function(){return"Error in batchNorm4D: x must be rank 4 but got rank "+(ob.rank+
".")});e(4===qb.rank||1===qb.rank,function(){return"Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank "+(qb.rank+".")});e(4===Eb.rank||1===Eb.rank,function(){return"Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank "+(Eb.rank+".")});null!=hc&&e(4===hc.rank||1===hc.rank,function(){return"Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank "+(hc.rank+".")});null!=Fc&&e(4===Fc.rank||1===Fc.rank,function(){return"Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank "+
(Fc.rank+".")});return Nc(ob,qb,Eb,Fc,hc,Ha)}}),Ld=vb({broadcastTo_:function(E,G){var N=La(E,"broadcastTo","x");E=N.shape;if(G.some(function(ob){return!(0<ob)||0!==ob%1}))throw Error("broadcastTo(): Invalid broadcast shape ["+G+"].");if(G.length<N.rank)throw Error("broadcastTo(): shape.length\x3d"+G.length+" \x3c input.rank\x3d"+N.rank+".");if(G.length>N.rank){for(var Y=N.shape.slice();Y.length<G.length;)Y.unshift(1);N=zd(N,Y)}Y=N.shape;for(var ra=Array.from(G),Ha=G.length-1;0<=Ha;Ha--)if(Y[Ha]===
G[Ha])ra[Ha]=1;else if(1!==N.shape[Ha])throw Error("broadcastTo(): ["+E+"] cannot be broadcast to ["+G+"].");return 0===ra.map(function(ob,qb){return 1<ob?qb:-1}).filter(function(ob){return 0<=ob}).length?Ed(N):Ic.runKernelFunc(function(ob){return ob.tile(N,ra)},{x:N},null,"BroadcastTo",{shape:G,inputShape:Y})}}),me=vb({ceil_:function(E){var G=La(E,"x","ceil");return Ic.runKernelFunc(function(N){return N.ceil(G)},{x:G},null,"Ceil")}}),Ie=vb({clipByValue_:function(E,G,N){var Y=La(E,"x","clipByValue");
e(G<=N,function(){return"Error in clip: min ("+G+") must be less than or equal to max ("+(N+").")});return Ic.runKernelFunc(function(ra,Ha){ra=ra.clip(Y,G,N);Ha([Y]);return ra},{x:Y},null,"ClipByValue",{clipValueMin:G,clipValueMax:N})}}),Ee=vb({concat1d_:function(E){return Pa(E,0)}}),Ff=vb({concat2d_:function(E,G){return Pa(E,G)}}),Kf=vb({concat3d_:function(E,G){return Pa(E,G)}}),ea=vb({concat4d_:function(E,G){return Pa(E,G)}}),sa=vb({conv2d_:function(E,G,N,Y,ra,Ha,ob){void 0===ra&&(ra="NHWC");void 0===
Ha&&(Ha=[1,1]);E=La(E,"x","conv2d");var qb=La(G,"filter","conv2d"),Eb=E;G=!1;3===E.rank&&(G=!0,Eb=zd(E,[1,E.shape[0],E.shape[1],E.shape[2]]));e(4===Eb.rank,function(){return"Error in conv2d: input must be rank 4, but got rank "+Eb.rank+"."});e(4===qb.rank,function(){return"Error in conv2d: filter must be rank 4, but got rank "+(qb.rank+".")});null!=ob&&e(m(Y),function(){return"Error in conv2d: pad must be an integer when using, dimRoundingMode "+(ob+" but got pad "+Y+".")});var hc="NHWC"===ra?Eb.shape[3]:
Eb.shape[1];e(hc===qb.shape[2],function(){return"Error in conv2d: depth of input ("+hc+") must match input depth for filter "+(qb.shape[2]+".")});e(he(N,Ha),function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+(N+" and dilations '"+Ha+"'")});E=Ic.runKernelFunc(function(Fc,Oc){var td=bf(ra);td=Re(Eb.shape,qb.shape,N,Ha,Y,ob,!1,td);Fc=Fc.conv2d(Eb,qb,td);Oc([Eb,qb]);return Fc},{x:Eb,filter:qb},null,"Conv2D",{strides:N,pad:Y,dataFormat:ra,dilations:Ha,dimRoundingMode:ob});
return G?zd(E,[E.shape[1],E.shape[2],E.shape[3]]):E}}),ia=vb({conv1d_:function(E,G,N,Y,ra,Ha,ob){void 0===ra&&(ra="NWC");void 0===Ha&&(Ha=1);E=La(E,"x","conv1d");var qb=La(G,"filter","conv1d"),Eb=E;G=!1;2===E.rank&&(G=!0,Eb=zd(E,[1,E.shape[0],E.shape[1]]));e(3===Eb.rank,function(){return"Error in conv1d: input must be rank 3, but got rank "+Eb.rank+"."});e(3===qb.rank,function(){return"Error in conv1d: filter must be rank 3, but got rank "+(qb.rank+".")});null!=ob&&e(m(Y),function(){return"Error in conv1d: pad must be an integer when using, dimRoundingMode "+
(ob+" but got pad "+Y+".")});e(Eb.shape[2]===qb.shape[1],function(){return"Error in conv1d: depth of input ("+Eb.shape[2]+") must match input depth for filter "+(qb.shape[1]+".")});e(he(N,Ha),function(){return"Error in conv1D: Either stride or dilation must be 1. Got stride "+(N+" and dilation '"+Ha+"'")});e("NWC"===ra,function(){return"Error in conv1d: got dataFormat of "+ra+" but only NWC is currently supported."});E=zd(qb,[1,qb.shape[0],qb.shape[1],qb.shape[2]]);var hc=zd(Eb,[Eb.shape[0],1,Eb.shape[1],
Eb.shape[2]]);E=sa(hc,E,[1,N],Y,"NHWC",[1,Ha],ob);return G?zd(E,[E.shape[2],E.shape[3]]):zd(E,[E.shape[0],E.shape[2],E.shape[3]])}}),za=vb({conv2DBackpropInput_:function(E,G,N,Y,ra,Ha,ob){void 0===Ha&&(Ha="NHWC");e(E.length===G.rank,function(){return"Length of inShape ("+(E.length+") and rank of dy ("+G.rank+") must match")});var qb=E,Eb=G,hc=!1;3===G.rank&&(hc=!0,Eb=zd(G,[1,G.shape[0],G.shape[1],G.shape[2]]),qb=[1,E[0],E[1],E[2]]);e(4===qb.length,function(){return"Error in conv2dDerInput: inShape must be length 4, but got length "+
(qb.length+".")});e(4===Eb.rank,function(){return"Error in conv2dDerInput: dy must be rank 4, but got rank "+Eb.rank});e(4===N.rank,function(){return"Error in conv2dDerInput: filter must be rank 4, but got rank "+N.rank});var Fc="NHWC"===Ha?qb[3]:qb[1],Oc="NHWC"===Ha?Eb.shape[3]:Eb.shape[1];e(Fc===N.shape[2],function(){return"Error in conv2dDerInput: depth of input ("+Fc+") must match input depth for filter "+(N.shape[2]+".")});e(Oc===N.shape[3],function(){return"Error in conv2dDerInput: depth of output ("+
Oc+") must match output depth for filter "+(N.shape[3]+".")});null!=ob&&e(m(ra),function(){return"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode "+(ob+" but got pad "+ra+".")});var td=Ic.runKernelFunc(function(be,Fe){var fe=bf(Ha);fe=Re(qb,N.shape,Y,1,ra,ob,!1,fe);be=be.conv2dDerInput(Eb,N,fe);Fe([Eb,N]);return be},{dy:Eb,filter:N},null,"Conv2DBackpropInput",{strides:Y,pad:ra,dataFormat:Ha,dimRoundingMode:ob,inputShape:qb});return hc?zd(td,[td.shape[1],td.shape[2],td.shape[3]]):
td}}),Xa=vb({conv2dTranspose_:function(E,G,N,Y,ra,Ha){E=La(E,"x","conv2dTranspose");G=La(G,"filter","conv2dTranspose");return za(N,E,G,Y,ra,"NHWC",Ha)}}),Cb=vb({conv3d_:function(E,G,N,Y,ra,Ha){void 0===ra&&(ra="NDHWC");void 0===Ha&&(Ha=[1,1,1]);E=La(E,"x","conv3d");var ob=La(G,"filter","conv3d"),qb=E;G=!1;4===E.rank&&(G=!0,qb=zd(E,[1,E.shape[0],E.shape[1],E.shape[2],E.shape[3]]));e(5===qb.rank,function(){return"Error in conv3d: input must be rank 5, but got rank "+qb.rank+"."});e(5===ob.rank,function(){return"Error in conv3d: filter must be rank 5, but got rank "+
(ob.rank+".")});e(qb.shape[4]===ob.shape[3],function(){return"Error in conv3d: depth of input ("+qb.shape[4]+") must match input depth for filter "+(ob.shape[3]+".")});e(he(N,Ha),function(){return"Error in conv3D: Either strides or dilations must be 1. Got strides "+(N+" and dilations '"+Ha+"'")});e("NDHWC"===ra,function(){return"Error in conv3d: got dataFormat of "+ra+" but only NDHWC is currently supported."});E=Ic.runKernelFunc(function(Eb,hc){var Fc=mf(qb.shape,ob.shape,N,Ha,Y);Eb=Eb.conv3d(qb,
ob,Fc);hc([qb,ob]);return Eb},{x:qb,filter:ob},null,"Conv3D",{strides:N,pad:Y,dataFormat:ra,dilations:Ha});return G?zd(E,[E.shape[1],E.shape[2],E.shape[3],E.shape[4]]):E}}),gc=vb({conv3DBackpropInput_:function(E,G,N,Y,ra){e(E.length===G.rank,function(){return"Length of inShape ("+(E.length+") and rank of dy ("+G.rank+") must match")});var Ha=E,ob=G,qb=!1;4===G.rank&&(qb=!0,ob=zd(G,[1,G.shape[0],G.shape[1],G.shape[2],G.shape[3]]),Ha=[1,E[0],E[1],E[2],E[3]]);var Eb=Ha[4],hc=ob.shape[4];e(5===Ha.length,
function(){return"Error in conv3dDerInput: inShape must be length 5, but got length "+(Ha.length+".")});e(5===ob.rank,function(){return"Error in conv3dDerInput: dy must be rank 5, but got rank "+ob.rank});e(5===N.rank,function(){return"Error in conv3dDerInput: filter must be rank 5, but got rank "+N.rank});e(Eb===N.shape[3],function(){return"Error in conv3dDerInput: depth of input ("+Eb+") must match input depth for filter "+(N.shape[3]+".")});e(hc===N.shape[4],function(){return"Error in conv3dDerInput: depth of output ("+
hc+") must match output depth for filter "+(N.shape[4]+".")});var Fc=Ic.runKernelFunc(function(Oc){var td=mf(Ha,N.shape,Y,1,ra);return Oc.conv3dDerInput(ob,N,td)},{dy:ob,filter:N},null,"Conv3DBackpropInputV2",{pad:ra,strides:Y,inputShape:Ha});return qb?zd(Fc,[Fc.shape[1],Fc.shape[2],Fc.shape[3],Fc.shape[4]]):Fc}}),nc=vb({conv3dTranspose_:function(E,G,N,Y,ra){E=La(E,"x","conv3dTranspose");G=La(G,"filter","conv3dTranspose");return gc(N,E,G,Y,ra)}}),Tc=vb({cos_:function(E){var G=La(E,"x","cos");return Ic.runKernelFunc(function(N,
Y){N=N.cos(G);Y([G]);return N},{x:G},null,"Cos")}}),hd=vb({cosh_:function(E){var G=La(E,"x","cosh");return Ic.runKernelFunc(function(N,Y){N=N.cosh(G);Y([G]);return N},{x:G},null,"Cosh")}}),Hd=vb({cumsum_:function(E,G,N,Y){void 0===G&&(G=0);void 0===N&&(N=!1);void 0===Y&&(Y=!1);var ra=La(E,"x","cumsum");return Ic.runKernelFunc(function(Ha,ob){var qb=yc([G],ra.rank),Eb=ra;null!=qb&&(Eb=hg(ra,qb));var hc=Ad(1,ra.rank)[0];Ha=Ha.cumsum(Eb,hc,N,Y);ob([ra]);null!=qb&&(ob=fd(qb),Ha=hg(Ha,ob));return Ha},
{x:ra},null,"Cumsum",{axis:G,exclusive:N,reverse:Y})}}),$d=vb({depthToSpace_:function(E,G,N){void 0===N&&(N="NHWC");var Y=La(E,"x","depthToSpace"),ra="NHWC"===N?Y.shape[1]:Y.shape[2],Ha="NHWC"===N?Y.shape[2]:Y.shape[3],ob="NHWC"===N?Y.shape[3]:Y.shape[1];e(0<=ra*G,function(){return"Negative dimension size caused by overflow when multiplying\n    "+ra+" and "+G+"  for depthToSpace with input shape\n    "+Y.shape});e(0<=Ha*G,function(){return"Negative dimension size caused by overflow when multiplying\n    "+
Ha+" and "+G+" for depthToSpace with input shape\n        "+Y.shape});e(0===ob%(G*G),function(){return"Dimension size must be evenly divisible by "+G*G+" but is "+ob+" for depthToSpace with input shape "+Y.shape});return Ic.runKernelFunc(function(qb){return qb.depthToSpace(Y,G,N)},{x:Y},null,"DepthToSpace",{blockSize:G,dataFormat:N})}}),te=vb({depthwiseConv2d_:function(E,G,N,Y,ra,Ha,ob){void 0===ra&&(ra="NHWC");void 0===Ha&&(Ha=[1,1]);E=La(E,"x","depthwiseConv2d");var qb=La(G,"filter","depthwiseConv2d"),
Eb=E;G=!1;3===E.rank&&(G=!0,Eb=zd(E,[1,E.shape[0],E.shape[1],E.shape[2]]));e(4===Eb.rank,function(){return"Error in depthwiseConv2d: input must be rank 4, but got rank "+(Eb.rank+".")});e(4===qb.rank,function(){return"Error in depthwiseConv2d: filter must be rank 4, but got rank "+(qb.rank+".")});e(Eb.shape[3]===qb.shape[2],function(){return"Error in depthwiseConv2d: number of input channels ("+(Eb.shape[3]+") must match the inChannels dimension in filter ")+(qb.shape[2]+".")});null!=ob&&e(m(Y),function(){return"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode "+
(ob+" but got pad "+Y+".")});ra=Ic.runKernelFunc(function(hc,Fc){null==Ha&&(Ha=[1,1]);e(he(N,Ha),function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+(N+" and dilations '"+Ha+"'")});var Oc=Re(Eb.shape,qb.shape,N,Ha,Y,ob,!0);hc=hc.depthwiseConv2D(Eb,qb,Oc);Fc([Eb,qb]);return hc},{x:Eb,filter:qb},null,"DepthwiseConv2dNative",{strides:N,pad:Y,dataFormat:ra,dilations:Ha,dimRoundingMode:ob});return G?zd(ra,[ra.shape[1],ra.shape[2],ra.shape[3]]):ra}}),He=vb({diag_:function(E){var G=
La(E,"x","diag");return Ic.runKernelFunc(function(N){var Y=zd(G,[G.size]);N=N.diag(Y);Y=E.shape.concat(E.shape);return zd(N,Y)},{x:G},null,"Diag")}}),Xd=vb({dilation2d_:function(E,G,N,Y,ra,Ha){void 0===ra&&(ra=[1,1]);void 0===Ha&&(Ha="NHWC");var ob=La(E,"x","dilation2d"),qb=La(G,"filter","dilation2d");e(3===ob.rank||4===ob.rank,function(){return"Error in dilation2d: input must be rank 3 or 4, but got rank "+(ob.rank+".")});e(3===qb.rank,function(){return"Error in dilation2d: filter must be rank 3, but got rank "+
(qb.rank+".")});e("NHWC"===Ha,function(){return"Error in dilation2d: Only NHWC is currently supported, but got dataFormat of "+Ha});G=ob;E=!1;3===ob.rank&&(G=zd(ob,[1,ob.shape[0],ob.shape[1],ob.shape[2]]),E=!0);N=Ic.runKernel("Dilation2D",{x:G,filter:qb},{strides:N,pad:Y,dilations:ra});return E?zd(N,[N.shape[1],N.shape[2],N.shape[3]]):N}}),ye=vb({equal_:function(E,G){var N=La(E,"a","equal"),Y=La(G,"b","equal");E=ya(N,Y);N=E[0];Y=E[1];Db(N.shape,Y.shape);return Ic.runKernelFunc(function(ra){return ra.equal(N,
Y)},{a:N,b:Y},null,"Equal")}}),cg=vb({where_:function(E,G,N){G=La(G,"a","where");N=La(N,"b","where");var Y=La(E,"condition","where","bool");E=Db(G.shape,N.shape);var ra=Ld(G,E),Ha=Ld(N,E);1===Y.rank&&e(Y.shape[0]===G.shape[0],function(){return"The first dimension of `a` must match the size of `condition`."});1!==Y.rank&&g(Y.shape,Ha.shape,"Error in where: ");return Ic.runKernelFunc(function(ob,qb){ob=ob.select(Y,ra,Ha);qb([Y]);return ob},{condition:Y,t:ra,e:Ha},null,"SelectV2")}}),Ef=vb({zerosLike_:function(E){var G=
La(E,"x","zerosLike");return Ic.runKernelFunc(function(N){return N.zerosLike(G)},{x:G},null,"ZerosLike")}}),Hg=vb({divNoNan_:function(E,G){E=La(E,"a","div");G=La(G,"b","div");G=ya(E,G);E=G[0];G=G[1];E=xf(E,G);var N=Ef(E);G=ye(G,N);return cg(G,N,E)}}),jg=vb({dot_:function(E,G){var N=La(E,"t1","dot"),Y=La(G,"t2","dot");e((1===N.rank||2===N.rank)&&(1===Y.rank||2===Y.rank),function(){return"Error in dot: inputs must all be rank 1 or 2, but got ranks "+(N.rank+" and "+Y.rank+".")});var ra=1===N.rank?N.size:
N.shape[1],Ha=1===Y.rank?Y.size:Y.shape[0];e(ra===Ha,function(){return"Error in dot: inner dimensions of inputs must match, but got "+(ra+" and "+Ha+".")});if(1===N.rank&&1===Y.rank)return E=zd(N,[1,-1]),G=zd(Y,[-1,1]),E=uf(E,G),zd(E,[]);if(1===N.rank&&2===Y.rank)return E=zd(N,[1,-1]),G=zd(Y,[Y.shape[0],Y.shape[1]]),E=uf(E,G),zd(E,[E.size]);if(2===N.rank&&1===Y.rank)return G=zd(Y,[-1,1]),E=uf(N,G),zd(E,[E.size]);G=zd(Y,[Y.shape[0],Y.shape[1]]);return E=uf(N,G)}}),gg=vb({elu_:function(E){var G=La(E,
"x","elu");return Ic.runKernelFunc(function(N,Y){N=N.elu(G);Y([N]);return N},{x:G},null,"Elu")}}),th=vb({erf_:function(E){var G=La(E,"x","erf");e("int32"===G.dtype||"float32"===G.dtype,function(){return"Input dtype must be `int32` or `float32`."});"int32"===G.dtype&&(G=Uc(G,"float32"));return Ic.runKernelFunc(function(N,Y){N=N.erf(G);Y([G]);return N},{x:G},null,"Erf")}}),Xg=vb({exp_:function(E){var G=La(E,"x","exp");return Ic.runKernelFunc(function(N,Y){N=N.exp(G);Y([N]);return N},{x:G},null,"Exp")}}),
Tg=vb({expandDims_:function(E,G){void 0===G&&(G=0);var N=La(E,"x","expandDims",null);e(G<=N.rank,function(){return"Axis must be \x3c\x3d rank of the tensor"});E=N.shape.slice();0>G&&(e(-(N.rank+1)<=G,function(){return"Axis must be in the interval ["+-(N.rank+1)+", "+N.rank+"]"}),G=N.rank+G+1);E.splice(G,0,1);return zd(N,E)}}),zh=vb({expm1_:function(E){var G=La(E,"x","expm1");return Ic.runKernelFunc(function(N,Y){N=N.expm1(G);Y([G]);return N},{x:G},null,"Expm1")}}),og=vb({tile_:function(E,G){var N=
La(E,"x","tile",null);e(N.rank===G.length,function(){return"Error in transpose: rank of input "+N.rank+" must match length of reps "+(G+".")});return Ic.runKernelFunc(function(Y,ra){Y=Y.tile(N,G);ra([N]);return Y},{x:N},null,"Tile",{reps:G},[N])}}),Fh=vb({eye_:function(E,G,N,Y){void 0===Y&&(Y="float32");null==G&&(G=E);Y=kd([E,G],Y);for(var ra=E<=G?E:G,Ha=0;Ha<ra;++Ha)Y.set(1,Ha,Ha);E=zd(Y.toTensor(),[E,G]);if(null==N)return E;if(1===N.length)return og(Tg(E,0),[N[0],1,1]);if(2===N.length)return og(Tg(Tg(E,
0),0),[N[0],N[1],1,1]);if(3===N.length)return og(Tg(Tg(Tg(E,0),0),0),[N[0],N[1],N[2],1,1]);throw Error("eye() currently supports only 1D and 2D batchShapes, but received "+(N.length+"D."));}}),Gh=vb({floor_:function(E){var G=La(E,"x","floor");return Ic.runKernelFunc(function(N){return N.floor(G)},{x:G},null,"Floor")}}),Jg={__proto__:null,segOpComputeOptimalWindowSize:function(E,G){var N=!1;if(30>=E){var Y=E;N=!0}else Y=H(E,Math.floor(Math.sqrt(E)));for(;!N;)Y>G||Y===E?N=!0:Y=H(E,Y+1);return Y},computeOutShape:function(E,
G,N){for(var Y=[],ra=E.length,Ha=0;Ha<ra;Ha++)Ha!==G?Y.push(E[Ha]):Y.push(N);return Y},collectGatherOpShapeInfo:uc},Hh=vb({gather_:function(E,G,N){void 0===N&&(N=0);var Y=La(E,"x","gather"),ra=La(G,"indices","gather","int32");return Ic.runKernelFunc(function(Ha,ob){var qb=p(N,Y.shape)[0],Eb=uc(Y,ra,qb);Ha=Ha.gather(Y,zd(ra,[ra.size]),qb);ob([Y,ra]);return zd(Ha,Eb.outputShape)},{x:Y,indices:ra},null,"GatherV2",{axis:N})}}),Ug=vb({greater_:function(E,G){var N=La(E,"a","greater"),Y=La(G,"b","greater");
E=ya(N,Y);N=E[0];Y=E[1];Db(N.shape,Y.shape);return Ic.runKernelFunc(function(ra){return ra.greater(N,Y)},{a:N,b:Y},null,"Greater")}}),ih=vb({greaterEqual_:function(E,G){var N=La(E,"a","greaterEqual"),Y=La(G,"b","greaterEqual");E=ya(N,Y);N=E[0];Y=E[1];Db(N.shape,Y.shape);return Ic.runKernelFunc(function(ra,Ha){ra=ra.greaterEqual(N,Y);Ha([N,Y]);return ra},{a:N,b:Y},null,"GreaterEqual")}}),lh=vb({imag_:function(E){var G=La(E,"input","imag");return Ic.runKernelFunc(function(N){return N.imag(G)},{input:G},
null,"Imag")}}),pg=vb({isFinite_:function(E){var G=La(E,"x","isFinite");return Ic.runKernelFunc(function(N){return N.isFinite(G)},{x:G},null,"IsFinite")}}),Rh=vb({isInf_:function(E){var G=La(E,"x","isInf");return Ic.runKernelFunc(function(N){return N.isInf(G)},{x:G},null,"IsInf")}}),Ph=vb({isNaN_:function(E){var G=La(E,"x","isNaN");return Ic.runKernelFunc(function(N){return N.isNaN(G)},{x:G},null,"IsNan")}}),Ah=vb({maximum_:function(E,G){var N=La(E,"a","maximum"),Y=La(G,"b","maximum");E=ya(N,Y);N=
E[0];Y=E[1];"bool"===N.dtype&&(N=Uc(N,"int32"),Y=Uc(Y,"int32"));Db(N.shape,Y.shape);return Ic.runKernelFunc(function(ra,Ha){ra=ra.maximum(N,Y);Ha([N,Y]);return ra},{a:N,b:Y},null,"Maximum")}}),Uh=vb({leakyRelu_:function(E,G){void 0===G&&(G=.2);E=La(E,"x","leakyRelu");return Ah(se(Qc(G),E),E)}}),Kh=vb({less_:function(E,G){var N=La(E,"a","less"),Y=La(G,"b","less");E=ya(N,Y);N=E[0];Y=E[1];Db(N.shape,Y.shape);return Ic.runKernelFunc(function(ra){return ra.less(N,Y)},{a:N,b:Y},null,"Less")}}),na=vb({lessEqual_:function(E,
G){var N=La(E,"a","lessEqual"),Y=La(G,"b","lessEqual");E=ya(N,Y);N=E[0];Y=E[1];Db(N.shape,Y.shape);return Ic.runKernelFunc(function(ra,Ha){ra=ra.lessEqual(N,Y);Ha([N,Y]);return ra},{a:N,b:Y},null,"LessEqual")}}),R=vb({localResponseNormalization_:function(E,G,N,Y,ra){void 0===G&&(G=5);void 0===N&&(N=1);void 0===Y&&(Y=1);void 0===ra&&(ra=.5);var Ha=La(E,"x","localResponseNormalization");e(4===Ha.rank||3===Ha.rank,function(){return"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank "+
Ha.rank+"."});e(m(G),function(){return"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius "+(G+".")});var ob=Ha;E=!1;3===Ha.rank&&(E=!0,ob=zd(Ha,[1,Ha.shape[0],Ha.shape[1],Ha.shape[2]]));var qb=Ic.runKernelFunc(function(Eb,hc){Eb=Eb.localResponseNormalization4D(ob,G,N,Y,ra);hc([ob,Eb]);return Eb},{x:ob},null,"LRN",{depthRadius:G,bias:N,alpha:Y,beta:ra});return E?zd(qb,[qb.shape[1],qb.shape[2],qb.shape[3]]):qb}}),x=vb({log_:function(E){var G=La(E,"x","log");return Ic.runKernelFunc(function(N,
Y){N=N.log(G);Y([G]);return N},{x:G},null,"Log")}}),P=vb({log1p_:function(E){var G=La(E,"x","log1p");return Ic.runKernelFunc(function(N,Y){N=N.log1p(G);Y([G]);return N},{x:G},null,"Log1p")}}),ca=vb({neg_:function(E){var G=La(E,"x","neg");return Ic.runKernelFunc(function(N){return N.neg(G)},{x:G},null,"Negate")}}),Ka=vb({softplus_:function(E){var G=La(E,"x","softplus");return Ic.runKernelFunc(function(N,Y){N=N.softplus(G);Y([G]);return N},{x:G},null,"Softplus")}}),rb=vb({logSigmoid_:function(E){E=
La(E,"x","logSigmoid");return Fd(function(G){return{value:ca(Ka(ca(G))),gradFunc:function(N){return se(N,Ab(ca(G)))}}})(E)}}),Mb=vb({max_:function(E,G,N){void 0===G&&(G=null);void 0===N&&(N=!1);var Y=La(E,"x","max");return Ic.runKernelFunc(function(ra,Ha){var ob=p(G,Y.shape),qb=yc(ob,Y.rank),Eb=Y;null!=qb&&(Eb=hg(Y,qb),ob=Ad(ob.length,Eb.rank));ra=ra.max(Eb,ob);null!=qb&&Eb.dispose();qb=ra;N&&(Eb=fc(qb.shape,p(G,Y.shape)),qb=zd(qb,Eb),ra.dispose());Ha([Y,qb]);return qb},{x:Y},null,"Max",{reductionIndices:G,
keepDims:N})}}),Zb=vb({sub_:function(E,G){var N=La(E,"a","sub"),Y=La(G,"b","sub");E=ya(N,Y);N=E[0];Y=E[1];return Ic.runKernelFunc(function(ra,Ha){ra=ra.subtract(N,Y);Ha([N,Y]);return ra},{a:N,b:Y},null,"Sub")}}),Yb=vb({sum_:function(E,G,N){void 0===G&&(G=null);void 0===N&&(N=!1);var Y=La(E,"x","sum");"bool"===Y.dtype&&(Y=Uc(Y,"int32"));return Ic.runKernelFunc(function(ra,Ha){Ha([Y]);Ha=p(G,Y.shape);var ob=yc(Ha,Y.rank),qb=Ha,Eb=Y;null!=ob&&(Eb=hg(Y,ob),qb=Ad(qb.length,Y.rank));ra=ra.sum(Eb,qb);N&&
(Ha=fc(ra.shape,Ha),ra=zd(ra,Ha));return ra},{x:Y},null,"Sum",{axis:G,keepDims:N})}}),Gc=vb({logSoftmax_:function(E,G){void 0===G&&(G=-1);var N=La(E,"logits","logSoftmax");-1===G&&(G=N.rank-1);if(G!==N.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank "+(N.rank+" and axis was "+G));return Ic.runKernelFunc(function(Y,ra){Y=Mb(E,G,!0);Y=Zb(E,Y);Y=Zb(Uc(Y,"float32"),x(Yb(Xg(Y),G,!0)));ra([Y]);return Y},{logits:N},null,"LogSoftmax",{axis:G})}}),cd=vb({logSumExp_:function(E,
G,N){void 0===G&&(G=null);void 0===N&&(N=!1);var Y=La(E,"x","logSumExp");G=p(G,Y.shape);E=Mb(Y,G,!0);Y=Zb(Y,E);Y=Xg(Y);Y=Yb(Y,G);Y=x(Y);E=vf(zd(E,Y.shape),Y);return N?(N=fc(E.shape,G),zd(E,N)):E}}),rd=vb({logicalAnd_:function(E,G){var N=La(E,"a","logicalAnd","bool"),Y=La(G,"b","logicalAnd","bool");Db(N.shape,Y.shape);return Ic.runKernelFunc(function(ra){return ra.logicalAnd(N,Y)},{a:N,b:Y},null,"LogicalAnd")}}),Pd=vb({logicalNot_:function(E){var G=La(E,"x","logicalNot","bool");return Ic.runKernelFunc(function(N){return N.logicalNot(G)},
{x:G},null,"LogicalNot")}}),Od=vb({logicalOr_:function(E,G){var N=La(E,"a","logicalOr","bool"),Y=La(G,"b","logicalOr","bool");Db(N.shape,Y.shape);return Ic.runKernelFunc(function(ra){return ra.logicalOr(N,Y)},{a:N,b:Y},null,"LogicalOr")}}),ce=vb({logicalXor_:function(E,G){var N=La(E,"a","logicalXor","bool"),Y=La(G,"b","logicalXor","bool");Db(N.shape,Y.shape);return rd(Od(E,G),Pd(rd(E,G)))}}),Yd=vb({maxPool_:function(E,G,N,Y,ra){var Ha=La(E,"x","maxPool"),ob=Ha;E=!1;3===Ha.rank&&(E=!0,ob=zd(Ha,[1,
Ha.shape[0],Ha.shape[1],Ha.shape[2]]));e(4===ob.rank,function(){return"Error in maxPool: input must be rank 4 but got rank "+ob.rank+"."});e(he(N,1),function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+(N+" and dilations '1'")});null!=ra&&e(m(Y),function(){return"Error in maxPool: pad must be an integer when using, dimRoundingMode "+(ra+" but got pad "+Y+".")});Ha=Ic.runKernelFunc(function(qb,Eb){var hc=Gd(ob.shape,G,N,1,Y,ra);qb=1===hc.filterWidth&&1===hc.filterHeight&&
l(hc.inShape,hc.outShape)?ob.clone():qb.maxPool(ob,hc);Eb([ob,qb]);return qb},{x:ob},null,"MaxPool",{filterSize:G,strides:N,pad:Y,dimRoundingMode:ra});return E?zd(Ha,[Ha.shape[1],Ha.shape[2],Ha.shape[3]]):Ha}}),ve=vb({maxPool3d_:function(E,G,N,Y,ra,Ha,ob){void 0===G&&(G=[1,1,1]);void 0===Ha&&(Ha="NDHWC");null==ob?ob=[1,1,1]:hb("dilations is deprecated, this field will be gone in v3.0.0.");var qb=La(E,"x","maxPool3d"),Eb=qb;E=!1;4===qb.rank&&(E=!0,Eb=zd(qb,[1,qb.shape[0],qb.shape[1],qb.shape[2],qb.shape[3]]));
e(5===Eb.rank,function(){return"Error in maxPool3d: x must be rank 5 but got rank "+Eb.rank+"."});e("NDHWC"===Ha,function(){return"Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of "+Ha});e(he(N,ob),function(){return"Error in maxPool3d: Either strides or dilations must be 1. Got strides "+(N+" and dilations '"+ob+"'")});null!=ra&&e(m(Y),function(){return"Error in maxPool3d: pad must be an integer when using, dimRoundingMode "+(ra+" but got pad "+Y+".")});qb=Ic.runKernelFunc(function(hc,
Fc){null==ob&&(ob=[1,1,1]);var Oc=Ge(Eb.shape,G,N,ob,Y,ra,Ha);hc=hc.maxPool3d(Eb,Oc);Fc([Eb,hc]);return hc},{x:Eb},null,"MaxPool3D",{filterSize:G,strides:N,pad:Y,dimRoundingMode:ra,dataFormat:Ha,dilations:ob});return E?zd(qb,[qb.shape[1],qb.shape[2],qb.shape[3],qb.shape[4]]):qb}}),Ye=vb({maxPoolWithArgmax_:function(E,G,N,Y,ra){void 0===ra&&(ra=!1);E={x:La(E,"x","maxPoolWithArgmax")};G=Ic.runKernel("MaxPoolWithArgmax",E,{filterSize:G,strides:N,pad:Y,includeBatchInIndex:ra});return{result:G[0],indexes:G[1]}}}),
jf=vb({mean_:function(E,G,N){void 0===G&&(G=null);void 0===N&&(N=!1);var Y=La(E,"x","mean"),ra=p(G,Y.shape);E=Ob(Y.shape,ra)[1];var Ha=c(E),ob={x:Y},qb={axis:G,keepDims:N},Eb=function(){var hc=Qc(Ha),Fc=hc.dtype===Y.dtype?Y:Uc(Y,hc.dtype);hc=xf(Fc,hc);return Yb(hc,G,N)};return Fd(function(hc){return{value:Ic.runKernelFunc(Eb,ob,null,"Mean",qb),gradFunc:function(Fc){var Oc=hc.shape.slice();ra.forEach(function(td){Oc[td]=1});Fc=zd(Fc,Oc);return xf(se(Fc,wd(hc.shape,"float32")),Ha)}}})(Y)}}),kf=vb({min_:function(E,
G,N){void 0===G&&(G=null);void 0===N&&(N=!1);var Y=La(E,"x","min");return Ic.runKernelFunc(function(ra,Ha){var ob=p(G,Y.shape),qb=ob,Eb=yc(qb,Y.rank),hc=Y;null!=Eb&&(hc=hg(Y,Eb),qb=Ad(qb.length,Y.rank));ra=ra.min(hc,qb);null!=Eb&&hc.dispose();Eb=ra;N&&(ob=fc(Eb.shape,ob),Eb=zd(ra,ob),ra.dispose());Ha([Y,Eb]);return Eb},{x:Y},null,"Min",{axis:G,keepDims:N})}}),Af=vb({minimum_:function(E,G){var N=La(E,"a","minimum"),Y=La(G,"b","minimum");E=ya(N,Y);N=E[0];Y=E[1];"bool"===N.dtype&&(N=Uc(N,"int32"),Y=
Uc(Y,"int32"));Db(N.shape,Y.shape);return Ic.runKernelFunc(function(ra,Ha){ra=ra.minimum(N,Y);Ha([N,Y]);return ra},{a:N,b:Y},null,"Minimum")}}),Mf=vb({mirrorPad_:function(E,G,N){e("reflect"===N||"symmetric"===N,function(){return"Invalid mode. Mode must be either reflect or symmetric. Got "+(N+".")});var Y=La(E,"x","mirrorPad");if(0===Y.rank)throw Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");e(G.length===Y.rank,function(){return"Padding doesn't match input. Must be "+Y.rank+
". Got "+(G.length+".")});var ra="reflect"===N?1:0;E=function(ob){e(2===G[ob].length,function(){return"Invalid number of paddings. Must be length of 2 each."});e(0<=G[ob][0]&&G[ob][0]<=Y.shape[ob]-ra&&0<=G[ob][1]&&G[ob][1]<=Y.shape[ob]-ra,function(){return"Padding in dimension "+ob+" cannot be greater than or equal to "+(Y.shape[ob]-ra+" or less than 0 for input of shape ")+Y.shape})};for(var Ha=0;Ha<Y.rank;Ha++)E(Ha);return Ic.runKernel("MirrorPad",{x:Y},{paddings:G,mode:N})}}),Rf=vb({mod_:function(E,
G){var N=La(E,"a","mod"),Y=La(G,"b","mod");E=ya(N,Y);N=E[0];Y=E[1];return Ic.runKernelFunc(function(ra,Ha){ra=ra.mod(N,Y);Ha([N,Y]);return ra},{a:N,b:Y},null,"Mod")}}),Bf=vb({square_:function(E){var G=La(E,"x","square");return Ic.runKernelFunc(function(N,Y){Y([G]);return N.square(G)},{x:G},null,"Square",{},[G],[])}}),lg=vb({moments_:function(E,G,N){void 0===G&&(G=null);void 0===N&&(N=!1);E=La(E,"x","moments");var Y=p(G,E.shape);G=jf(E,Y,N);var ra=G.shape;N||(ra=fc(G.shape,Y));E=Bf(Zb(Uc(E,"float32"),
zd(G,ra)));N=jf(E,Y,N);return{mean:G,variance:N}}}),eh=vb({multiRNNCell_:function(E,G,N,Y){G=La(G,"data","multiRNNCell");N=Fb(N,"c","multiRNNCell");var ra=Fb(Y,"h","multiRNNCell"),Ha=G;Y=[];for(G=0;G<E.length;G++)Ha=E[G](Ha,N[G],ra[G]),Y.push(Ha[0]),Y.push(Ha[1]),Ha=Ha[1];E=[];N=[];for(G=0;G<Y.length;G+=2)E.push(Y[G]),N.push(Y[G+1]);return[E,N]}}),Ih=vb({multinomial_:function(E,G,N,Y){void 0===Y&&(Y=!1);var ra=La(E,"logits","multinomial"),Ha=ra.size;E=ra.rank;if(2>Ha)throw Error("Error in multinomial: you need at least 2 outcomes, but got "+
(Ha+"."));if(2<E)throw Error("Rank of probabilities must be 1 or 2, but is "+E);N=N||Math.random();var ob=1===E?zd(ra,[1,-1]):ra;ra=Ic.runKernelFunc(function(qb){return qb.multinomial(ob,Y,G,N)},{logits2D:ob});return 1===E?zd(ra,[ra.size]):ra}}),Vg=vb({notEqual_:function(E,G){var N=La(E,"a","notEqual"),Y=La(G,"b","notEqual");E=ya(N,Y);N=E[0];Y=E[1];Db(N.shape,Y.shape);return Ic.runKernelFunc(function(ra){return ra.notEqual(N,Y)},{a:N,b:Y},null,"NotEqual")}}),uh=vb({real_:function(E){var G=La(E,"input",
"real");return Ic.runKernelFunc(function(N){return N.real(G)},{input:G},null,"Real")}}),oh=vb({onesLike_:function(E){var G=La(E,"x","onesLike");return Ic.runKernelFunc(function(N,Y){return"complex64"===G.dtype?(N=oh(uh(G)),Y=Ef(lh(G)),vd(N,Y)):N.onesLike(G)},{x:G},null,"OnesLike")}}),Vh=vb({outerProduct_:function(E,G){var N=La(E,"v1","outerProduct"),Y=La(G,"v2","outerProduct");e(1===N.rank&&1===Y.rank,function(){return"Error in outerProduct: inputs must be rank 1, but got ranks "+(N.rank+" and "+
Y.rank+".")});E=zd(N,[-1,1]);G=zd(Y,[1,-1]);return uf(E,G)}}),Yg=vb({pad_:function(E,G,N){void 0===N&&(N=0);var Y=La(E,"x","pad");if(0===Y.rank)throw Error("pad(scalar) is not defined. Pass non-scalar to pad");return Ic.runKernelFunc(function(ra,Ha){Ha([Y]);return ra.pad(Y,G,N)},{x:Y},null,"PadV2",{paddings:G,constantValue:N})}}),$g=vb({pad1d_:function(E,G,N){void 0===N&&(N=0);e(2===G.length,function(){return"Invalid number of paddings. Must be length of 2."});return Yg(E,[G],N)}}),Zg=vb({pad2d_:function(E,
G,N){void 0===N&&(N=0);e(2===G.length&&2===G[0].length&&2===G[1].length,function(){return"Invalid number of paddings. Must be length of 2 each."});return Yg(E,G,N)}}),hh=vb({pad3d_:function(E,G,N){void 0===N&&(N=0);e(3===G.length&&2===G[0].length&&2===G[1].length&&2===G[2].length,function(){return"Invalid number of paddings. Must be length of 2 each."});return Yg(E,G,N)}}),Lg=vb({pad4d_:function(E,G,N){void 0===N&&(N=0);e(4===G.length&&2===G[0].length&&2===G[1].length&&2===G[2].length&&2===G[3].length,
function(){return"Invalid number of paddings. Must be length of 2 each."});return Yg(E,G,N)}}),zg=vb({spaceToBatchND_:function(E,G,N){var Y=La(E,"x","spaceToBatchND");e(Y.rank>=1+G.length,function(){return"input rank "+Y.rank+" should be \x3e than [blockShape] "+G.length});e(N.length===G.length,function(){return"paddings.shape[0] "+N.length+" must be equal to [blockShape] "+G.length});e(Y.shape.reduce(function(ra,Ha,ob){return 0<ob&&ob<=G.length?ra&&0===(Ha+N[ob-1][0]+N[ob-1][1])%G[ob-1]:ra},!0),
function(){return"input spatial dimensions "+Y.shape.slice(1)+" with paddings "+N.toString()+" must be divisible by blockShapes "+G.toString()});return Ic.runKernelFunc(function(ra){return ra.spaceToBatchND(Y,G,N)},{x:Y},null,"SpaceToBatchND",{blockShape:G,paddings:N})}}),vh=vb({pool_:function(E,G,N,Y,ra,Ha){null==ra&&(ra=[1,1]);null==Ha&&(Ha=1);0===Y&&(Y="valid");var ob=La(E,"x","maxPool"),qb=ob;E=!1;3===ob.rank&&(E=!0,qb=zd(ob,[1,ob.shape[0],ob.shape[1],ob.shape[2]]));e(he(Ha,ra),function(){return"Error in pool: Either strides or dilations must be 1. Got strides "+
(Ha+" and dilations '"+ra+"'")});var Eb=Gd(qb.shape,G,Ha,ra,Y);ob=[Eb.dilationHeight,Eb.dilationWidth];var hc="same"===Y?Te([Eb.filterHeight,Eb.filterWidth],ob):[[0,0],[0,0]];var Fc=1===ob[0]&&1===ob[1];hc=Zd([Eb.inHeight,Eb.inWidth],ob,hc);Eb=hc[0];hc=hc[1];var Oc=Fc?Y:"valid",td=Fc?qb:zg(qb,ob,Eb);N=("avg"===N?function(){return Fg(td,G,Ha,Oc)}:function(){return Yd(td,G,Ha,Oc)})();N=Fc?N:kc(N,ob,hc);return E?zd(N,[N.shape[1],N.shape[2],N.shape[3]]):N}}),ph=vb({pow_:function(E,G){var N=La(E,"base",
"pow"),Y=La(G,"exp","pow");E=ya(N,Y);N=E[0];Y=E[1];return Ic.runKernelFunc(function(ra,Ha){ra=ra.pow(N,Y);Ha([N,Y,ra]);return ra},{a:N,b:Y},null,"Pow")}}),Li=vb({prelu_:function(E,G){var N=La(E,"x","prelu"),Y=La(G,"alpha","prelu");return Ic.runKernelFunc(function(ra,Ha){ra=ra.prelu(N,Y);Ha([N,Y]);return ra},{x:N,alpha:Y},null,"Prelu")}}),gi=vb({prod_:function(E,G,N){void 0===G&&(G=null);void 0===N&&(N=!1);var Y=La(E,"x","prod");"bool"===Y.dtype&&(Y=Uc(Y,"int32"));return Ic.runKernelFunc(function(ra){var Ha=
p(G,Y.shape),ob=yc(Ha,Y.rank),qb=Ha,Eb=Y;null!=ob&&(Eb=hg(Y,ob),qb=Ad(qb.length,Y.rank));ra=ra.prod(Eb,qb);N&&(Ha=fc(ra.shape,Ha),ra=zd(ra,Ha));return ra},{x:Y},null,"Prod",{axis:G,keepDims:N})}}),oi=vb({rand_:function(E,G,N){var Y=c(E);if(null==N||"float32"===N)var ra=new Float32Array(Y);else if("int32"===N)ra=new Int32Array(Y);else if("bool"===N)ra=new Uint8Array(Y);else throw Error("Unknown data type "+N);for(var Ha=0;Ha<Y;Ha++)ra[Ha]=G();return Ic.makeTensor(ra,E,N)}}),Sh="undefined"!==typeof globalThis?
globalThis:"undefined"!==typeof window?window:"undefined"!==typeof W?W:"undefined"!==typeof self?self:{},pj=re(function(E){(function(G,N,Y){function ra(Eb){var hc=this,Fc=qb();hc.next=function(){var Oc=2091639*hc.s0+2.3283064365386963E-10*hc.c;hc.s0=hc.s1;hc.s1=hc.s2;return hc.s2=Oc-(hc.c=Oc|0)};hc.c=1;hc.s0=Fc(" ");hc.s1=Fc(" ");hc.s2=Fc(" ");hc.s0-=Fc(Eb);0>hc.s0&&(hc.s0+=1);hc.s1-=Fc(Eb);0>hc.s1&&(hc.s1+=1);hc.s2-=Fc(Eb);0>hc.s2&&(hc.s2+=1);Fc=null}function Ha(Eb,hc){hc.c=Eb.c;hc.s0=Eb.s0;hc.s1=
Eb.s1;hc.s2=Eb.s2;return hc}function ob(Eb,hc){var Fc=new ra(Eb);Eb=hc&&hc.state;var Oc=Fc.next;Oc.int32=function(){return 4294967296*Fc.next()|0};Oc.double=function(){return Oc()+1.1102230246251565E-16*(2097152*Oc()|0)};Oc.quick=Oc;Eb&&("object"==typeof Eb&&Ha(Eb,Fc),Oc.state=function(){return Ha(Fc,{})});return Oc}function qb(){var Eb=4022871197;return function(hc){hc=hc.toString();for(var Fc=0;Fc<hc.length;Fc++){Eb+=hc.charCodeAt(Fc);var Oc=.02519603282416938*Eb;Eb=Oc>>>0;Oc-=Eb;Oc*=Eb;Eb=Oc>>>
0;Oc-=Eb;Eb+=4294967296*Oc}return 2.3283064365386963E-10*(Eb>>>0)}}N&&N.exports?N.exports=ob:Y&&Y.amd?Y(function(){return ob}):this.alea=ob})(Sh,E,!1)}),ii=re(function(E){(function(G,N,Y){function ra(qb){var Eb=this,hc="";Eb.x=0;Eb.y=0;Eb.z=0;Eb.w=0;Eb.next=function(){var Fc=Eb.x^Eb.x<<11;Eb.x=Eb.y;Eb.y=Eb.z;Eb.z=Eb.w;return Eb.w=Eb.w^Eb.w>>>19^Fc^Fc>>>8};qb===(qb|0)?Eb.x=qb:hc+=qb;for(qb=0;qb<hc.length+64;qb++)Eb.x^=hc.charCodeAt(qb)|0,Eb.next()}function Ha(qb,Eb){Eb.x=qb.x;Eb.y=qb.y;Eb.z=qb.z;Eb.w=
qb.w;return Eb}function ob(qb,Eb){var hc=new ra(qb);qb=Eb&&Eb.state;Eb=function(){return(hc.next()>>>0)/4294967296};Eb.double=function(){do{var Fc=hc.next()>>>11,Oc=(hc.next()>>>0)/4294967296;Fc=(Fc+Oc)/2097152}while(0===Fc);return Fc};Eb.int32=hc.next;Eb.quick=Eb;qb&&("object"==typeof qb&&Ha(qb,hc),Eb.state=function(){return Ha(hc,{})});return Eb}N&&N.exports?N.exports=ob:Y&&Y.amd?Y(function(){return ob}):this.xor128=ob})(Sh,E,!1)}),Yh=re(function(E){(function(G,N,Y){function ra(qb){var Eb=this,
hc="";Eb.next=function(){var Fc=Eb.x^Eb.x>>>2;Eb.x=Eb.y;Eb.y=Eb.z;Eb.z=Eb.w;Eb.w=Eb.v;return(Eb.d=Eb.d+362437|0)+(Eb.v=Eb.v^Eb.v<<4^Fc^Fc<<1)|0};Eb.x=0;Eb.y=0;Eb.z=0;Eb.w=0;Eb.v=0;qb===(qb|0)?Eb.x=qb:hc+=qb;for(qb=0;qb<hc.length+64;qb++)Eb.x^=hc.charCodeAt(qb)|0,qb==hc.length&&(Eb.d=Eb.x<<10^Eb.x>>>4),Eb.next()}function Ha(qb,Eb){Eb.x=qb.x;Eb.y=qb.y;Eb.z=qb.z;Eb.w=qb.w;Eb.v=qb.v;Eb.d=qb.d;return Eb}function ob(qb,Eb){var hc=new ra(qb);qb=Eb&&Eb.state;Eb=function(){return(hc.next()>>>0)/4294967296};
Eb.double=function(){do{var Fc=hc.next()>>>11,Oc=(hc.next()>>>0)/4294967296;Fc=(Fc+Oc)/2097152}while(0===Fc);return Fc};Eb.int32=hc.next;Eb.quick=Eb;qb&&("object"==typeof qb&&Ha(qb,hc),Eb.state=function(){return Ha(hc,{})});return Eb}N&&N.exports?N.exports=ob:Y&&Y.amd?Y(function(){return ob}):this.xorwow=ob})(Sh,E,!1)}),qj=re(function(E){(function(G,N,Y){function ra(qb){var Eb=this;Eb.next=function(){var hc=Eb.x,Fc=Eb.i;var Oc=hc[Fc];Oc^=Oc>>>7;var td=Oc^Oc<<24;Oc=hc[Fc+1&7];td^=Oc^Oc>>>10;Oc=hc[Fc+
3&7];td^=Oc^Oc>>>3;Oc=hc[Fc+4&7];td^=Oc^Oc<<7;Oc=hc[Fc+7&7];Oc^=Oc<<13;td^=Oc^Oc<<9;hc[Fc]=td;Eb.i=Fc+1&7;return td};(function(hc,Fc){var Oc,td=[];if(Fc===(Fc|0))td[0]=Fc;else for(Fc=""+Fc,Oc=0;Oc<Fc.length;++Oc)td[Oc&7]=td[Oc&7]<<15^Fc.charCodeAt(Oc)+td[Oc+1&7]<<13;for(;8>td.length;)td.push(0);for(Oc=0;8>Oc&&0===td[Oc];++Oc);8==Oc&&(td[7]=-1);hc.x=td;hc.i=0;for(Oc=256;0<Oc;--Oc)hc.next()})(Eb,qb)}function Ha(qb,Eb){Eb.x=qb.x.slice();Eb.i=qb.i;return Eb}function ob(qb,Eb){null==qb&&(qb=+new Date);
var hc=new ra(qb);qb=Eb&&Eb.state;Eb=function(){return(hc.next()>>>0)/4294967296};Eb.double=function(){do{var Fc=hc.next()>>>11,Oc=(hc.next()>>>0)/4294967296;Fc=(Fc+Oc)/2097152}while(0===Fc);return Fc};Eb.int32=hc.next;Eb.quick=Eb;qb&&(qb.x&&Ha(qb,hc),Eb.state=function(){return Ha(hc,{})});return Eb}N&&N.exports?N.exports=ob:Y&&Y.amd?Y(function(){return ob}):this.xorshift7=ob})(Sh,E,!1)}),Ki=re(function(E){(function(G,N,Y){function ra(qb){var Eb=this;Eb.next=function(){var hc=Eb.w,Fc=Eb.X,Oc=Eb.i;
Eb.w=hc=hc+1640531527|0;var td=Fc[Oc+34&127];var be=Fc[Oc=Oc+1&127];td^=td<<13;be^=be<<17;td=Fc[Oc]=td^td>>>15^be^be>>>12;Eb.i=Oc;return td+(hc^hc>>>16)|0};(function(hc,Fc){var Oc,td,be=[],Fe=128;if(Fc===(Fc|0)){var fe=Fc;Fc=null}else Fc+="\x00",fe=0,Fe=Math.max(Fe,Fc.length);var Be=0;for(Oc=-32;Oc<Fe;++Oc)if(Fc&&(fe^=Fc.charCodeAt((Oc+32)%Fc.length)),0===Oc&&(td=fe),fe^=fe<<10,fe^=fe>>>15,fe^=fe<<4,fe^=fe>>>13,0<=Oc){td=td+1640531527|0;var Me=be[Oc&127]^=fe+td;Be=0==Me?Be+1:0}128<=Be&&(be[(Fc&&Fc.length||
0)&127]=-1);Be=127;for(Oc=512;0<Oc;--Oc)fe=be[Be+34&127],Me=be[Be=Be+1&127],fe^=fe<<13,Me^=Me<<17,fe^=fe>>>15,Me^=Me>>>12,be[Be]=fe^Me;hc.w=td;hc.X=be;hc.i=Be})(Eb,qb)}function Ha(qb,Eb){Eb.i=qb.i;Eb.w=qb.w;Eb.X=qb.X.slice();return Eb}function ob(qb,Eb){null==qb&&(qb=+new Date);var hc=new ra(qb);qb=Eb&&Eb.state;Eb=function(){return(hc.next()>>>0)/4294967296};Eb.double=function(){do{var Fc=hc.next()>>>11,Oc=(hc.next()>>>0)/4294967296;Fc=(Fc+Oc)/2097152}while(0===Fc);return Fc};Eb.int32=hc.next;Eb.quick=
Eb;qb&&(qb.X&&Ha(qb,hc),Eb.state=function(){return Ha(hc,{})});return Eb}N&&N.exports?N.exports=ob:Y&&Y.amd?Y(function(){return ob}):this.xor4096=ob})(Sh,E,!1)}),Ji=re(function(E){(function(G,N,Y){function ra(qb){var Eb=this,hc="";Eb.next=function(){var Fc=Eb.b,Oc=Eb.c,td=Eb.d,be=Eb.a;Fc=Fc<<25^Fc>>>7^Oc;Oc=Oc-td|0;td=td<<24^td>>>8^be;be=be-Fc|0;Eb.b=Fc=Fc<<20^Fc>>>12^Oc;Eb.c=Oc=Oc-td|0;Eb.d=td<<16^Oc>>>16^be;return Eb.a=be-Fc|0};Eb.a=0;Eb.b=0;Eb.c=-1640531527;Eb.d=1367130551;qb===Math.floor(qb)?
(Eb.a=qb/4294967296|0,Eb.b=qb|0):hc+=qb;for(qb=0;qb<hc.length+20;qb++)Eb.b^=hc.charCodeAt(qb)|0,Eb.next()}function Ha(qb,Eb){Eb.a=qb.a;Eb.b=qb.b;Eb.c=qb.c;Eb.d=qb.d;return Eb}function ob(qb,Eb){var hc=new ra(qb);qb=Eb&&Eb.state;Eb=function(){return(hc.next()>>>0)/4294967296};Eb.double=function(){do{var Fc=hc.next()>>>11,Oc=(hc.next()>>>0)/4294967296;Fc=(Fc+Oc)/2097152}while(0===Fc);return Fc};Eb.int32=hc.next;Eb.quick=Eb;qb&&("object"==typeof qb&&Ha(qb,hc),Eb.state=function(){return Ha(hc,{})});return Eb}
N&&N.exports?N.exports=ob:Y&&Y.amd?Y(function(){return ob}):this.tychei=ob})(Sh,E,!1)}),ei=re(function(E){(function(G,N){function Y(fe,Be,Me){var hf=[];Be=1==Be?{entropy:!0}:Be||{};fe=qb(ob(Be.entropy?[fe,hc(G)]:null==fe?Eb():fe,3),hf);var Se=new ra(hf);hf=function(){for(var Hf=Se.g(6),yf=Oc,Sf=0;Hf<td;)Hf=256*(Hf+Sf),yf*=256,Sf=Se.g(1);for(;Hf>=be;)Hf/=2,yf/=2,Sf>>>=1;return(Hf+Sf)/yf};hf.int32=function(){return Se.g(4)|0};hf.quick=function(){return Se.g(4)/4294967296};hf.double=hf;qb(hc(Se.S),G);
return(Be.pass||Me||function(Hf,yf,Sf,af){af&&(af.S&&Ha(af,Se),Hf.state=function(){return Ha(Se,{})});return Sf?(N.random=Hf,yf):Hf})(hf,fe,"global"in Be?Be.global:this==N,Be.state)}function ra(fe){var Be,Me=fe.length,hf=this,Se=0,Hf=hf.i=hf.j=0,yf=hf.S=[];for(Me||(fe=[Me++]);256>Se;)yf[Se]=Se++;for(Se=0;256>Se;Se++)yf[Se]=yf[Hf=255&Hf+fe[Se%Me]+(Be=yf[Se])],yf[Hf]=Be;(hf.g=function(Sf){for(var af,tf=0,zf=hf.i,ig=hf.j,Mg=hf.S;Sf--;)af=Mg[zf=255&zf+1],tf=256*tf+Mg[255&(Mg[zf]=Mg[ig=255&ig+af])+(Mg[ig]=
af)];hf.i=zf;hf.j=ig;return tf})(256)}function Ha(fe,Be){Be.i=fe.i;Be.j=fe.j;Be.S=fe.S.slice();return Be}function ob(fe,Be){var Me=[],hf=typeof fe,Se;if(Be&&"object"==hf)for(Se in fe)try{Me.push(ob(fe[Se],Be-1))}catch(Hf){}return Me.length?Me:"string"==hf?fe:fe+"\x00"}function qb(fe,Be){fe+="";for(var Me,hf=0;hf<fe.length;)Be[255&hf]=255&(Me^=19*Be[255&hf])+fe.charCodeAt(hf++);return hc(Be)}function Eb(){try{var fe;Fe&&(fe=Fe.randomBytes)?fe=fe(256):(fe=new Uint8Array(256),(Fc.crypto||Fc.msCrypto).getRandomValues(fe));
return hc(fe)}catch(Be){return fe=Fc.navigator,[+new Date,Fc,fe&&fe.plugins,Fc.screen,hc(G)]}}function hc(fe){return String.fromCharCode.apply(0,fe)}var Fc=this,Oc=N.pow(256,6),td=N.pow(2,52),be=2*td;N.seedrandom=Y;qb(N.random(),G);if(E.exports){E.exports=Y;try{var Fe=A(35)}catch(fe){}}})([],Math)});ei.alea=pj;ei.xor128=ii;ei.xorwow=Yh;ei.xorshift7=qj;ei.xor4096=Ki;ei.tychei=Ji;var xj=ei.alea,Wg=function(){function E(G,N,Y,ra,Ha){this.mean=G;this.stdDev=N;this.dtype=Y;this.nextVal=NaN;if(this.truncated=
ra)this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev;this.random=xj((Ha?Ha:Math.random()).toString())}E.prototype.nextValue=function(){if(!isNaN(this.nextVal)){var G=this.nextVal;this.nextVal=NaN;return G}for(G=!1;!G;){do{var N=2*this.random()-1;var Y=2*this.random()-1;var ra=N*N+Y*Y}while(1<=ra||0===ra);ra=Math.sqrt(-2*Math.log(ra)/ra);N=this.mean+this.stdDev*N*ra;Y=this.mean+this.stdDev*Y*ra;if(!this.truncated||this.isValidTruncated(N))G=!0}if(!this.truncated||this.isValidTruncated(Y))this.nextVal=
this.convertValue(Y);return this.convertValue(N)};E.prototype.convertValue=function(G){return null==this.dtype||"float32"===this.dtype?G:Math.round(G)};E.prototype.isValidTruncated=function(G){return G<=this.upper&&G>=this.lower};return E}(),ai=function(){function E(G,N,Y,ra){this.alpha=G;this.beta=1/N;this.dtype=Y;this.randu=xj((ra?ra:Math.random()).toString());this.randn=new Wg(0,1,Y,!1,this.randu());this.d=1>G?G+2/3:G-1/3;this.c=1/Math.sqrt(9*this.d)}E.prototype.nextValue=function(){for(var G,
N,Y,ra;;){do N=this.randn.nextValue(),ra=1+this.c*N;while(0>=ra);ra*=ra*ra;G=N*N;N=1-.331*G*G;G=.5*G+this.d*(1-ra+Math.log(ra));Y=this.randu();if(Y<N||Math.log(Y)<G)break}ra*=1/this.beta*this.d;1>this.alpha&&(ra*=Math.pow(this.randu(),1/this.alpha));return this.convertValue(ra)};E.prototype.convertValue=function(G){return"float32"===this.dtype?G:Math.round(G)};return E}(),fj=function(){function E(G,N,Y,ra){var Ha=this;void 0===G&&(G=0);void 0===N&&(N=1);this.canReturnFloat=function(){return null==
Ha.dtype||"float32"===Ha.dtype};this.min=G;this.range=N-G;this.dtype=Y;null==ra&&(ra=Math.random());"number"===typeof ra&&(ra=ra.toString());if(!this.canReturnFloat()&&1>=this.range)throw Error("The difference between "+G+" - "+N+" \x3c\x3d 1 and dtype is not float");this.random=xj(ra)}E.prototype.convertValue=function(G){return this.canReturnFloat()?G:Math.round(G)};E.prototype.nextValue=function(){return this.convertValue(this.min+this.range*this.random())};return E}(),gj=vb({randomGamma_:function(E,
G,N,Y,ra){void 0===N&&(N=1);void 0===Y&&(Y="float32");null==N&&(N=1);null==Y&&(Y="float32");if("float32"!==Y&&"int32"!==Y)throw Error("Unsupported data type "+Y);G=new ai(G,N,Y,ra);E=kd(E,Y);for(Y=0;Y<E.values.length;Y++)E.values[Y]=G.nextValue();return E.toTensor()}}),Aj=vb({randomNormal_:function(E,G,N,Y,ra){void 0===G&&(G=0);void 0===N&&(N=1);if(null!=Y&&"bool"===Y)throw Error("Unsupported data type "+Y);G=new Wg(G,N,Y,!1,ra);E=kd(E,Y);for(Y=0;Y<E.values.length;Y++)E.values[Y]=G.nextValue();return E.toTensor()}}),
qh=vb({randomUniform_:function(E,G,N,Y,ra){void 0===G&&(G=0);void 0===N&&(N=1);void 0===Y&&(Y="float32");E=kd(E,Y);G=new fj(G,N,null,ra);for(N=0;N<E.values.length;N++)E.values[N]=G.nextValue();return E.toTensor()}}),Ai=vb({reciprocal_:function(E){var G=La(E,"x","reciprocal");return Ic.runKernelFunc(function(N,Y){N=N.reciprocal(G);Y([G]);return N},{x:G},null,"Reciprocal")}}),Lh=vb({relu_:function(E){var G=La(E,"x","relu");return Ic.runKernelFunc(function(N,Y){Y([G]);return"bool"===G.dtype?Uc(G,"int32"):
N.relu(G)},{x:G},null,"Relu")}}),Wh=vb({relu6_:function(E){var G=La(E,"x","relu6");return Ic.runKernelFunc(function(N,Y){Y([G]);return"bool"===G.dtype?Uc(G,"int32"):N.relu6(G)},{x:G},null,"Relu6")}}),Jh=vb({reverse_:function(E,G){var N=La(E,"x","reverse");return Ic.runKernelFunc(function(Y){var ra=p(G,N.shape);if(0===N.rank)return Ed(N);Y=Y.reverse(N,ra);return zd(Y,N.shape)},{x:N},null,"Reverse",{dims:G})}}),li=vb({reverse1d_:function(E){var G=La(E,"x","reverse");e(1===G.rank,function(){return"Error in reverse1D: x must be rank 1 but got rank "+
G.rank+"."});return Jh(G,0)}}),jj=vb({reverse2d_:function(E,G){var N=La(E,"x","reverse");e(2===N.rank,function(){return"Error in reverse2D: x must be rank 2 but got rank "+N.rank+"."});return Jh(N,G)}}),Fi=vb({reverse3d_:function(E,G){var N=La(E,"x","reverse");e(3===N.rank,function(){return"Error in reverse3D: x must be rank 3 but got rank "+N.rank+"."});return Jh(N,G)}}),Sj=vb({reverse4d_:function(E,G){var N=La(E,"x","reverse");e(4===N.rank,function(){return"Error in reverse4D: x must be rank 4 but got rank "+
N.rank+"."});return Jh(N,G)}}),Zi=vb({round_:function(E){var G=La(E,"x","round");return Ic.runKernelFunc(function(N){return N.round(G)},{x:G},null,"Round")}}),Gi=vb({rsqrt_:function(E){var G=La(E,"x","rsqrt");return Ic.runKernelFunc(function(N,Y){N=N.rsqrt(G);Y([G]);return N},{x:G},null,"Rsqrt")}}),wi=vb({selu_:function(E){var G=La(E,"x","selu");return Ic.runKernelFunc(function(N,Y){N=N.selu(G);Y([G]);return N},{x:G},null,"Selu")}}),Hi=vb({separableConv2d_:function(E,G,N,Y,ra,Ha,ob){void 0===Ha&&
(Ha=[1,1]);void 0===ob&&(ob="NHWC");E=La(E,"x","separableConv2d");var qb=La(G,"depthwiseFilter","separableConv2d"),Eb=La(N,"pointwiseFilter","separableConv2d"),hc=E;G=!1;3===E.rank&&(G=!0,hc=zd(E,[1,E.shape[0],E.shape[1],E.shape[2]]));if("NCHW"===ob)throw Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");e(4===hc.rank,function(){return"Error in separableConv2d: input must be rank 4, but got rank "+(hc.rank+".")});e(4===qb.rank,function(){return"Error in separableConv2d: depthwise filter must be rank 4, but got rank "+
(qb.rank+".")});e(4===Eb.rank,function(){return"Error in separableConv2d: pointwise filter must be rank 4, but got rank "+(qb.rank+".")});e(1===Eb.shape[0],function(){return"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got "+(Eb.shape[0]+".")});e(1===Eb.shape[1],function(){return"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got "+(Eb.shape[1]+".")});var Fc=qb.shape[2],Oc=qb.shape[3];e(Eb.shape[2]===Fc*Oc,function(){return"Error in separableConv2d: the third dimension of pointwise filter must be "+
(Fc*Oc+", but got ")+(Eb.shape[2]+".")});Y=te(hc,qb,Y,ra,ob,Ha);ob=sa(Y,Eb,1,"valid",ob);return G?zd(ob,[ob.shape[1],ob.shape[2],ob.shape[3]]):ob}}),nj=vb({sign_:function(E){var G=La(E,"x","sign");return Ic.runKernelFunc(function(N){return N.sign(G)},{x:G},null,"Sign")}}),yj=vb({sin_:function(E){var G=La(E,"x","sin");return Ic.runKernelFunc(function(N,Y){N=N.sin(G);Y([G]);return N},{x:G},null,"Sin")}}),oj=vb({sinh_:function(E){var G=La(E,"x","sinh");return Ic.runKernelFunc(function(N,Y){N=N.sinh(G);
Y([G]);return N},{x:G},null,"Sinh")}}),dk=vb({slice1d_:function(E,G,N){var Y=La(E,"x","slice1d");e(1===Y.rank,function(){return"slice1d expects a rank-1 tensor, but got a rank-"+Y.rank+" tensor"});return Qb(Y,[G],[N])}}),mj=vb({slice2d_:function(E,G,N){var Y=La(E,"x","slice2d");e(2===Y.rank,function(){return"slice2d expects a rank-2 tensor, but got a rank-"+Y.rank+" tensor"});return Qb(Y,G,N)}}),ek=vb({slice3d_:function(E,G,N){var Y=La(E,"x","slice3d");e(3===Y.rank,function(){return"slice3d expects a rank-3 tensor, but got a rank-"+
Y.rank+" tensor"});return Qb(Y,G,N)}}),Rj=vb({slice4d_:function(E,G,N){var Y=La(E,"x","slice4d");e(4===Y.rank,function(){return"slice4d expects a rank-4 tensor, but got a rank-"+Y.rank+" tensor"});return Qb(Y,G,N)}}),Mj=vb({softmax_:function(E,G){void 0===G&&(G=-1);var N=La(E,"logits","softmax","float32");-1===G&&(G=N.rank-1);if(G!==N.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+(N.rank+" and dim was "+G));return Ic.runKernelFunc(function(Y,ra){Y=
Y.softmax(N,G);ra([Y]);return Y},{logits:N},null,"Softmax",{dim:G})}}),Oi=vb({fft_:function(E){e("complex64"===E.dtype,function(){return"The dtype for tf.spectral.fft() must be complex64 but got "+(E.dtype+".")});return Ic.runKernelFunc(function(G){var N=E.shape[E.shape.length-1];N=E.as2D(E.size/N,N);return G.fft(N).reshape(E.shape)},{input:E},null,"FFT")}}),$i=vb({ifft_:function(E){e("complex64"===E.dtype,function(){return"The dtype for tf.spectral.ifft() must be complex64 but got "+(E.dtype+".")});
return Ic.runKernelFunc(function(G){var N=E.shape[E.shape.length-1];N=zd(E,[E.size/N,N]);G=G.ifft(N);return zd(G,E.shape)},{input:E},null,"IFFT")}}),Ri=vb({irfft_:function(E){var G=E.shape[E.shape.length-1],N=E.size/G;if(2>=G)var Y=zd(E,[N,G]);else{Y=[N,2*(G-1)];var ra=zd(uh(E),[N,G]),Ha=zd(lh(E),[N,G]),ob=Jh(Qb(ra,[0,1],[N,G-2]),1);G=se(Jh(Qb(Ha,[0,1],[N,G-2]),1),Qc(-1));ra=Pa([ra,ob],1);Ha=Pa([Ha,G],1);Y=zd(vd(ra,Ha),[Y[0],Y[1]])}Y=$i(Y);Y=uh(Y);3===E.rank&&0!==E.shape[0]&&(Ha=Y,E=E.shape[0],Y=
zd(Y,[E,Y.shape[0]/E,Y.shape[1]]),Ha.dispose());return Y}}),xi=vb({split_:function(E,G,N){void 0===N&&(N=0);var Y=La(E,"x","split");return Ic.runKernelFunc(function(ra,Ha){Ha=p(N,Y.shape)[0];var ob=bg(Y,G,Ha);return ra.split(Y,ob,Ha)},{x:Y},null,"SplitV",{numOrSizeSplits:G,axis:N})}}),aj=vb({rfft_:function(E,G){e("float32"===E.dtype,function(){return"The dtype for rfft() must be real value but got "+E.dtype});var N=E.shape[E.shape.length-1],Y=E.size/N;if(null!=G&&G<N){var ra=E.shape.map(function(ob){return 0});
N=E.shape.map(function(ob){return ob});N[E.shape.length-1]=G;ra=Qb(E,ra,N);N=G}else null!=G&&G>N?(ra=E.shape.map(function(ob){return ob}),ra[E.shape.length-1]=G-N,ra=Pa([E,sd(ra)],E.shape.length-1),N=G):ra=E;G=Ef(ra);Y=zd(vd(ra,G),[Y,N]);var Ha=Oi(Y);Y=Math.floor(N/2)+1;G=uh(Ha);Ha=lh(Ha);G=xi(G,[Y,N-Y],G.shape.length-1);N=xi(Ha,[Y,N-Y],Ha.shape.length-1);Ha=ra.shape.slice();Ha[ra.shape.length-1]=Y;return zd(vd(G[0],N[0]),Ha)}}),Bh=vb({sqrt_:function(E){var G=La(E,"x","sqrt");return Ic.runKernelFunc(function(N,
Y){N=N.sqrt(G);Y([G]);return N},{x:G},null,"Sqrt")}}),bj=vb({squaredDifference_:function(E,G){var N=La(E,"a","squaredDifference"),Y=La(G,"b","squaredDifference");E=ya(N,Y);N=E[0];Y=E[1];Db(N.shape,Y.shape);return Ic.runKernelFunc(function(ra,Ha){ra=ra.squaredDifference(N,Y);Ha([N,Y]);return ra},{a:N,b:Y},null,"SquaredDifference",{})}}),Ni=vb({squeeze_:function(E,G){E=La(E,"x","squeeze");return zd(E,q(E.shape,G).newShape)}}),mi=vb({stack_:function(E,G){void 0===G&&(G=0);E=Fb(E,"tensors","stack");e(1<=
E.length,function(){return"Pass at least one tensor to tf.stack"});if(1===E.length)return Tg(E[0],G);var N=E[0].shape,Y=E[0].dtype;e(G<=E[0].rank,function(){return"Axis must be \x3c\x3d rank of the tensor"});E.forEach(function(ra){g(N,ra.shape,"All tensors passed to stack must have matching shapes");e(Y===ra.dtype,function(){return"All tensors passed to stack must have matching dtypes"})});E=E.map(function(ra){return Tg(ra,G)});return Pa(E,G)}}),ji=vb({step_:function(E,G){void 0===G&&(G=0);var N=
La(E,"x","step");return Ic.runKernelFunc(function(Y){return Y.step(N,G)},{x:N},null,"Step",{alpha:G})}}),Nj=vb({stridedSlice_:function(E,G,N,Y,ra,Ha,ob,qb,Eb){void 0===ra&&(ra=0);void 0===Ha&&(Ha=0);void 0===ob&&(ob=0);void 0===qb&&(qb=0);void 0===Eb&&(Eb=0);var hc=La(E,"x","stridedSlice");return Ic.runKernelFunc(function(Fc){null==Y&&(Y=Array(G.length));var Oc=Je(ob);if(1<Oc.length)throw Error("Multiple ellipses in slice is not allowed.");if(0!==ob&&0!==qb)throw Error("Using both ellipsisMask and newAxisMask is not yet supported.");
if(0!==ob&&0!==Eb)throw Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");var td=hc.rank-G.length,be=Je(qb),Fe=hc.shape.slice();be.forEach(function(Be){G[Be]=0;N[Be]=1;Fe.splice(Be,0,1)});hc=zd(hc,Fe);Oc=od(hc.shape,Oc,td,G,N,Y,ra,Ha,ob);td=Oc.end;be=Oc.strides;G=Oc.begin;N=td;Y=be;var fe=Je(Eb);fe.forEach(function(Be){N[Be]=G[Be]+1;Y[Be]=1});td=Qe(G,N,Y);Oc=td.filter(function(Be,Me){return-1===fe.indexOf(Me)});if(Y.every(function(Be){return 1===Be}))return zd(Qb(hc,G,td),
Oc);Fc=Fc.stridedSlice(hc,G,N,Y);return zd(Fc,Oc)},{x:hc},null,"StridedSlice",{begin:G,end:N,strides:Y,beginMask:ra,endMask:Ha,ellipsisMask:ob,newAxisMask:qb,shrinkAxisMask:Eb})}}),Ci=vb({tan_:function(E){var G=La(E,"x","tan");return Ic.runKernelFunc(function(N,Y){N=N.tan(G);Y([G]);return N},{x:G},null,"Tan")}}),cj=vb({topk_:function(E,G,N){void 0===G&&(G=1);void 0===N&&(N=!0);var Y=La(E,"x","topk");if(0===Y.rank)throw Error("topk() expects the input to be of rank 1 or higher");E=Y.shape[Y.shape.length-
1];if(G>E)throw Error("'k' passed to topk() must be \x3c\x3d the last dimension ("+E+") but got "+G);E=Ic.runKernelFunc(function(ra){return ra.topk(Y,G,N)},{x:Y},null,"TopK",{k:G,sorted:N});return{values:E[0],indices:E[1]}}}),Ej=vb({truncatedNormal_:function(E,G,N,Y,ra){void 0===G&&(G=0);void 0===N&&(N=1);if(null!=Y&&"bool"===Y)throw Error("Unsupported data type $ { dtype }");G=new Wg(G,N,Y,!0,ra);E=kd(E,Y);for(Y=0;Y<E.values.length;Y++)E.values[Y]=G.nextValue();return E.toTensor()}}),Oj=vb({unique_:function(E,
G){void 0===G&&(G=0);E=La(E,"x","unique",null);e(0<E.rank,function(){return"The input tensor must be at least 1D"});G=Ic.runKernel("Unique",{x:E},{axis:G});return{values:G[0],indices:G[1]}}}),rj=vb({unsortedSegmentSum_:function(E,G,N){var Y=La(E,"x","unsortedSegmentSum"),ra=La(G,"segmentIds","unsortedSegmentSum","int32");e(m(N),function(){return"numSegments must be of dtype int"});return Ic.runKernelFunc(function(Ha,ob){Ha=Ha.unsortedSegmentSum(Y,ra,N);ob([ra]);return Ha},{x:Y,segmentIds:ra},null,
"UnsortedSegmentSum",{numSegments:N})}}),Mi=vb({unstack_:function(E,G){void 0===G&&(G=0);var N=La(E,"x","unstack");e(G>=-N.shape.length&&G<N.shape.length,function(){return"Axis \x3d "+G+" is not in [-"+N.shape.length+", "+N.shape.length+")"});0>G&&(G+=N.shape.length);return Ic.runKernelFunc(function(Y){return Y.unstack(N,G)},{value:N},null,"Unpack",{axis:G})}}),pi=function(E){return r(this,void 0,void 0,function(){var G,N,Y;return u(this,function(ra){switch(ra.label){case 0:return G=La(E,"condition",
"whereAsync","bool"),[4,G.data()];case 1:return N=ra.sent(),Y=Wf(G.shape,N),E!==G&&G.dispose(),[2,Y]}})})},ni=vb({equalStrict_:function(E,G){hb("strict variants of ops have been deprecated and will be removed in future");E=La(E,"a","equalStrict");G=La(G,"b","equalStrict");g(E.shape,G.shape,"Error in equalStrict: ");return ye(E,G)}}),Fj=vb({greaterEqualStrict_:function(E,G){hb("strict variants of ops have been deprecated and will be removed in future");E=La(E,"a","greaterEqualStrict");G=La(G,"b","greaterEqualStrict");
g(E.shape,G.shape,"Error in greaterEqualStrict: ");return ih(E,G)}}),ij=vb({greaterStrict_:function(E,G){hb("strict variants of ops have been deprecated and will be removed in future");E=La(E,"a","greaterStrict");G=La(G,"b","greaterStrict");g(E.shape,G.shape,"Error in greaterStrict: ");return Ug(E,G)}}),hj=vb({lessEqualStrict_:function(E,G){hb("strict variants of ops have been deprecated and will be removed in future");E=La(E,"a","lessEqualStrict");G=La(G,"b","lessEqualStrict");g(E.shape,G.shape,
"Error in lessEqualStrict: ");return na(E,G)}}),Xh=vb({lessStrict_:function(E,G){hb("strict variants of ops have been deprecated and will be removed in future");E=La(E,"a","lessStrict");G=La(G,"b","lessStrict");g(E.shape,G.shape,"Error in lessStrict: ");return Kh(E,G)}}),kg=vb({notEqualStrict_:function(E,G){hb("strict variants of ops have been deprecated and will be removed in future");E=La(E,"a","notEqualStrict");G=La(G,"b","notEqualStrict");g(E.shape,G.shape,"Error in notEqualStrict: ");return Vg(E,
G)}}),Bj=vb({addStrict_:function(E,G){hb("strict variants of ops have been deprecated and will be removed in future");E=La(E,"a","addStrict");G=La(G,"b","addStrict");g(E.shape,G.shape,"Error in addStrict: ");return vf(E,G)}}),Mh=vb({divStrict_:function(E,G){hb("strict variants of ops have been deprecated and will be removed in future");E=La(E,"a","div");G=La(G,"b","div");g(E.shape,G.shape,"Error in divideStrict: ");return xf(E,G)}}),qi=vb({maximumStrict_:function(E,G){hb("strict variants of ops have been deprecated and will be removed in future");
E=La(E,"a","maximumStrict");G=La(G,"b","maximumStrict");g(E.shape,G.shape,"Error in maximumStrict: ");return Ah(E,G)}}),Pi=vb({minimumStrict_:function(E,G){hb("strict variants of ops have been deprecated and will be removed in future");E=La(E,"a","minimumStrict");G=La(G,"b","minimumStrict");g(E.shape,G.shape,"Error in minimumStrict: ");return Af(E,G)}}),yi=vb({modStrict_:function(E,G){hb("strict variants of ops have been deprecated and will be removed in future");E=La(E,"a","modStrict");G=La(G,"b",
"modStrict");g(E.shape,G.shape,"Error in modStrict: ");return Rf(E,G)}}),dj=vb({mulStrict_:function(E,G){hb("strict variants of ops have been deprecated and will be removed in future");E=La(E,"a","mul");G=La(G,"b","mul");g(E.shape,G.shape,"Error in multiplyStrict: ");return se(E,G)}}),fi=vb({powStrict_:function(E,G){hb("strict variants of ops have been deprecated and will be removed in future");g(E.shape,G.shape,"Error in powStrict: ");return ph(E,G)}}),Nh=vb({squaredDifferenceStrict_:function(E,
G){hb("strict variants of ops have been deprecated and will be removed in future");E=La(E,"a","squaredDifferenceStrict");G=La(G,"b","squaredDifferenceStrict");g(E.shape,G.shape,"Error in squaredDifferenceStrict: ");return bj(E,G)}}),Cj=vb({subStrict_:function(E,G){hb("strict variants of ops have been deprecated and will be removed in future");E=La(E,"a","subStrict");G=La(G,"b","subStrict");g(E.shape,G.shape,"Error in subStrict: ");return Zb(E,G)}}),Qi=vb({norm_:function(E,G,N,Y){void 0===G&&(G="euclidean");
void 0===N&&(N=null);void 0===Y&&(Y=!1);E=La(E,"x","norm");G=Pf(E,G,N);var ra=G.shape;Y&&(E=p(N,E.shape),ra=fc(G.shape,E));return zd(G,ra)}}),hi=vb({movingAverage_:function(E,G,N,Y,ra){void 0===ra&&(ra=!0);E=La(E,"v","movingAverage");var Ha=La(G,"x","movingAverage");N=La(N,"decay","movingAverage");Qa(E,Ha);e(l(E.shape,Ha.shape),function(){return"Shape mismatch in v and x"});G=Qc(1);var ob=Zb(G,N);Ha=se(Zb(Ha,E),ob);ra&&(e(null!=Y,function(){return"When using zeroDebias: true, step is required."}),
Y=La(Y,"step","movingAverage"),Ha=xf(Ha,Zb(G,ph(N,Y))));return vf(E,Ha)}}),ri=vb({scatterND_:function(E,G,N){var Y=La(E,"indices","scatterND","int32"),ra=La(G,"updates","scatterND");Jd(ra,Y,N);return Ic.runKernelFunc(function(Ha){return Ha.scatterND(Y,ra,N)},{indices:Y,updates:ra},null,"ScatterNd",{shape:N})}}),Bi=vb({sparseToDense_:function(E,G,N,Y){void 0===Y&&(Y=0);var ra=La(E,"sparseIndices","sparseToDense","int32"),Ha=La(G,"sparseValues","sparseToDense"),ob=La(Y,"defaultValue","sparseToDense",
Ha.dtype);Bg(ra,Ha,N,ob);return Ic.runKernelFunc(function(qb){return qb.sparseToDense(ra,Ha,N,ob)},{sparseIndices:ra,sparseValues:Ha,defaultValue:ob},null,"SparseToDense",{outputShape:N})}}),kj=vb({gatherND_:function(E,G){var N=La(G,"indices","gatherND","int32"),Y=La(E,"x","gatherND");return Ic.runKernelFunc(function(ra){return ra.gatherND(Y,N)},{params:Y,indices:N},null,"GatherNd")}}),Pj=vb({dropout_:function(E,G,N,Y){var ra=La(E,"x","dropout");e("float32"===ra.dtype,function(){return"x has to be a floating point tensor since it's going to be scaled, but got a "+
(ra.dtype+" tensor instead.")});e(0<=G&&1>G,function(){return"rate must be a float in the range [0, 1), but got "+G+"."});if(0===G)return E instanceof Da?ra.clone():ra;E=Uf(ra,N);N=1-G;Y=xf(Gh(vf(qh(E,0,1,"float32",Y),N)),N);return se(ra,Y)}}),Ii=vb({conv2DBackpropFilter_:function(E,G,N,Y,ra,Ha,ob){void 0===Ha&&(Ha="NHWC");var qb=E;3===E.rank&&(qb=zd(E,[1,E.shape[0],E.shape[1],E.shape[2]]));var Eb=G;3===Eb.rank&&(Eb=zd(G,[1,G.shape[0],G.shape[1],G.shape[2]]));e(4===qb.rank,function(){return"Error in conv2dDerFilter: input must be rank 4, but got shape "+
(qb.shape+".")});e(4===Eb.rank,function(){return"Error in conv2dDerFilter: dy must be rank 4, but got shape "+(Eb.shape+".")});e(4===N.length,function(){return"Error in conv2dDerFilter: filterShape must be length 4, but got "+(N+".")});var hc="NHWC"===Ha?qb.shape[3]:qb.shape[1],Fc="NHWC"===Ha?Eb.shape[3]:Eb.shape[1];e(hc===N[2],function(){return"Error in conv2dDerFilter: depth of input "+hc+") must match input depth in filter ("+(N[2]+".")});e(Fc===N[3],function(){return"Error in conv2dDerFilter: depth of dy ("+
Fc+") must match output depth for filter ("+(N[3]+").")});null!=ob&&e(m(ra),function(){return"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode "+(ob+" but got pad "+ra+".")});return Ic.runKernelFunc(function(Oc){var td=bf(Ha);td=Re(qb.shape,N,Y,1,ra,ob,!1,td);return Oc.conv2dDerFilter(qb,Eb,td)},{x:qb,dy:Eb},null,"Conv2DBackpropFilter",{strides:Y,pad:ra,dataFormat:Ha,dimRoundingMode:ob,filterShape:N})}}),di=function(E,G){return!(0<E)||"linear"===G},Dj=vb({fusedConv2d_:function(E){var G=
E.x,N=E.filter,Y=E.strides,ra=E.pad,Ha=E.dataFormat,ob=void 0===Ha?"NHWC":Ha;Ha=E.dilations;var qb=void 0===Ha?[1,1]:Ha,Eb=E.dimRoundingMode;Ha=E.bias;var hc=E.activation,Fc=void 0===hc?"linear":hc;E=E.preluActivationWeights;Fc=Fc||"linear";if(!1===di(Ic.state.gradientDepth,Fc))return N=sa(G,N,Y,ra,ob,qb,Eb),null!=Ha&&(N=vf(N,Ha)),gf(N,Fc,E);G=La(G,"x","conv2d");var Oc=La(N,"filter","conv2d"),td=G,be=!1;3===G.rank&&(be=!0,td=zd(G,[1,G.shape[0],G.shape[1],G.shape[2]]));e(4===td.rank,function(){return"Error in fused conv2d: input must be rank 4, but got rank "+
(td.rank+".")});e(4===Oc.rank,function(){return"Error in fused conv2d: filter must be rank 4, but got rank "+(Oc.rank+".")});null!=Eb&&e(m(ra),function(){return"Error in fused conv2d: pad must be an integer when using, dimRoundingMode "+(Eb+" but got pad "+ra+".")});e(td.shape[3]===Oc.shape[2],function(){return"Error in conv2d: depth of input ("+td.shape[3]+") must match input depth for filter "+(Oc.shape[2]+".")});e(he(Y,qb),function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+
(Y+" and dilations '"+qb+"'")});e("NHWC"===ob,function(){return"Error in conv2d: got dataFormat of "+ob+" but only NHWC is currently supported."});var Fe=Re(td.shape,Oc.shape,Y,qb,ra,Eb);if(null!=Ha){var fe=La(Ha,"bias","fused conv2d");fe=ya(fe,G)[0];Db(Fe.outShape,fe.shape)}var Be;null!=E&&(Be=La(E,"prelu weights","fused conv2d"));var Me=function(yf,Sf){var af=Sf[0],tf=Sf[1],zf=Sf[3];yf=sf(yf,Sf[2],Fc);e(ge(qb),function(){return"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+
(qb+"'")});Sf=za(tf.shape,yf,af,Y,ra);af=Ii(tf,yf,af.shape,Y,ra);af=[Sf,af];null!=zf&&(zf=Cf(zf,yf),af.push(zf));return af},hf=function(yf){return yf.fusedConv2d({input:td,filter:Oc,convInfo:Fe,bias:fe,activation:Fc,preluActivationWeights:Be})},Se={x:td,filter:Oc,bias:fe,preluActivationWeights:Be},Hf={strides:Y,pad:ra,dataFormat:ob,dilations:qb,dimRoundingMode:Eb,activation:Fc};return null==Ha?Fd(function(yf,Sf,af){var tf=Ic.runKernelFunc(hf,Se,null,"FusedConv2D",Hf);af([Sf,yf,tf]);be&&(tf=zd(tf,
[tf.shape[1],tf.shape[2],tf.shape[3]]));return{value:tf,gradFunc:Me}})(td,Oc):Fd(function(yf,Sf,af,tf){var zf=Ic.runKernelFunc(hf,Se,null,"FusedConv2D",Hf);tf([Sf,yf,zf,af]);be&&(zf=zd(zf,[zf.shape[1],zf.shape[2],zf.shape[3]]));return{value:zf,gradFunc:Me}})(td,Oc,fe)}}),lj=vb({depthwiseConv2dNativeBackpropFilter_:function(E,G,N,Y,ra,Ha,ob){void 0===Ha&&(Ha=[1,1]);var qb=E;3===E.rank&&(qb=zd(E,[1,E.shape[0],E.shape[1],E.shape[2]]));var Eb=G;3===Eb.rank&&(Eb=zd(G,[1,G.shape[0],G.shape[1],G.shape[2]]));
return Ic.runKernelFunc(function(hc){var Fc=Re(E.shape,N,Y,Ha,ra,ob,!0);return hc.depthwiseConv2DDerFilter(qb,Eb,Fc)},{x:qb,dy:Eb},null,"DepthwiseConv2dNativeBackpropFilter",{strides:Y,pad:ra,dimRoundingMode:ob,dilations:Ha,filterShape:N})}}),Wi=vb({depthwiseConv2dNativeBackpropInput_:function(E,G,N,Y,ra,Ha,ob){void 0===Ha&&(Ha=[1,1]);var qb=G,Eb=!1;3===G.rank&&(Eb=!0,qb=zd(G,[1,G.shape[0],G.shape[1],G.shape[2]]));G=Ic.runKernelFunc(function(hc){var Fc=Re(E,N.shape,Y,Ha,ra,ob,!0);return hc.depthwiseConv2DDerInput(qb,
N,Fc)},{dy:qb,filter:N},null,"DepthwiseConv2dNativeBackpropInput",{strides:Y,pad:ra,dimRoundingMode:ob,dilations:Ha,inputShape:E});return Eb?zd(G,[G.shape[1],G.shape[2],G.shape[3]]):G}}),Xi=vb({fusedDepthwiseConv2d_:function(E){var G=E.x,N=E.filter,Y=E.strides,ra=E.pad,Ha=E.dataFormat;Ha=void 0===Ha?"NHWC":Ha;var ob=E.dilations,qb=void 0===ob?[1,1]:ob,Eb=E.dimRoundingMode;ob=E.bias;var hc=E.activation,Fc=void 0===hc?"linear":hc;E=E.preluActivationWeights;if(!1===di(Ic.state.gradientDepth,Fc))return N=
te(G,N,Y,ra,Ha,qb,Eb),null!=ob&&(N=vf(N,ob)),gf(N,Fc,E);G=La(G,"x","depthwiseConv2d");var Oc=La(N,"filter","depthwiseConv2d"),td=G,be=!1;3===G.rank&&(be=!0,td=zd(G,[1,G.shape[0],G.shape[1],G.shape[2]]));e(4===td.rank,function(){return"Error in fused depthwiseConv2d: input must be rank 4, but got rank "+(td.rank+".")});e(4===Oc.rank,function(){return"Error in fused depthwiseConv2d: filter must be rank 4, but got rank "+(Oc.rank+".")});e(td.shape[3]===Oc.shape[2],function(){return"Error in fused depthwiseConv2d: number of input channels ("+
(td.shape[3]+") must match the inChannels dimension in filter ")+(Oc.shape[2]+".")});null==qb&&(qb=[1,1]);e(he(Y,qb),function(){return"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides "+(Y+" and dilations '"+qb+"'")});null!=Eb&&e(m(ra),function(){return"Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode "+(Eb+" but got pad "+ra+".")});var Fe=Re(td.shape,Oc.shape,Y,qb,ra,Eb,!0);if(null!=ob){var fe=La(ob,"bias","fused conv2d");fe=ya(fe,
G)[0];Db(Fe.outShape,fe.shape)}var Be;null!=E&&(Be=La(E,"prelu weights","fused depthwiseConv2d"));var Me=function(yf,Sf){e(ge(qb),function(){return"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+(qb+"'")});var af=Sf[0],tf=Sf[1],zf=Sf[3];Sf=sf(yf,Sf[2],Fc);yf=Wi(tf.shape,Sf,af,Y,ra,qb,Eb);af=lj(tf,Sf,af.shape,Y,ra,qb,Eb);return null!=zf?(zf=Cf(fe,Sf),[yf,af,zf]):[yf,af]},hf=function(yf){return yf.fusedDepthwiseConv2D({input:td,filter:Oc,
convInfo:Fe,bias:fe,activation:Fc,preluActivationWeights:Be})},Se={x:td,filter:Oc,bias:fe,preluActivationWeights:Be},Hf={strides:Y,pad:ra,dataFormat:Ha,dilations:qb,dimRoundingMode:Eb,activation:Fc};return null==ob?Fd(function(yf,Sf,af){var tf=Ic.runKernelFunc(hf,Se,null,"FusedDepthwiseConv2D",Hf);af([Sf,yf,tf]);be&&(tf=zd(tf,[tf.shape[1],tf.shape[2],tf.shape[3]]));return{value:tf,gradFunc:Me}})(td,Oc):Fd(function(yf,Sf,af,tf){var zf=Ic.runKernelFunc(hf,Se,null,"FusedDepthwiseConv2D",Hf);tf([Sf,yf,
zf,af]);be&&(zf=zd(zf,[zf.shape[1],zf.shape[2],zf.shape[3]]));return{value:zf,gradFunc:Me}})(td,Oc,fe)}}),Lj=vb({fusedMatMul_:function(E){var G=E.a;var N=E.b,Y=E.transposeA,ra=void 0===Y?!1:Y;Y=E.transposeB;var Ha=void 0===Y?!1:Y,ob=E.bias;Y=E.activation;var qb=void 0===Y?"linear":Y;E=E.preluActivationWeights;if(!1===di(Ic.state.gradientDepth,qb))return G=uf(G,N,ra,Ha),null!=ob&&(G=vf(G,ob)),gf(G,qb,E);var Eb=La(G,"a","fused matMul"),hc=La(N,"b","fused matMul");G=ya(Eb,hc);Eb=G[0];hc=G[1];var Fc=
ra?Eb.shape[Eb.rank-2]:Eb.shape[Eb.rank-1],Oc=Ha?hc.shape[hc.rank-1]:hc.shape[hc.rank-2];G=ra?Eb.shape[Eb.rank-1]:Eb.shape[Eb.rank-2];N=Ha?hc.shape[hc.rank-2]:hc.shape[hc.rank-1];var td=Eb.shape.slice(0,-2),be=hc.shape.slice(0,-2);Y=c(td);var Fe=c(be);e(2<=Eb.rank&&2<=hc.rank&&Eb.rank===hc.rank,function(){return"Error in fused matMul: inputs must have the same rank of at least 2, got ranks "+(Eb.rank+" and "+hc.rank+".")});e(l(td,be),function(){return"Error in fused matMul: outer dimensions ("+td+
") and ("+(be+") of Tensors with shapes "+Eb.shape+" and ")+(hc.shape+" must match.")});e(Fc===Oc,function(){return"Error in fused matMul: inner shapes ("+Fc+") and ("+(Oc+") of Tensors with shapes "+Eb.shape+" and ")+(hc.shape+" and transposeA\x3d"+ra)+(" and transposeB\x3d"+Ha+" must match.")});var fe=Eb.shape.slice(0,-2).concat([G,N]),Be=ra?zd(Eb,[Y,Fc,G]):zd(Eb,[Y,G,Fc]),Me=Ha?zd(hc,[Fe,N,Oc]):zd(hc,[Fe,Oc,N]);if(null!=ob){var hf=La(ob,"bias","fused matMul");hf=ya(hf,Eb)[0];Db(fe,hf.shape)}var Se;
null!=E&&(Se=La(E,"prelu weights","fused matMul"));var Hf=function(tf,zf){var ig=zf[0],Mg=zf[1],Qh=zf[2];zf=zf[3];tf=sf(zd(tf,Qh.shape),Qh,qb);ra||Ha?!ra&&Ha?(Mg=uf(tf,Mg,!1,!1),ig=uf(tf,ig,!0,!1)):ra&&!Ha?(Mg=uf(Mg,tf,!1,!0),ig=uf(ig,tf,!1,!1)):(Mg=uf(Mg,tf,!0,!0),ig=uf(tf,ig,!0,!0)):(Mg=uf(tf,Mg,!1,!0),ig=uf(ig,tf,!0,!1));return null!=ob?(zf=Cf(zf,tf),[Mg,ig,zf]):[Mg,ig]},yf=function(tf){return tf.fusedBatchMatMul({a:Be,b:Me,transposeA:ra,transposeB:Ha,bias:hf,activation:qb,preluActivationWeights:Se})},
Sf={a:Be,b:Me,bias:hf,preluActivationWeights:Se},af={transposeA:ra,transposeB:Ha,activation:qb};return null==ob?Fd(function(tf,zf,ig){var Mg=Ic.runKernelFunc(yf,Sf,null,"_FusedMatMul",af);ig([tf,zf,Mg]);return{value:zd(Mg,fe),gradFunc:Hf}})(Be,Me):Fd(function(tf,zf,ig,Mg){var Qh=Ic.runKernelFunc(yf,Sf,null,"_FusedMatMul",af);Mg([tf,zf,Qh,ig]);return{value:zd(Qh,fe),gradFunc:Hf}})(Be,Me,hf)}}),Yj={__proto__:null,conv2d:Dj,depthwiseConv2d:Xi,matMul:Lj},ej=vb({hammingWindow_:function(E){return ug(E,
.54,.46)}}),zi=vb({hannWindow_:function(E){return ug(E,.5,.5)}}),Zh=vb({frame_:function(E,G,N,Y,ra){void 0===Y&&(Y=!1);void 0===ra&&(ra=0);for(var Ha=0,ob=[];Ha+G<=E.size;)ob.push(Qb(E,Ha,G)),Ha+=N;if(Y)for(;Ha<E.size;)Y=Ha+G-E.size,Y=Pa([Qb(E,Ha,G-Y),dc([Y],ra)]),ob.push(Y),Ha+=N;return 0===ob.length?Lf([],[0,G]):zd(Pa(ob),[ob.length,G])}}),Si=vb({stft_:function(E,G,N,Y,ra){void 0===ra&&(ra=zi);null==Y&&(Y=Kb(G));E=Zh(E,G,N);ra=se(E,ra(G));N=[];for(var Ha=0;Ha<E.shape[0];Ha++)N.push(aj(Qb(ra,[Ha,
0],[1,G]),Y));return Pa(N)}}),si=vb({cropAndResize_:function(E,G,N,Y,ra,Ha){var ob=La(E,"image","cropAndResize"),qb=La(G,"boxes","cropAndResize","float32"),Eb=La(N,"boxInd","cropAndResize","int32");ra=ra||"bilinear";Ha=Ha||0;var hc=qb.shape[0];e(4===ob.rank,function(){return"Error in cropAndResize: image must be rank 4,but got rank "+(ob.rank+".")});e(2===qb.rank&&4===qb.shape[1],function(){return"Error in cropAndResize: boxes must be have size ["+hc+",4] but had shape "+(qb.shape+".")});e(1===Eb.rank&&
Eb.shape[0]===hc,function(){return"Error in cropAndResize: boxInd must be have size ["+hc+"] but had shape "+(qb.shape+".")});e(2===Y.length,function(){return"Error in cropAndResize: cropSize must be of length 2, but got length "+(Y.length+".")});e(1<=Y[0]&&1<=Y[1],function(){return"cropSize must be atleast [1,1], but was "+Y});e("bilinear"===ra||"nearest"===ra,function(){return"method must be bilinear or nearest, but was "+ra});return Ic.runKernelFunc(function(Fc){return Fc.cropAndResize(ob,qb,Eb,
Y,ra,Ha)},{image:ob,boxes:qb,boxInd:Eb},null,"CropAndResize",{method:ra,extrapolationValue:Ha,cropSize:Y})}}),Gj=vb({flipLeftRight_:function(E){var G=La(E,"image","flipLeftRight","float32");e(4===G.rank,function(){return"Error in flipLeftRight: image must be rank 4,but got rank "+(G.rank+".")});return Ic.runKernel("FlipLeftRight",{image:G},{})}}),sj=vb({rotateWithOffset_:function(E,G,N,Y){void 0===N&&(N=0);void 0===Y&&(Y=.5);var ra=La(E,"image","rotateWithOffset","float32");e(4===ra.rank,function(){return"Error in rotateWithOffset: image must be rank 4,but got rank "+
(ra.rank+".")});return Ic.runKernel("RotateWithOffset",{image:ra},{radians:G,fillValue:N,center:Y})}}),ti=vb({nonMaxSuppression_:function(E,G,N,Y,ra){void 0===Y&&(Y=.5);void 0===ra&&(ra=Number.NEGATIVE_INFINITY);var Ha=La(E,"boxes","nonMaxSuppression"),ob=La(G,"scores","nonMaxSuppression");E=Gf(Ha,ob,N,Y,ra);N=E.maxOutputSize;Y=E.iouThreshold;ra=E.scoreThreshold;return Ic.runKernelFunc(function(qb){return qb.nonMaxSuppression(Ha,ob,N,Y,ra)},{boxes:Ha,scores:ob},null,"NonMaxSuppressionV3",{maxOutputSize:N,
iouThreshold:Y,scoreThreshold:ra})}}),bi=vb({nonMaxSuppressionWithScore_:function(E,G,N,Y,ra,Ha){void 0===Y&&(Y=.5);void 0===ra&&(ra=Number.NEGATIVE_INFINITY);void 0===Ha&&(Ha=0);E=La(E,"boxes","nonMaxSuppression");G=La(G,"scores","nonMaxSuppression");Ha=Gf(E,G,N,Y,ra,Ha);N=Ha.maxOutputSize;Y=Ha.iouThreshold;ra=Ha.scoreThreshold;Ha=Ha.softNmsSigma;N=Ic.runKernel("NonMaxSuppressionV5",{boxes:E,scores:G},{maxOutputSize:N,iouThreshold:Y,scoreThreshold:ra,softNmsSigma:Ha});return{selectedIndices:N[0],
selectedScores:N[1]}}}),mh=vb({nonMaxSuppressionPadded_:function(E,G,N,Y,ra,Ha){void 0===Y&&(Y=.5);void 0===ra&&(ra=Number.NEGATIVE_INFINITY);void 0===Ha&&(Ha=!1);E=La(E,"boxes","nonMaxSuppression");G=La(G,"scores","nonMaxSuppression");N=Gf(E,G,N,Y,ra,null);Ha=Ic.runKernel("NonMaxSuppressionV4",{boxes:E,scores:G},{maxOutputSize:N.maxOutputSize,iouThreshold:N.iouThreshold,scoreThreshold:N.scoreThreshold,padToMaxOutputSize:Ha});return{selectedIndices:Ha[0],validOutputs:Ha[1]}}}),wh=vb({resizeBilinear_:function(E,
G,N){void 0===N&&(N=!1);var Y=La(E,"images","resizeBilinear");e(3===Y.rank||4===Y.rank,function(){return"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+(Y.rank+".")});e(2===G.length,function(){return"Error in resizeBilinear: new shape must 2D, but got shape "+(G+".")});var ra=Y;E=!1;3===Y.rank&&(E=!0,ra=zd(Y,[1,Y.shape[0],Y.shape[1],Y.shape[2]]));var Ha=G[0],ob=G[1],qb=Ic.runKernelFunc(function(Eb,hc){hc([ra]);return Eb.resizeBilinear(ra,Ha,ob,N)},{images:ra},null,"ResizeBilinear",
{alignCorners:N,size:G});return E?zd(qb,[qb.shape[1],qb.shape[2],qb.shape[3]]):qb}}),ci=vb({resizeNearestNeighbor_:function(E,G,N){void 0===N&&(N=!1);var Y=La(E,"images","resizeNearestNeighbor");e(3===Y.rank||4===Y.rank,function(){return"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+(Y.rank+".")});e(2===G.length,function(){return"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+(G+".")});e("float32"===Y.dtype||"int32"===Y.dtype,function(){return"`images` must have `int32` or `float32` as dtype"});
var ra=Y;E=!1;3===Y.rank&&(E=!0,ra=zd(Y,[1,Y.shape[0],Y.shape[1],Y.shape[2]]));var Ha=G[0],ob=G[1],qb=Ic.runKernelFunc(function(Eb,hc){hc([ra]);return Eb.resizeNearestNeighbor(ra,Ha,ob,N)},{images:ra},null,"ResizeNearestNeighbor",{alignCorners:N,size:G});return E?zd(qb,[qb.shape[1],qb.shape[2],qb.shape[3]]):qb}}),uj=vb({bandPart_:function(E,G,N){e(0===G%1,function(){return"bandPart(): numLower must be an integer, got "+G+"."});e(0===N%1,function(){return"bandPart(): numUpper must be an integer, got "+
N+"."});var Y=La(E,"a","bandPart");e(2<=Y.rank,function(){return"bandPart(): Rank must be at least 2, got "+Y.rank+"."});E=Y.shape;var ra=Y.shape.slice(-2),Ha=ra[0];ra=ra[1];if(!(G<=Ha))throw Error("bandPart(): numLower ("+G+") must not be greater than the number of rows ("+(Ha+")."));if(!(N<=ra))throw Error("bandPart(): numUpper ("+N+") must not be greater than the number of columns ("+(ra+")."));0>G&&(G=Ha);0>N&&(N=ra);var ob=zd(nf(0,Ha,1,"int32"),[-1,1]),qb=nf(0,ra,1,"int32");ob=Zb(ob,qb);var Eb=
rd(na(ob,Qc(+G,"int32")),ih(ob,Qc(-N,"int32"))),hc=sd([Ha,ra],Y.dtype);return zd(mi(Mi(zd(Y,[-1,Ha,ra])).map(function(Fc){return cg(Eb,Fc,hc)})),E)}}),ki=vb({gramSchmidt_:function(E){if(Array.isArray(E)){var G=!1;e(null!=E&&0<E.length,function(){return"Gram-Schmidt process: input must not be null, undefined, or empty"});for(var N=E[0].shape[0],Y=function(qb){e(E[qb].shape[0]===N,function(){return"Gram-Schmidt: Non-unique lengths found in the input vectors: ("+(E[qb].shape[0]+" vs. "+N+")")})},ra=
1;ra<E.length;++ra)Y(ra)}else G=!0,E=xi(E,E.shape[0],0).map(function(qb){return Ni(qb,[0])});e(E.length<=E[0].shape[0],function(){return"Gram-Schmidt: Number of vectors ("+E.length+") exceeds number of dimensions ("+(E[0].shape[0]+").")});var Ha=[],ob=E;Y=function(qb){Ha.push(Ic.tidy(function(){var Eb=ob[qb];if(0<qb)for(var hc=0;hc<qb;++hc){var Fc=se(Yb(se(Ha[hc],Eb)),Ha[hc]);Eb=Zb(Eb,Fc)}return xf(Eb,Qi(Eb,"euclidean"))}))};for(ra=0;ra<E.length;++ra)Y(ra);return G?mi(Ha,0):Ha}}),Uj=vb({qr_:function(E,
G){void 0===G&&(G=!1);e(2<=E.rank,function(){return"qr() requires input tensor to have a rank \x3e\x3d 2, but got rank "+E.rank});if(2===E.rank)return Ea(E,G);var N=E.shape.slice(0,E.shape.length-2).reduce(function(ob,qb){return ob*qb}),Y=[],ra=[];Mi(zd(E,[N,E.shape[E.shape.length-2],E.shape[E.shape.length-1]]),0).forEach(function(ob){ob=Ea(ob,G);var qb=ob[1];Y.push(ob[0]);ra.push(qb)});N=zd(mi(Y,0),E.shape);var Ha=zd(mi(ra,0),E.shape);return[N,Ha]}});(function(E){E[E.NONE=0]="NONE";E[E.MEAN=1]="MEAN";
E[E.SUM=2]="SUM";E[E.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(v.Reduction||(v.Reduction={}));var Th=vb({computeWeightedLoss_:function(E,G,N){void 0===N&&(N=v.Reduction.SUM_BY_NONZERO_WEIGHTS);var Y=La(E,"losses","computeWeightedLoss");E=null;null!=G&&(E=La(G,"weights","computeWeightedLoss"));G=null==E?Y:se(Y,E);if(N===v.Reduction.NONE)return G;if(N===v.Reduction.SUM)return Yb(G);if(N===v.Reduction.MEAN){if(null==E)return jf(G);N=Y.size/E.size;G=xf(Yb(G),Yb(E));return 1<N?xf(G,Qc(N)):G}if(N===
v.Reduction.SUM_BY_NONZERO_WEIGHTS){if(null==E)return xf(Yb(G),Qc(Y.size));N=se(E,wd(Y.shape));N=Uc(Yb(Vg(N,Qc(0))),"float32");return xf(Yb(G),N)}throw Error("Unknown reduction: "+N);}}),tj=vb({absoluteDifference_:function(E,G,N,Y){void 0===Y&&(Y=v.Reduction.SUM_BY_NONZERO_WEIGHTS);E=La(E,"labels","absoluteDifference");var ra=La(G,"predictions","absoluteDifference");G=null;null!=N&&(G=La(N,"weights","absoluteDifference"));g(E.shape,ra.shape,"Error in absoluteDifference: ");N=sg(Zb(E,ra));return Th(N,
G,Y)}}),Xj=vb({cosineDistance_:function(E,G,N,Y,ra){void 0===ra&&(ra=v.Reduction.SUM_BY_NONZERO_WEIGHTS);E=La(E,"labels","cosineDistance");var Ha=La(G,"predictions","cosineDistance");G=null;null!=Y&&(G=La(Y,"weights","cosineDistance"));g(E.shape,Ha.shape,"Error in cosineDistance: ");Y=Qc(1);N=Zb(Y,Yb(se(E,Ha),N,!0));return Th(N,G,ra)}}),Qj=vb({hingeLoss_:function(E,G,N,Y){void 0===Y&&(Y=v.Reduction.SUM_BY_NONZERO_WEIGHTS);E=La(E,"labels","hingeLoss");var ra=La(G,"predictions","hingeLoss");G=null;
null!=N&&(G=La(N,"weights","hingeLoss"));g(E.shape,ra.shape,"Error in hingeLoss: ");N=Qc(1);E=Zb(se(Qc(2),E),N);N=Lh(Zb(N,se(E,ra)));return Th(N,G,Y)}}),zj=vb({huberLoss_:function(E,G,N,Y,ra){void 0===Y&&(Y=1);void 0===ra&&(ra=v.Reduction.SUM_BY_NONZERO_WEIGHTS);E=La(E,"labels","huberLoss");var Ha=La(G,"predictions","huberLoss");G=null;null!=N&&(G=La(N,"weights","huberLoss"));g(E.shape,Ha.shape,"Error in huberLoss: ");N=Qc(Y);E=sg(Zb(Ha,E));Y=Af(E,N);E=Zb(E,Y);N=vf(se(Qc(.5),Bf(Y)),se(N,E));return Th(N,
G,ra)}}),Tj=vb({logLoss_:function(E,G,N,Y,ra){void 0===Y&&(Y=1E-7);void 0===ra&&(ra=v.Reduction.SUM_BY_NONZERO_WEIGHTS);E=La(E,"labels","logLoss");var Ha=La(G,"predictions","logLoss");G=null;null!=N&&(G=La(N,"weights","logLoss"));g(E.shape,Ha.shape,"Error in logLoss: ");N=Qc(1);var ob=Qc(Y);Y=ca(se(E,x(vf(Ha,ob))));E=se(Zb(N,E),x(vf(Zb(N,Ha),ob)));E=Zb(Y,E);return Th(E,G,ra)}}),Ti=vb({meanSquaredError_:function(E,G,N,Y){void 0===Y&&(Y=v.Reduction.SUM_BY_NONZERO_WEIGHTS);E=La(E,"labels","meanSquaredError");
var ra=La(G,"predictions","meanSquaredError");G=null;null!=N&&(G=La(N,"weights","meanSquaredError"));g(E.shape,ra.shape,"Error in meanSquaredError: ");N=bj(E,ra);return Th(N,G,Y)}}),Hj=vb({sigmoidCrossEntropy_:function(E,G,N,Y,ra){void 0===Y&&(Y=0);void 0===ra&&(ra=v.Reduction.SUM_BY_NONZERO_WEIGHTS);E=La(E,"multiClassLabels","sigmoidCrossEntropy");var Ha=La(G,"logits","sigmoidCrossEntropy");G=null;null!=N&&(G=La(N,"weights","sigmoidCrossEntropy"));g(E.shape,Ha.shape,"Error in sigmoidCrossEntropy: ");
if(0<Y){N=Qc(Y);Y=Qc(1);var ob=Qc(.5);E=vf(se(E,Zb(Y,N)),se(ob,N))}N=La(E,"labels","sigmoidCrossEntropyWithLogits");Ha=La(Ha,"logits","sigmoidCrossEntropyWithLogits");g(N.shape,Ha.shape,"Error in sigmoidCrossEntropyWithLogits: ");E=Lh(Ha);N=se(Ha,N);Ha=P(Xg(ca(sg(Ha))));E=vf(Zb(E,N),Ha);return Th(E,G,ra)}}),Ij=vb({softmaxCrossEntropy_:function(E,G,N,Y,ra){void 0===Y&&(Y=0);void 0===ra&&(ra=v.Reduction.SUM_BY_NONZERO_WEIGHTS);E=La(E,"onehotLabels","softmaxCrossEntropy");var Ha=La(G,"logits","softmaxCrossEntropy");
G=null;null!=N&&(G=La(N,"weights","softmaxCrossEntropy"));g(E.shape,Ha.shape,"Error in softmaxCrossEntropy: ");if(0<Y){N=Qc(Y);Y=Qc(1);var ob=Qc(E.shape[1]);E=vf(se(E,Zb(Y,N)),xf(N,ob))}E=db(E,Ha);return Th(E,G,ra)}}),Jj={fft:Oi,ifft:$i,rfft:aj,irfft:Ri},Ui={hammingWindow:ej,hannWindow:zi,frame:Zh,stft:Si},vj={flipLeftRight:Gj,resizeNearestNeighbor:ci,resizeBilinear:wh,rotateWithOffset:sj,cropAndResize:si,nonMaxSuppression:ti,nonMaxSuppressionAsync:function(E,G,N,Y,ra){void 0===Y&&(Y=.5);void 0===
ra&&(ra=Number.NEGATIVE_INFINITY);return r(this,void 0,void 0,function(){var Ha,ob,qb,Eb,hc,Fc,Oc;return u(this,function(td){switch(td.label){case 0:return Ha=La(E,"boxes","nonMaxSuppressionAsync"),ob=La(G,"scores","nonMaxSuppressionAsync"),qb=Gf(Ha,ob,N,Y,ra),N=qb.maxOutputSize,Y=qb.iouThreshold,ra=qb.scoreThreshold,[4,Promise.all([Ha.data(),ob.data()])];case 1:return Eb=td.sent(),hc=Eb[0],Fc=Eb[1],Oc=$e(hc,Fc,N,Y,ra),Ha!==E&&Ha.dispose(),ob!==G&&ob.dispose(),[2,Oc]}})})},nonMaxSuppressionWithScore:bi,
nonMaxSuppressionWithScoreAsync:function(E,G,N,Y,ra,Ha){void 0===Y&&(Y=.5);void 0===ra&&(ra=Number.NEGATIVE_INFINITY);void 0===Ha&&(Ha=0);return r(this,void 0,void 0,function(){var ob,qb,Eb,hc,Fc,Oc,td;return u(this,function(be){switch(be.label){case 0:return ob=La(E,"boxes","nonMaxSuppressionAsync"),qb=La(G,"scores","nonMaxSuppressionAsync"),Eb=Gf(ob,qb,N,Y,ra,Ha),N=Eb.maxOutputSize,Y=Eb.iouThreshold,ra=Eb.scoreThreshold,Ha=Eb.softNmsSigma,[4,Promise.all([ob.data(),qb.data()])];case 1:return hc=
be.sent(),Fc=hc[0],Oc=hc[1],td=eb(Fc,Oc,N,Y,ra,Ha),ob!==E&&ob.dispose(),qb!==G&&qb.dispose(),[2,td]}})})},nonMaxSuppressionPadded:mh,nonMaxSuppressionPaddedAsync:function(E,G,N,Y,ra,Ha){void 0===Y&&(Y=.5);void 0===ra&&(ra=Number.NEGATIVE_INFINITY);void 0===Ha&&(Ha=!1);return r(this,void 0,void 0,function(){var ob,qb,Eb,hc,Fc,Oc,td,be,Fe,fe;return u(this,function(Be){switch(Be.label){case 0:return ob=La(E,"boxes","nonMaxSuppressionAsync"),qb=La(G,"scores","nonMaxSuppressionAsync"),Eb=Gf(ob,qb,N,Y,
ra,null),hc=Eb.maxOutputSize,Fc=Eb.iouThreshold,Oc=Eb.scoreThreshold,[4,Promise.all([ob.data(),qb.data()])];case 1:return td=Be.sent(),be=td[0],Fe=td[1],fe=va(be,Fe,hc,Fc,Oc,Ha),ob!==E&&ob.dispose(),qb!==G&&qb.dispose(),[2,fe]}})})}},bk={bandPart:uj,gramSchmidt:ki,qr:Uj},$h={absoluteDifference:tj,computeWeightedLoss:Th,cosineDistance:Xj,hingeLoss:Qj,huberLoss:zj,logLoss:Tj,meanSquaredError:Ti,sigmoidCrossEntropy:Hj,softmaxCrossEntropy:Ij},Na=function(E){function G(){return null!==E&&E.apply(this,
arguments)||this}t(G,E);G.prototype.minimize=function(N,Y,ra){void 0===Y&&(Y=!1);var Ha=this.computeGradients(N,ra);N=Ha.value;var ob=Ha.grads;null!=ra?(ra=ra.map(function(qb){return{name:qb.name,tensor:ob[qb.name]}}),this.applyGradients(ra)):this.applyGradients(ob);mc(ob);if(Y)return N;N.dispose();return null};Object.defineProperty(G.prototype,"iterations",{get:function(){null==this.iterations_&&(this.iterations_=0);return this.iterations_},enumerable:!0,configurable:!0});G.prototype.incrementIterations=
function(){this.iterations_=this.iterations+1};G.prototype.computeGradients=function(N,Y){return ud(N,Y)};G.prototype.dispose=function(){null!=this.iterations_&&mc(this.iterations_)};G.prototype.saveIterations=function(){return r(this,void 0,void 0,function(){return u(this,function(N){null==this.iterations_&&(this.iterations_=0);return[2,{name:"iter",tensor:Qc(this.iterations_,"int32")}]})})};G.prototype.getWeights=function(){return r(this,void 0,void 0,function(){return u(this,function(N){throw Error("getWeights() is not implemented for this optimizer yet.");
})})};G.prototype.setWeights=function(N){return r(this,void 0,void 0,function(){return u(this,function(Y){throw Error("setWeights() is not implemented for this optimizer class "+this.getClassName());})})};G.prototype.extractIterations=function(N){return r(this,void 0,void 0,function(){var Y;return u(this,function(ra){switch(ra.label){case 0:return Y=this,[4,N[0].tensor.data()];case 1:return Y.iterations_=ra.sent()[0],[2,N.slice(1)]}})})};return G}(Pg);Object.defineProperty(Na,Symbol.hasInstance,{value:function(E){return null!=
E.minimize&&null!=E.computeGradients&&null!=E.applyGradients}});var sb=function(E){function G(N,Y,ra){void 0===ra&&(ra=null);var Ha=E.call(this)||this;Ha.learningRate=N;Ha.rho=Y;Ha.epsilon=ra;Ha.accumulatedGrads=[];Ha.accumulatedUpdates=[];null==ra&&(Ha.epsilon=Ic.backend.epsilon());return Ha}t(G,E);G.prototype.applyGradients=function(N){var Y=this;(Array.isArray(N)?N.map(function(ra){return ra.name}):Object.keys(N)).forEach(function(ra,Ha){var ob=Ic.registeredVariables[ra];null==Y.accumulatedGrads[Ha]&&
(Y.accumulatedGrads[Ha]={originalName:ra+"/accum_grad",variable:Rb(function(){return Ef(ob).variable(!1)})});null==Y.accumulatedUpdates[Ha]&&(Y.accumulatedUpdates[Ha]={originalName:ra+"/accum_var",variable:Rb(function(){return Ef(ob).variable(!1)})});var qb=Array.isArray(N)?N[Ha].tensor:N[ra];if(null!=qb){var Eb=Y.accumulatedGrads[Ha].variable,hc=Y.accumulatedUpdates[Ha].variable;Rb(function(){var Fc=vf(se(Eb,Y.rho),se(Bf(qb),1-Y.rho)),Oc=se(xf(Bh(vf(hc,Y.epsilon)),Bh(vf(Eb,Y.epsilon))),qb),td=vf(se(hc,
Y.rho),se(Bf(Oc),1-Y.rho));Eb.assign(Fc);hc.assign(td);Fc=vf(se(Oc,-Y.learningRate),ob);ob.assign(Fc)})}});this.incrementIterations()};G.prototype.dispose=function(){null!=this.accumulatedUpdates&&(mc(this.accumulatedGrads.map(function(N){return N.variable})),mc(this.accumulatedUpdates.map(function(N){return N.variable})))};G.prototype.getWeights=function(){return r(this,void 0,void 0,function(){var N;return u(this,function(Y){switch(Y.label){case 0:return N=this.accumulatedGrads.concat(this.accumulatedUpdates),
[4,this.saveIterations()];case 1:return[2,[Y.sent()].concat(N.map(function(ra){return{name:ra.originalName,tensor:ra.variable}}))]}})})};G.prototype.setWeights=function(N){return r(this,void 0,void 0,function(){var Y;return u(this,function(ra){switch(ra.label){case 0:return[4,this.extractIterations(N)];case 1:return N=ra.sent(),Y=N.length/2,this.accumulatedGrads=N.slice(0,Y).map(function(Ha){return{originalName:Ha.name,variable:Ha.tensor.variable(!1)}}),this.accumulatedUpdates=N.slice(Y,2*Y).map(function(Ha){return{originalName:Ha.name,
variable:Ha.tensor.variable(!1)}}),[2]}})})};G.prototype.getConfig=function(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}};G.fromConfig=function(N,Y){return new N(Y.learningRate,Y.rho,Y.epsilon)};G.className="Adadelta";return G}(Na);rc(sb);var Oa=function(E){function G(N,Y){void 0===Y&&(Y=.1);var ra=E.call(this)||this;ra.learningRate=N;ra.initialAccumulatorValue=Y;ra.accumulatedGrads=[];return ra}t(G,E);G.prototype.applyGradients=function(N){var Y=this;(Array.isArray(N)?
N.map(function(ra){return ra.name}):Object.keys(N)).forEach(function(ra,Ha){var ob=Ic.registeredVariables[ra];null==Y.accumulatedGrads[Ha]&&(Y.accumulatedGrads[Ha]={originalName:ra+"/accumulator",variable:Rb(function(){return dc(ob.shape,Y.initialAccumulatorValue).variable(!1)})});var qb=Array.isArray(N)?N[Ha].tensor:N[ra];if(null!=qb){var Eb=Y.accumulatedGrads[Ha].variable;Rb(function(){var hc=vf(Eb,Bf(qb));Eb.assign(hc);hc=vf(se(xf(qb,Bh(vf(hc,Ic.backend.epsilon()))),-Y.learningRate),ob);ob.assign(hc)})}});
this.incrementIterations()};G.prototype.dispose=function(){null!=this.accumulatedGrads&&mc(this.accumulatedGrads.map(function(N){return N.variable}))};G.prototype.getWeights=function(){return r(this,void 0,void 0,function(){return u(this,function(N){switch(N.label){case 0:return[4,this.saveIterations()];case 1:return[2,[N.sent()].concat(this.accumulatedGrads.map(function(Y){return{name:Y.originalName,tensor:Y.variable}}))]}})})};G.prototype.setWeights=function(N){return r(this,void 0,void 0,function(){return u(this,
function(Y){switch(Y.label){case 0:return[4,this.extractIterations(N)];case 1:return N=Y.sent(),this.accumulatedGrads=N.map(function(ra){return{originalName:ra.name,variable:ra.tensor.variable(!1)}}),[2]}})})};G.prototype.getConfig=function(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}};G.fromConfig=function(N,Y){return new N(Y.learningRate,Y.initialAccumulatorValue)};G.className="Adagrad";return G}(Na);rc(Oa);var xb=function(E){function G(N,Y,ra,Ha){void 0===
Ha&&(Ha=null);var ob=E.call(this)||this;ob.learningRate=N;ob.beta1=Y;ob.beta2=ra;ob.epsilon=Ha;ob.accumulatedFirstMoment=[];ob.accumulatedSecondMoment=[];Rb(function(){ob.accBeta1=Qc(Y).variable();ob.accBeta2=Qc(ra).variable()});null==Ha&&(ob.epsilon=Ic.backend.epsilon());return ob}t(G,E);G.prototype.applyGradients=function(N){var Y=this,ra=Array.isArray(N)?N.map(function(Ha){return Ha.name}):Object.keys(N);Rb(function(){var Ha=Zb(1,Y.accBeta1),ob=Zb(1,Y.accBeta2);ra.forEach(function(qb,Eb){var hc=
Ic.registeredVariables[qb];null==Y.accumulatedFirstMoment[Eb]&&(Y.accumulatedFirstMoment[Eb]={originalName:qb+"/m",variable:Rb(function(){return Ef(hc).variable(!1)})});null==Y.accumulatedSecondMoment[Eb]&&(Y.accumulatedSecondMoment[Eb]={originalName:qb+"/v",variable:Rb(function(){return Ef(hc).variable(!1)})});var Fc=Array.isArray(N)?N[Eb].tensor:N[qb];if(null!=Fc){qb=Y.accumulatedFirstMoment[Eb].variable;Eb=Y.accumulatedSecondMoment[Eb].variable;var Oc=vf(se(qb,Y.beta1),se(Fc,1-Y.beta1));Fc=vf(se(Eb,
Y.beta2),se(Bf(Fc),1-Y.beta2));var td=xf(Oc,Ha),be=xf(Fc,ob);qb.assign(Oc);Eb.assign(Fc);qb=vf(se(xf(td,vf(Bh(be),Y.epsilon)),-Y.learningRate),hc);hc.assign(qb)}});Y.accBeta1.assign(se(Y.accBeta1,Y.beta1));Y.accBeta2.assign(se(Y.accBeta2,Y.beta2))});this.incrementIterations()};G.prototype.dispose=function(){this.accBeta1.dispose();this.accBeta2.dispose();null!=this.accumulatedFirstMoment&&mc(this.accumulatedFirstMoment.map(function(N){return N.variable}));null!=this.accumulatedSecondMoment&&mc(this.accumulatedSecondMoment.map(function(N){return N.variable}))};
G.prototype.getWeights=function(){return r(this,void 0,void 0,function(){var N;return u(this,function(Y){switch(Y.label){case 0:return N=this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment),[4,this.saveIterations()];case 1:return[2,[Y.sent()].concat(N.map(function(ra){return{name:ra.originalName,tensor:ra.variable}}))]}})})};G.prototype.setWeights=function(N){return r(this,void 0,void 0,function(){var Y,ra=this;return u(this,function(Ha){switch(Ha.label){case 0:return[4,this.extractIterations(N)];
case 1:return N=Ha.sent(),Rb(function(){ra.accBeta1.assign(ph(ra.beta1,ra.iterations_+1));ra.accBeta2.assign(ph(ra.beta2,ra.iterations_+1))}),Y=N.length/2,this.accumulatedFirstMoment=N.slice(0,Y).map(function(ob){return{originalName:ob.name,variable:ob.tensor.variable(!1)}}),this.accumulatedSecondMoment=N.slice(Y,2*Y).map(function(ob){return{originalName:ob.name,variable:ob.tensor.variable(!1)}}),[2]}})})};G.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,
epsilon:this.epsilon}};G.fromConfig=function(N,Y){return new N(Y.learningRate,Y.beta1,Y.beta2,Y.epsilon)};G.className="Adam";return G}(Na);rc(xb);var bc=function(E){function G(N,Y,ra,Ha,ob){void 0===Ha&&(Ha=null);void 0===ob&&(ob=0);var qb=E.call(this)||this;qb.learningRate=N;qb.beta1=Y;qb.beta2=ra;qb.epsilon=Ha;qb.decay=ob;qb.accumulatedFirstMoment=[];qb.accumulatedWeightedInfNorm=[];Rb(function(){qb.iteration=Qc(0).variable();qb.accBeta1=Qc(Y).variable()});null==Ha&&(qb.epsilon=Ic.backend.epsilon());
return qb}t(G,E);G.prototype.applyGradients=function(N){var Y=this,ra=Array.isArray(N)?N.map(function(Ha){return Ha.name}):Object.keys(N);Rb(function(){var Ha=Zb(1,Y.accBeta1),ob=xf(-Y.learningRate,vf(se(Y.iteration,Y.decay),1));ra.forEach(function(qb,Eb){var hc=Ic.registeredVariables[qb];null==Y.accumulatedFirstMoment[Eb]&&(Y.accumulatedFirstMoment[Eb]={originalName:qb+"/m",variable:Ef(hc).variable(!1)});null==Y.accumulatedWeightedInfNorm[Eb]&&(Y.accumulatedWeightedInfNorm[Eb]={originalName:qb+"/v",
variable:Ef(hc).variable(!1)});var Fc=Array.isArray(N)?N[Eb].tensor:N[qb];if(null!=Fc){qb=Y.accumulatedFirstMoment[Eb].variable;Eb=Y.accumulatedWeightedInfNorm[Eb].variable;var Oc=vf(se(qb,Y.beta1),se(Fc,1-Y.beta1)),td=se(Eb,Y.beta2);Fc=sg(Fc);Fc=Ah(td,Fc);qb.assign(Oc);Eb.assign(Fc);qb=vf(se(xf(ob,Ha),xf(Oc,vf(Fc,Y.epsilon))),hc);hc.assign(qb)}});Y.iteration.assign(vf(Y.iteration,1));Y.accBeta1.assign(se(Y.accBeta1,Y.beta1))});this.incrementIterations()};G.prototype.dispose=function(){this.accBeta1.dispose();
this.iteration.dispose();null!=this.accumulatedFirstMoment&&mc(this.accumulatedFirstMoment.map(function(N){return N.variable}));null!=this.accumulatedWeightedInfNorm&&mc(this.accumulatedWeightedInfNorm.map(function(N){return N.variable}))};G.prototype.getWeights=function(){return r(this,void 0,void 0,function(){return u(this,function(N){throw Error("getWeights() is not implemented for Adamax yet.");})})};G.prototype.setWeights=function(N){return r(this,void 0,void 0,function(){return u(this,function(Y){throw Error("setWeights() is not implemented for Adamax yet.");
})})};G.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}};G.fromConfig=function(N,Y){return new N(Y.learningRate,Y.beta1,Y.beta2,Y.epsilon,Y.decay)};G.className="Adamax";return G}(Na);rc(bc);var Jc=function(E){function G(N){var Y=E.call(this)||this;Y.learningRate=N;Y.setLearningRate(N);return Y}t(G,E);G.prototype.applyGradients=function(N){var Y=this;(Array.isArray(N)?N.map(function(ra){return ra.name}):Object.keys(N)).forEach(function(ra,
Ha){var ob=Array.isArray(N)?N[Ha].tensor:N[ra];if(null!=ob){var qb=Ic.registeredVariables[ra];Rb(function(){var Eb=vf(se(Y.c,ob),qb);qb.assign(Eb)})}});this.incrementIterations()};G.prototype.setLearningRate=function(N){this.learningRate=N;null!=this.c&&this.c.dispose();this.c=Ub(Qc(-N))};G.prototype.dispose=function(){this.c.dispose()};G.prototype.getWeights=function(){return r(this,void 0,void 0,function(){return u(this,function(N){switch(N.label){case 0:return[4,this.saveIterations()];case 1:return[2,
[N.sent()]]}})})};G.prototype.setWeights=function(N){return r(this,void 0,void 0,function(){return u(this,function(Y){switch(Y.label){case 0:return[4,this.extractIterations(N)];case 1:N=Y.sent();if(0!==N.length)throw Error("SGD optimizer does not have settable weights.");return[2]}})})};G.prototype.getConfig=function(){return{learningRate:this.learningRate}};G.fromConfig=function(N,Y){return new N(Y.learningRate)};G.className="SGD";return G}(Na);rc(Jc);var qd=function(E){function G(N,Y,ra){void 0===
ra&&(ra=!1);var Ha=E.call(this,N)||this;Ha.learningRate=N;Ha.momentum=Y;Ha.useNesterov=ra;Ha.accumulations=[];Ha.m=Qc(Ha.momentum);return Ha}t(G,E);G.prototype.applyGradients=function(N){var Y=this;(Array.isArray(N)?N.map(function(ra){return ra.name}):Object.keys(N)).forEach(function(ra,Ha){var ob=Ic.registeredVariables[ra];null==Y.accumulations[Ha]&&(Y.accumulations[Ha]={originalName:ra+"/momentum",variable:Rb(function(){return Ef(ob).variable(!1)})});var qb=Y.accumulations[Ha].variable,Eb=Array.isArray(N)?
N[Ha].tensor:N[ra];null!=Eb&&Rb(function(){var hc=vf(se(Y.m,qb),Eb);var Fc=Y.useNesterov?vf(se(Y.c,vf(Eb,se(hc,Y.m))),ob):vf(se(Y.c,hc),ob);qb.assign(hc);ob.assign(Fc)})});this.incrementIterations()};G.prototype.dispose=function(){this.m.dispose();null!=this.accumulations&&mc(this.accumulations.map(function(N){return N.variable}))};G.prototype.setMomentum=function(N){this.momentum=N};G.prototype.getWeights=function(){return r(this,void 0,void 0,function(){return u(this,function(N){switch(N.label){case 0:return[4,
this.saveIterations()];case 1:return[2,[N.sent()].concat(this.accumulations.map(function(Y){return{name:Y.originalName,tensor:Y.variable}}))]}})})};G.prototype.setWeights=function(N){return r(this,void 0,void 0,function(){return u(this,function(Y){switch(Y.label){case 0:return[4,this.extractIterations(N)];case 1:return N=Y.sent(),this.accumulations=N.map(function(ra){return{originalName:ra.name,variable:ra.tensor.variable(!1)}}),[2]}})})};G.prototype.getConfig=function(){return{learningRate:this.learningRate,
momentum:this.momentum,useNesterov:this.useNesterov}};G.fromConfig=function(N,Y){return new N(Y.learningRate,Y.momentum,Y.useNesterov)};G.className="Momentum";return G}(Jc);rc(qd);var Id=function(E){function G(N,Y,ra,Ha,ob){void 0===Y&&(Y=.9);void 0===ra&&(ra=0);void 0===Ha&&(Ha=null);void 0===ob&&(ob=!1);var qb=E.call(this)||this;qb.learningRate=N;qb.decay=Y;qb.momentum=ra;qb.epsilon=Ha;qb.accumulatedMeanSquares=[];qb.accumulatedMoments=[];qb.accumulatedMeanGrads=[];qb.centered=ob;null==Ha&&(qb.epsilon=
Ic.backend.epsilon());if(null==N)throw Error("learningRate for RMSPropOptimizer must be defined.");return qb}t(G,E);G.prototype.applyGradients=function(N){var Y=this;(Array.isArray(N)?N.map(function(ra){return ra.name}):Object.keys(N)).forEach(function(ra,Ha){var ob=Ic.registeredVariables[ra];null==Y.accumulatedMeanSquares[Ha]&&(Y.accumulatedMeanSquares[Ha]={originalName:ra+"/rms",variable:Rb(function(){return Ef(ob).variable(!1)})});null==Y.accumulatedMoments[Ha]&&(Y.accumulatedMoments[Ha]={originalName:ra+
"/momentum",variable:Rb(function(){return Ef(ob).variable(!1)})});null==Y.accumulatedMeanGrads[Ha]&&Y.centered&&(Y.accumulatedMeanGrads[Ha]={originalName:ra+"/mg",variable:Rb(function(){return Ef(ob).variable(!1)})});var qb=Array.isArray(N)?N[Ha].tensor:N[ra];if(null!=qb){var Eb=Y.accumulatedMeanSquares[Ha].variable,hc=Y.accumulatedMoments[Ha].variable;Rb(function(){var Fc=vf(se(Eb,Y.decay),se(Bf(qb),1-Y.decay));if(Y.centered){var Oc=Y.accumulatedMeanGrads[Ha].variable,td=vf(se(Oc,Y.decay),se(qb,
1-Y.decay)),be=xf(se(qb,Y.learningRate),Bh(Zb(Fc,vf(Bf(td),Y.epsilon))));be=vf(se(hc,Y.momentum),be);Eb.assign(Fc);Oc.assign(td);hc.assign(be);Fc=Zb(ob,be)}else Fc=vf(se(Eb,Y.decay),se(Bf(qb),1-Y.decay)),be=vf(se(hc,Y.momentum),xf(se(qb,Y.learningRate),Bh(vf(Fc,Y.epsilon)))),Eb.assign(Fc),hc.assign(be),Fc=Zb(ob,be);ob.assign(Fc)})}});this.incrementIterations()};G.prototype.dispose=function(){null!=this.accumulatedMeanSquares&&mc(this.accumulatedMeanSquares.map(function(N){return N.variable}));null!=
this.accumulatedMeanGrads&&this.centered&&mc(this.accumulatedMeanGrads.map(function(N){return N.variable}));null!=this.accumulatedMoments&&mc(this.accumulatedMoments.map(function(N){return N.variable}))};G.prototype.getWeights=function(){return r(this,void 0,void 0,function(){var N;return u(this,function(Y){switch(Y.label){case 0:return N=this.accumulatedMeanSquares.concat(this.accumulatedMoments),this.centered&&N.push.apply(N,this.accumulatedMeanGrads),[4,this.saveIterations()];case 1:return[2,[Y.sent()].concat(N.map(function(ra){return{name:ra.originalName,
tensor:ra.variable}}))]}})})};G.prototype.setWeights=function(N){return r(this,void 0,void 0,function(){var Y;return u(this,function(ra){switch(ra.label){case 0:return[4,this.extractIterations(N)];case 1:return N=ra.sent(),Y=this.centered?N.length/3:N.length/2,this.accumulatedMeanSquares=N.slice(0,Y).map(function(Ha){return{originalName:Ha.name,variable:Ha.tensor.variable(!1)}}),this.accumulatedMoments=N.slice(Y,2*Y).map(function(Ha){return{originalName:Ha.name,variable:Ha.tensor.variable(!1)}}),
this.centered&&(this.accumulatedMeanGrads=N.slice(2*Y,3*Y).map(function(Ha){return{originalName:Ha.name,variable:Ha.tensor.variable(!1)}})),[2]}})})};G.prototype.getConfig=function(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}};G.fromConfig=function(N,Y){return new N(Y.learningRate,Y.decay,Y.momentum,Y.epsilon,Y.centered)};G.className="RMSProp";return G}(Na);rc(Id);for(var ee=function(){function E(){}E.sgd=function(G){return new Jc(G)};
E.momentum=function(G,N,Y){void 0===Y&&(Y=!1);return new qd(G,N,Y)};E.rmsprop=function(G,N,Y,ra,Ha){void 0===N&&(N=.9);void 0===Y&&(Y=0);void 0===ra&&(ra=null);void 0===Ha&&(Ha=!1);return new Id(G,N,Y,ra,Ha)};E.adam=function(G,N,Y,ra){void 0===G&&(G=.001);void 0===N&&(N=.9);void 0===Y&&(Y=.999);void 0===ra&&(ra=null);return new xb(G,N,Y,ra)};E.adadelta=function(G,N,Y){void 0===G&&(G=.001);void 0===N&&(N=.95);void 0===Y&&(Y=null);return new sb(G,N,Y)};E.adamax=function(G,N,Y,ra,Ha){void 0===G&&(G=
.002);void 0===N&&(N=.9);void 0===Y&&(Y=.999);void 0===ra&&(ra=null);void 0===Ha&&(Ha=0);return new bc(G,N,Y,ra,Ha)};E.adagrad=function(G,N){void 0===N&&(N=.1);return new Oa(G,N)};return E}(),Ke={sgd:ee.sgd,momentum:ee.momentum,adadelta:ee.adadelta,adagrad:ee.adagrad,rmsprop:ee.rmsprop,adamax:ee.adamax,adam:ee.adam},Pe=function(){return"undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:function(E){return E()}}(),lf={__proto__:null,slice_util:Kg,
segment_util:Jg,castTensor:function(E,G,N){if("complex64"===G){if("complex64"===E.dtype)return E.clone();G=sd(E.shape);E=Uc(E,"float32");N=N.complex(E,G);G.dispose();E.dispose();return N}if(!K(E.dtype,G))return Ic.makeTensorFromDataId(E.dataId,E.shape,G);if("complex64"===E.dtype)return E=N.real(E),N=Uc(E,G),E.dispose(),N;if("int32"===G)return N.int(E);if("bool"===G)return G=Qc(0,E.dtype),N=N.notEqual(E,G),G.dispose(),N;throw Error("Error in Cast: failed to cast "+E.dtype+" to "+G);},reshapeTensor:function(E,
G){return Ic.makeTensorFromDataId(E.dataId,G,E.dtype)},linspaceImpl:function(E,G,N){G=(G-E)/(N-1);N=aa(N,"float32");N[0]=E;for(E=1;E<N.length;E++)N[E]=N[E-1]+G;return We(N,"float32")},upcastType:ha,axesAreInnerMostDims:ic,combineLocations:jc,computeOutAndReduceShapes:Ob,expandShapeToKeepDim:fc,assertAxesAreInnerMostDims:function(E,G,N){e(ic(G,N),function(){return E+" supports only inner-most axes for now. Got axes "+(G+" and rank-"+N+" input.")})},getAxesPermutation:yc,getUndoAxesPermutation:fd,getInnerMostAxes:Ad,
getBroadcastDims:function(E,G){for(var N=E.length,Y=[],ra=0;ra<N;ra++){var Ha=N-1-ra,ob=E[Ha]||1;1<(G[G.length-1-ra]||1)&&1===ob&&Y.unshift(Ha)}return Y},getReductionAxes:nb,assertAndGetBroadcastShape:Db,assertParamsConsistent:cf,computeOutShape:qe,computeDilation2DInfo:function(E,G,N,Y,ra,Ha){void 0===ra&&(ra="NHWC");G=G.concat([E[3]]);ra=bf(ra);return Re(E,G,N,Ha,Y,null,null,ra)},computePool2DInfo:Gd,computePool3DInfo:Ge,computeConv2DInfo:Re,computeConv3DInfo:mf,computeDefaultPad:wb,tupleValuesAreOne:ge,
eitherStridesOrDilationsAreOne:he,convertConv2DDataFormat:bf,getFusedDyActivation:sf,getFusedBiasGradient:Cf,applyActivation:gf,shouldFuse:di,PARALLELIZE_THRESHOLD:30,computeOptimalWindowSize:function(E){return 30>=E?E:H(E,Math.floor(Math.sqrt(E)))},getImageCenter:function(E,G,N){return[N*("number"===typeof E?E:E[0]),G*("number"===typeof E?E:E[1])]},getReshaped:function(E,G,N,Y){void 0===Y&&(Y=!0);var ra=[];if(Y)ra=ra.concat(G.slice(0)),ra.push(E[0]/N),ra=ra.concat(E.slice(1));else{ra=ra.concat(E[0]);
N=G.length;for(Y=0;Y<N;++Y)ra=ra.concat([E[Y+1]/G[Y],G[Y]]);ra=ra.concat(E.slice(N+1))}return ra},getPermuted:function(E,G,N){void 0===N&&(N=!0);var Y=[];if(N)for(Y.push(G),N=G+1;N<E;++N)N<=2*G?(Y.push(N),Y.push(N-(G+1))):Y.push(N);else{var ra=[],Ha=[];for(N=1;N<E;++N)N>=2*G+1||1===N%2?Ha.push(N):ra.push(N);Y.push.apply(Y,ra);Y.push(0);Y.push.apply(Y,Ha)}return Y},getReshapedPermuted:function(E,G,N,Y){void 0===Y&&(Y=!0);var ra=[];Y?ra.push(E[0]/N):ra.push(E[0]*N);for(N=1;N<E.length;++N)N<=G.length?
Y?ra.push(G[N-1]*E[N]):ra.push(E[N]/G[N-1]):ra.push(E[N]);return ra},getSliceBeginCoords:function(E,G){for(var N=[0],Y=0;Y<G;++Y)N.push(E[Y][0]);return N},getSliceSize:function(E,G,N){for(var Y=E.slice(0,1),ra=0;ra<N;++ra)Y.push(E[ra+1]-G[ra][0]-G[ra][1]);return Y},prepareAndValidate:gd,validateUpdateShape:Dd,validateInput:Jd,calculateShapes:we,SELU_SCALEALPHA:1.7580993408473768,SELU_SCALE:1.0507009873554805,ERF_P:.3275911,ERF_A1:.254829592,ERF_A2:-.284496736,ERF_A3:1.421413741,ERF_A4:-1.453152027,
ERF_A5:1.061405429,warn:function(){for(var E=[],G=0;G<arguments.length;G++)E[G]=arguments[G];pa().getBool("IS_TEST")||console.warn.apply(console,E)},log:function(){for(var E=[],G=0;G<arguments.length;G++)E[G]=arguments[G];pa().getBool("IS_TEST")||console.log.apply(console,E)},mergeRealAndImagArrays:function(E,G){if(E.length!==G.length)throw Error("Cannot merge real and imag arrays of different lengths. real:"+(E.length+", imag: "+G.length+"."));for(var N=new Float32Array(2*E.length),Y=0;Y<N.length;Y+=
2)N[Y]=E[Y/2],N[Y+1]=G[Y/2];return N},splitRealAndImagArrays:function(E){for(var G=new Float32Array(E.length/2),N=new Float32Array(E.length/2),Y=0;Y<E.length;Y+=2)G[Y/2]=E[Y],N[Y/2]=E[Y+1];return{real:G,imag:N}},complexWithEvenIndex:function(E){var G=Math.ceil(E.length/4),N=new Float32Array(G);G=new Float32Array(G);for(var Y=0;Y<E.length;Y+=4)N[Math.floor(Y/4)]=E[Y],G[Math.floor(Y/4)]=E[Y+1];return{real:N,imag:G}},complexWithOddIndex:function(E){var G=Math.floor(E.length/4),N=new Float32Array(G);
G=new Float32Array(G);for(var Y=2;Y<E.length;Y+=4)N[Math.floor(Y/4)]=E[Y],G[Math.floor(Y/4)]=E[Y+1];return{real:N,imag:G}},getComplexWithIndex:function(E,G){return{real:E[2*G],imag:E[2*G+1]}},assignToTypedArray:function(E,G,N,Y){E[2*Y]=G;E[2*Y+1]=N},exponents:function(E,G){for(var N=new Float32Array(E/2),Y=new Float32Array(E/2),ra=0;ra<Math.ceil(E/2);ra++){var Ha=ra/E*Math.PI*(G?2:-2);N[ra]=Math.cos(Ha);Y[ra]=Math.sin(Ha)}return{real:N,imag:Y}},exponent:function(E,G,N){E=E/G*Math.PI*(N?2:-2);return{real:Math.cos(E),
imag:Math.sin(E)}},prepareSplitSize:bg},Xf={__proto__:null,nonMaxSuppressionV3Impl:$e,nonMaxSuppressionV4Impl:va,nonMaxSuppressionV5Impl:eb,split:function(E,G,N){var Y=Array(E.rank).fill(0),ra=E.shape.slice();return G.map(function(Ha){var ob=ra.slice();ob[N]=Ha;ob=Qb(E,Y,ob);Y[N]+=Ha;return ob})},tile:function(E,G){for(var N=Array(E.rank),Y=0;Y<N.length;Y++)N[Y]=E.shape[Y]*G[Y];G=kd(N,E.dtype);for(Y=0;Y<G.values.length;++Y){N=G.indexToLoc(Y);for(var ra=Array(E.rank),Ha=0;Ha<ra.length;Ha++)ra[Ha]=
N[Ha]%E.shape[Ha];N=E.locToIndex(ra);G.values[Y]=E.values[N]}return G.toTensor()},topkImpl:function(E,G,N,Y,ra){ra=G[G.length-1];var Ha=[E.length/ra,ra];ra=Ha[0];var ob=Ha[1];Ha=w(N,ra*Y);for(var qb=w("int32",ra*Y),Eb=0;Eb<ra;Eb++){var hc=Eb*ob,Fc=E.subarray(hc,hc+ob);hc=[];for(var Oc=0;Oc<Fc.length;Oc++)hc.push({value:Fc[Oc],index:Oc});hc.sort(function(be,Fe){return Fe.value-be.value});Oc=Eb*Y;Fc=Ha.subarray(Oc,Oc+Y);var td=qb.subarray(Oc,Oc+Y);for(Oc=0;Oc<Y;Oc++)Fc[Oc]=hc[Oc].value,td[Oc]=hc[Oc].index}E=
G.slice();E[E.length-1]=Y;return[Mc(Ha,E,N),Mc(qb,E,"int32")]},whereImpl:Wf},Le=vb({avgPool3dBackprop_:function(E,G,N,Y,ra,Ha,ob){void 0===ra&&(ra=[1,1,1]);E=La(E,"dy","avgPool3dBackprop");var qb=La(G,"input","avgPool3dBackprop"),Eb=E,hc=qb;G=!1;4===qb.rank&&(G=!0,Eb=zd(E,[1,E.shape[0],E.shape[1],E.shape[2],E.shape[3]]),hc=zd(qb,[1,qb.shape[0],qb.shape[1],qb.shape[2],qb.shape[3]]));e(5===Eb.rank,function(){return"Error in avgPool3dBackprop: dy must be rank 5 but got rank "+(Eb.rank+".")});e(5===hc.rank,
function(){return"Error in avgPool3dBackprop: input must be rank 5 but got rank "+(hc.rank+".")});e(he(Y,ra),function(){return"Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides "+(Y+" and dilations '"+ra+"'")});null!=ob&&e(m(Ha),function(){return"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode "+(ob+" but got pad "+Ha+".")});E=Ic.runKernelFunc(function(Fc){var Oc=Ge(hc.shape,N,Y,ra,Ha,ob);return Fc.avgPool3dBackprop(Eb,hc,Oc)},{dy:Eb,input:hc},
null,"AvgPool3DBackprop",{filterSize:N,strides:Y,dilations:ra,pad:Ha,dimRoundingMode:ob});return G?zd(E,[E.shape[1],E.shape[2],E.shape[3],E.shape[4]]):E}}),qf=vb({avgPoolBackprop_:function(E,G,N,Y,ra){var Ha=La(E,"dy","avgPoolBackprop"),ob=La(G,"input","avgPoolBackprop");e(ob.rank===Ha.rank,function(){return"Rank of input ("+ob.rank+") does not match rank of dy ("+Ha.rank+")"});var qb=ob,Eb=Ha;E=!1;3===ob.rank&&(E=!0,qb=zd(ob,[1,ob.shape[0],ob.shape[1],ob.shape[2]]),Eb=zd(Ha,[1,Ha.shape[0],Ha.shape[1],
Ha.shape[2]]));e(4===Eb.rank,function(){return"Error in avgPoolBackprop: dy must be rank 4 but got rank "+(Eb.rank+".")});e(4===qb.rank,function(){return"Error in avgPoolBackprop: input must be rank 4 but got rank "+(qb.rank+".")});G=Ic.runKernelFunc(function(hc){var Fc=Gd(qb.shape,N,Y,1,ra);return hc.avgPoolBackprop(Eb,qb,Fc)},{dy:Eb,input:qb},null,"AvgPoolBackprop",{filterSize:N,strides:Y,pad:ra});return E?zd(G,[G.shape[1],G.shape[2],G.shape[3]]):G}}),dg=vb({conv3DBackpropFilter_:function(E,G,N,
Y,ra){var Ha=E;4===E.rank&&(Ha=zd(E,[1,E.shape[0],E.shape[1],E.shape[2],E.shape[3]]));var ob=G;4===ob.rank&&(ob=zd(G,[1,G.shape[0],G.shape[1],G.shape[2],G.shape[3]]));e(5===Ha.rank,function(){return"Error in conv3dDerFilter: input must be rank 5, but got shape "+(Ha.shape+".")});e(5===ob.rank,function(){return"Error in conv3dDerFilter: dy must be rank 5, but got shape "+(ob.shape+".")});e(5===N.length,function(){return"Error in conv3dDerFilter: filterShape must be length 5, but got "+(N+".")});e(Ha.shape[4]===
N[3],function(){return"Error in conv3dDerFilter: depth of input "+Ha.shape[4]+") must match input depth in filter ("+(N[3]+".")});e(ob.shape[4]===N[4],function(){return"Error in conv3dDerFilter: depth of dy ("+ob.shape[4]+") must match output depth for filter ("+(N[4]+").")});return Ic.runKernelFunc(function(qb){var Eb=mf(Ha.shape,N,Y,1,ra);return qb.conv3dDerFilter(Ha,ob,Eb)},{x:Ha,dy:ob},null,"Conv3DBackpropFilterV2",{strides:Y,pad:ra,filterShape:N})}}),Jf=vb({localResponseNormalizationBackprop_:function(E,
G,N,Y,ra,Ha,ob){void 0===Y&&(Y=5);void 0===ra&&(ra=1);void 0===Ha&&(Ha=1);void 0===ob&&(ob=.5);return Ic.runKernelFunc(function(qb){return qb.LRNGrad(N,E,G,Y,ra,Ha,ob)},{x:E,y:G,dy:N},null,"LRNBackprop",{depthRadius:Y,bias:ra,alpha:Ha,beta:ob})}}),Vf={kernelName:"Max",inputsToSave:["x"],outputsToSave:[!0],gradFunc:function(E,G,N){var Y=G[0];G=G[1];N=p(N.reductionIndices,Y.shape);var ra=Vb(E,G,Y,N);return{x:function(){return ra.x()}}}},Of=vb({maxPool3dBackprop_:function(E,G,N,Y,ra,Ha,ob,qb){void 0===
Ha&&(Ha=[1,1,1]);E=La(E,"dy","maxPool3dBackprop");G=La(G,"input","maxPool3dBackprop");var Eb=La(N,"output","maxPool3dBackprop"),hc=E,Fc=G,Oc=Eb;N=!1;4===G.rank&&(N=!0,hc=zd(E,[1,E.shape[0],E.shape[1],E.shape[2],E.shape[3]]),Fc=zd(G,[1,G.shape[0],G.shape[1],G.shape[2],G.shape[3]]),Oc=zd(Eb,[1,Eb.shape[0],Eb.shape[1],Eb.shape[2],Eb.shape[3]]));e(5===hc.rank,function(){return"Error in maxPool3dBackprop: dy must be rank 5 but got rank "+(hc.rank+".")});e(5===Fc.rank,function(){return"Error in maxPool3dBackprop: input must be rank 5 but got rank "+
(Fc.rank+".")});e(5===Oc.rank,function(){return"Error in maxPool3dBackprop: output must be rank 5 but got rank "+(Oc.rank+".")});e(he(ra,Ha),function(){return"Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides "+(ra+" and dilations '"+Ha+"'")});null!=qb&&e(m(ob),function(){return"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode "+(qb+" but got pad "+ob+".")});E=Ic.runKernelFunc(function(td){var be=Ge(Fc.shape,Y,ra,Ha,ob,qb);return td.maxPool3dBackprop(hc,
Fc,Oc,be)},{dy:hc,input:Fc,output:Oc},null,"MaxPool3DBackprop",{filterSize:Y,strides:ra,dilations:Ha,pad:ob,dimRoundingMode:qb});return N?zd(E,[E.shape[1],E.shape[2],E.shape[3],E.shape[4]]):E}}),rf=vb({maxPoolBackprop_:function(E,G,N,Y,ra,Ha,ob){var qb=La(E,"dy","maxPoolBackprop"),Eb=La(G,"input","maxPoolBackprop"),hc=La(N,"output","maxPoolBackprop");e(Eb.rank===qb.rank,function(){return"Rank of input ("+Eb.rank+") does not match rank of dy ("+(qb.rank+")")});e(4===qb.rank,function(){return"Error in maxPoolBackprop: dy must be rank 4 but got rank "+
(qb.rank+".")});e(4===Eb.rank,function(){return"Error in maxPoolBackprop: input must be rank 4 but got rank "+(Eb.rank+".")});null!=ob&&e(m(Ha),function(){return"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode "+(ob+" but got pad "+Ha+".")});return Ic.runKernelFunc(function(Fc){var Oc=Gd(Eb.shape,Y,ra,1,Ha,ob);return Fc.maxPoolBackprop(qb,Eb,hc,Oc)},{dy:qb,input:Eb,output:hc},null,"MaxPoolBackprop",{filterSize:Y,strides:ra,pad:Ha,dimRoundingMode:ob})}}),yg={kernelName:"PadV2",
inputsToSave:["x"],gradFunc:function(E,G,N){var Y=G[0],ra=N.paddings.map(function(Ha){return Ha[0]});return{x:function(){return Qb(E,ra,Y.shape)}}}},xg={kernelName:"SpaceToBatchND",gradFunc:function(E,G,N){var Y=N.blockShape,ra=N.paddings;return{x:function(){return kc(E,Y,ra)}}}},Eg={kernelName:"SplitV",gradFunc:function(E,G,N){var Y=N.axis;return{x:function(){return Pa(E,Y)}}}},ah=0,Oh=[{kernelName:"Abs",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return se(E,ji(Uc(N,
"float32"),-1))}}}},{kernelName:"Acos",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){var Y=Bf(Uc(N,"float32"));Y=Bh(Zb(Qc(1),Y));return ca(xf(E,Y))}}}},{kernelName:"Acosh",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){var Y=Bh(Zb(Bf(Uc(N,"float32")),1));return xf(E,Y)}}}},{kernelName:"Add",inputsToSave:["a","b"],gradFunc:function(E,G){var N=G[0],Y=G[1],ra=Db(N.shape,Y.shape);return{a:function(){var Ha=E,ob=nb(N.shape,ra);0<ob.length&&(Ha=Yb(Ha,
ob));return zd(Ha,N.shape)},b:function(){var Ha=E,ob=nb(Y.shape,ra);0<ob.length&&(Ha=Yb(Ha,ob));return zd(Ha,Y.shape)}}}},{kernelName:"AddN",saveAllInputs:!0,gradFunc:function(E,G){var N={};G.forEach(function(Y,ra){N[ra]=function(){return E.clone()}});return N}},{kernelName:"ArgMax",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return Ef(N)}}}},{kernelName:"ArgMin",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return Ef(N)}}}},{kernelName:"Asin",
inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return xf(E,Bh(Zb(Qc(1),Bf(Uc(N,"float32")))))}}}},{kernelName:"Asinh",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){var Y=Bh(vf(Qc(1),Bf(Uc(N,"float32"))));return xf(E,Y)}}}},{kernelName:"Atan2",inputsToSave:["a","b"],gradFunc:function(E,G){var N=G[0],Y=G[1],ra=Db(N.shape,Y.shape);return{a:function(){var Ha=vf(Bf(N),Bf(Y));Ha=se(E,xf(Y,Ha));var ob=nb(N.shape,ra);0<ob.length&&(Ha=Yb(Ha,ob));return zd(Ha,
N.shape)},b:function(){var Ha=vf(Bf(N),Bf(Y));Ha=ca(se(E,xf(N,Ha)));var ob=nb(Y.shape,ra);0<ob.length&&(Ha=Yb(Ha,ob));return zd(Ha,Y.shape)}}}},{kernelName:"Atan",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return xf(E,vf(Bf(Uc(N,"float32")),1))}}}},{kernelName:"Atanh",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return xf(E,Zb(Qc(1),Bf(Uc(N,"float32"))))}}}},{kernelName:"AvgPool3D",inputsToSave:["x"],gradFunc:function(E,G,N){var Y=G[0],ra=
N.filterSize,Ha=N.strides;G=N.dilations;var ob=N.pad,qb=N.dimRoundingMode,Eb=null==G?[1,1,1]:G;return{x:function(){return Le(E,Y,ra,Ha,Eb,ob,qb)}}}},{kernelName:"AvgPool",inputsToSave:["x"],gradFunc:function(E,G,N){var Y=G[0],ra=N.filterSize,Ha=N.strides,ob=N.pad;return{x:function(){return qf(E,Y,ra,Ha,ob)}}}},{kernelName:"BatchMatMul",inputsToSave:["a","b"],gradFunc:function(E,G,N){var Y=G[0],ra=G[1];G=N.transposeA;N=N.transposeB;return G||N?!G&&N?{a:function(){return uf(E,ra,!1,!1)},b:function(){return uf(E,
Y,!0,!1)}}:G&&!N?{a:function(){return uf(ra,E,!1,!0)},b:function(){return uf(Y,E,!1,!1)}}:{a:function(){return uf(ra,E,!0,!0)},b:function(){return uf(E,Y,!0,!0)}}:{a:function(){return uf(E,ra,!1,!0)},b:function(){return uf(Y,E,!0,!1)}}}},{kernelName:"BatchToSpaceND",gradFunc:function(E,G,N){var Y=N.blockShape,ra=N.crops;return{x:function(){return zg(E,Y,ra)}}}},{kernelName:"BroadcastTo",gradFunc:function(E,G,N){G=N.inputShape;N=N.shape;for(var Y=Array.from(N),ra=G.length-1;0<=ra;ra--)if(G[ra]===N[ra])Y[ra]=
1;else if(1!==G[ra])throw Error("broadcastTo(): ["+G+"] cannot be broadcast to ["+N+"].");var Ha=[];for(ra=0;ra<Y.length;ra++)1<Y[ra]&&Ha.push(ra);return{x:function(){return Yb(E,Ha,!0)}}}},{kernelName:"Cast",gradFunc:function(E){return{x:function(){return E.clone()}}}},{kernelName:"Ceil",gradFunc:function(E){return{x:function(){return Ef(E)}}}},{kernelName:"ClipByValue",inputsToSave:["x"],gradFunc:function(E,G,N){var Y=G[0],ra=N.clipValueMin,Ha=N.clipValueMax;return{x:function(){return cg(rd(ih(Y,
ra),na(Y,Ha)),E,Ef(E))}}}},{kernelName:"Concat",saveAllInputs:!0,gradFunc:function(E,G,N){var Y=G.map(function(Ha){return Ha.shape}),ra=p(N.axis,G[0].shape)[0];G=Y.map(function(Ha){return Ha[ra]});return xi(E,G,ra).map(function(Ha){return function(){return Ha}})}},{kernelName:"Conv2DBackpropInput",inputsToSave:["dy","filter"],gradFunc:function(E,G,N){var Y=G[0],ra=G[1],Ha=N.strides,ob=N.pad,qb=N.dataFormat,Eb=N.dimRoundingMode;return{dy:function(){return sa(E,ra,Ha,ob,qb,1,Eb)},filter:function(){return Ii(E,
Y,ra.shape,Ha,ob,qb,Eb)}}}},{kernelName:"Conv2D",inputsToSave:["x","filter"],gradFunc:function(E,G,N){var Y=G[0],ra=G[1],Ha=N.dilations,ob=N.strides,qb=N.pad,Eb=N.dataFormat;e(ge(Ha),function(){return"Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+(Ha+"'")});return{x:function(){return za(Y.shape,E,ra,ob,qb,Eb)},filter:function(){return Ii(Y,E,ra.shape,ob,qb,Eb)}}}},{kernelName:"Conv3D",inputsToSave:["x","filter"],gradFunc:function(E,
G,N){var Y=N.dilations,ra=N.strides,Ha=N.pad;e(ge(Y),function(){return"Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+(Y+"'")});var ob=G[0],qb=G[1];return{x:function(){return gc(ob.shape,E,qb,ra,Ha)},filter:function(){return dg(ob,E,qb.shape,ra,Ha)}}}},{kernelName:"Cos",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return se(ca(yj(Uc(N,"float32"))),E)}}}},{kernelName:"Cosh",inputsToSave:["x"],gradFunc:function(E,
G){var N=G[0];return{x:function(){return se(oj(Uc(N,"float32")),E)}}}},{kernelName:"Cumsum",inputsToSave:["x"],gradFunc:function(E,G,N){var Y=G[0],ra=N.axis,Ha=N.exclusive,ob=N.reverse;return{x:function(){var qb=yc([ra],Y.rank),Eb=Hd(E,ra,Ha,!ob);null!=qb&&(Eb=hg(Eb,qb));return Eb}}}},{kernelName:"DepthwiseConv2dNative",inputsToSave:["x","filter"],gradFunc:function(E,G,N){var Y=N.dilations,ra=N.strides,Ha=N.pad,ob=N.dimRoundingMode,qb=null==Y?[1,1]:Y;e(ge(qb),function(){return"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '"+
(qb+"'")});var Eb=G[0],hc=G[1];e(4===Eb.rank,function(){return"Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank "+(Eb.rank+".")});e(4===hc.rank,function(){return"Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank "+(hc.rank+".")});e(Eb.shape[3]===hc.shape[2],function(){return"Error in gradient of depthwiseConv2d: number of input channels ("+(Eb.shape[3]+") must match the inChannels dimension in filter ")+(hc.shape[2]+".")});e(he(ra,qb),function(){return"Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides "+
(ra+" and dilations '")+(qb+"'.")});null!=ob&&e(m(Ha),function(){return"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode "+(ob+" but got pad "+Ha+".")});return{x:function(){return Wi(Eb.shape,E,hc,ra,Ha,Y,ob)},filter:function(){return lj(Eb,E,hc.shape,ra,Ha,Y,ob)}}}},{kernelName:"Dilation2D",inputsToSave:["x","filter"],gradFunc:function(E,G,N){var Y=G[0];G=G[1];var ra={x:Y,filter:G,dy:E},Ha={x:Y,filter:G,dy:E};return{x:function(){return Ic.runKernel("Dilation2DBackpropInput",
ra,N)},filter:function(){return Ic.runKernel("Dilation2DBackpropFilter",Ha,N)}}}},{kernelName:"Div",inputsToSave:["a","b"],gradFunc:function(E,G){var N=G[0],Y=G[1],ra=Db(N.shape,Y.shape);return{a:function(){var Ha=xf(E,Uc(Y,"float32")),ob=nb(N.shape,ra);return 0<ob.length?zd(Yb(Ha,ob),N.shape):Ha},b:function(){var Ha=se(E,Uc(N,"float32")),ob=nb(Y.shape,ra);0<ob.length&&(Ha=zd(Yb(Ha,ob),Y.shape));ob=Bf(Y);return ca(xf(Ha,Uc(ob,"float32")))}}}},{kernelName:"Elu",outputsToSave:[!0],gradFunc:function(E,
G){var N=G[0],Y=function(Ha){return Ha.eluDer(E,N)},ra={dy:E,y:N};return{x:function(){return Ic.runKernelFunc(Y,ra,null,"EluGrad")}}}},{kernelName:"Erf",inputsToSave:["x"],gradFunc:function(E,G){var N=se(Xg(ca(Bf(G[0]))),2/Math.sqrt(Math.PI));return{x:function(){return se(E,N)}}}},{kernelName:"Exp",outputsToSave:[!0],gradFunc:function(E,G){var N=G[0];return{x:function(){return se(E,N)}}}},{kernelName:"Expm1",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return se(E,Xg(N))}}}},
{kernelName:"FloorDiv",inputsToSave:["a","b"],gradFunc:function(E,G){var N=G[0],Y=G[1],ra=Db(N.shape,Y.shape);return{a:function(){var Ha=xf(E,Uc(Y,"float32")),ob=nb(N.shape,ra);return 0<ob.length?zd(Yb(Ha,ob),N.shape):Ha},b:function(){var Ha=se(E,Uc(N,"float32")),ob=nb(Y.shape,ra);0<ob.length&&(Ha=zd(Yb(Ha,ob),Y.shape));ob=Bf(Y);return ca(xf(Ha,Uc(ob,"float32")))}}}},{kernelName:"Floor",gradFunc:function(E){return{x:function(){return Ef(E)}}}},{kernelName:"FusedBatchNorm",inputsToSave:["x","mean",
"variance","scale"],gradFunc:function(E,G,N){N=N.varianceEpsilon;var Y=G[0],ra=G[1],Ha=G[2];G=G[3];var ob=null==G?Qc(1):G,qb=nb(ra.shape,Y.shape),Eb=[];if(1===ra.rank){for(G=0;G<Y.shape.length-1;++G)Eb.push(Y.shape[G]);Eb.push(1)}var hc=Zb(Y,ra),Fc=se(E,ob),Oc=Gi(vf(Ha,Qc(N))),td=se(se(se(Oc,Oc),Oc),Qc(-.5));return{x:function(){return 1===ra.rank?zd(se(se(E,og(zd(Oc,[1,1,1,ra.shape[0]]),Eb)),ob),Y.shape):zd(se(se(E,Oc),ob),Y.shape)},mean:function(){var be=se(se(Oc,Qc(-1)),Fc);1===ra.rank&&(be=Yb(be,
qb));return zd(be,ra.shape)},variance:function(){var be=se(se(td,hc),Fc);1===ra.rank&&(be=Yb(be,qb));return zd(be,ra.shape)},scale:function(){var be=se(hc,Oc);be=se(E,be);1===ra.rank&&(be=Yb(be,qb));return zd(be,ra.shape)},offset:function(){var be=E;1===ra.rank&&(be=Yb(be,qb));return zd(be,ra.shape)}}}},{kernelName:"GatherV2",inputsToSave:["x","indices"],gradFunc:function(E,G,N){var Y=G[0],ra=G[1],Ha=N.axis,ob=p(Ha,Y.shape)[0];return{x:function(){var qb=Y.shape,Eb=ra.size,hc=qb.slice(0,ob),Fc=hc.length,
Oc=qb.slice(Ha,qb.length).slice(1),td=Oc.length;qb=fb(0,Fc);td=fb(Fc+1,Fc+1+td);hc=Gb([hc,[Eb],Oc]);hc=zd(E,hc);Eb=zd(ra,[Eb]);Fc=Gb([[Fc],qb,td]);qb=hg(hc,Fc);Eb=rj(qb,Eb,Y.shape[ob]);Fc=fd(Fc);return Eb=hg(Eb,Fc)},indices:function(){return ra}}}},{kernelName:"GreaterEqual",inputsToSave:["a","b"],gradFunc:function(E,G){var N=G[0],Y=G[1];return{a:function(){return Ef(N)},b:function(){return Ef(Y)}}}},{kernelName:"Identity",gradFunc:function(E){return{x:function(){return Uc(E,"float32")}}}},{kernelName:"IsFinite",
gradFunc:function(E){return{x:function(){return Ef(E)}}}},{kernelName:"IsInf",gradFunc:function(E){return{x:function(){return Ef(E)}}}},{kernelName:"IsNan",gradFunc:function(E){return{x:function(){return Ef(E)}}}},{kernelName:"Log1p",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return xf(E,vf(N,1))}}}},{kernelName:"Log",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return xf(E,Uc(N,"float32"))}}}},{kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],
gradFunc:function(E,G,N){var Y=G[0],ra=N.axis;return{logits:function(){var Ha=Xg(Y);return Zb(E,se(Yb(E,ra,!0),Ha))}}}},{kernelName:"LRN",inputsToSave:["x"],outputsToSave:[!0],gradFunc:function(E,G,N){var Y=G[0],ra=G[1],Ha=N.depthRadius,ob=N.bias,qb=N.alpha,Eb=N.beta;return{x:function(){return Jf(Y,ra,E,Ha,ob,qb,Eb)}}}},Vf,Vf,{kernelName:"Maximum",inputsToSave:["a","b"],gradFunc:function(E,G){var N=G[0],Y=G[1];return{a:function(){return se(E,Uc(ih(N,Y),"float32"))},b:function(){return se(E,Uc(Kh(N,
Y),"float32"))}}}},{kernelName:"MaxPool3D",inputsToSave:["x"],outputsToSave:[!0],gradFunc:function(E,G,N){var Y=G[0],ra=G[1],Ha=N.filterSize,ob=N.strides;G=N.dilations;var qb=N.pad,Eb=N.dimRoundingMode,hc=null==G?[1,1,1]:G;return{x:function(){return Of(E,Y,ra,Ha,ob,hc,qb,Eb)}}}},{kernelName:"MaxPool",inputsToSave:["x"],outputsToSave:[!0],gradFunc:function(E,G,N){var Y=G[0],ra=G[1],Ha=N.filterSize,ob=N.strides,qb=N.pad;return{x:function(){return rf(E,Y,ra,Ha,ob,qb)}}}},{kernelName:"Min",inputsToSave:["x"],
outputsToSave:[!0],gradFunc:function(E,G,N){var Y=G[0];G=G[1];N=p(N.axis,Y.shape);var ra=Vb(E,G,Y,N);return{x:function(){return ra.x()}}}},{kernelName:"Minimum",inputsToSave:["a","b"],gradFunc:function(E,G){var N=G[0],Y=G[1];return{a:function(){return se(E,Uc(na(N,Y),"float32"))},b:function(){return se(E,Uc(Ug(N,Y),"float32"))}}}},{kernelName:"MirrorPad",inputsToSave:["x"],gradFunc:function(E,G,N){var Y=G[0],ra=N.paddings.map(function(Ha){return Ha[0]});return{x:function(){return Qb(E,ra,Y.shape)}}}},
{kernelName:"Mod",inputsToSave:["a","b"],gradFunc:function(E,G){var N=G[0],Y=G[1],ra=Db(N.shape,Y.shape);return{a:function(){var Ha=nb(N.shape,ra);return 0<Ha.length?zd(Yb(E,Ha),N.shape):E},b:function(){var Ha=se(E,ca(Gh(xf(N,Y)))),ob=nb(Y.shape,ra);return 0<ob.length?zd(Yb(Ha,ob),Y.shape):Ha}}}},{kernelName:"Multiply",inputsToSave:["a","b"],gradFunc:function(E,G){var N=G[0],Y=G[1],ra=Db(N.shape,Y.shape);return{a:function(){var Ha=se(E,Uc(Y,"float32")),ob=nb(N.shape,ra);return 0<ob.length?zd(Yb(Ha,
ob),N.shape):Ha},b:function(){var Ha=se(E,Uc(N,"float32")),ob=nb(Y.shape,ra);return 0<ob.length?zd(Yb(Ha,ob),Y.shape):Ha}}}},{kernelName:"Negate",gradFunc:function(E){return{x:function(){return ca(E)}}}},{kernelName:"OneHot",inputsToSave:["indices"],gradFunc:function(E,G){var N=G[0];return{indices:function(){return sd(N.shape,"float32")}}}},{kernelName:"OnesLike",gradFunc:function(E){return{x:function(){return Ef(E)}}}},yg,yg,{kernelName:"Pow",inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:function(E,
G){var N=G[2],Y=G[0],ra=G[1],Ha=Db(Y.shape,ra.shape);return{a:function(){var ob=Uc(ra,"float32");ob=se(E,se(ob,ph(Y,Zb(ob,Qc(1)))));var qb=nb(Y.shape,Ha);0<qb.length&&(ob=Yb(ob,qb));return zd(ob,Y.shape)},b:function(){var ob=Ug(Y,0);ob=cg(ob,x(Y),Ef(Y));ob=se(E,se(N,ob));var qb=nb(ra.shape,Ha);0<qb.length&&(ob=Yb(ob,qb));return zd(ob,ra.shape)}}}},{kernelName:"Prelu",inputsToSave:["x","alpha"],gradFunc:function(E,G){var N=G[0],Y=G[1],ra=Ug(N,0);return{x:function(){return cg(ra,E,se(E,Y))},alpha:function(){var Ha=
cg(ra,Ef(E),se(E,N)),ob=nb(Y.shape,E.shape);0<ob.length&&(Ha=Yb(Ha,ob));return zd(Ha,Y.shape)}}}},{kernelName:"Reciprocal",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return xf(E,ca(Bf(N)))}}}},{kernelName:"Relu6",inputsToSave:["x"],gradFunc:function(E,G){G=G[0];var N=se(na(G,6),ji(G));return{x:function(){return se(E,Uc(N,"float32"))}}}},{kernelName:"Relu",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return se(E,Uc(ji(N),"float32"))}}}},{kernelName:"Reshape",
inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return zd(E,N.shape)}}}},{kernelName:"ResizeBilinear",inputsToSave:["images"],gradFunc:function(E,G,N){var Y=G[0],ra=function(ob){return ob.resizeBilinearBackprop(E,Y,N.alignCorners)},Ha={images:Y};return{images:function(){return Ic.runKernelFunc(ra,Ha,null,"ResizeBilinearGrad",N)}}}},{kernelName:"ResizeNearestNeighbor",inputsToSave:["images"],gradFunc:function(E,G,N){var Y=G[0],ra=function(ob){return ob.resizeNearestNeighborBackprop(E,
Y,N.alignCorners)},Ha={images:Y};return{images:function(){return Ic.runKernelFunc(ra,Ha,null,"ResizeNearestNeighborGrad",N)}}}},{kernelName:"Reverse",gradFunc:function(E,G,N){var Y=p(N.dims,E.shape);return{x:function(){return Jh(E,Y)}}}},{kernelName:"Round",gradFunc:function(E){return{x:function(){return Ef(E)}}}},{kernelName:"Rsqrt",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return ca(xf(E,se(ph(N,1.5),2)))}}}},{kernelName:"SelectV2",inputsToSave:["condition"],gradFunc:function(E,
G){var N=G[0];return{condition:function(){return Uc(Ef(N),"float32")},t:function(){return se(E,Uc(N,E.dtype))},e:function(){return se(E,Uc(Pd(N),E.dtype))}}}},{kernelName:"Selu",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){var Y=Ug(N,Qc(0)),ra=Qc(1.7580993408473768),Ha=Qc(1.0507009873554805);Ha=se(E,Ha);ra=se(se(E,ra),Xg(Uc(N,"float32")));return cg(Y,Ha,ra)}}}},{kernelName:"Sigmoid",outputsToSave:[!0],gradFunc:function(E,G){var N=G[0];return{x:function(){return se(E,se(N,
Zb(Qc(1),N)))}}}},{kernelName:"Sign",gradFunc:function(E){return{x:function(){return Ef(E)}}}},{kernelName:"Sin",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return se(Tc(Uc(N,"float32")),E)}}}},{kernelName:"Sinh",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return se(hd(Uc(N,"float32")),E)}}}},{kernelName:"Slice",inputsToSave:["x"],gradFunc:function(E,G,N){var Y=G[0];G=Y.shape;Y=pe(Y,N.begin,N.size);N=Y[0];Y=Y[1];for(var ra=[],Ha=0;Ha<E.rank;Ha++)ra.push([N[Ha],
G[Ha]-N[Ha]-Y[Ha]]);return{x:function(){return Yg(E,ra)}}}},{kernelName:"Softmax",outputsToSave:[!0],gradFunc:function(E,G,N){var Y=G[0],ra=N.dim,Ha=se(E,Y);return{logits:function(){return Zb(Ha,se(Yb(Ha,[ra],!0),Y))}}}},{kernelName:"Softplus",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return se(E,Ab(N))}}}},xg,xg,Eg,Eg,{kernelName:"Sqrt",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return xf(E,se(Bh(Uc(N,"float32")),2))}}}},{kernelName:"SquaredDifference",
inputsToSave:["a","b"],gradFunc:function(E,G){var N=G[0],Y=G[1],ra=Qc(2);return{a:function(){return se(E,se(ra,Zb(N,Y)))},b:function(){return se(E,se(ra,Zb(Y,N)))}}}},{kernelName:"Square",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return se(E,se(Uc(N,"float32"),2))}}}},{kernelName:"Step",gradFunc:function(E){return{x:function(){return Ef(E)}}}},{kernelName:"Sub",inputsToSave:["a","b"],gradFunc:function(E,G){var N=G[0],Y=G[1],ra=Db(N.shape,Y.shape);return{a:function(){var Ha=
E,ob=nb(N.shape,ra);0<ob.length&&(Ha=Yb(Ha,ob));return zd(Ha,N.shape)},b:function(){var Ha=E,ob=nb(Y.shape,ra);0<ob.length&&(Ha=Yb(Ha,ob));return zd(ca(Ha),Y.shape)}}}},{kernelName:"Sum",inputsToSave:["x"],gradFunc:function(E,G,N){G=G[0];var Y=G.shape.slice();p(N.axis,G.shape).forEach(function(Ha){Y[Ha]=1});E=zd(E,Y);var ra=se(E,wd(G.shape,"float32"));return{x:function(){return ra}}}},{kernelName:"Tan",inputsToSave:["x"],gradFunc:function(E,G){var N=G[0];return{x:function(){return xf(E,Bf(Tc(N)))}}}},
{kernelName:"Tanh",outputsToSave:[!0],gradFunc:function(E,G){var N=G[0];return{x:function(){return se(Zb(Qc(1),Bf(N)),E)}}}},{kernelName:"Tile",inputsToSave:["x"],gradFunc:function(E,G,N){var Y=G[0],ra=N.reps;return{x:function(){var Ha=Ef(Y);if(1===Y.rank)for(var ob=0;ob<ra[0];++ob)Ha=vf(Ha,Qb(E,[ob*Y.shape[0]],[Y.shape[0]]));else if(2===Y.rank)for(ob=0;ob<ra[0];++ob)for(var qb=0;qb<ra[1];++qb)Ha=vf(Ha,Qb(E,[ob*Y.shape[0],qb*Y.shape[1]],[Y.shape[0],Y.shape[1]]));else if(3===Y.rank)for(ob=0;ob<ra[0];++ob)for(qb=
0;qb<ra[1];++qb)for(var Eb=0;Eb<ra[2];++Eb)Ha=vf(Ha,Qb(E,[ob*Y.shape[0],qb*Y.shape[1],Eb*Y.shape[2]],[Y.shape[0],Y.shape[1],Y.shape[2]]));else if(4===Y.rank)for(ob=0;ob<ra[0];++ob)for(qb=0;qb<ra[1];++qb)for(Eb=0;Eb<ra[2];++Eb)for(var hc=0;hc<ra[3];++hc)Ha=vf(Ha,Qb(E,[ob*Y.shape[0],qb*Y.shape[1],Eb*Y.shape[2],hc*Y.shape[3]],[Y.shape[0],Y.shape[1],Y.shape[2],Y.shape[3]]));else throw Error("Gradient for tile operation is not implemented for rank-"+(Y.rank+" tensors yet."));return Ha}}}},{kernelName:"Transpose",
gradFunc:function(E,G,N){var Y=fd(N.perm);return{x:function(){return hg(E,Y)}}}},{kernelName:"Unpack",gradFunc:function(E,G,N){var Y=N.axis;return{value:function(){return mi(E,Y)}}}},{kernelName:"UnsortedSegmentSum",inputsToSave:["segmentIds"],gradFunc:function(E,G){var N=G[0];return{x:function(){var Y=Ah(N,Ef(N));Y=Hh(E,Y);for(var ra=ih(N,Qc(0,"int32")),Ha=Y.rank-ra.rank,ob=0;ob<Ha;++ob)ra=Tg(ra,ob+1);ra=rd(ra,wd(Y.shape,"bool"));Ha=Ef(Y);return cg(ra,Y,Ha)}}}},{kernelName:"ZerosLike",gradFunc:function(E){return{x:function(){return Ef(E)}}}}];ah<
Oh.length;ah++)ua(Oh[ah]);Da.prototype.abs=function(){this.throwIfDisposed();return sg(this)};Da.prototype.acos=function(){this.throwIfDisposed();return Sg(this)};Da.prototype.acosh=function(){this.throwIfDisposed();return Ch(this)};Da.prototype.addStrict=function(E){this.throwIfDisposed();return Bj(this,E)};Da.prototype.add=function(E){this.throwIfDisposed();return vf(this,E)};Da.prototype.all=function(E,G){this.throwIfDisposed();return ch(this,E,G)};Da.prototype.any=function(E,G){this.throwIfDisposed();
return Dh(this,E,G)};Da.prototype.argMax=function(E){this.throwIfDisposed();return Eh(this,E)};Da.prototype.argMin=function(E){this.throwIfDisposed();return jh(this,E)};Da.prototype.asScalar=function(){this.throwIfDisposed();e(1===this.size,function(){return"The array must have only 1 element."});return zd(this,[])};Da.prototype.asType=function(E){this.throwIfDisposed();return Uc(this,E)};Da.prototype.as1D=function(){this.throwIfDisposed();return zd(this,[this.size])};Da.prototype.as2D=function(E,
G){this.throwIfDisposed();return zd(this,[E,G])};Da.prototype.as3D=function(E,G,N){this.throwIfDisposed();return zd(this,[E,G,N])};Da.prototype.as4D=function(E,G,N,Y){this.throwIfDisposed();return zd(this,[E,G,N,Y])};Da.prototype.as5D=function(E,G,N,Y,ra){this.throwIfDisposed();return zd(this,[E,G,N,Y,ra])};Da.prototype.asin=function(){this.throwIfDisposed();return rh(this)};Da.prototype.asinh=function(){this.throwIfDisposed();return yh(this)};Da.prototype.atan=function(){this.throwIfDisposed();return kh(this)};
Da.prototype.atan2=function(E){this.throwIfDisposed();return nh(this,E)};Da.prototype.atanh=function(){this.throwIfDisposed();return sh(this)};Da.prototype.avgPool=function(E,G,N,Y){this.throwIfDisposed();return Fg(this,E,G,N,Y)};Da.prototype.batchToSpaceND=function(E,G){this.throwIfDisposed();return kc(this,E,G)};Da.prototype.batchNorm=function(E,G,N,Y,ra){this.throwIfDisposed();return Nc(this,E,G,N,Y,ra)};Da.prototype.broadcastTo=function(E){this.throwIfDisposed();return Ld(this,E)};Da.prototype.cast=
function(E){this.throwIfDisposed();return Uc(this,E)};Da.prototype.ceil=function(){this.throwIfDisposed();return me(this)};Da.prototype.clipByValue=function(E,G){this.throwIfDisposed();return Ie(this,E,G)};Da.prototype.concat=function(E,G){this.throwIfDisposed();E instanceof Da&&(E=[E]);return Pa([this].concat(E),G)};Da.prototype.conv1d=function(E,G,N,Y,ra,Ha){this.throwIfDisposed();return ia(this,E,G,N,Y,ra,Ha)};Da.prototype.conv2dTranspose=function(E,G,N,Y,ra){this.throwIfDisposed();return Xa(this,
E,G,N,Y,ra)};Da.prototype.conv2d=function(E,G,N,Y,ra,Ha){this.throwIfDisposed();return sa(this,E,G,N,Y,ra,Ha)};Da.prototype.cos=function(){this.throwIfDisposed();return Tc(this)};Da.prototype.cosh=function(){this.throwIfDisposed();return hd(this)};Da.prototype.cumsum=function(E,G,N){this.throwIfDisposed();return Hd(this,E,G,N)};Da.prototype.depthToSpace=function(E,G){this.throwIfDisposed();return $d(this,E,G)};Da.prototype.depthwiseConv2D=function(E,G,N,Y,ra,Ha){hb("depthwiseConv2D is deprecated, use depthwiseConv2d instead");
this.throwIfDisposed();return te(this,E,G,N,Y,ra,Ha)};Da.prototype.depthwiseConv2d=function(E,G,N,Y,ra,Ha){this.throwIfDisposed();return te(this,E,G,N,Y,ra,Ha)};Da.prototype.dilation2d=function(E,G,N,Y,ra){this.throwIfDisposed();return Xd(this,E,G,N,Y,ra)};Da.prototype.divNoNan=function(E){this.throwIfDisposed();return Hg(this,E)};Da.prototype.divStrict=function(E){this.throwIfDisposed();return Mh(this,E)};Da.prototype.div=function(E){this.throwIfDisposed();return xf(this,E)};Da.prototype.dot=function(E){this.throwIfDisposed();
return jg(this,E)};Da.prototype.elu=function(){this.throwIfDisposed();return gg(this)};Da.prototype.equalStrict=function(E){this.throwIfDisposed();return ni(this,E)};Da.prototype.equal=function(E){this.throwIfDisposed();return ye(this,E)};Da.prototype.erf=function(){this.throwIfDisposed();return th(this)};Da.prototype.exp=function(){this.throwIfDisposed();return Xg(this)};Da.prototype.expandDims=function(E){this.throwIfDisposed();return Tg(this,E)};Da.prototype.expm1=function(){this.throwIfDisposed();
return zh(this)};Da.prototype.fft=function(){this.throwIfDisposed();return Oi(this)};Da.prototype.flatten=function(){this.throwIfDisposed();return zd(this,[this.size])};Da.prototype.floor=function(){this.throwIfDisposed();return Gh(this)};Da.prototype.floorDiv=function(E){this.throwIfDisposed();return Qg(this,E)};Da.prototype.gather=function(E,G){this.throwIfDisposed();return Hh(this,E,G)};Da.prototype.greaterEqualStrict=function(E){this.throwIfDisposed();return Fj(this,E)};Da.prototype.greaterEqual=
function(E){this.throwIfDisposed();return ih(this,E)};Da.prototype.greaterStrict=function(E){this.throwIfDisposed();return ij(this,E)};Da.prototype.greater=function(E){this.throwIfDisposed();return Ug(this,E)};Da.prototype.ifft=function(){this.throwIfDisposed();return $i(this)};Da.prototype.irfft=function(){this.throwIfDisposed();return Ri(this)};Da.prototype.isFinite=function(){this.throwIfDisposed();return pg(this)};Da.prototype.isInf=function(){this.throwIfDisposed();return Rh(this)};Da.prototype.isNaN=
function(){this.throwIfDisposed();return Ph(this)};Da.prototype.leakyRelu=function(E){this.throwIfDisposed();return Uh(this,E)};Da.prototype.lessEqualStrict=function(E){this.throwIfDisposed();return hj(this,E)};Da.prototype.lessEqual=function(E){this.throwIfDisposed();return na(this,E)};Da.prototype.lessStrict=function(E){this.throwIfDisposed();return Xh(this,E)};Da.prototype.less=function(E){this.throwIfDisposed();return Kh(this,E)};Da.prototype.localResponseNormalization=function(E,G,N,Y){this.throwIfDisposed();
return R(this,E,G,N,Y)};Da.prototype.logSigmoid=function(){this.throwIfDisposed();return rb(this)};Da.prototype.logSoftmax=function(E){this.throwIfDisposed();return Gc(this,E)};Da.prototype.logSumExp=function(E,G){this.throwIfDisposed();return cd(this,E,G)};Da.prototype.log=function(){this.throwIfDisposed();return x(this)};Da.prototype.log1p=function(){this.throwIfDisposed();return P(this)};Da.prototype.logicalAnd=function(E){this.throwIfDisposed();return rd(this,E)};Da.prototype.logicalNot=function(){this.throwIfDisposed();
return Pd(this)};Da.prototype.logicalOr=function(E){this.throwIfDisposed();return Od(this,E)};Da.prototype.logicalXor=function(E){this.throwIfDisposed();return ce(this,E)};Da.prototype.matMul=function(E,G,N){this.throwIfDisposed();return uf(this,E,G,N)};Da.prototype.maxPool=function(E,G,N,Y){this.throwIfDisposed();return Yd(this,E,G,N,Y)};Da.prototype.max=function(E,G){this.throwIfDisposed();return Mb(this,E,G)};Da.prototype.maximumStrict=function(E){this.throwIfDisposed();return qi(this,E)};Da.prototype.maximum=
function(E){this.throwIfDisposed();return Ah(this,E)};Da.prototype.mean=function(E,G){this.throwIfDisposed();return jf(this,E,G)};Da.prototype.min=function(E,G){this.throwIfDisposed();return kf(this,E,G)};Da.prototype.minimumStrict=function(E){this.throwIfDisposed();return Pi(this,E)};Da.prototype.minimum=function(E){this.throwIfDisposed();return Af(this,E)};Da.prototype.mirrorPad=function(E,G){this.throwIfDisposed();return Mf(this,E,G)};Da.prototype.modStrict=function(E){this.throwIfDisposed();return yi(this,
E)};Da.prototype.mod=function(E){this.throwIfDisposed();return Rf(this,E)};Da.prototype.mulStrict=function(E){this.throwIfDisposed();return dj(this,E)};Da.prototype.mul=function(E){this.throwIfDisposed();return se(this,E)};Da.prototype.neg=function(){this.throwIfDisposed();return ca(this)};Da.prototype.norm=function(E,G,N){this.throwIfDisposed();return Qi(this,E,G,N)};Da.prototype.notEqualStrict=function(E){this.throwIfDisposed();return kg(this,E)};Da.prototype.notEqual=function(E){this.throwIfDisposed();
return Vg(this,E)};Da.prototype.oneHot=function(E,G,N){void 0===G&&(G=1);void 0===N&&(N=0);this.throwIfDisposed();return ng(this,E,G,N)};Da.prototype.onesLike=function(){this.throwIfDisposed();return oh(this)};Da.prototype.pad=function(E,G){this.throwIfDisposed();return Yg(this,E,G)};Da.prototype.pool=function(E,G,N,Y,ra){this.throwIfDisposed();return vh(this,E,G,N,Y,ra)};Da.prototype.powStrict=function(E){this.throwIfDisposed();return fi(this,E)};Da.prototype.pow=function(E){this.throwIfDisposed();
return ph(this,E)};Da.prototype.prelu=function(E){this.throwIfDisposed();return Li(this,E)};Da.prototype.prod=function(E,G){this.throwIfDisposed();return gi(this,E,G)};Da.prototype.reciprocal=function(){this.throwIfDisposed();return Ai(this)};Da.prototype.relu=function(){this.throwIfDisposed();return Lh(this)};Da.prototype.relu6=function(){this.throwIfDisposed();return Wh(this)};Da.prototype.reshapeAs=function(E){this.throwIfDisposed();return zd(this,E.shape)};Da.prototype.reshape=function(E){this.throwIfDisposed();
return zd(this,E)};Da.prototype.resizeBilinear=function(E,G){this.throwIfDisposed();return wh(this,E,G)};Da.prototype.resizeNearestNeighbor=function(E,G){this.throwIfDisposed();return ci(this,E,G)};Da.prototype.reverse=function(E){this.throwIfDisposed();return Jh(this,E)};Da.prototype.rfft=function(){this.throwIfDisposed();return aj(this)};Da.prototype.round=function(){this.throwIfDisposed();return Zi(this)};Da.prototype.rsqrt=function(){this.throwIfDisposed();return Gi(this)};Da.prototype.selu=function(){this.throwIfDisposed();
return wi(this)};Da.prototype.separableConv2d=function(E,G,N,Y,ra,Ha){this.throwIfDisposed();return Hi(this,E,G,N,Y,ra,Ha)};Da.prototype.sigmoid=function(){this.throwIfDisposed();return Ab(this)};Da.prototype.sign=function(){this.throwIfDisposed();return nj(this)};Da.prototype.sin=function(){this.throwIfDisposed();return yj(this)};Da.prototype.sinh=function(){this.throwIfDisposed();return oj(this)};Da.prototype.slice=function(E,G){this.throwIfDisposed();return Qb(this,E,G)};Da.prototype.softmax=function(E){this.throwIfDisposed();
return Mj(this,E)};Da.prototype.softplus=function(){this.throwIfDisposed();return Ka(this)};Da.prototype.spaceToBatchND=function(E,G){this.throwIfDisposed();return zg(this,E,G)};Da.prototype.split=function(E,G){this.throwIfDisposed();return xi(this,E,G)};Da.prototype.sqrt=function(){this.throwIfDisposed();return Bh(this)};Da.prototype.square=function(){this.throwIfDisposed();return Bf(this)};Da.prototype.squaredDifference=function(E){this.throwIfDisposed();return bj(this,E)};Da.prototype.squaredDifferenceStrict=
function(E){this.throwIfDisposed();return Nh(this,E)};Da.prototype.squeeze=function(E){this.throwIfDisposed();return Ni(this,E)};Da.prototype.stack=function(E,G){this.throwIfDisposed();E=E instanceof Da?[this,E]:[this].concat(E);return mi(E,G)};Da.prototype.step=function(E){this.throwIfDisposed();return ji(this,E)};Da.prototype.stridedSlice=function(E,G,N,Y,ra,Ha,ob,qb){this.throwIfDisposed();return Nj(this,E,G,N,Y,ra,Ha,ob,qb)};Da.prototype.subStrict=function(E){this.throwIfDisposed();return Cj(this,
E)};Da.prototype.sub=function(E){this.throwIfDisposed();return Zb(this,E)};Da.prototype.sum=function(E,G){this.throwIfDisposed();return Yb(this,E,G)};Da.prototype.tan=function(){this.throwIfDisposed();return Ci(this)};Da.prototype.tanh=function(){this.throwIfDisposed();return cc(this)};Da.prototype.tile=function(E){this.throwIfDisposed();return og(this,E)};Da.prototype.toBool=function(){this.throwIfDisposed();return Uc(this,"bool")};Da.prototype.toFloat=function(){this.throwIfDisposed();return Uc(this,
"float32")};Da.prototype.toInt=function(){this.throwIfDisposed();return Uc(this,"int32")};Da.prototype.topk=function(E,G){this.throwIfDisposed();return cj(this,E,G)};Da.prototype.transpose=function(E){this.throwIfDisposed();return hg(this,E)};Da.prototype.unique=function(E){this.throwIfDisposed();return Oj(this,E)};Da.prototype.unsortedSegmentSum=function(E,G){this.throwIfDisposed();return rj(this,E,G)};Da.prototype.unstack=function(E){this.throwIfDisposed();return Mi(this,E)};Da.prototype.where=
function(E,G){this.throwIfDisposed();return cg(E,this,G)};Da.prototype.zerosLike=function(){this.throwIfDisposed();return Ef(this)};v.Abs="Abs";v.Acos="Acos";v.Acosh="Acosh";v.AdadeltaOptimizer=sb;v.AdagradOptimizer=Oa;v.AdamOptimizer=xb;v.AdamaxOptimizer=bc;v.Add="Add";v.AddN="AddN";v.All="All";v.Any="Any";v.ArgMax="ArgMax";v.ArgMin="ArgMin";v.Asin="Asin";v.Asinh="Asinh";v.Atan="Atan";v.Atan2="Atan2";v.Atanh="Atanh";v.AvgPool="AvgPool";v.AvgPool3D="AvgPool3D";v.AvgPool3DBackprop="AvgPool3DBackprop";
v.AvgPoolBackprop="AvgPoolBackprop";v.BatchMatMul="BatchMatMul";v.BatchToSpaceND="BatchToSpaceND";v.BroadcastTo="BroadcastTo";v.Cast="Cast";v.Ceil="Ceil";v.ClipByValue="ClipByValue";v.Complex="Complex";v.Concat="Concat";v.Conv2D="Conv2D";v.Conv2DBackpropFilter="Conv2DBackpropFilter";v.Conv2DBackpropInput="Conv2DBackpropInput";v.Conv3D="Conv3D";v.Conv3DBackpropFilterV2="Conv3DBackpropFilterV2";v.Conv3DBackpropInputV2="Conv3DBackpropInputV2";v.Cos="Cos";v.Cosh="Cosh";v.CropAndResize="CropAndResize";
v.Cumsum="Cumsum";v.DataStorage=ae;v.DepthToSpace="DepthToSpace";v.DepthwiseConv2dNative="DepthwiseConv2dNative";v.DepthwiseConv2dNativeBackpropFilter="DepthwiseConv2dNativeBackpropFilter";v.DepthwiseConv2dNativeBackpropInput="DepthwiseConv2dNativeBackpropInput";v.Diag="Diag";v.Dilation2D="Dilation2D";v.Dilation2DBackpropFilter="Dilation2DBackpropFilter";v.Dilation2DBackpropInput="Dilation2DBackpropInput";v.Div="Div";v.Elu="Elu";v.EluGrad="EluGrad";v.Environment=ef;v.Equal="Equal";v.Erf="Erf";v.Exp=
"Exp";v.Expm1="Expm1";v.FFT="FFT";v.Fill="Fill";v.FlipLeftRight="FlipLeftRight";v.Floor="Floor";v.FloorDiv="FloorDiv";v.FromPixels="FromPixels";v.FusedBatchNorm="FusedBatchNorm";v.FusedConv2D="FusedConv2D";v.FusedDepthwiseConv2D="FusedDepthwiseConv2D";v.GatherNd="GatherNd";v.GatherV2="GatherV2";v.Greater="Greater";v.GreaterEqual="GreaterEqual";v.IFFT="IFFT";v.Identity="Identity";v.Imag="Imag";v.IsFinite="IsFinite";v.IsInf="IsInf";v.IsNan="IsNan";v.KernelBackend=ze;v.LRN="LRN";v.LRNBackprop="LRNBackprop";
v.Less="Less";v.LessEqual="LessEqual";v.LinSpace="LinSpace";v.Log="Log";v.Log1p="Log1p";v.LogSoftmax="LogSoftmax";v.LogicalAnd="LogicalAnd";v.LogicalNot="LogicalNot";v.LogicalOr="LogicalOr";v.Max="Max";v.MaxPool="MaxPool";v.MaxPool3D="MaxPool3D";v.MaxPool3DBackprop="MaxPool3DBackprop";v.MaxPoolBackprop="MaxPoolBackprop";v.MaxPoolWithArgmax="MaxPoolWithArgmax";v.Maximum="Maximum";v.Mean="Mean";v.Min="Min";v.Minimum="Minimum";v.MirrorPad="MirrorPad";v.Mod="Mod";v.MomentumOptimizer=qd;v.Multiply="Multiply";
v.Negate="Negate";v.NonMaxSuppressionV3="NonMaxSuppressionV3";v.NonMaxSuppressionV4="NonMaxSuppressionV4";v.NonMaxSuppressionV5="NonMaxSuppressionV5";v.NotEqual="NotEqual";v.OP_SCOPE_SUFFIX="__op";v.OneHot="OneHot";v.OnesLike="OnesLike";v.Optimizer=Na;v.PadV2="PadV2";v.Pool="Pool";v.Pow="Pow";v.Prelu="Prelu";v.Prod="Prod";v.RMSPropOptimizer=Id;v.Range="Range";v.Real="Real";v.Reciprocal="Reciprocal";v.Relu="Relu";v.Relu6="Relu6";v.Reshape="Reshape";v.ResizeBilinear="ResizeBilinear";v.ResizeBilinearGrad=
"ResizeBilinearGrad";v.ResizeNearestNeighbor="ResizeNearestNeighbor";v.ResizeNearestNeighborGrad="ResizeNearestNeighborGrad";v.Reverse="Reverse";v.RotateWithOffset="RotateWithOffset";v.Round="Round";v.Rsqrt="Rsqrt";v.SGDOptimizer=Jc;v.ScatterNd="ScatterNd";v.SelectV2="SelectV2";v.Selu="Selu";v.Sigmoid="Sigmoid";v.Sign="Sign";v.Sin="Sin";v.Sinh="Sinh";v.Slice="Slice";v.Softmax="Softmax";v.Softplus="Softplus";v.SpaceToBatchND="SpaceToBatchND";v.SparseToDense="SparseToDense";v.SplitV="SplitV";v.Sqrt=
"Sqrt";v.Square="Square";v.SquaredDifference="SquaredDifference";v.Step="Step";v.StridedSlice="StridedSlice";v.Sub="Sub";v.Sum="Sum";v.Tan="Tan";v.Tanh="Tanh";v.Tensor=Da;v.TensorBuffer=Ua;v.Tile="Tile";v.TopK="TopK";v.Transpose="Transpose";v.Unique="Unique";v.Unpack="Unpack";v.UnsortedSegmentSum="UnsortedSegmentSum";v.Variable=mb;v.ZerosLike="ZerosLike";v._FusedMatMul="_FusedMatMul";v.abs=sg;v.acos=Sg;v.acosh=Ch;v.add=vf;v.addN=dh;v.addStrict=Bj;v.all=ch;v.any=Dh;v.argMax=Eh;v.argMin=jh;v.asin=rh;
v.asinh=yh;v.atan=kh;v.atan2=nh;v.atanh=sh;v.avgPool=Fg;v.avgPool3d=Rg;v.backend=function(){return Ic.backend};v.backend_util=lf;v.basicLSTMCell=zc;v.batchNorm=Nc;v.batchNorm2d=jd;v.batchNorm3d=Td;v.batchNorm4d=Wd;v.batchToSpaceND=kc;v.booleanMaskAsync=function(E,G,N){return r(this,void 0,void 0,function(){var Y,ra,Ha,ob,qb,Eb,hc,Fc,Oc,td,be,Fe,fe;return u(this,function(Be){switch(Be.label){case 0:Y=La(E,"tensor","boolMask");ra=La(G,"mask","boolMask","bool");Ha=null==N?0:N;ob=ra.rank;qb=Y.shape;e(0<
ob,function(){return"mask cannot be scalar"});g(qb.slice(Ha,Ha+ob),ra.shape,"mask's shape must match the first K dimensions of tensor's shape,");Eb=1;for(hc=Ha;hc<Ha+ob;hc++)Eb*=qb[hc];Fc=qb.slice(0,Ha).concat([Eb],qb.slice(Ha+ob));Oc=zd(Y,Fc);td=zd(ra,[-1]);return[4,pi(td)];case 1:return be=Be.sent(),Fe=Ni(be,[1]),fe=Hh(Oc,Fe,Ha),E!==Y&&Y.dispose(),G!==ra&&ra.dispose(),Fe.dispose(),Oc.dispose(),td.dispose(),be.dispose(),[2,fe]}})})};v.broadcastTo=Ld;v.browser=Og;v.buffer=kd;v.cast=Uc;v.ceil=me;v.clipByValue=
Ie;v.clone=Ed;v.complex=vd;v.concat=Pa;v.concat1d=Ee;v.concat2d=Ff;v.concat3d=Kf;v.concat4d=ea;v.conv1d=ia;v.conv2d=sa;v.conv2dTranspose=Xa;v.conv3d=Cb;v.conv3dTranspose=nc;v.copyRegisteredKernels=function(E,G){qa(E).forEach(function(N){N=Object.assign({},N,{backendName:G});Fa(N)})};v.cos=Tc;v.cosh=hd;v.cosineWindow=ug;v.cumsum=Hd;v.customGrad=Fd;v.deprecationWarn=hb;v.depthToSpace=$d;v.depthwiseConv2d=te;v.device_util=Kd;v.diag=He;v.dilation2d=Xd;v.disableDeprecationWarnings=function(){pa().set("DEPRECATION_WARNINGS_ENABLED",
!1);console.warn("TensorFlow.js deprecation warnings have been disabled.")};v.dispose=mc;v.disposeVariables=function(){Ic.disposeVariables()};v.div=xf;v.divNoNan=Hg;v.divStrict=Mh;v.dot=jg;v.dropout=Pj;v.elu=gg;v.enableDebugMode=function(){pa().set("DEBUG",!0)};v.enableProdMode=function(){pa().set("PROD",!0)};v.enclosingPowerOfTwo=Kb;v.engine=function(){return Ic};v.env=pa;v.equal=ye;v.equalStrict=ni;v.erf=th;v.exp=Xg;v.expandDims=Tg;v.expm1=zh;v.eye=Fh;v.fft=Oi;v.fill=dc;v.findBackend=function(E){return Ic.findBackend(E)};
v.findBackendFactory=function(E){return Ic.findBackendFactory(E)};v.floor=Gh;v.floorDiv=Qg;v.fused=Yj;v.gather=Hh;v.gatherND=kj;v.gather_util=Dg;v.getBackend=function(){return Ic.backendName};v.getGradient=ja;v.getKernel=ma;v.getKernelsForBackend=qa;v.grad=function(E){e(D(E),function(){return"The f passed in grad(f) must be a function"});return function(G,N){var Y=La(G,"x","tf.grad",null),ra=null!=N?La(N,"dy","tf.grad"):null;return Ic.tidy(function(){var Ha=Ic.gradients(function(){return E(Y)},[Y],
ra),ob=Ha.value;Ha=Ha.grads;null!=ra&&g(ob.shape,ra.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)");je(Ha);return Ha[0]})}};v.grads=function(E){e(D(E),function(){return"The f passed in grads(f) must be a function"});return function(G,N){e(Array.isArray(G),function(){return"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"});var Y=Fb(G,"args","tf.grads",null),ra=null!=N?La(N,"dy","tf.grads"):null;return Ic.tidy(function(){var Ha=
Ic.gradients(function(){return E.apply(void 0,Y)},Y,ra),ob=Ha.value;Ha=Ha.grads;null!=ra&&g(ob.shape,ra.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])");je(Ha);return Ha})}};v.greater=Ug;v.greaterEqual=ih;v.greaterEqualStrict=Fj;v.greaterStrict=ij;v.ifft=$i;v.imag=lh;v.image=vj;v.inTopKAsync=function(E,G,N){void 0===N&&(N=1);return r(this,void 0,void 0,function(){var Y,ra,Ha,ob,qb,Eb,hc,Fc,Oc,td,be,Fe,fe,Be;return u(this,function(Me){switch(Me.label){case 0:return Y=
La(E,"predictions","inTopK"),ra=La(G,"targets","inTopK"),e(1<Y.rank,function(){return"inTopK() expects the predictions to be of rank 2 or higher, but got "+Y.rank}),e(Y.rank-1===ra.rank,function(){return"predictions rank should be 1 larger than targets rank, but got predictions rank "+(Y.rank+" and targets rank "+ra.rank)}),g(Y.shape.slice(0,Y.shape.length-1),ra.shape,"predictions's shape should be align with the targets' shape, except the last dimension."),Ha=Y.shape[Y.shape.length-1],e(0<N&&N<=
Ha,function(){return"'k' passed to inTopK() must be \x3e 0 \x26\x26 \x3c\x3d the predictions last dimension ("+(Ha+"), but got "+N)}),[4,Y.data()];case 1:return ob=Me.sent(),[4,ra.data()];case 2:qb=Me.sent();Eb=[ob.length/Ha,Ha];hc=Eb[0];Fc=Eb[1];Oc=w("bool",hc);for(td=0;td<hc;td++){be=td*Fc;Fe=ob.subarray(be,be+Fc);fe=[];for(Be=0;Be<Fe.length;Be++)fe.push({value:Fe[Be],index:Be});fe.sort(function(hf,Se){return Se.value-hf.value});for(Be=Oc[td]=0;Be<N;Be++)if(fe[Be].index===qb[td]){Oc[td]=1;break}}E!==
Y&&Y.dispose();G!==ra&&ra.dispose();return[2,Mc(Oc,ra.shape,"bool")]}})})};v.io=fg;v.irfft=Ri;v.isFinite=pg;v.isInf=Rh;v.isNaN=Ph;v.keep=Ub;v.kernel_impls=Xf;v.leakyRelu=Uh;v.less=Kh;v.lessEqual=na;v.lessEqualStrict=hj;v.lessStrict=Xh;v.linalg=bk;v.linspace=function(E,G,N){if(0>=N)throw Error("The number of values should be positive.");return Ic.runKernelFunc(function(Y){return Y.linspace(E,G,N)},{},null,"LinSpace",{start:E,stop:G,num:N})};v.localResponseNormalization=R;v.log=x;v.log1p=P;v.logSigmoid=
rb;v.logSoftmax=Gc;v.logSumExp=cd;v.logicalAnd=rd;v.logicalNot=Pd;v.logicalOr=Od;v.logicalXor=ce;v.losses=$h;v.matMul=uf;v.math=Ng;v.max=Mb;v.maxPool=Yd;v.maxPool3d=ve;v.maxPoolWithArgmax=Ye;v.maximum=Ah;v.maximumStrict=qi;v.mean=jf;v.memory=function(){return Ic.memory()};v.min=kf;v.minimum=Af;v.minimumStrict=Pi;v.mirrorPad=Mf;v.mod=Rf;v.modStrict=yi;v.moments=lg;v.movingAverage=hi;v.mul=se;v.mulStrict=dj;v.multiRNNCell=eh;v.multinomial=Ih;v.neg=ca;v.nextFrame=function(){return new Promise(function(E){return Pe(function(){return E()})})};
v.norm=Qi;v.notEqual=Vg;v.notEqualStrict=kg;v.oneHot=ng;v.ones=wd;v.onesLike=oh;v.op=vb;v.outerProduct=Vh;v.pad=Yg;v.pad1d=$g;v.pad2d=Zg;v.pad3d=hh;v.pad4d=Lg;v.pool=vh;v.pow=ph;v.powStrict=fi;v.prelu=Li;v.print=ld;v.prod=gi;v.profile=function(E){return Ic.profile(E)};v.rand=oi;v.randomGamma=gj;v.randomNormal=Aj;v.randomUniform=qh;v.range=nf;v.ready=function(){return Ic.ready()};v.real=uh;v.reciprocal=Ai;v.registerBackend=function(E,G,N){void 0===N&&(N=1);return Ic.registerBackend(E,G,N)};v.registerGradient=
ua;v.registerKernel=Fa;v.relu=Lh;v.relu6=Wh;v.removeBackend=function(E){Ic.removeBackend(E)};v.reshape=zd;v.reverse=Jh;v.reverse1d=li;v.reverse2d=jj;v.reverse3d=Fi;v.reverse4d=Sj;v.rfft=aj;v.round=Zi;v.rsqrt=Gi;v.scalar=Qc;v.scatterND=ri;v.scatter_util=fh;v.selu=wi;v.separableConv2d=Hi;v.serialization=bh;v.setBackend=function(E){return Ic.setBackend(E)};v.setPlatform=function(E,G){pa().setPlatform(E,G)};v.setdiff1dAsync=function(E,G){return r(this,void 0,void 0,function(){var N,Y,ra,Ha,ob,qb,Eb,hc,
Fc,Oc;return u(this,function(td){switch(td.label){case 0:return N=La(E,"x","setdiff1d"),Y=La(G,"y","setdiff1d"),e(N.dtype===Y.dtype,function(){return"x and y should have the same dtype, but got x ("+N.dtype+") and y ("+Y.dtype+")."}),e(1===N.rank,function(){return"x should be 1D tensor, but got x ("+N.shape+")."}),e(1===Y.rank,function(){return"y should be 1D tensor, but got y ("+Y.shape+")."}),[4,N.data()];case 1:return ra=td.sent(),[4,Y.data()];case 2:Ha=td.sent();ob=new Set(Ha);for(Eb=qb=0;Eb<
ra.length;Eb++)ob.has(ra[Eb])||qb++;hc=new Ua([qb],N.dtype);Fc=new Ua([qb],"int32");for(Oc=Eb=0;Eb<ra.length;Eb++)ob.has(ra[Eb])||(hc.values[Oc]=ra[Eb],Fc.values[Oc]=Eb,Oc++);return[2,[hc.toTensor(),Fc.toTensor()]]}})})};v.sigmoid=Ab;v.sign=nj;v.signal=Ui;v.sin=yj;v.sinh=oj;v.slice=Qb;v.slice1d=dk;v.slice2d=mj;v.slice3d=ek;v.slice4d=Rj;v.slice_util=Kg;v.softmax=Mj;v.softplus=Ka;v.spaceToBatchND=zg;v.sparseToDense=Bi;v.spectral=Jj;v.split=xi;v.sqrt=Bh;v.square=Bf;v.squaredDifference=bj;v.squaredDifferenceStrict=
Nh;v.squeeze=Ni;v.stack=mi;v.step=ji;v.stridedSlice=Nj;v.sub=Zb;v.subStrict=Cj;v.sum=Yb;v.sumOutType=function(E){return ha(E,"int32")};v.tan=Ci;v.tanh=cc;v.tensor=Mc;v.tensor1d=We;v.tensor2d=Lf;v.tensor3d=Pc;v.tensor4d=function(E,G,N){d(E);if(null!=G&&4!==G.length)throw Error("tensor4d() requires shape to have four numbers");var Y=Pb(E,N);if(4!==Y.length&&1!==Y.length)throw Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===Y.length&&null==G)throw Error("tensor4d() requires shape to be provided when `values` are a flat array");
return Xb(E,G,Y,N)};v.tensor5d=function(E,G,N){d(E);if(null!=G&&5!==G.length)throw Error("tensor5d() requires shape to have five numbers");var Y=Pb(E,N);if(5!==Y.length&&1!==Y.length)throw Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===Y.length&&null==G)throw Error("tensor5d() requires shape to be provided when `values` are a flat array");return Xb(E,G,Y,N)};v.tensor6d=function(E,G,N){d(E);if(null!=G&&6!==G.length)throw Error("tensor6d() requires shape to have six numbers");
var Y=Pb(E,N);if(6!==Y.length&&1!==Y.length)throw Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===Y.length&&null==G)throw Error("tensor6d() requires shape to be provided when `values` are a flat array");return Xb(E,G||Y,Y,N)};v.tensor_util=Xc;v.test_util=Cg;v.tidy=Rb;v.tile=og;v.time=function(E){return Ic.time(E)};v.topk=cj;v.train=Ke;v.transpose=hg;v.truncatedNormal=Ej;v.unique=Oj;v.unregisterGradient=function(E){if(!Df.has(E))throw Error("The gradient '"+E+
"' for backend is not registered");Df.delete(E)};v.unregisterKernel=function(E,G){var N=G+"_"+E;if(!Zf.has(N))throw Error("The kernel '"+E+"' for backend '"+(G+"' is not registered"));Zf.delete(N)};v.unsortedSegmentSum=rj;v.unstack=Mi;v.upcastType=ha;v.util=rg;v.valueAndGrad=function(E){e(D(E),function(){return"The f passed in valueAndGrad(f) must be a function"});return function(G,N){e(G instanceof Da,function(){return"The x passed in valueAndGrad(f)(x) must be a tensor"});e(null==N||N instanceof
Da,function(){return"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"});var Y=Ic.gradients(function(){return E(G)},[G],N);N=Y.grads;Y=Y.value;je(N);return{grad:N[0],value:Y}}};v.valueAndGrads=function(E){e(D(E),function(){return"The f passed in valueAndGrads(f) must be a function"});return function(G,N){e(Array.isArray(G)&&G.every(function(ra){return ra instanceof Da}),function(){return"The args passed in valueAndGrads(f)(args) must be array of tensors"});e(null==N||N instanceof Da,function(){return"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"});
var Y=Ic.gradients(function(){return E.apply(void 0,G)},G,N);null!=N&&g(Y.value.shape,N.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])");je(Y.grads);return Y}};v.variable=function(E,G,N,Y){void 0===G&&(G=!0);return Ic.makeVariable(E,G,N,Y)};v.variableGrads=ud;v.version_core="2.7.0";v.where=cg;v.whereAsync=pi;v.zeros=sd;v.zerosLike=Ef};
shadow$provide[949]=function(W,A,la,v){function t(na,R){function x(){this.constructor=na}ug(na,R);na.prototype=null===R?Object.create(R):(x.prototype=R.prototype,new x)}function r(na,R,x,P){return new (x||(x=Promise))(function(ca,Ka){function rb(Yb){try{Zb(P.next(Yb))}catch(Gc){Ka(Gc)}}function Mb(Yb){try{Zb(P["throw"](Yb))}catch(Gc){Ka(Gc)}}function Zb(Yb){Yb.done?ca(Yb.value):(new x(function(Gc){Gc(Yb.value)})).then(rb,Mb)}Zb((P=P.apply(na,R||[])).next())})}function u(na,R){function x(Yb){return function(Gc){return P([Yb,
Gc])}}function P(Yb){if(Ka)throw new TypeError("Generator is already executing.");for(;ca;)try{if(Ka=1,rb&&(Mb=Yb[0]&2?rb["return"]:Yb[0]?rb["throw"]||((Mb=rb["return"])&&Mb.call(rb),0):rb.next)&&!(Mb=Mb.call(rb,Yb[1])).done)return Mb;if(rb=0,Mb)Yb=[Yb[0]&2,Mb.value];switch(Yb[0]){case 0:case 1:Mb=Yb;break;case 4:return ca.label++,{value:Yb[1],done:!1};case 5:ca.label++;rb=Yb[1];Yb=[0];continue;case 7:Yb=ca.ops.pop();ca.trys.pop();continue;default:if(!(Mb=ca.trys,Mb=0<Mb.length&&Mb[Mb.length-1])&&
(6===Yb[0]||2===Yb[0])){ca=0;continue}if(3===Yb[0]&&(!Mb||Yb[1]>Mb[0]&&Yb[1]<Mb[3]))ca.label=Yb[1];else if(6===Yb[0]&&ca.label<Mb[1])ca.label=Mb[1],Mb=Yb;else if(Mb&&ca.label<Mb[2])ca.label=Mb[2],ca.ops.push(Yb);else{Mb[2]&&ca.ops.pop();ca.trys.pop();continue}}Yb=R.call(na,ca)}catch(Gc){Yb=[6,Gc],rb=0}finally{Ka=Mb=0}if(Yb[0]&5)throw Yb[1];return{value:Yb[0]?Yb[1]:void 0,done:!0}}var ca={label:0,sent:function(){if(Mb[0]&1)throw Mb[1];return Mb[1]},trys:[],ops:[]},Ka,rb,Mb,Zb;return Zb={next:x(0),
"throw":x(1),"return":x(2)},"function"===typeof Symbol&&(Zb[Symbol.iterator]=function(){return this}),Zb}function f(){null==Cf&&(Cf=Kb.backend().epsilon());return Cf}function a(){return"channelsLast"}function b(na,R){if(Array.isArray(na))for(var x=[],P=0;P<R;P++)x=x.concat(na);else x=Array(R),x.fill(na);return x}function e(na,R){if(!na)throw new va(R);}function g(na,R){for(var x=0,P=0;P<na.length;P++)na[P]===R&&x++;return x}function d(na){return 1===na.length?na[0]:na}function h(na){return Array.isArray(na)?
na:[na]}function c(na){na=na.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==na[0]?na:"private"+na}function l(na){return 1>=na.length||-1===na.indexOf("_")?na:na.replace(/[_]+(\w|$)/g,function(R,x){return x.toUpperCase()})}function m(na){if(null===na||void 0===na)return null;var R={};R.className=na.getClassName();R.config=na.getConfig();return R}function n(na){if(null!=na&&"object"===typeof na)if(Array.isArray(na))na.forEach(function(Ka){return n(Ka)});
else for(var R=0,x=Object.keys(na);R<x.length;R++){var P=x[R],ca=na[P];null!=ca&&"object"===typeof ca&&(Array.isArray(ca)||"ndarray"!==ca.type||"number"!==typeof ca.value?n(ca):na[P]=ca.value)}}function k(na,R,x,P,ca){void 0===R&&(R={});void 0===x&&(x={});void 0===P&&(P="object");void 0===ca&&(ca=!1);if("string"===typeof na){if(na in x)x=x[na];else if(na in eb)x=eb[na];else if(x=R[na],null==x)throw new ad("Unknown "+P+": "+na+". This may be due to one of the following reasons:\n1. The "+(P+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ")+
(P+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass()."));return x}if(null==na.className||null==na.config)throw new ad(P+": Improper config format: "+(JSON.stringify(na)+".\n'className' and 'config' must set."));var Ka=na.className,rb=void 0;var Mb=void 0;Ka in x?(Mb=x[Ka],rb=Mb[0],Mb=Mb[1]):Ka in eb?(Mb=eb.className,rb=Mb[0],Mb=Mb[1]):Ka in R&&(Mb=R[Ka],rb=Mb[0],Mb=Mb[1]);if(null==rb)throw new ad("Unknown "+P+": "+Ka+". This may be due to one of the following reasons:\n1. The "+
(P+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ")+(P+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass()."));if(null!=Mb){Ka={};R=0;for(var Zb=Object.keys(eb);R<Zb.length;R++)P=Zb[R],Ka[P]=eb[P];R=0;for(Zb=Object.keys(x);R<Zb.length;R++)P=Zb[R],Ka[P]=x[P];na.config.customObjects=Ka;Ka=sf({},eb);R=0;for(Zb=Object.keys(x);R<Zb.length;R++)P=Zb[R],eb[P]=x[P];n(na.config);na=Mb(rb,na.config,
x,ca)}else{Ka=sf({},eb);ca=0;for(Mb=Object.keys(x);ca<Mb.length;ca++)P=Mb[ca],eb[P]=x[P];na=new rb(na.config)}eb=sf({},Ka);return na}function p(na,R){return-1*(na<R?-1:na>R?1:0)}function q(na){if(null==na)return na;for(var R=[],x=0;x<na.length;x++){var P=na[x];-1===R.indexOf(P)&&R.push(P)}return R}function w(na){if(null==na)throw new ad("Invalid value in obj: "+JSON.stringify(na));for(var R in na)if(na.hasOwnProperty(R))return!1;return!0}function y(na,R,x){if(null!=x&&0>na.indexOf(x))throw new ad(x+
" is not a valid "+R+".  Valid values are "+na+" or null/undefined.");}function C(na,R,x,P){void 0===x&&(x=0);void 0===P&&(P=Infinity);e(0<=x);e(P>=x);return Array.isArray(na)&&na.length>=x&&na.length<=P&&na.every(function(ca){return typeof ca===R})}function z(na,R){Array.isArray(na)?(Kb.util.assert(0<na.length,function(){return R+" is unexpectedly an empty array."}),na.forEach(function(x,P){return z(x,"element "+(P+1)+" of "+R)})):Kb.util.assert(Number.isInteger(na)&&0<na,function(){return"Expected "+
R+" to be a positive integer, but got "+(K(na)+".")})}function K(na){return null===na?"null":Array.isArray(na)?"["+na.map(function(R){return K(R)}).join(",")+"]":"string"===typeof na?'"'+na+'"':""+na}function J(na,R){var x=Kb.util.now(),P;return function(){for(var ca=[],Ka=0;Ka<arguments.length;Ka++)ca[Ka]=arguments[Ka];Ka=Kb.util.now();if(Ka-x<R)return P;x=Ka;return P=na.apply(void 0,ca)}}function B(na){return"relu"===na?"relu":"linear"===na?"linear":"elu"===na?"elu":null}function O(na,R){return Kb.tidy(function(){return Kb.sqrt(Kb.sum(Kb.mul(na,
na),R,!0))})}function Q(na,R){void 0===R&&(R={});return k(na,Kb.serialization.SerializationMap.getMap().classNameMap,R,"constraint")}function V(na){return null==na?null:"string"===typeof na?Q({className:na in Gb?Gb[na]:na,config:{}}):na instanceof ub?na:Q(na)}function M(na){y(Vb,"DataFormat",na)}function F(na){y(Hc,"PaddingMode",na)}function D(na,R){ze.push(na);try{var x=R();ze.pop();return x}catch(P){throw ze.pop(),P;}}function H(na){if(!na.match(ef))throw Error("Not a valid tensor name: '"+na+"'");
var R=0===ze.length?"":ze.join("/")+"/";return R+na}function U(na){if(!na.match(ef))throw Error("Not a valid tensor name: '"+na+"'");ae.has(na)||ae.set(na,0);var R=ae.get(na);ae.set(na,ae.get(na)+1);return 0<R?(na=na+"_"+R,ae.set(na,1),na):na}function L(na,R,x){null==R&&(R=0);null==x&&(x=na.length);for(var P=1;R<x;++R)P*=na[R];return P}function I(na){na=Array.isArray(na)?new Float32Array(na):na;return Kb.tensor1d(na)}function T(na){return Kb.min(I(na)).dataSync()[0]}function aa(na){return Kb.max(I(na)).dataSync()[0]}
function ba(na,R){if(R<na)throw new ad("end ("+R+") \x3c begin ("+na+") is forbidden.");for(var x=[];na<R;++na)x.push(na);return x}function Z(na,R){return na.asType(R)}function da(na,R){void 0===R&&(R=-1);var x=na.shape.slice();0>R&&(R=x.length+R+1);x.splice(R,0,1);return na.reshape(x)}function pa(na,R){return Kb.tidy(function(){if(2!==na.shape.length)throw new ad("repeat() expects a rank-2 tensor, but received a rank-"+(na.shape.length+" tensor."));var x=da(na,1);return Fa(x,[1,R,1])})}function fa(na,
R,x){return Kb.tidy(function(){switch(na.rank){case 1:return Kb.slice1d(na,R,x);case 2:return Kb.slice2d(na,[R,0],[x,na.shape[1]]);case 3:return Kb.slice3d(na,[R,0,0],[x,na.shape[1],na.shape[2]]);case 4:return Kb.slice4d(na,[R,0,0,0],[x,na.shape[1],na.shape[2],na.shape[3]]);case 5:return Kb.slice(na,[R,0,0,0,0],[x,na.shape[1],na.shape[2],na.shape[3],na.shape[4]]);case 6:return Kb.slice(na,[R,0,0,0,0,0],[x,na.shape[1],na.shape[2],na.shape[3],na.shape[4],na.shape[5]]);default:throw new ad("sliceAlongFirstAxis() received an unsupported tensor rank: "+
na.rank);}})}function ta(na,R,x){return Kb.tidy(function(){switch(na.rank){case 1:return Kb.slice1d(na,R,x);case 2:return Kb.slice2d(na,[0,R],[na.shape[0],x]);case 3:return Kb.slice3d(na,[0,0,R],[na.shape[0],na.shape[1],x]);case 4:return Kb.slice4d(na,[0,0,0,R],[na.shape[0],na.shape[1],na.shape[2],x]);default:throw new ad("sliceAlongLastAxis() received an unsupported tensor rank: "+na.rank);}})}function ma(na,R,x,P){return Kb.tidy(function(){switch(na.rank){case 1:return Kb.slice1d(na,R,x);case 2:switch(P){case 1:return fa(na,
R,x);case 2:return ta(na,R,x);default:throw new ad("The axis is not within the rank of the tensor "+P);}case 3:switch(P){case 1:return fa(na,R,x);case 2:return Kb.slice3d(na,[0,R,0],[na.shape[0],x,na.shape[2]]);case 3:return ta(na,R,x);default:throw new ad("The axis is not within the rank of the tensor "+P);}case 4:switch(P){case 1:return fa(na,R,x);case 2:return Kb.slice4d(na,[0,R,0,0],[na.shape[0],x,na.shape[2],na.shape[3]]);case 3:return Kb.slice4d(na,[0,0,R,0],[na.shape[0],na.shape[1],x,na.shape[3]]);
case 4:return ta(na,R,x);default:throw new ad("The axis is not within the rank of the tensor "+P);}default:throw new ad("sliceAlongLastAxis() received an unsupported tensor rank: "+na.rank);}})}function ja(na,R){void 0===R&&(R=-1);0>R&&(R=na[0].rank,R=0!==R?R:0);R===na[0].rank&&(R=-1);return Kb.concat(na,R)}function qa(na,R){switch(na.rank){case 1:return Kb.concat1d([na,R]);case 2:return Kb.concat2d([na,R],0);case 3:return Kb.concat3d([na,R],0);case 4:return Kb.concat4d([na,R],0);default:throw new ad("concatAlongFirstAxis() received an unsupported tensor rank: "+
na.rank);}}function Fa(na,R){Array.isArray(R)||(R=[R]);if(na.rank!==R.length)throw new ad("The length of input n ("+R.length+") does not match the number of dimensions in input x ("+(na.rank+")"));return Kb.tile(na,R)}function ua(na,R,x,P,ca){void 0===R&&(R=0);void 0===x&&(x=1);return Kb.randomNormal(na,R,x,P,ca)}function Ra(na,R,x,P){if(2>na.rank||2>R.rank)throw new $e("dot requires both inputs to be rank \x3e\x3d 2 but got x shape \x3d "+(na.shape+" and y shape \x3d "+R.shape));if(3<=R.rank){var ca=
na.shape.slice(-1)[0],Ka=R.shape.slice(-2)[0];if(ca!==Ka)throw new $e("If rank y \x3e\x3d 3, then the second last dim of y must equal the last dim of x but got x shape \x3d "+(na.shape+" and  y shape \x3d ")+R.shape);}if(2===na.rank&&2===R.rank)return Kb.fused.matMul({a:na,b:R,transposeA:!1,transposeB:!1,bias:P?Ba(na.rank,P,a()):null,activation:x});ca=na.shape.slice();Ka=ca.pop();na=na.reshape([-1,Ka]);var rb=R.shape.slice(),Mb=rb.pop();Ka=rb.pop();rb=rb.concat([Mb]);Mb=Array.from({length:R.rank},
function(Zb,Yb){return 0===Yb?R.rank-2:Yb<=R.rank-2?Yb-1:Yb});R=R.transpose(Mb).reshape([Ka,-1]);Ka=ca.concat(rb);return Kb.fused.matMul({a:na,b:R,transposeA:!1,transposeB:!1,bias:P?Ba(na.rank,P,a()):null,activation:x}).reshape(Ka)}function Ia(na,R,x){return Kb.tidy(function(){R=Array.isArray(R)?Kb.tensor1d(R,"int32"):R.toInt();return Kb.gather(na,R,x)})}function oa(na){return Kb.mul(na,na)}function Ba(na,R,x){var P=R.shape;if(1!==R.rank&&R.rank!==na)throw new ad("Unexpected bias dimensions: "+R.rank+
("; expected it to be 1 or "+na));if(5===na){if("channelsFirst"===x)return 1===P.length?R.reshape([1,P[0],1,1,1]):R.reshape([1,P[3],P[0],P[1],P[2]]);if("channelsLast"===x)return 1===P.length?R.reshape([1,1,1,1,P[0]]):R.reshape([1].concat(P))}else if(4===na){if("channelsFirst"===x)return 1===P.length?R.reshape([1,P[0],1,1]):R.reshape([1,P[2],P[0],P[1]]);if("channelsLast"===x)return 1===P.length?R.reshape([1,1,1,P[0]]):R.reshape([1].concat(P))}else if(3===na){if("channelsFirst"===x)return 1===P.length?
R.reshape([1,P[0],1]):R.reshape([1,P[1],P[0]]);if("channelsLast"===x)return 1===P.length?R.reshape([1,1,P[0]]):R.reshape([1].concat(P))}else if(3>na)return R;throw new ad("Unsupported input rank by biasAdd: "+R.rank);}function gb(na,R,x){return Kb.tidy(function(){null==x&&(x=a());M(x);return na.add(Ba(na.rank,R,x))})}function Va(na){return Kb.tidy(function(){return Kb.div(na,Kb.abs(na).add(1))})}function Ma(na,R,x,P){return Kb.tidy(function(){return Kb.dropout(na,R,x,P)})}function ib(na){return Kb.tidy(function(){var R=
Kb.add(.5,Kb.mul(.2,na));return Kb.clipByValue(R,0,1)})}function Ja(na,R,x){void 0===x&&(x=!1);return x?na():R()}function Sa(na,R){void 0===R&&(R={});return k(na,Kb.serialization.SerializationMap.getMap().classNameMap,R,"initializer")}function S(na){if("string"===typeof na){na=na in id?id[na]:na;if("GlorotNormal"===na)return new $b;if("GlorotUniform"===na)return new Bb;if("HeNormal"===na)return new wc;if("HeUniform"===na)return new Rc;if("LeCunNormal"===na)return new Zc;if("LeCunUniform"===na)return new Xc;
var R={};R.className=na;R.config={};return Sa(R)}return na instanceof Df?na:Sa(na)}function ha(na){void 0===na&&(na="");na in Kd||(Kd[na]=0);Kd[na]+=1;return na+Kd[na].toString()}function ya(na){return Array.isArray(na)&&Array.isArray(na[0])}function Qa(na){return 0===na.length?[]:Array.isArray(na[0])?na:[na]}function $a(na){if(Array.isArray(na)){if(1!==na.length)throw new ad("Expected Tensor length to be 1; got "+na.length);na=na[0]}return na}function cb(na){if(Array.isArray(na)&&Array.isArray(na[0])){if(1===
na.length)return na[0];throw new ad("Expected exactly 1 Shape; got "+na.length);}return na}function wa(na){for(var R=0,x=0;x<na.length;x++){var P=na[x];R=0===P.shape.length?R+1:R+P.shape.reduce(function(ca,Ka){return ca*Ka})}return R}function Aa(na){return na.map(function(R){return R.read()})}function lb(na){na.forEach(function(R){R[0].write(R[1])})}function Ya(na){na=h(na);for(var R=[],x=0;x<na.length;x++)R.push(na[x].shape);return d(R)}function Pb(na,R,x){if(null==R||null!=x&&0<x)R=na.sourceLayer,
x=na.nodeIndex;if(0===R.inboundNodes.length)return[na];na=R.inboundNodes[x];if(0===na.inboundLayers.length)return na.inputTensors;R=[];for(x=0;x<na.inboundLayers.length;x++)for(var P=0,ca=Pb(na.inputTensors[x],na.inboundLayers[x],na.nodeIndices[x]);P<ca.length;P++){var Ka=ca[P];-1===R.indexOf(Ka)&&R.push(Ka)}return R}function tb(na){if(null==na.batchShape&&null==na.shape)throw Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
if(null!=na.batchShape&&null!=na.shape)throw new ad("Please provide either a `shape` or `batchShape` argument to Input, but not both.");var R=na.batchShape;null!=na.shape&&null==R&&(R=[null].concat(na.shape));var x=na.dtype;null==x&&(x="float32");return(new le({batchInputShape:R,name:na.name,dtype:x,sparse:na.sparse})).inboundNodes[0].outputTensors[0]}function bb(na){return r(this,void 0,void 0,function(){var R,x,P,ca,Ka,rb,Mb,Zb;return u(this,function(Yb){switch(Yb.label){case 0:if(null==na)return[2];
R=[];x=[];P=[];for(ca in na)Ka=na[ca],"number"!==typeof Ka&&(rb=Ka,R.push(rb.data()),x.push(ca),P.push(rb));return 0<R.length?[4,Promise.all(R)]:[3,2];case 1:Mb=Yb.sent();for(Zb=0;Zb<Mb.length;++Zb)na[x[Zb]]=Mb[Zb][0];Kb.dispose(P);Yb.label=2;case 2:return[2]}})})}function La(na){if(null!=na)for(var R in na){var x=na[R];"number"!==typeof x&&x.dispose()}}function Fb(na,R){null==na&&(na={});return na instanceof Ae?[na]:Array.isArray(na)&&na[0]instanceof Ae?na:h(na).map(function(x){return new ec(x,R)})}
function vb(na,R,x,P,ca,Ka,rb,Mb,Zb){var Yb=new Hb,Gc=[new yb].concat(Bc.createCallbacks(R));null!=na&&Gc.push.apply(Gc,na);Gc.push(Yb);na=new kb(Gc);na.setParams({epochs:x,initialEpoch:P,samples:ca,steps:Ka,batchSize:rb,verbose:R,doValidation:Mb,metrics:Zb});return{callbackList:na,history:Yb}}function Xb(na,R,x){void 0===R&&(R={});void 0===x&&(x=!1);return k(na,Kb.serialization.SerializationMap.getMap().classNameMap,R,"layer",x)}function Mc(na,R){return Kb.tidy(function(){"float32"!==na.dtype&&(na=
na.asType("float32"));var x=Kb.sum(oa(na),R,!0),P=Kb.fill(x.shape,f());x=Kb.sqrt(Kb.maximum(x,P));return Kb.div(na,x)})}function Yc(na,R){return Kb.tidy(function(){return Kb.mean(oa(Kb.sub(R,na)),-1)})}function yd(na,R){return Kb.tidy(function(){return Kb.mean(Kb.abs(Kb.sub(R,na)),-1)})}function pd(na,R){return Kb.tidy(function(){var x=Kb.sub(na,R),P=Kb.clipByValue(Kb.abs(na),f(),Number.MAX_VALUE);x=Kb.abs(Kb.div(x,P));return Kb.mul(100,Kb.mean(x,-1))})}function sc(na,R,x){void 0===x&&(x=!1);return Kb.tidy(function(){if(x)R=
Kb.softmax(R);else{var P=Kb.sum(R,R.shape.length-1,!0);R=Kb.div(R,P)}R=Kb.clipByValue(R,f(),1-f());return Kb.neg(Kb.sum(Kb.mul(na.toFloat(),Kb.log(R)),R.shape.length-1))})}function tc(na,R,x){void 0===x&&(x=!1);return Kb.tidy(function(){var P=Kb,ca=P.floor;var Ka=[L(na.shape)];Ka=na.reshape(Ka);P=ca.call(P,Ka).toInt();R=Kb.clipByValue(R,f(),1-f());ca=R.shape;P=Kb.oneHot(P,ca[ca.length-1]).reshape(ca);return sc(P,R,x)})}function vc(na,R){if(!Kb.util.arraysEqual(na.shape,R.shape))throw new ad("logits and labels must have the same shape, but got shapes "+
(JSON.stringify(na.shape)+" and "+JSON.stringify(R.shape)));return Kb.tidy(function(){var x=R.relu(),P=R.abs().neg();return x.sub(R.mul(na)).add(P.exp().log1p())})}function $c(na,R){return Kb.tidy(function(){var x=Kb.clipByValue(R,f(),1-f());x=Kb.log(Kb.div(x,Kb.sub(1,x)));return Kb.mean(vc(na,x),-1)})}function xd(na,R){return Kb.tidy(function(){var x=Mc(na,-1),P=Mc(R,-1);x=Kb.mul(x,P);return Kb.neg(Kb.sum(x,-1))})}function ab(na){if("string"===typeof na){if(na in Sc)return Sc[na];var R="Unknown loss "+
na;na.toLowerCase().includes("softmaxcrossentropy")&&(R="Unknown loss "+na+'. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy');throw new ad(R);}return na}function Ta(na,R){return Kb.tidy(function(){var x=Kb.mul(.5,Kb.onesLike(R));x=Z(Kb.greater(R,x),na.dtype);return Kb.mean(Kb.equal(na,x),-1)})}function jb(na,R){return Kb.tidy(function(){return Z(Kb.equal(Kb.argMax(na,-1),Kb.argMax(R,-1)),"float32")})}function Wb(na,R){return Kb.tidy(function(){return Kb.logicalAnd(na.equal(1),
R.equal(1)).sum().cast("float32")})}function xc(na,R){return Kb.tidy(function(){return Kb.logicalAnd(na.equal(1),R.equal(0)).sum().cast("float32")})}function Ec(na,R){return Kb.tidy(function(){return Kb.logicalAnd(na.equal(0),R.equal(1)).sum().cast("float32")})}function dd(na,R){return Kb.tidy(function(){var x=Wb(na,R),P=Ec(na,R);P=x.add(P);return Kb.where(Kb.greater(P,0),x.div(P),0).cast("float32")})}function Dc(na,R){return Kb.tidy(function(){var x=Wb(na,R),P=xc(na,R);P=x.add(P);return Kb.where(Kb.greater(P,
0),x.div(P),0).cast("float32")})}function kd(na,R){return $c(na,R)}function ld(na,R){na.rank===R.rank&&(na=na.squeeze([na.rank-1]));R=R.argMax(-1);R.dtype!==na.dtype&&(R=R.asType(na.dtype));return Kb.equal(na,R).asType("float32")}function Nb(na){e(null!==na,"Unknown LossOrMetricFn "+na);if("string"===typeof na)return na;for(var R=void 0,x=0,P=Object.keys(Sc);x<P.length;x++){var ca=P[x];if(Sc[ca]===na){R=ca;break}}if(void 0!==R)return R;x=0;for(P=Object.keys(Uc);x<P.length;x++)if(ca=P[x],Uc[ca]===
na){R=ca;break}return void 0!==R?R:na.name}function Sb(na){var R={Adagrad:function(){return Kb.train.adagrad(.01)},Adadelta:function(){return Kb.train.adadelta(1,.95,f())},Adam:function(){return Kb.train.adam(.001,.9,.999,f())},Adamax:function(){return Kb.train.adamax(.002,.9,.999,f(),0)},RMSProp:function(){return Kb.train.rmsprop(.001,.9,0,f())},SGD:function(){return Kb.train.sgd(.01)}};R.adagrad=R.Adagrad;R.adadelta=R.Adadelta;R.adam=R.Adam;R.adamax=R.Adamax;R.rmsprop=R.RMSProp;R.sgd=R.SGD;if(na in
R)return R[na]();throw new ad("Unknown Optimizer "+na);}function Tb(na,R,x){void 0===x&&(x=!1);if(null==na||"object"!==typeof na||Object.getPrototypeOf(na)!==Object.prototype||!Ac(na))throw Error("User-defined metadata is expected to be a JSON object, but is not.");x&&(na=JSON.stringify(na),1048576<na.length&&console.warn('User-defined metadata of model "'+R+'" is too large in size (length\x3d'+(na.length+" when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is \x3c\x3d 1048576.")))}
function Ac(na){if(null===na)return!0;if("object"===typeof na){if(Object.getPrototypeOf(na)===Object.prototype){for(var R=0,x=Object.keys(na);R<x.length;R++){var P=x[R];if("string"!==typeof P||!Ac(na[P]))return!1}return!0}if(Array.isArray(na)){for(R=0;R<na.length;R++)if(!Ac(na[R]))return!1;return!0}return!1}na=typeof na;return"string"===na||"number"===na||"boolean"===na}function Kc(na,R,x,P){void 0===P&&(P=console.log);var ca=Pc(na),Ka=["Layer (type)","Output shape","Param #"];ca?(R=R||65,x=x||[.45,
.85,1]):(R=R||98,x=x||[.33,.55,.67,1]);1>=x[x.length-1]&&(x=x.map(function(Zb){return Math.floor(R*Zb)}));if(!ca){Ka.push("Receives inputs");var rb=[];for(var Mb in na.nodesByDepth)rb.push.apply(rb,na.nodesByDepth[Mb])}P("_".repeat(R));gd(Ka,x,P);P("\x3d".repeat(R));Ka=na.layers;for(Mb=0;Mb<Ka.length;++Mb)ca?Dd(Ka[Mb],x,P):Jd(Ka[Mb],x,rb,P),P((Mb===Ka.length-1?"\x3d":"_").repeat(R));na.checkTrainableWeightsConsistency();x=Vc(na);na=wa(na.nonTrainableWeights);P("Total params: "+(x+na));P("Trainable params: "+
x);P("Non-trainable params: "+na);P("_".repeat(R))}function Vc(na){return null!=na.collectedTrainableWeights?wa(na.collectedTrainableWeights):wa(na.trainableWeights)}function Pc(na){var R=!0,x=[],P=[],ca;for(ca in na.nodesByDepth)x.push(na.nodesByDepth[ca]);for(ca=0;ca<x.length;ca++){var Ka=x[ca];if(1<Ka.length||1===Ka.length&&1<Ka[0].inboundLayers.length){R=!1;break}P.push.apply(P,Ka)}if(R)for(x=0,na=na.layers;x<na.length;x++){ca=!1;Ka=0;for(var rb=na[x].inboundNodes;Ka<rb.length;Ka++)if(-1!==P.indexOf(rb[Ka]))if(ca){R=
!1;break}else ca=!0;if(!R)break}return R}function gd(na,R,x){void 0===x&&(x=console.log);for(var P="",ca=0;ca<na.length;++ca)0<ca&&(P=P.slice(0,P.length-1)+" "),P+=na[ca],P=P.slice(0,R[ca]),P+=" ".repeat(R[ca]-P.length);x(P)}function Dd(na,R,x){try{var P=JSON.stringify(na.outputShape)}catch(rb){P="multiple"}var ca=na.name,Ka=na.getClassName();na=[ca+" ("+Ka+")",P,na.countParams().toString()];gd(na,R,x)}function Jd(na,R,x,P){try{var ca=JSON.stringify(na.outputShape)}catch(Gc){ca="multiple"}for(var Ka=
[],rb=0,Mb=na.inboundNodes;rb<Mb.length;rb++){var Zb=Mb[rb];if(!(null!=x&&0<x.length&&-1===x.indexOf(Zb)))for(var Yb=0;Yb<Zb.inboundLayers.length;++Yb)Ka.push(Zb.inboundLayers[Yb].name+"["+Zb.nodeIndices[Yb]+"]["+Zb.tensorIndices[Yb]+"]")}x=na.name;rb=na.getClassName();Mb=0===Ka.length?"":Ka[0];na=[x+" ("+rb+")",ca,na.countParams().toString(),Mb];gd(na,R,P);for(Yb=1;Yb<Ka.length;++Yb)gd(["","","",Ka[Yb]],R,P)}function we(na,R,x){return("inboundNodes"===na||"outputLayers"===na||"inputLayers"===na)&&
0===R&&"string"===typeof x}function Ne(na,R){if(null===na)return null;if("string"===typeof na)return l(na);if("number"===typeof na||"boolean"===typeof na)return na;if(na instanceof Array){for(var x=[],P=na.length,ca=0;ca<P;++ca){var Ka=na[ca];we(R,ca,Ka)?x.push(Ka):x.push(Ne(Ka,R))}return x}R={};x=0;for(P=Object.keys(na);x<P.length;x++)Ka=P[x],ca=na[Ka],"name"===Ka&&"string"===typeof ca?R[Ka]=ca:(Ka=l(Ka),R[Ka]=Ne(ca,Ka));return R}function Je(na,R){if(null===na||void 0===na)return null;if("string"===
typeof na)return c(na);if("number"===typeof na||"boolean"===typeof na)return na;if(na instanceof Array){for(var x=[],P=na.length,ca=0;ca<P;++ca){var Ka=na[ca];we(R,ca,Ka)?x.push(Ka):x.push(Je(Ka,R))}return x}R={};x=0;for(P=Object.keys(na);x<P.length;x++){ca=P[x];Ka=na[ca];var rb=c(ca);R[rb]="name"!==ca&&"className"!==ca||"string"!==typeof Ka?Je(Ka,ca):Ka}return R}function Qe(na,R,x,P){var ca=null==x?!1:x.training,Ka=Array.isArray(na),rb=Ka?na:[na];na=rb.map(function(Mf){return Mf.name});for(var Mb=
[],Zb=R.names(),Yb=0;Yb<na.length;Yb++){var Gc=na[Yb];-1!==Zb.indexOf(Gc)?Mb.push(R.getValue(Gc)):Mb.push(null)}null!=P&&(P.maxNumTensors=-Infinity,P.minNumTensors=Infinity);Yb=na.join(",")+"|"+R.names().join(",");null==Sd[Yb]&&(Zb=Ce(rb,R),rb=Zb.sorted,Zb=Zb.recipientCounts,Sd[Yb]=rb,Xe[Yb]=Zb);rb=Sd[Yb];Zb={};ca||Object.assign(Zb,Xe[Yb]);Yb=new Ed(R);for(Gc=0;Gc<rb.length;++Gc){if(null!=P){var cd=Kb.memory().numTensors;cd>P.maxNumTensors&&(P.maxNumTensors=cd);cd<P.minNumTensors&&(P.minNumTensors=
cd)}var rd=rb[Gc],Pd=rd.sourceLayer;if(!(Pd instanceof le)){var Od=[],ce=[];cd=[];for(var Yd=!1,ve=0,Ye=rd.inputs;ve<Ye.length;ve++){var jf=Ye[ve],kf=Yb.getValue(jf),Af=Yb.getMask(jf);Od.push(kf);ce.push(Af);null!=Af&&(Yd=!0);ca||(Zb[jf.name]--,0!==Zb[jf.name]||R.hasKey(jf)||-1!==na.indexOf(jf.name)||kf.isDisposed||!0===jf.sourceLayer.stateful||cd.push(kf))}Yd&&(x=x||{},x.mask=ce[0]);Yd=h(Pd.apply(Od,x));ve=null;Pd.supportsMasking&&(ve=Pd.computeMask(Od,ce));rd=Ud(rd);rd=Array.isArray(rd)?rd:[rd];
for(Pd=0;Pd<rd.length;++Pd)Yb.hasKey(rd[Pd])||Yb.add(rd[Pd],Yd[Pd],Array.isArray(ve)?ve[0]:ve),Od=na.indexOf(rd[Pd].name),-1!==Od&&(Mb[Od]=Yd[Pd]);ca||Kb.dispose(cd)}}Yb.disposeMasks();return Ka?Mb:Mb[0]}function Ce(na,R){Kb.util.assert(null!=na&&0<na.length,function(){return"Expected at least one fetch, got none"});var x=[],P={};if(1===na.length)na=od(na[0],R),x=na.sorted,P=na.recipientMap;else for(var ca=new Set,Ka=0;Ka<na.length;Ka++){var rb=od(na[Ka],R),Mb=rb.recipientMap,Zb=0;for(rb=rb.sorted;Zb<
rb.length;Zb++){var Yb=rb[Zb];ca.has(Yb.name)||(x.push(Yb),ca.add(Yb.name))}Zb=function(cd){null==P[cd]&&(P[cd]=new Set);Mb[cd].forEach(function(rd){return P[cd].add(rd)})};for(var Gc in Mb)Zb(Gc)}return{sorted:x,recipientCounts:Oe(P)}}function Oe(na){var R={},x;for(x in na)R[x]=na[x].size;return R}function od(na,R){var x=new Set,P=[],ca={},Ka=0;for(R=R.names();Ka<R.length;Ka++)x.add(R[Ka]);Ka=[];R=[];for(Ka.push(na);0<Ka.length;)if(na=Ka[Ka.length-1],x.has(na.name))Ka.pop();else{var rb=R[R.length-
1]===Ka.length-1;if(0===na.inputs.length||rb)Ka.pop(),P.push(na),x.add(na.name),rb&&R.pop();else{R.push(Ka.length-1);rb=0;for(var Mb=na.inputs;rb<Mb.length;rb++){var Zb=Mb[rb];null==ca[Zb.name]&&(ca[Zb.name]=new Set);ca[Zb.name].add(na.name);x.has(Zb.name)||Ka.push(Zb)}}}return{sorted:P,recipientMap:ca}}function Ud(na){if(1===na.sourceLayer.inboundNodes.length)na=na.sourceLayer.output;else{for(var R=null,x=0;x<na.sourceLayer.inboundNodes.length;++x)for(var P=0,ca=na.sourceLayer.inboundNodes[x].outputTensors;P<
ca.length;P++)if(ca[P].id===na.id){R=x;break}na=na.sourceLayer.getOutputAt(R)}return na}function Rd(na,R,x){var P=R.length;if(null==na||Array.isArray(na)&&0===na.length)return R.map(function(Ka){return null});if(1===P)return Array.isArray(na)&&1===na.length?na:"object"===typeof na&&R[0]in na?[na[R[0]]]:[na];if(Array.isArray(na)){if(na.length!==P)throw Error("Provided "+x+" is an array of "+na.length+" element(s), but the model has "+(P+" outputs. Make sure a set of weights is provided for each model output."));
return na}if("object"===typeof na&&0<Object.keys(na).length&&"object"===typeof na[Object.keys(na)[0]]){var ca=[];R.forEach(function(Ka){Ka in na?ca.push(na[Ka]):ca.push(null)});return ca}throw Error("The model has multiple ("+P+") outputs, so "+(x+" must be either an array with ")+(P+" elements or an object with "+R+" keys. Provided ")+(x+" not understood: "+JSON.stringify(na)));}function pc(na,R,x,P){return r(this,void 0,void 0,function(){var ca,Ka,rb,Mb,Zb;return u(this,function(Yb){switch(Yb.label){case 0:if(null!=
R||null!=P)throw Error("Support sampleWeight is not implemented yet");if(null==x)return[3,2];ca=Kb.tidy(function(){if(1===na.shape.length)return na.clone();if(2===na.shape.length){if(1<na.shape[1])return na.argMax(1);if(1===na.shape[1])return na.reshape([na.shape[0]]);throw Error("Encountered unexpected last-dimension size ("+na.shape[1]+") during handling of class weights. The size is expected to be \x3e\x3d 1.");}throw Error("Unexpected rank of target (y) tensor ("+na.rank+") during handling of class weights. The rank is expected to be 1 or 2.");
});Mb=(rb=Array).from;return[4,ca.data()];case 1:return Ka=Mb.apply(rb,[Yb.sent()]),Kb.dispose(ca),Zb=[],Ka.forEach(function(Gc){if(null==x[Gc])throw Error("classWeight must contain all classes in the training data. The class "+(Gc+" exists in the data but not in classWeight"));Zb.push(x[Gc])}),[2,Kb.tensor1d(Zb,"float32")];case 2:return[2,null]}})})}function Ue(na,R){var x=R.xs;var P=R.ys;Kb.util.assert(null!=x&&null!=P,function(){return"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+
R});var ca=lc("input",na.inputNames,x),Ka=lc("output",na.outputNames,P),rb=ca[0].shape[0];Kb.util.assert(ca.length===na.inputs.length,function(){return"LayersModel has "+na.inputs.length+" inputs, but the dataset provides "+(ca.length+" inputs.  (Expected input keys: ")+(JSON.stringify(na.inputNames)+")")});Kb.util.assert(Ka.length===na.outputs.length,function(){return"LayersModel has "+na.outputs.length+" outputs, but the dataset provides "+(Ka.length+" outputs.  (Expected output keys: ")+(JSON.stringify(na.outputNames)+
")")});x=function(Mb){Kb.util.assert(ca[Mb].shape[0]===rb,function(){return"Batch size mismatch: input "+(na.inputNames[Mb]+" has "+ca[Mb].shape[0]+"; expected  ")+(rb+" based on input "+na.inputNames[0]+".")})};for(P=0;P<ca.length;P++)x(P);x=function(Mb){Kb.util.assert(Ka[Mb].shape[0]===rb,function(){return"Batch size mismatch: output "+(na.outputNames[Mb]+" has "+Ka[Mb].shape[0]+"; expected  ")+(rb+" based on input "+na.inputNames[0]+".")})};for(P=0;P<Ka.length;P++)x(P);return{xs:ca,ys:Ka}}function lc(na,
R,x){if(x instanceof Kb.Tensor)return[x];if(Array.isArray(x))return Kb.util.assert(x.length===R.length,function(){return"Received an array of "+x.length+" Tensors, but expected "+R.length+" to match the "+na+" keys "+R+"."}),x;for(var P=[],ca=0;ca<R.length;ca++){var Ka=R[ca];if(null==x[Ka])throw new ad("The feature data generated by the dataset lacks the required "+(na+" key '"+Ka+"'."));P.push(x[Ka])}return P}function pe(na){if(3===na.length)throw new $e("Validation with sample weights is not implemented yet.");
return{xs:na[0],ys:na[1]}}function rc(na,R,x){return r(this,void 0,void 0,function(){var P,ca,Ka,rb,Mb,Zb,Yb,Gc,cd,rd,Pd,Od,ce,Yd,ve,Ye,jf,kf,Af,Mf,Rf,Bf,lg,eh,Ih,Vg,uh,oh,Vh,Yg,$g,Zg,hh,Lg;return u(this,function(zg){switch(zg.label){case 0:P=null!=x.batchesPerEpoch;Kb.util.assert(null!=na.optimizer,function(){return"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."});Kb.util.assert(null!=x,function(){return"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."});
Kb.util.assert(null!=x.epochs&&0<x.epochs&&Number.isInteger(x.epochs),function(){return"For fitDataset(), config.epochs is expected to be a positive integer, but got "+x.epochs});Kb.util.assert(!P||0<x.batchesPerEpoch&&Number.isInteger(x.batchesPerEpoch),function(){return"For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got "+x.batchesPerEpoch});Kb.util.assert(null==x.validationSplit,function(){return"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."});
if(na.isTraining)throw Error("Cannot start training because another fit() call is ongoing.");na.isTraining=!0;zg.label=1;case 1:return zg.trys.push([1,,26,27]),ca=null!=x.validationData,rb=Ka=void 0,ca&&("function"===typeof x.validationData.iterator?Kb.util.assert(null==x.validationBatches||0<x.validationBatches&&Number.isInteger(x.validationBatches),function(){return"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got "+
x.validationBatches}):(Mb=pe(x.validationData),Ka=Mb.xs,rb=Mb.ys)),Zb=na.makeTrainFunction(),Yb=na.getDedupedMetricsNames(),Gc=void 0,Gc=ca?Yb.slice().concat(Yb.map(function(vh){return"val_"+vh})):Yb.slice(),cd=Fb(x.callbacks,x.yieldEvery),rd=null==x.verbose?1:x.verbose,Pd=vb(cd,rd,x.epochs,null,null,qc(R,x),null,ca,Gc),Od=Pd.callbackList,ce=Pd.history,Od.setModel(na),na.history=ce,[4,Od.onTrainBegin()];case 2:return zg.sent(),na.stopTraining_=!1,Yd=null==x.initialEpoch?0:x.initialEpoch,[4,R.iterator()];
case 3:ve=zg.sent(),zg.label=4;case 4:if(!(Yd<x.epochs))return[3,23];Ye={};return[4,Od.onEpochBegin(Yd)];case 5:return zg.sent(),kf=jf=0,P?[3,7]:[4,R.iterator()];case 6:ve=zg.sent(),zg.label=7;case 7:return(P?jf<x.batchesPerEpoch:1)?[4,ve.next()]:[3,21];case 8:Af=zg.sent();if(P&&Af.done)return console.warn("You provided `batchesPerEpoch` as "+(x.batchesPerEpoch+", but your dataset iterator ran out of data after ")+(jf+" batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, ")+
(x.batchesPerEpoch*x.epochs+" batches). You may need to use the repeat() function when building your dataset.")),[3,21];if(null==Af.value)return[3,15];Mf=Ue(na,Af.value);Rf=Mf.xs;Bf=Mf.ys;lg={};lg.batch=kf;lg.size=Rf[0].shape[0];return[4,Od.onBatchBegin(kf,lg)];case 9:zg.sent();eh=[];if(null==x.classWeight)return[3,13];Ih=Rd(x.classWeight,na.outputNames,"classWeight");Vg=0;zg.label=10;case 10:if(!(Vg<Ih.length))return[3,13];oh=(uh=eh).push;return[4,pc(Bf[Vg],null,Ih[Vg])];case 11:oh.apply(uh,[zg.sent()]),
zg.label=12;case 12:return++Vg,[3,10];case 13:Vh=Rf.concat(Bf).concat(eh);Yg=Zb(Vh);Kb.dispose(Vh);for(Vg=0;Vg<Yb.length;++Vg)$g=Yb[Vg],Zg=Yg[Vg],lg[$g]=Zg,Kb.keep(Zg);return[4,Od.onBatchEnd(kf,lg)];case 14:zg.sent(),La(lg),kf++,jf++,zg.label=15;case 15:if(!(P?jf>=x.batchesPerEpoch:Af.done))return[3,20];if(!ca)return[3,19];hh=void 0;if("function"!==typeof x.validationData.iterator)return[3,17];Lg=h;return[4,na.evaluateDataset(x.validationData,{batches:x.validationBatches})];case 16:return hh=Lg.apply(void 0,
[zg.sent()]),[3,18];case 17:hh=h(na.evaluate(Ka,rb,{batchSize:null==x.validationBatchSize?32:x.validationBatchSize,verbose:0})),zg.label=18;case 18:for(Vg=0;Vg<na.metricsNames.length;++Vg)Ye["val_"+na.metricsNames[Vg]]=hh[Vg];zg.label=19;case 19:return[3,21];case 20:return na.stopTraining_?[3,21]:[3,7];case 21:return[4,Od.onEpochEnd(Yd,Ye)];case 22:return zg.sent(),Yd++,na.stopTraining_?[3,23]:[3,4];case 23:return[4,Od.onTrainEnd()];case 24:return zg.sent(),[4,na.history.syncData()];case 25:return zg.sent(),
[2,na.history];case 26:return na.isTraining=!1,[7];case 27:return[2]}})})}function qc(na,R){var x=null;null!=R.batchesPerEpoch?x=R.batchesPerEpoch:Number.isFinite(na.size)&&(x=na.size);return x}function Ib(na,R,x){return r(this,void 0,void 0,function(){var P,ca,Ka,rb,Mb,Zb,Yb,Gc,cd,rd,Pd;return u(this,function(Od){switch(Od.label){case 0:x=x||{};P=null!=x.batches;ca=na.testFunction;Ka=[];if(0<x.verbose)throw new $e("Verbose mode is not implemented yet.");Kb.util.assert(!P||0<x.batches&&Number.isInteger(x.batches),
function(){return"Test loop expects `batches` to be a positive integer, but received "+JSON.stringify(x.batches)});if("function"!==typeof R.next)return[3,1];Mb=R;return[3,3];case 1:return[4,R.iterator()];case 2:Mb=Od.sent(),Od.label=3;case 3:rb=Mb,Yb=Zb=0,Gc=function(){var ce;return u(this,function(Yd){switch(Yd.label){case 0:return[4,rb.next()];case 1:return ce=Yd.sent(),Ka=Kb.tidy(function(){if(ce.value){var ve=Ue(na,ce.value),Ye=ve.xs.concat(ve.ys),jf=Kb.tidy(function(){return ca(Ye)});Kb.dispose(Ye);
if(0===Yb)for(ve=0;ve<jf.length;++ve)Ka.push(Kb.scalar(0));var kf=Ye[0].shape[0],Af=function(Mf){var Rf=jf[Mf],Bf=Ka[Mf];Ka[Mf]=Kb.tidy(function(){return Kb.add(Ka[Mf],Kb.mul(kf,Rf))});0<Yb&&Kb.dispose(Bf)};for(ve=0;ve<jf.length;++ve)Af(ve);Kb.dispose(jf);Zb+=kf;++Yb}return Ka}),ce.done?(P&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, "+(x.batches+" batches). You may need to use the repeat() function when building your dataset.")),
[2,"break"]):[2]}})},Od.label=4;case 4:return(P?Yb<x.batches:1)?[5,Gc()]:[3,6];case 5:return cd=Od.sent(),"break"===cd?[3,6]:[3,4];case 6:for(rd=0;rd<Ka.length;++rd)Pd=Ka[rd],Ka[rd]=Kb.div(Ka[rd],Zb),Kb.dispose(Pd);return[2,d(Ka)]}})})}function Ga(na){Kb.util.assert(0<na&&Number.isInteger(na),function(){return"batchSize is required to be a positive integer, but got "+na})}function hb(na,R,x){return null==na?[null]:Array.isArray(na)?na.map(function(P){return fa(P,R,x-R)}):fa(na,R,x-R)}function Rb(na,
R){return Kb.tidy(function(){return null==na?null:Array.isArray(na)?na.map(function(x){return Rb(x,R)}):Ia(na,"int32"===R.dtype?R:R.toInt())})}function mc(na,R){for(var x=[],P=0,ca;P<na;)ca=P+R,ca>=na&&(ca=na),x.push([P,ca]),P=ca;return x}function Ub(na,R,x,P,ca,Ka,rb,Mb,Zb,Yb,Gc,cd,rd,Pd,Od){return r(this,void 0,void 0,function(){var ce,Yd,ve,Ye,jf,kf,Af,Mf,Rf;return u(this,function(Bf){switch(Bf.label){case 0:null==ca&&(ca=32);null==Ka&&(Ka=1);null==Gc&&(Gc=!0);null==rd&&(rd=0);ce=!1;null!=Zb&&
null!=Yb&&(ce=!0);if(null!=Od&&(ce=!0,null==Pd))throw new ad("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");Yd=na.checkNumSamples(x,ca,Pd,"steps_per_epoch");null!=Yd&&(ve=ba(0,Yd));null==rb&&(rb=1);Ye=vb(Mb,rb,Ka,rd,Yd,Pd,ca,ce,cd);jf=Ye.callbackList;kf=Ye.history;jf.setModel(na);na.history=kf;return[4,jf.onTrainBegin()];case 1:Bf.sent(),na.stopTraining_=!1,Af=function(lg){var eh,Ih,Vg,uh,oh,Vh;return u(this,function(Yg){switch(Yg.label){case 0:return[4,
jf.onEpochBegin(lg)];case 1:Yg.sent();eh={};if(null==Pd)return[3,2];throw new $e("stepsPerEpoch mode is not implemented yet.");case 2:if("batch"===Gc)throw new $e("batch shuffling is not implemneted yet");Gc&&Kb.util.shuffle(ve);Ih=Kb.tensor1d(ve);Vg=mc(Yd,ca);uh=function($g){var Zg;return u(this,function(hh){switch(hh.label){case 0:return Zg={},[4,jf.onBatchBegin($g,Zg)];case 1:return hh.sent(),Kb.tidy(function(){var Lg=Vg[$g][0],zg=Vg[$g][1],vh=fa(Ih,Lg,zg-Lg);Zg.batch=$g;Zg.size=zg-Lg;Lg=Rb(x,
vh);var ph=R(Lg);for(Lg=0;Lg<P.length;++Lg)zg=P[Lg],vh=ph[Lg],Zg[zg]=vh,Kb.keep(vh);if($g===Vg.length-1&&ce)for(ph=na.testLoop(Zb,Yb,ca),Lg=0;Lg<P.length;++Lg)zg=P[Lg],vh=ph[Lg],Kb.keep(vh),eh["val_"+zg]=vh}),[4,jf.onBatchEnd($g,Zg)];case 2:return hh.sent(),La(Zg),na.stopTraining_?[2,"break"]:[2]}})};oh=0;Yg.label=3;case 3:return oh<Vg.length?[5,uh(oh)]:[3,6];case 4:Vh=Yg.sent();if("break"===Vh)return[3,6];Yg.label=5;case 5:return++oh,[3,3];case 6:Ih.dispose(),Yg.label=7;case 7:return[4,jf.onEpochEnd(lg,
eh)];case 8:return Yg.sent(),na.stopTraining_?[2,"break"]:[2]}})},Mf=rd,Bf.label=2;case 2:return Mf<Ka?[5,Af(Mf)]:[3,5];case 3:Rf=Bf.sent();if("break"===Rf)return[3,5];Bf.label=4;case 4:return++Mf,[3,2];case 5:return[4,jf.onTrainEnd()];case 6:return Bf.sent(),[4,na.history.syncData()];case 7:return Bf.sent(),[2,na.history]}})})}function ic(na,R,x,P){void 0===P&&(P={});return r(this,void 0,void 0,function(){var ca,Ka,rb,Mb,Zb,Yb,Gc,cd,rd,Pd,Od,ce,Yd,ve,Ye,jf,kf,Af,Mf,Rf,Bf;return u(this,function(lg){switch(lg.label){case 0:if(na.isTraining)throw Error("Cannot start training because another fit() call is ongoing.");
na.isTraining=!0;lg.label=1;case 1:return lg.trys.push([1,,7,8]),cd=null==P.batchSize?32:P.batchSize,Ga(cd),[4,na.standardizeUserData(R,x,P.sampleWeight,P.classWeight,!1,cd)];case 2:rd=lg.sent();ca=rd[0];Ka=rd[1];Gc=rd[2];Pd=!1;Od=void 0;if(!(null!=P.validationData&&0<P.validationData.length))return[3,4];Pd=!0;if(2===P.validationData.length)rb=P.validationData[0],Mb=P.validationData[1];else{if(3===P.validationData.length)throw new $e("validationData including sample weights is not supported yet.");
throw new ad("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+(P.validationData+" is invalid."));}return[4,na.standardizeUserData(rb,Mb,null,null,!0,cd)];case 3:return ce=lg.sent(),Zb=ce[0],Yb=ce[1],Od=Zb.concat(Yb),[3,5];case 4:null!=P.validationSplit&&0<P.validationSplit&&1>P.validationSplit?(Pd=!0,Yd=Math.floor(ca[0].shape[0]*(1-P.validationSplit)),ve=ca[0].shape[0],Zb=hb(ca,Yd,ve),ca=hb(ca,0,Yd),Yb=hb(Ka,Yd,ve),Ka=hb(Ka,0,Yd),Od=Zb.concat(Yb)):
null!=P.validationSteps&&(Pd=!0),lg.label=5;case 5:return Ye=ca.concat(Ka).concat(Gc),na.checkTrainableWeightsConsistency(),jf=na.makeTrainFunction(),kf=na.getDedupedMetricsNames(),Mf=Af=void 0,Pd?(na.makeTestFunction(),Af=na.testFunction,Mf=kf.slice().concat(kf.map(function(eh){return"val_"+eh}))):(Af=null,Od=[],Mf=kf.slice()),Rf=Fb(P.callbacks,P.yieldEvery),[4,Ub(na,jf,Ye,kf,cd,P.epochs,P.verbose,Rf,Af,Od,P.shuffle,Mf,P.initialEpoch,null,null)];case 6:return Bf=lg.sent(),[2,Bf];case 7:return na.isTraining=
!1,Ob(ca,R),Ob(Ka,x),Ob(Zb,rb),Ob(Yb,Mb),null!=Gc&&Kb.dispose(Gc),[7];case 8:return[2]}})})}function jc(na){var R=[];na instanceof Kb.Tensor&&(na=[na]);for(var x=0;x<na.length;++x){var P=na[x];if(1===P.rank)R.push(da(P,1));else{if(0===P.rank)throw Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");R.push(P)}}return R}function Ob(na,R){if(null!=na){var x=[];if(R instanceof Kb.Tensor)x.push(R.id);else if(Array.isArray(R))R.forEach(function(rb){return x.push(rb.id)});else if(null!=
R)for(var P in R)x.push(R[P].id);var ca=[];if(na instanceof Kb.Tensor)-1===x.indexOf(na.id)&&ca.push(na);else if(Array.isArray(na))na.forEach(function(rb){-1===x.indexOf(rb.id)&&ca.push(rb)});else if(null!=na)for(var Ka in na)R=na[Ka],-1===x.indexOf(R.id)&&ca.push(R);ca.forEach(function(rb){rb.isDisposed||rb.dispose()})}}function fc(na,R,x,P,ca){void 0===P&&(P=!0);void 0===ca&&(ca="");if(null==R||0===R.length){if(null!=na){R=!1;if(Array.isArray(na)&&0<na.length)R=!0;else if(na instanceof Kb.Tensor||
Array.isArray(na))R=!0;else for(var Ka in na)if(na.hasOwnProperty(Ka)){R=!0;break}if(R)throw new ad("Error when checking model "+ca+" expected no data, but got "+na);}return[]}if(null==na)return R.map(function(Gc){return null});if(na instanceof Kb.Tensor||Array.isArray(na))if(Array.isArray(na)){if(na.length!==R.length)throw new ad("Error when checking model "+ca+": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see "+(R.length+" Tensor(s), but instead got the following list of Tensor(s): ")+
na);Ka=na}else{if(1<R.length)throw new ad("The model "+ca+" expects "+R.length+" Tensor(s), but only received one Tensor. Found: Tensor with shape "+na.shape);Ka=[na]}else{Ka=[];for(var rb=0;rb<R.length;rb++){var Mb=R[rb];if(null==na[Mb])throw new ad('No data provided for "'+Mb+'". Need data for each key in: '+R);Ka.push(na[Mb])}}Ka=jc(Ka);if(null!=x)for(na=0;na<R.length;++na)if(null!=x[na]){rb=Ka[na];if(rb.shape.length!==x[na].length)throw new ad("Error when checking "+ca+": expected "+R[na]+" to have "+
(x[na].length+" dimension(s). but got array with shape ")+rb.shape);for(Mb=0;Mb<x[na].length;++Mb)if(0!==Mb||P){var Zb=rb.shape[Mb],Yb=x[na][Mb];if(null!=Yb&&0<=Yb&&Zb!==Yb)throw new ad("Error when checking "+ca+": expected "+R[na]+" to have shape ["+(x[na]+"], but got array with shape [")+(rb.shape+"]."));}}return Ka}function yc(na,R,x){x=q(na.map(function(ca){return ca.shape[0]}));x.sort();var P=q(R.map(function(ca){return ca.shape[0]}));P.sort();if(1<x.length)throw new ad("All input Tensors (x) should have the same number of samples. Got array shapes: "+
JSON.stringify(na.map(function(ca){return ca.shape})));if(1<P.length)throw new ad("All target Tensors (y) should have the same number of samples. Got array shapes: "+JSON.stringify(R.map(function(ca){return ca.shape})));if(0<x.length&&0<P.length&&!Kb.util.arraysEqual(x,P))throw new ad("Input Tensors should have the same number of samples as target Tensors. Found "+(x[0]+" input sample(s) and "+P[0]+" target sample(s)."));}function fd(na,R,x,P,ca){void 0===P&&(P=!0);void 0===ca&&(ca="");if(Array.isArray(na)){if(na.length!==
R.length)throw new ad("Error when checking model "+ca+": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see "+(R.length+" Tensor(s), but instead got ")+(na.length+" Tensors(s)."));}else{if(1<R.length)throw new ad("The model expects "+R.length+" "+ca+" Tensors, but only received one Tensor. Found: array with shape "+(JSON.stringify(na.shape)+"."));na=[na]}if(null!=x)for(var Ka=0;Ka<R.length;++Ka)if(null!=x[Ka]){var rb=na[Ka];if(rb.shape.length!==
x[Ka].length)throw new ad("Error when checking "+ca+": expected "+R[Ka]+" to have "+(x[Ka].length+" dimension(s), but got array with shape ")+JSON.stringify(rb.shape));for(var Mb=0;Mb<x[Ka].length;++Mb)if(0!==Mb||P){var Zb=rb.shape[Mb],Yb=x[Ka][Mb];if(null!=Yb&&Yb!==Zb)throw new ad("Error when checking "+ca+": expected "+(R[Ka]+" to have shape "+JSON.stringify(x[Ka])+" but got array with shape ")+(JSON.stringify(rb.shape)+"."));}}}function Ad(na,R){if(null==na||Array.isArray(na)&&0===na.length)return R.map(function(Ka){return[]});
if("string"===typeof na||"function"===typeof na)var x=[na];else if(Array.isArray(na)||"object"===typeof na)x=na;else throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: "+na);if(Array.isArray(x))return R.map(function(Ka){return x});na=[];for(var P=0;P<R.length;P++){var ca=R[P];ca=x.hasOwnProperty(ca)?x[ca]:[];Array.isArray(ca)||(ca=[ca]);na.push(ca)}return na}function Gd(na,R){return r(this,void 0,void 0,function(){var x;return u(this,
function(P){null==R&&(R={});if("string"===typeof na){x=Kb.io.getLoadHandlers(na,R);if(0===x.length)x.push(Kb.io.browserHTTPRequest(na,R));else if(1<x.length)throw new ad("Found more than one ("+x.length+") load handlers for URL '"+(na+"'"));na=x[0]}return[2,Ge(na,void 0,R)]})})}function Ge(na,R,x){return r(this,void 0,void 0,function(){var P,ca,Ka,rb,Mb,Zb,Yb,Gc,cd;return u(this,function(rd){switch(rd.label){case 0:null==x&&(x={});if(null==na.load)throw new ad("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
return[4,na.load()];case 1:P=rd.sent();ca=P.modelTopology;null!=ca.model_config&&(ca=ca.model_config);Ka=null==x.strict?!0:x.strict;rb=null!=P.weightData&&null!=P.weightSpecs&&Ka;Mb=Xb(Ne(ca),R,rb);Zb=P.trainingConfig;null!=Zb&&Mb.loadTrainingConfig(Zb);null!=P.userDefinedMetadata&&Mb.setUserDefinedMetadata(P.userDefinedMetadata);if(null==P.weightData)return[3,4];if(null==P.weightSpecs)throw new ad("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");
Yb=Re(P.weightData,P.weightSpecs);Gc=Yb.modelWeights;cd=Yb.optimizerWeights;Mb.loadWeights(Gc,Ka);return null!=Mb.optimizer&&0<cd.length?[4,Mb.optimizer.setWeights(cd)]:[3,3];case 2:rd.sent(),rd.label=3;case 3:Kb.dispose(Gc),Kb.dispose(cd.map(function(Pd){return Pd.tensor})),rd.label=4;case 4:return[2,Mb]}})})}function Re(na,R){var x=Kb.io.decodeWeights(na,R),P={},ca=[];R.forEach(function(Ka){"optimizer"===Ka.group?ca.push({name:Ka.name,tensor:x[Ka.name]}):P[Ka.name]=x[Ka.name]});return{modelWeights:P,
optimizerWeights:ca}}function mf(na){return tb(na)}function Ze(na,R){void 0===R&&(R={});return k(na,Kb.serialization.SerializationMap.getMap().classNameMap,R,"activation")}function Jb(na){if(null==na){var R={className:"linear",config:{}};return Ze(R)}return"string"===typeof na?(R={},R.className=na,R.config={},Ze(R)):na instanceof of?na:Ze(na)}function wb(na){if(null!=na&&"object"!==typeof na)throw Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: "+na);}
function Lb(na,R){void 0===R&&(R={});return k(na,Kb.serialization.SerializationMap.getMap().classNameMap,R,"regularizer")}function oc(na){return null==na?null:"string"===typeof na?Lb({className:na in vf?vf[na]:na,config:{}}):na instanceof bh?na:Lb(na)}function Lc(na,R,x){if("number"===typeof na)return b(na,R);if(na.length!==R)throw new ad("The "+x+" argument must be an integer or tuple of "+R+" integers. Received: "+(na.length+" elements."));for(var P=0;P<R;++P){var ca=na[P];if(ca!==parseInt(ca.toString(),
10))throw new ad("The "+x+" argument must be an integer or tuple of "+R+(" integers. Received: "+JSON.stringify(na)+" including a non-integer number ")+ca);}return na}function ed(na,R,x,P,ca){void 0===ca&&(ca=1);return null==na?na:Math.floor((("same"===x?na:na-(R+(R-1)*(ca-1))+1)+P-1)/P)}function ge(na,R,x,P){if(null==na)return null;if("valid"===P)na=na*R+aa([x-R,0]);else if("same"===P)na*=R;else throw new ad("Unsupport padding mode: "+P+".");return na}function he(na,R){return Kb.tidy(function(){M(R);
return"channelsFirst"===R?Kb.transpose(na,[0,2,3,1]):na})}function bf(na,R){return Kb.tidy(function(){M(R);return"channelsFirst"===R?Kb.transpose(na,[0,2,3,4,1]):na})}function cf(na,R,x,P,ca,Ka,rb){void 0===P&&(P=1);void 0===ca&&(ca="valid");void 0===rb&&(rb=1);return Kb.tidy(function(){null==Ka&&(Ka=a());M(Ka);if(3!==na.shape.length)throw new ad("The input of a conv1dWithBias operation should be 3, but is "+(na.shape.length+" instead."));if(3!==R.shape.length)throw new ad("The kernel for a conv1dWithBias operation should be 3, but is "+
(R.shape.length+" instead"));if(null!=x&&1!==x.shape.length)throw new ad("The bias for a conv1dWithBias operation should be 1, but is "+(R.shape.length+" instead"));"channelsFirst"===Ka&&(na=Kb.transpose(na,[0,2,1]));if("causal"===ca)throw new $e("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");var Mb=Kb.conv1d(na,R,P,"same"===ca?"same":"valid","NWC",rb);null!=x&&(Mb=gb(Mb,x));return Mb})}function qe(na,R,x,P,ca,Ka,rb,Mb){void 0===P&&(P=[1,1]);void 0===ca&&(ca="valid");
void 0===Mb&&(Mb=null);return Kb.tidy(function(){null==Ka&&(Ka=a());M(Ka);if(3!==na.rank&&4!==na.rank)throw new ad("conv2dWithBiasActivation expects input to be of rank 3 or 4, but received "+(na.rank+"."));if(3!==R.rank&&4!==R.rank)throw new ad("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received "+(na.rank+"."));var Zb=he(na,Ka);if("causal"===ca)throw new $e("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");Zb=Kb.fused.conv2d({x:Zb,filter:R,
strides:P,pad:"same"===ca?"same":"valid",dilations:rb,dataFormat:"NHWC",bias:x,activation:Mb});"channelsFirst"===Ka&&(Zb=Kb.transpose(Zb,[0,3,1,2]));return Zb})}function ie(na,R,x,P,ca,Ka,rb){void 0===P&&(P=[1,1,1]);void 0===ca&&(ca="valid");return Kb.tidy(function(){null==Ka&&(Ka=a());M(Ka);if(4!==na.rank&&5!==na.rank)throw new ad("conv3dWithBias expects input to be of rank 4 or 5, but received "+(na.rank+"."));if(4!==R.rank&&5!==R.rank)throw new ad("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+
(na.rank+"."));var Mb=bf(na,Ka);if("causal"===ca)throw new $e("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");Mb=Kb.conv3d(Mb,R,P,"same"===ca?"same":"valid","NDHWC",rb);null!=x&&(Mb=gb(Mb,x));"channelsFirst"===Ka&&(Mb=Kb.transpose(Mb,[0,4,1,2,3]));return Mb})}function Za(na,R,x,P,ca,Ka){void 0===x&&(x=[1,1]);void 0===P&&(P="valid");return Kb.tidy(function(){null==ca&&(ca=a());M(ca);var rb=he(na,ca);if(4!==na.rank)throw new ad("Input for depthwiseConv2d is required to be 4-D, but is instead "+
(na.rank+"-D"));if(4!==R.rank)throw new ad("depthwiseKernel is required to be 4-D, but is instead "+(R.rank+"-D"));rb=Kb.depthwiseConv2d(rb,R,x,"same"===P?"same":"valid","NHWC",Ka);"channelsFirst"===ca&&(rb=Kb.transpose(rb,[0,3,1,2]));return rb})}function nb(na,R,x,P){function ca(Ka){return null==Ka||Array.isArray(Ka)?Ka:[Ka]}if(Array.isArray(na)){if(null!=R||null!=x)throw new ad("When inputs is an array, neither initialState or constants should be provided");null!=P&&(x=na.slice(na.length-P,na.length),
na=na.slice(0,na.length-P));1<na.length&&(R=na.slice(1,na.length));na=na[0]}R=ca(R);x=ca(x);return{inputs:na,initialState:R,constants:x}}function Db(na,R,x,P,ca,Ka,rb,Mb){void 0===P&&(P=!1);void 0===rb&&(rb=!1);void 0===Mb&&(Mb=!1);return Kb.tidy(function(){var Zb=R.shape.length;if(3>Zb)throw new ad("Input should be at least 3D, but is "+Zb+"D.");var Yb=[1,0].concat(ba(2,Zb));R=Kb.transpose(R,Yb);if(null!=Ka)throw new $e("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
rb&&console.warn("Backend rnn(): the unroll \x3d true option is not applicable to the imperative deeplearn.js backend.");null!=ca&&(ca=ca.asType("bool").asType("float32"),ca.rank===Zb-1&&(ca=Kb.expandDims(ca,-1)),ca=Kb.transpose(ca,Yb));P&&(R=Kb.reverse(R,0),null!=ca&&(ca=Kb.reverse(ca,0)));var Gc=[],cd,rd=x;Zb=R.shape[0];var Pd=Kb.unstack(R),Od;null!=ca&&(Od=Kb.unstack(ca));Yb=function(ve){var Ye=Pd[ve],jf=Kb.tidy(function(){return na(Ye,rd)});if(null==ca)cd=jf[0],rd=jf[1];else{var kf=Kb.tidy(function(){var Af=
Od[ve],Mf=Kb.onesLike(Af).sub(Af),Rf=jf[0].mul(Af).add(rd[0].mul(Mf)),Bf=rd.map(function(lg,eh){return jf[1][eh].mul(Af).add(lg.mul(Mf))});return{output:Rf,newStates:Bf}});cd=kf.output;rd=kf.newStates}Mb&&Gc.push(cd)};for(var ce=0;ce<Zb;++ce)Yb(ce);var Yd;Mb&&(Yd=Kb.stack(Gc,1));return[cd,Yd,rd]})}function dc(na){var R=na.ones,x=na.rate,P=na.training,ca=void 0===P?!1:P;na=na.count;na=void 0===na?1:na;var Ka=function(){return Ma(R(),x)};P=function(){return Ja(Ka,R,ca)};return!na||1>=na?Kb.keep(P().clone()):
Array(na).fill(void 0).map(P).map(function(rb){return Kb.keep(rb.clone())})}function uc(na,R){for(;0>na;)na+=R;return na}function Qc(na,R,x){if(3<na.shape.length||3<R.shape.length)throw new $e("batchDot is not implemented for tensors of 4D or higher rank yet");Kb.util.assert(2<=na.shape.length,function(){return"batchDot requires the rank of x to be \x3e\x3d 2, but got "+na.shape.length});Kb.util.assert(2<=na.shape.length,function(){return"batchDot requires the rank of y to be \x3e\x3d 2, but got "+
R.shape.length});"number"===typeof x&&(x=[x,x]);if("complex64"===na.dtype||"complex64"===R.dtype)throw new $e("batchDot is not implemented for complex64-type Tensors yet.");var P=na.shape.length,ca=R.shape.length;null==x&&(x=[P-1,ca-2]);var Ka=x;return Kb.tidy(function(){if(P>ca){var rb=P-ca;for(var Mb=[],Zb=0;Zb<rb;++Zb)Mb.push(1);R=R.reshape(R.shape.concat(Mb))}else if(ca>P){rb=ca-P;Mb=[];for(Zb=0;Zb<rb;++Zb)Mb.push(1);na=na.reshape(na.shape.concat(Mb))}else rb=0;Mb=2===na.shape.length&&2===R.shape.length?
Ka[0]===Ka[1]?na.mul(R).sum(Ka[0]):na.transpose([1,0]).mul(R).sum(Ka[1]):na.matMul(R,Ka[0]!==na.shape.length-1,Ka[1]===R.shape.length-1);if(0<rb){var Yb=P>ca?P+ca-3:P-1;var Gc=[];for(Zb=Yb;Zb<Yb+rb;++Zb)Gc.push(Zb);Mb=Mb.squeeze(Gc)}1===Mb.shape.length&&(Mb=Mb.expandDims(1));return Mb})}function ud(na,R,x,P,ca,Ka){void 0===Ka&&(Ka=.001);if(2===na.rank)na=Kb.batchNorm2d(na,R,x,P,ca,Ka);else if(3===na.rank)na=Kb.batchNorm3d(na,R,x,P,ca,Ka);else if(4===na.rank)na=Kb.batchNorm4d(na,R,x,P,ca,Ka);else throw new $e("batchNormalization is not implemented for array of rank "+
na.rank+" yet");return na}function Fd(na,R,x,P,ca){void 0===ca&&(ca=.001);return Kb.tidy(function(){var Ka=Kb.moments(na,P),rb=Ka.mean;Ka=Ka.variance;return[ud(na,rb,Ka,x,R,ca),rb,Ka]})}function je(na,R,x,P,ca){void 0===ca&&(ca=.001);return Kb.tidy(function(){var Ka=Kb.moments(na,P),rb=Ka.mean;Ka=Ka.variance;for(var Mb=[],Zb=0,Yb=ba(0,na.rank);Zb<Yb.length;Zb++){var Gc=Yb[Zb];-1!==P.indexOf(Gc)?Mb.push(1):Mb.push(na.shape[Gc])}Zb=rb.reshape(Mb);Yb=Ka.reshape(Mb);Gc=null==R?null:R.reshape(Mb);Mb=null==
x?null:x.reshape(Mb);return[ud(na,Zb,Yb,Mb,Gc,ca),rb,Ka]})}function sd(na,R,x,P,ca){void 0===ca&&(ca=.001);return Kb.util.arraysEqual(P.slice().sort(),ba(0,na.rank-1))?Fd(na,R,x,P,ca):je(na,R,x,P,ca)}function wd(na,R,x){return Kb.tidy(function(){if(4!==na.rank)throw new ad("temporalPadding expects input tensor to be 4-D, but received a "+(na.rank+"-D tensor."));null==R&&(R=[[1,1],[1,1]]);if(2!==R.length||2!==R[0].length||2!==R[1].length)throw new ad("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
null==x&&(x=a());if("channelsLast"!==x&&"channelsFirst"!==x)throw new ad("Unknown data format: "+x+". Supported data formats are 'channelsLast' and 'channelsFirst.");return Kb.pad(na,"channelsFirst"===x?[[0,0],[0,0],R[0],R[1]]:[[0,0],R[0],R[1],[0,0]])})}function Zd(na,R,x,P,ca,Ka){return Kb.tidy(function(){M(ca);y(md,"PoolMode",Ka);F(P);null==x&&(x=[1,1]);null==P&&(P="valid");null==ca&&(ca=a());null==Ka&&(Ka="max");na=he(na,ca);var rb="same"===P?"same":"valid";rb="max"===Ka?Kb.maxPool(na,R,x,rb):
Kb.avgPool(na,R,x,rb);"channelsFirst"===ca&&(rb=Kb.transpose(rb,[0,3,1,2]));return rb})}function Te(na,R,x,P,ca,Ka){return Kb.tidy(function(){M(ca);y(md,"PoolMode",Ka);F(P);null==x&&(x=[1,1,1]);null==P&&(P="valid");null==ca&&(ca=a());null==Ka&&(Ka="max");na=bf(na,ca);var rb="same"===P?"same":"valid";rb="max"===Ka?Kb.maxPool3d(na,R,x,rb):Kb.avgPool3d(na,R,x,rb);"channelsFirst"===ca&&(rb=Kb.transpose(rb,[0,4,1,2,3]));return rb})}function re(na){return new gg(na)}function We(na){return new Tg(na)}function nf(na){return new Fh(na)}
function bg(na){return new Hh(na)}function Lf(na){return new lh(na)}function Wf(na){return new jg(na)}function Pf(na){return new Xg(na)}function Bg(na,R){return na<R}function Uf(na,R){return na>R}Object.defineProperty(v,"__esModule",{value:!0});var Kb=A(948),ug=function(na,R){ug=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(x,P){x.__proto__=P}||function(x,P){for(var ca in P)P.hasOwnProperty(ca)&&(x[ca]=P[ca])};return ug(na,R)},sf=function(){sf=Object.assign||function(na){for(var R,
x=1,P=arguments.length;x<P;x++){R=arguments[x];for(var ca in R)Object.prototype.hasOwnProperty.call(R,ca)&&(na[ca]=R[ca])}return na};return sf.apply(this,arguments)},Cf,gf=function(na){function R(x){x=na.call(this,x)||this;Object.setPrototypeOf(x,R.prototype);return x}t(R,na);return R}(Error),Gf=function(na){function R(x){x=na.call(this,x)||this;Object.setPrototypeOf(x,R.prototype);return x}t(R,na);return R}(Error),ad=function(na){function R(x){x=na.call(this,x)||this;Object.setPrototypeOf(x,R.prototype);
return x}t(R,na);return R}(Error),$e=function(na){function R(x){x=na.call(this,x)||this;Object.setPrototypeOf(x,R.prototype);return x}t(R,na);return R}(Error),va=function(na){function R(x){x=na.call(this,x)||this;Object.setPrototypeOf(x,R.prototype);return x}t(R,na);return R}(Error);(function(na){function R(x){x=na.call(this,x)||this;Object.setPrototypeOf(x,R.prototype);return x}t(R,na);return R})(Error);var eb={},ub=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);
R.prototype.getConfig=function(){return{}};return R}(Kb.serialization.Serializable),pb=function(na){function R(x){var P=na.call(this)||this;P.defaultMaxValue=2;P.defaultAxis=0;P.maxValue=null!=x.maxValue?x.maxValue:P.defaultMaxValue;P.axis=null!=x.axis?x.axis:P.defaultAxis;return P}t(R,na);R.prototype.apply=function(x){var P=this;return Kb.tidy(function(){var ca=O(x,P.axis),Ka=Kb.clipByValue(ca,0,P.maxValue);return Kb.mul(x,Kb.div(Ka,Kb.add(f(),ca)))})};R.prototype.getConfig=function(){return{maxValue:this.maxValue,
axis:this.axis}};R.className="MaxNorm";return R}(ub);Kb.serialization.registerClass(pb);var Ea=function(na){function R(x){var P=na.call(this)||this;P.defaultAxis=0;P.axis=null!=x.axis?x.axis:P.defaultAxis;return P}t(R,na);R.prototype.apply=function(x){var P=this;return Kb.tidy(function(){return Kb.div(x,Kb.add(f(),O(x,P.axis)))})};R.prototype.getConfig=function(){return{axis:this.axis}};R.className="UnitNorm";return R}(ub);Kb.serialization.registerClass(Ea);var db=function(na){function R(){return null!==
na&&na.apply(this,arguments)||this}t(R,na);R.prototype.apply=function(x){return Kb.relu(x)};R.className="NonNeg";return R}(ub);Kb.serialization.registerClass(db);var fb=function(na){function R(x){var P=na.call(this)||this;P.defaultMinValue=0;P.defaultMaxValue=1;P.defaultRate=1;P.defaultAxis=0;P.minValue=null!=x.minValue?x.minValue:P.defaultMinValue;P.maxValue=null!=x.maxValue?x.maxValue:P.defaultMaxValue;P.rate=null!=x.rate?x.rate:P.defaultRate;P.axis=null!=x.axis?x.axis:P.defaultAxis;return P}t(R,
na);R.prototype.apply=function(x){var P=this;return Kb.tidy(function(){var ca=O(x,P.axis),Ka=Kb.add(Kb.mul(P.rate,Kb.clipByValue(ca,P.minValue,P.maxValue)),Kb.mul(1-P.rate,ca));return Kb.mul(x,Kb.div(Ka,Kb.add(f(),ca)))})};R.prototype.getConfig=function(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}};R.className="MinMaxNorm";return R}(ub);Kb.serialization.registerClass(fb);var Gb={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"},
Vb=["channelsFirst","channelsLast"],Hc=["valid","same","causal"],md=["max","avg"],Cd=["sum","mul","concat","ave"],ae=new Map,ze=[],ef=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/),Qf=["fanIn","fanOut","fanAvg"],Zf=["normal","uniform","truncatedNormal"],Df=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.fromConfigUsesCustomObjects=function(){return!1};R.prototype.getConfig=function(){return{}};return R}(Kb.serialization.Serializable),rg=function(na){function R(){return null!==
na&&na.apply(this,arguments)||this}t(R,na);R.prototype.apply=function(x,P){return Kb.zeros(x,P)};R.className="Zeros";return R}(Df);Kb.serialization.registerClass(rg);var If=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.apply=function(x,P){return Kb.ones(x,P)};R.className="Ones";return R}(Df);Kb.serialization.registerClass(If);var ag=function(na){function R(x){var P=na.call(this)||this;if("object"!==typeof x)throw new ad("Expected argument of type ConstantConfig but got "+
x);if(void 0===x.value)throw new ad("config must have value set but got "+x);P.value=x.value;return P}t(R,na);R.prototype.apply=function(x,P){var ca=this;return Kb.tidy(function(){return Kb.mul(Kb.scalar(ca.value),Kb.ones(x,P))})};R.prototype.getConfig=function(){return{value:this.value}};R.className="Constant";return R}(Df);Kb.serialization.registerClass(ag);var Ua=function(na){function R(x){var P=na.call(this)||this;P.DEFAULT_MINVAL=-.05;P.DEFAULT_MAXVAL=.05;P.minval=x.minval||P.DEFAULT_MINVAL;
P.maxval=x.maxval||P.DEFAULT_MAXVAL;P.seed=x.seed;return P}t(R,na);R.prototype.apply=function(x,P){return Kb.randomUniform(x,this.minval,this.maxval,P)};R.prototype.getConfig=function(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}};R.className="RandomUniform";return R}(Df);Kb.serialization.registerClass(Ua);var xa=function(na){function R(x){var P=na.call(this)||this;P.DEFAULT_MEAN=0;P.DEFAULT_STDDEV=.05;P.mean=x.mean||P.DEFAULT_MEAN;P.stddev=x.stddev||P.DEFAULT_STDDEV;P.seed=x.seed;
return P}t(R,na);R.prototype.apply=function(x,P){P=P||"float32";if("float32"!==P&&"int32"!==P)throw new $e("randomNormal does not support dType "+P+".");return ua(x,this.mean,this.stddev,P,this.seed)};R.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}};R.className="RandomNormal";return R}(Df);Kb.serialization.registerClass(xa);var Wa=function(na){function R(x){var P=na.call(this)||this;P.DEFAULT_MEAN=0;P.DEFAULT_STDDEV=.05;P.mean=x.mean||P.DEFAULT_MEAN;P.stddev=
x.stddev||P.DEFAULT_STDDEV;P.seed=x.seed;return P}t(R,na);R.prototype.apply=function(x,P){P=P||"float32";if("float32"!==P&&"int32"!==P)throw new $e("truncatedNormal does not support dType "+P+".");return Kb.truncatedNormal(x,this.mean,this.stddev,P,this.seed)};R.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}};R.className="TruncatedNormal";return R}(Df);Kb.serialization.registerClass(Wa);var Da=function(na){function R(x){var P=na.call(this)||this;P.gain=null!=
x.gain?x.gain:1;return P}t(R,na);R.prototype.apply=function(x,P){var ca=this;return Kb.tidy(function(){if(2!==x.length||x[0]!==x[1])throw new ad("Identity matrix initializer can only be used for 2D square matrices.");return Kb.mul(ca.gain,Kb.eye(x[0]))})};R.prototype.getConfig=function(){return{gain:this.gain}};R.className="Identity";return R}(Df);Kb.serialization.registerClass(Da);var mb=function(na){function R(x){var P=na.call(this)||this;if(0>x.scale)throw new ad("scale must be a positive float. Got: "+
x.scale);P.scale=null==x.scale?1:x.scale;P.mode=null==x.mode?"fanIn":x.mode;y(Qf,"FanMode",P.mode);P.distribution=null==x.distribution?"normal":x.distribution;y(Zf,"Distribution",P.distribution);P.seed=x.seed;return P}t(R,na);R.prototype.apply=function(x,P){var ca=void 0;void 0===ca&&(ca="channelsLast");M(ca);if(2===x.length){var Ka=x[0];var rb=x[1]}else-1!==[3,4,5].indexOf(x.length)?"channelsFirst"===ca?(ca=L(x,2),Ka=x[1]*ca,rb=x[0]*ca):"channelsLast"===ca&&(ca=L(x,0,x.length-2),Ka=x[x.length-2]*
ca,rb=x[x.length-1]*ca):(ca=L(x),Ka=Math.sqrt(ca),rb=Math.sqrt(ca));ca=[Ka,rb];Ka=ca[0];ca=ca[1];rb=this.scale;rb="fanIn"===this.mode?rb/Math.max(1,Ka):"fanOut"===this.mode?rb/Math.max(1,ca):rb/Math.max(1,(Ka+ca)/2);if("normal"===this.distribution){Ka=Math.sqrt(rb);P=P||"float32";if("float32"!==P&&"int32"!==P)throw new $e(this.getClassName()+" does not support dType "+P+".");return Kb.truncatedNormal(x,0,Ka,P,this.seed)}Ka=Math.sqrt(3*rb);return Kb.randomUniform(x,-Ka,Ka,P)};R.prototype.getConfig=
function(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}};R.className="VarianceScaling";return R}(Df);Kb.serialization.registerClass(mb);var Bb=function(na){function R(x){return na.call(this,{scale:1,mode:"fanAvg",distribution:"uniform",seed:null==x?null:x.seed})||this}t(R,na);R.prototype.getClassName=function(){return mb.className};R.className="GlorotUniform";return R}(mb);Kb.serialization.registerClass(Bb);var $b=function(na){function R(x){return na.call(this,
{scale:1,mode:"fanAvg",distribution:"normal",seed:null==x?null:x.seed})||this}t(R,na);R.prototype.getClassName=function(){return mb.className};R.className="GlorotNormal";return R}(mb);Kb.serialization.registerClass($b);var wc=function(na){function R(x){return na.call(this,{scale:2,mode:"fanIn",distribution:"normal",seed:null==x?null:x.seed})||this}t(R,na);R.prototype.getClassName=function(){return mb.className};R.className="HeNormal";return R}(mb);Kb.serialization.registerClass(wc);var Rc=function(na){function R(x){return na.call(this,
{scale:2,mode:"fanIn",distribution:"uniform",seed:null==x?null:x.seed})||this}t(R,na);R.prototype.getClassName=function(){return mb.className};R.className="HeUniform";return R}(mb);Kb.serialization.registerClass(Rc);var Zc=function(na){function R(x){return na.call(this,{scale:1,mode:"fanIn",distribution:"normal",seed:null==x?null:x.seed})||this}t(R,na);R.prototype.getClassName=function(){return mb.className};R.className="LeCunNormal";return R}(mb);Kb.serialization.registerClass(Zc);var Xc=function(na){function R(x){return na.call(this,
{scale:1,mode:"fanIn",distribution:"uniform",seed:null==x?null:x.seed})||this}t(R,na);R.prototype.getClassName=function(){return mb.className};R.className="LeCunNormal";return R}(mb);Kb.serialization.registerClass(Xc);var bd=function(na){function R(x){var P=na.call(this)||this;P.DEFAULT_GAIN=1;P.gain=null==x.gain?P.DEFAULT_GAIN:x.gain;P.seed=x.seed;if(null!=P.seed)throw new $e("Random seed is not implemented for Orthogonal Initializer yet.");return P}t(R,na);R.prototype.apply=function(x,P){var ca=
this;return Kb.tidy(function(){if(2>x.length)throw new $e("Shape must be at least 2D.");2E3<x[0]*x[1]&&console.warn("Orthogonal initializer is being called on a matrix with more than 2000 ("+(x[0]*x[1]+") elements: Slowness may result."));var Ka=ua(x[0]>x[1]?[x[1],x[0]]:x,0,1,"float32");Ka=Kb.linalg.gramSchmidt(Ka);x[0]>x[1]&&(Ka=Ka.transpose());return Kb.mul(ca.gain,Ka)})};R.prototype.getConfig=function(){return{gain:this.gain,seed:this.seed}};R.className="Orthogonal";return R}(Df);Kb.serialization.registerClass(bd);
var id={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"},Ic=0,Kd={},Bd=function(){function na(R,x,P,ca,Ka){void 0===x&&(x="float32");void 0===P&&(P="Variable");void 0===ca&&(ca=!0);
void 0===Ka&&(Ka=null);this.dtype=null==x?"float32":x;this.shape=R.shape;this.id=Ic++;this.originalName=H(null==P?"Variable":P);this.name=U(this.originalName);this.trainable_=ca;this.constraint=Ka;this.val=Kb.variable(R,this.trainable_,this.name,this.dtype)}na.prototype.read=function(){this.assertNotDisposed();return this.val};na.prototype.write=function(R){this.assertNotDisposed();var x=this.val;if(x.shape.toString()!==R.shape.toString())throw Error("Shape mismatch: "+JSON.stringify(x.shape)+" vs. "+
JSON.stringify(R.shape));this.val.id!==R.id&&(this.val.assign(R),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val)));return this};na.prototype.dispose=function(){this.assertNotDisposed();this.val.dispose()};na.prototype.assertNotDisposed=function(){if(this.val.isDisposed)throw Error("LayersVariable "+this.name+" is already disposed.");};Object.defineProperty(na.prototype,"trainable",{get:function(){return this.trainable_},set:function(R){this.trainable_=R;this.val.trainable=R},
enumerable:!0,configurable:!0});return na}(),vd=function(){return function(na){this.dtype=na.dtype;this.shape=na.shape;this.ndim=null!=na.shape?na.shape.length:na.ndim;this.maxNDim=na.maxNDim;this.minNDim=na.minNDim;this.axes=na.axes||{}}}(),Nd=function(){return function(na,R,x,P,ca,Ka,rb){this.dtype=na;this.shape=R;this.sourceLayer=x;this.inputs=P;this.callArgs=ca;this.outputTensorIndex=rb;this.id=Ic++;null!=Ka&&(this.originalName=H(Ka),this.name=U(this.originalName));this.rank=R.length}}(),de=0,
ne=function(){function na(R,x){this.callArgs=x;this.id=de++;this.outboundLayer=R.outboundLayer;this.inboundLayers=R.inboundLayers;this.nodeIndices=R.nodeIndices;this.tensorIndices=R.tensorIndices;this.inputTensors=R.inputTensors;this.outputTensors=R.outputTensors;this.inputMasks=R.inputMasks;this.outputMasks=R.outputMasks;this.inputShapes=R.inputShapes;this.outputShapes=R.outputShapes;x=0;for(var P=R.inboundLayers;x<P.length;x++){var ca=P[x];null!=ca&&ca.outboundNodes.push(this)}R.outboundLayer.inboundNodes.push(this)}
na.prototype.getConfig=function(){for(var R=[],x=0,P=this.inboundLayers;x<P.length;x++){var ca=P[x];null!=ca?R.push(ca.name):R.push(null)}return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:R,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}};return na}(),xe=0,Vd=function(na){function R(x){void 0===x&&(x={});var P=na.call(this)||this;P._callHook=null;P._addedWeightNames=[];P._stateful=!1;P.id=xe++;P.activityRegularizer=null;P.inputSpec=null;P.supportsMasking=
!1;P._trainableWeights=[];P._nonTrainableWeights=[];P._losses=[];P._updates=[];P._built=!1;P.inboundNodes=[];P.outboundNodes=[];var ca=x.name;ca||(ca=P.getClassName(),ca=c(ca)+"_"+ha(ca));P.name=ca;P.trainable_=null==x.trainable?!0:x.trainable;if(null!=x.inputShape||null!=x.batchInputShape)ca=void 0,null!=x.batchInputShape?ca=x.batchInputShape:null!=x.inputShape&&(ca=null,null!=x.batchSize&&(ca=x.batchSize),ca=[ca].concat(x.inputShape)),P.batchInputShape=ca,ca=x.dtype,null==ca&&(ca=x.inputDType),
null==ca&&(ca="float32"),P.dtype=ca;P.initialWeights=null!=x.weights?x.weights:null;P._refCount=null;P.fastWeightInitDuringBuild=!1;return P}t(R,na);R.nodeKey=function(x,P){return x.name+"_ib-"+P.toString()};R.prototype.getNodeAtIndex=function(x,P){if(0===this.inboundNodes.length)throw new Gf("The layer has never been called and thus has no defined "+(P+"."));if(this.inboundNodes.length<=x)throw new ad("Asked to get "+P+" at node "+x+", but the layer has only "+(this.inboundNodes.length+" inbound nodes."));
return this.inboundNodes[x]};R.prototype.getInputAt=function(x){return d(this.getNodeAtIndex(x,"input").inputTensors)};R.prototype.getOutputAt=function(x){return d(this.getNodeAtIndex(x,"output").outputTensors)};Object.defineProperty(R.prototype,"input",{get:function(){if(1<this.inboundNodes.length)throw new gf("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new gf("Layer "+
this.name+" is not connected, no input to return.");return d(this.getNodeAtIndex(0,"input").inputTensors)},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"output",{get:function(){if(0===this.inboundNodes.length)throw new gf("Layer "+this.name+" has no inbound nodes.");if(1<this.inboundNodes.length)throw new gf("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return d(this.getNodeAtIndex(0,
"output").outputTensors)},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"losses",{get:function(){return this._losses},enumerable:!0,configurable:!0});R.prototype.calculateLosses=function(){return this.losses.map(function(x){return x()})};Object.defineProperty(R.prototype,"updates",{get:function(){return this._updates},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"built",{get:function(){return this._built},set:function(x){this._built=x},enumerable:!0,configurable:!0});
Object.defineProperty(R.prototype,"trainable",{get:function(){return this.trainable_},set:function(x){this._trainableWeights.forEach(function(P){return P.trainable=x});this.trainable_=x},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"trainableWeights",{get:function(){return this.trainable_?this._trainableWeights.filter(function(x){return x.trainable}):[]},set:function(x){this._trainableWeights=x},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"nonTrainableWeights",
{get:function(){return this.trainable?this._trainableWeights.filter(function(x){return!x.trainable}).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)},set:function(x){this._nonTrainableWeights=x},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"stateful",{get:function(){return this._stateful},
enumerable:!0,configurable:!0});R.prototype.resetStates=function(){if(!this.stateful)throw Error("Cannot call the resetStates() method of a non-stateful Layer object.");};R.prototype.assertInputCompatibility=function(x){x=h(x);if(null!=this.inputSpec&&0!==this.inputSpec.length){var P=h(this.inputSpec);if(x.length!==P.length)throw new ad("Layer "+this.name+" expects "+P.length+" inputs, but it received "+(x.length+" input tensors. Input received: ")+x);for(var ca=0;ca<x.length;ca++){var Ka=x[ca],rb=
P[ca];if(null!=rb){var Mb=Ka.rank;if(null!=rb.ndim&&Mb!==rb.ndim)throw new ad("Input "+ca+" is incompatible with layer "+this.name+": expected ndim\x3d"+(rb.ndim+", found ndim\x3d"+Mb));if(null!=rb.maxNDim&&Mb>rb.maxNDim)throw new ad("Input "+ca+" is incompatible with layer "+this.name+(": expected max_ndim\x3d"+rb.maxNDim+", found ndim\x3d"+Mb));if(null!=rb.minNDim&&Mb<rb.minNDim)throw new ad("Input "+ca+" is incompatible with layer "+this.name+(": expected min_ndim\x3d"+rb.minNDim+", found ndim\x3d"+
Mb+"."));if(null!=rb.dtype&&Ka.dtype!==rb.dtype)throw new ad("Input "+ca+" is incompatible with layer "+this.name+" : expected dtype\x3d"+(rb.dtype+", found dtype\x3d"+Ka.dtype+"."));if(rb.axes){Mb=Ka.shape;for(var Zb in rb.axes){var Yb=Number(Zb),Gc=rb.axes[Zb],cd=0<=Yb?Mb[Yb]:Mb[Mb.length+Yb];if(null!=Gc&&-1===[Gc,null].indexOf(cd))throw new ad("Input "+ca+" is incompatible with layer "+(this.name+": expected axis "+Yb+" of input shape to have value ")+(Gc+" but got shape "+Mb+"."));}}if(null!=
rb.shape)for(Mb=0;Mb<rb.shape.length;++Mb)if(Yb=rb.shape[Mb],Gc=Ka.shape[Mb],null!=Yb&&null!=Gc&&Yb!==Gc)throw new ad("Input "+ca+" is incompatible with layer "+(this.name+": expected shape\x3d"+rb.shape+", found shape\x3d")+(Ka.shape+"."));}}}};R.prototype.call=function(x,P){return x};R.prototype.invokeCallHook=function(x,P){null!=this._callHook&&this._callHook(x,P)};R.prototype.setCallHook=function(x){this._callHook=x};R.prototype.clearCallHook=function(){this._callHook=null};R.prototype.apply=
function(x,P){var ca=this;P=P||{};this.assertNotDisposed();for(var Ka=h(x),rb=!0,Mb=0;Mb<Ka.length;Mb++){var Zb=Ka[Mb];if(!(Zb instanceof Nd)){rb=!1;break}}var Yb=!0;for(Mb=0;Mb<Ka.length;Mb++)if(Zb=Ka[Mb],Zb instanceof Nd){Yb=!1;break}if(rb===Yb)throw new ad("Arguments to apply() must be all SymbolicTensors or all Tensors");return D(this.name,function(){if(!ca.built){ca.assertInputCompatibility(x);for(var Gc=[],cd=0,rd=h(x);cd<rd.length;cd++)Gc.push(rd[cd].shape);ca.build(d(Gc));ca.built=!0;ca.initialWeights&&
ca.setWeights(ca.initialWeights);null===ca._refCount&&Yb&&(ca._refCount=1)}ca.assertInputCompatibility(x);if(Yb){Gc=ca.call(x,P);cd=[];rd=0;for(Gc=h(Gc);rd<Gc.length;rd++){var Pd=Gc[rd];-1!==Ka.indexOf(Pd)&&(Pd=Pd.clone());cd.push(Pd)}Gc=d(cd)}else cd=Ya(x),rd=ca.computeOutputShape(cd),Gc=void 0,ca.warnOnIncompatibleInputShape(Array.isArray(x)?cd[0]:cd),Gc=null!=rd&&0<rd.length&&Array.isArray(rd[0])?rd.map(function(Od,ce){return new Nd("float32",Od,ca,h(x),P,ca.name,ce)}):new Nd("float32",rd,ca,h(x),
P,ca.name),ca.addInboundNode(x,Gc,null,null,cd,rd,P),ca._refCount++;if(null!=ca.activityRegularizer)throw new $e("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return Gc})};R.prototype.warnOnIncompatibleInputShape=function(x){if(null!=this.batchInputShape)if(x.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+(JSON.stringify(x)+") does not match that of the batchInputShape (")+(JSON.stringify(this.batchInputShape)+
") of the layer ")+this.name);else{var P=!1;this.batchInputShape.forEach(function(ca,Ka){null!=ca&&null!=x[Ka]&&x[Ka]!==ca&&(P=!0)});P&&console.warn("The shape of the input tensor ("+(JSON.stringify(x)+") does not match the expectation of layer ")+(this.name+": ")+JSON.stringify(this.batchInputShape))}};Object.defineProperty(R.prototype,"outputShape",{get:function(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new gf("The layer "+this.name+" has never been called and thus has no defined output shape.");
for(var x=[],P=0,ca=this.inboundNodes;P<ca.length;P++){var Ka=JSON.stringify(ca[P].outputShapes);-1===x.indexOf(Ka)&&x.push(Ka)}if(1===x.length)return x=this.inboundNodes[0].outputShapes,Array.isArray(x)&&Array.isArray(x[0])&&1===x.length?x[0]:x;throw new gf("The layer "+this.name+' has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.');},enumerable:!0,configurable:!0});R.prototype.countParams=function(){if(!this.built)throw new Gf("You tried to call countParams() on "+
this.name+", but the layer is not built yet. Build it first by calling build(batchInputShape).");return wa(this.weights)};R.prototype.build=function(x){this.built=!0};R.prototype.getWeights=function(x){void 0===x&&(x=!1);return Aa(x?this.trainableWeights:this.weights)};R.prototype.setWeights=function(x){var P=this;Kb.tidy(function(){var ca=P.weights;if(ca.length!==x.length)throw new ad('You called setWeights(weights) on layer "'+P.name+'" with a weight list of length '+(x.length+", but the layer was expecting ")+
(ca.length+" weights. Provided weights: ")+(x+"..."));if(0!==ca.length){for(var Ka=[],rb=Aa(ca),Mb=0;Mb<rb.length;++Mb){var Zb=rb[Mb],Yb=ca[Mb],Gc=x[Mb];if(!Kb.util.arraysEqual(Zb.shape,Gc.shape))throw new ad("Layer weight shape "+Zb.shape+" not compatible with provided weight shape "+Gc.shape);Ka.push([Yb,Gc])}lb(Ka)}})};R.prototype.addWeight=function(x,P,ca,Ka,rb,Mb,Zb){if(-1!==this._addedWeightNames.indexOf(x))throw new ad("Duplicate weight name "+x+" for layer "+this.name);this._addedWeightNames.push(x);
null==ca&&(ca="float32");this.fastWeightInitDuringBuild&&(Ka=S("zeros"));P=Ka.apply(P,ca);var Yb=new Bd(P,ca,x,Mb,Zb);P.dispose();null!=rb&&this.addLoss(function(){return rb.apply(Yb.read())});null==Mb&&(Mb=!0);Mb?this._trainableWeights.push(Yb):this._nonTrainableWeights.push(Yb);return Yb};R.prototype.setFastWeightInitDuringBuild=function(x){this.fastWeightInitDuringBuild=x};R.prototype.addLoss=function(x){var P;null==x||Array.isArray(x)&&0===x.length||(x=h(x),void 0!==this._losses&&null!==this._losses&&
(P=this.losses).push.apply(P,x))};R.prototype.computeOutputShape=function(x){return x};R.prototype.computeMask=function(x,P){var ca=this;if(!this.supportsMasking){if(null!=P)if(Array.isArray(P))P.forEach(function(Ka){if(null!=Ka)throw new TypeError("Layer "+ca.name+" does not support masking, but was passed an inputMask.");});else throw new TypeError("Layer "+this.name+" does not support masking, but was passed an inputMask.");return null}return P};R.prototype.addInboundNode=function(x,P,ca,Ka,rb,
Mb,Zb){void 0===Zb&&(Zb=null);x=h(x);P=h(P);ca=h(ca);Ka=h(Ka);rb=Qa(rb);Mb=Qa(Mb);for(var Yb=[],Gc=[],cd=[],rd=0;rd<x.length;rd++){var Pd=x[rd];Yb.push(Pd.sourceLayer);Gc.push(Pd.nodeIndex);cd.push(Pd.tensorIndex)}new ne({outboundLayer:this,inboundLayers:Yb,nodeIndices:Gc,tensorIndices:cd,inputTensors:x,outputTensors:P,inputMasks:ca,outputMasks:Ka,inputShapes:rb,outputShapes:Mb},Zb);for(ca=0;ca<P.length;ca++)P[ca].sourceLayer=this,P[ca].nodeIndex=this.inboundNodes.length-1,P[ca].tensorIndex=ca};R.prototype.getConfig=
function(){var x={name:this.name,trainable:this.trainable};null!=this.batchInputShape&&(x.batchInputShape=this.batchInputShape);null!=this.dtype&&(x.dtype=this.dtype);return x};R.prototype.disposeWeights=function(){this.weights.forEach(function(x){return x.dispose()});return this.weights.length};R.prototype.assertNotDisposed=function(){if(0===this._refCount)throw Error("Layer '"+this.name+"' is already disposed.");};R.prototype.dispose=function(){if(!this.built)throw Error("Cannot dispose Layer "+
this.name+" because it has not been built yet.");if(null===this._refCount)throw Error("Cannot dispose Layer "+this.name+" because it has not been used yet.");this.assertNotDisposed();var x=0;0===--this._refCount&&(x=this.disposeWeights());return{refCountAfterDispose:this._refCount,numDisposedVariables:x}};return R}(Kb.serialization.Serializable),le=function(na){function R(x){var P=na.call(this,{dtype:x.dtype,name:null!=x.name?x.name:ha("input").toString()})||this;null==x.batchSize&&(x.batchSize=null);
null==x.sparse&&(x.sparse=!1);P.trainable=!1;P.built=!0;P.sparse=x.sparse;if(null!=x.inputShape&&null!=x.batchInputShape)throw new ad("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");var ca=x.batchInputShape;if(null==ca){if(null==x.inputShape)throw new ad("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");ca=[x.batchSize].concat(x.inputShape)}else if(null!=x.batchSize)throw new ad("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
x=x.dtype||"float32";P.batchInputShape=ca;P.dtype=x;P.inputSpec=[{shape:ca}];x=new Nd(P.dtype,P.batchInputShape,P,[],{},P.name);x.nodeIndex=0;x.tensorIndex=0;new ne({outboundLayer:P,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[x],outputTensors:[x],inputMasks:[null],outputMasks:[null],inputShapes:[ca],outputShapes:[ca]});return P}t(R,na);R.prototype.apply=function(x,P){throw new ad("Cannot pass any input to an InputLayer's apply() method. InputLayer name: "+this.name);};R.prototype.dispose=
function(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}};R.prototype.getConfig=function(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}};R.className="InputLayer";return R}(Vd);Kb.serialization.registerClass(le);var ue;(function(na){na[na.SILENT=0]="SILENT";na[na.VERBOSE=1]="VERBOSE"})(ue||(ue={}));var Ae=function(){function na(){this.validationData=null}na.prototype.setParams=function(R){this.params=R};na.prototype.onEpochBegin=
function(R,x){return r(this,void 0,void 0,function(){return u(this,function(P){return[2]})})};na.prototype.onEpochEnd=function(R,x){return r(this,void 0,void 0,function(){return u(this,function(P){return[2]})})};na.prototype.onBatchBegin=function(R,x){return r(this,void 0,void 0,function(){return u(this,function(P){return[2]})})};na.prototype.onBatchEnd=function(R,x){return r(this,void 0,void 0,function(){return u(this,function(P){return[2]})})};na.prototype.onTrainBegin=function(R){return r(this,
void 0,void 0,function(){return u(this,function(x){return[2]})})};na.prototype.onTrainEnd=function(R){return r(this,void 0,void 0,function(){return u(this,function(x){return[2]})})};na.prototype.setModel=function(R){};return na}(),kb=function(){function na(R,x){void 0===x&&(x=10);null==R&&(R=[]);this.callbacks=R;this.queueLength=x}na.prototype.append=function(R){this.callbacks.push(R)};na.prototype.setParams=function(R){for(var x=0,P=this.callbacks;x<P.length;x++)P[x].setParams(R)};na.prototype.setModel=
function(R){for(var x=0,P=this.callbacks;x<P.length;x++)P[x].setModel(R)};na.prototype.onEpochBegin=function(R,x){return r(this,void 0,void 0,function(){var P,ca,Ka;return u(this,function(rb){switch(rb.label){case 0:null==x&&(x={}),P=0,ca=this.callbacks,rb.label=1;case 1:if(!(P<ca.length))return[3,4];Ka=ca[P];return[4,Ka.onEpochBegin(R,x)];case 2:rb.sent(),rb.label=3;case 3:return P++,[3,1];case 4:return[2]}})})};na.prototype.onEpochEnd=function(R,x){return r(this,void 0,void 0,function(){var P,ca,
Ka;return u(this,function(rb){switch(rb.label){case 0:null==x&&(x={}),P=0,ca=this.callbacks,rb.label=1;case 1:if(!(P<ca.length))return[3,4];Ka=ca[P];return[4,Ka.onEpochEnd(R,x)];case 2:rb.sent(),rb.label=3;case 3:return P++,[3,1];case 4:return[2]}})})};na.prototype.onBatchBegin=function(R,x){return r(this,void 0,void 0,function(){var P,ca,Ka;return u(this,function(rb){switch(rb.label){case 0:null==x&&(x={}),P=0,ca=this.callbacks,rb.label=1;case 1:if(!(P<ca.length))return[3,4];Ka=ca[P];return[4,Ka.onBatchBegin(R,
x)];case 2:rb.sent(),rb.label=3;case 3:return P++,[3,1];case 4:return[2]}})})};na.prototype.onBatchEnd=function(R,x){return r(this,void 0,void 0,function(){var P,ca,Ka;return u(this,function(rb){switch(rb.label){case 0:null==x&&(x={}),P=0,ca=this.callbacks,rb.label=1;case 1:if(!(P<ca.length))return[3,4];Ka=ca[P];return[4,Ka.onBatchEnd(R,x)];case 2:rb.sent(),rb.label=3;case 3:return P++,[3,1];case 4:return[2]}})})};na.prototype.onTrainBegin=function(R){return r(this,void 0,void 0,function(){var x,
P,ca;return u(this,function(Ka){switch(Ka.label){case 0:null==R&&(R={}),x=0,P=this.callbacks,Ka.label=1;case 1:if(!(x<P.length))return[3,4];ca=P[x];return[4,ca.onTrainBegin(R)];case 2:Ka.sent(),Ka.label=3;case 3:return x++,[3,1];case 4:return[2]}})})};na.prototype.onTrainEnd=function(R){return r(this,void 0,void 0,function(){var x,P,ca;return u(this,function(Ka){switch(Ka.label){case 0:null==R&&(R={}),x=0,P=this.callbacks,Ka.label=1;case 1:if(!(x<P.length))return[3,4];ca=P[x];return[4,ca.onTrainEnd(R)];
case 2:Ka.sent(),Ka.label=3;case 3:return x++,[3,1];case 4:return[2]}})})};return na}(),yb=function(na){function R(){return na.call(this)||this}t(R,na);R.prototype.onEpochBegin=function(x){return r(this,void 0,void 0,function(){return u(this,function(P){this.seen=0;this.totals={};return[2]})})};R.prototype.onBatchEnd=function(x,P){return r(this,void 0,void 0,function(){var ca,Ka,rb,Mb,Zb=this;return u(this,function(Yb){null==P&&(P={});ca=null==P.size?0:P.size;this.seen+=ca;Ka=function(Gc){var cd=
P[Gc];if("number"===typeof cd)rb.totals.hasOwnProperty(Gc)||(rb.totals[Gc]=0),rb.totals[Gc]+=cd*ca;else{var rd=void 0;Gc in rb.totals?rd=rb.totals[Gc]:rb.totals[Gc]=0;var Pd=Kb.tidy(function(){return Kb.add(Zb.totals[Gc],Kb.mul(cd,ca))});rb.totals[Gc]=Pd;null!=rd&&rd.dispose()}};rb=this;for(Mb in P)Ka(Mb);return[2]})})};R.prototype.onEpochEnd=function(x,P){return r(this,void 0,void 0,function(){var ca,Ka,rb,Mb,Zb,Yb=this;return u(this,function(Gc){if(null!=P)for(ca=function(cd){if(null==Ka.totals[cd])return"continue";
"number"===typeof Ka.totals[cd]?P[cd]=Ka.totals[cd]/Ka.seen:Kb.tidy(function(){var rd=Kb.mul(Kb.div(1,Yb.seen),Yb.totals[cd]);P[cd]=rd;Yb.totals[cd].dispose();Kb.keep(P[cd])})},Ka=this,rb=0,Mb=this.params.metrics;rb<Mb.length;rb++)Zb=Mb[rb],ca(Zb);return[2]})})};return R}(Ae),Hb=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.onTrainBegin=function(x){return r(this,void 0,void 0,function(){return u(this,function(P){this.epoch=[];this.history={};return[2]})})};
R.prototype.onEpochEnd=function(x,P){return r(this,void 0,void 0,function(){var ca;return u(this,function(Ka){null==P&&(P={});this.epoch.push(x);for(ca in P)null==this.history[ca]&&(this.history[ca]=[]),this.history[ca].push(P[ca]);return[2]})})};R.prototype.syncData=function(){return r(this,void 0,void 0,function(){var x,P,ca,Ka,rb,Mb,Zb,Yb,Gc,cd;return u(this,function(rd){switch(rd.label){case 0:x=[];P=[];ca=[];for(Ka in this.history)for(rb=this.history[Ka],Mb=0;Mb<rb.length;++Mb)"number"!==typeof rb[Mb]&&
(Zb=rb[Mb],x.push(Zb.data()),P.push(Ka),ca.push(Mb));return[4,Promise.all(x)];case 1:Yb=rd.sent();for(Gc=0;Gc<Yb.length;++Gc)cd=this.history[P[Gc]][ca[Gc]],cd.dispose(),this.history[P[Gc]][ca[Gc]]=Yb[Gc][0];return[2]}})})};return R}(Ae),ec=function(na){function R(x,P){var ca=na.call(this)||this;ca.currentEpoch=0;ca.yieldEvery=P||"auto";"auto"===ca.yieldEvery&&(ca.yieldEvery=125);if("never"===ca.yieldEvery&&null!=x.onYield)throw Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
Kb.util.isNumber(ca.yieldEvery)&&(ca.maybeWait=J(ca.maybeWait.bind(ca),ca.yieldEvery));ca.trainBegin=x.onTrainBegin;ca.trainEnd=x.onTrainEnd;ca.epochBegin=x.onEpochBegin;ca.epochEnd=x.onEpochEnd;ca.batchBegin=x.onBatchBegin;ca.batchEnd=x.onBatchEnd;ca.yield=x.onYield;return ca}t(R,na);R.prototype.maybeWait=function(x,P,ca){return r(this,void 0,void 0,function(){var Ka;return u(this,function(rb){switch(rb.label){case 0:return Ka=[],null==this.yield?[3,2]:[4,bb(ca)];case 1:rb.sent(),Ka.push(this.yield(x,
P,ca)),rb.label=2;case 2:return Ka.push(Kb.nextFrame()),[4,Promise.all(Ka)];case 3:return rb.sent(),[2]}})})};R.prototype.onEpochBegin=function(x,P){return r(this,void 0,void 0,function(){return u(this,function(ca){switch(ca.label){case 0:return this.currentEpoch=x,null==this.epochBegin?[3,3]:[4,bb(P)];case 1:return ca.sent(),[4,this.epochBegin(x,P)];case 2:ca.sent(),ca.label=3;case 3:return[2]}})})};R.prototype.onEpochEnd=function(x,P){return r(this,void 0,void 0,function(){var ca;return u(this,
function(Ka){switch(Ka.label){case 0:return ca=[],null==this.epochEnd?[3,2]:[4,bb(P)];case 1:Ka.sent(),ca.push(this.epochEnd(x,P)),Ka.label=2;case 2:return"epoch"===this.yieldEvery&&ca.push(Kb.nextFrame()),[4,Promise.all(ca)];case 3:return Ka.sent(),[2]}})})};R.prototype.onBatchBegin=function(x,P){return r(this,void 0,void 0,function(){return u(this,function(ca){switch(ca.label){case 0:return null==this.batchBegin?[3,3]:[4,bb(P)];case 1:return ca.sent(),[4,this.batchBegin(x,P)];case 2:ca.sent(),ca.label=
3;case 3:return[2]}})})};R.prototype.onBatchEnd=function(x,P){return r(this,void 0,void 0,function(){var ca;return u(this,function(Ka){switch(Ka.label){case 0:return ca=[],null==this.batchEnd?[3,2]:[4,bb(P)];case 1:Ka.sent(),ca.push(this.batchEnd(x,P)),Ka.label=2;case 2:return"batch"===this.yieldEvery?ca.push(Kb.nextFrame()):Kb.util.isNumber(this.yieldEvery)&&ca.push(this.maybeWait(this.currentEpoch,x,P)),[4,Promise.all(ca)];case 3:return Ka.sent(),[2]}})})};R.prototype.onTrainBegin=function(x){return r(this,
void 0,void 0,function(){return u(this,function(P){switch(P.label){case 0:return null==this.trainBegin?[3,3]:[4,bb(x)];case 1:return P.sent(),[4,this.trainBegin(x)];case 2:P.sent(),P.label=3;case 3:return[2]}})})};R.prototype.onTrainEnd=function(x){return r(this,void 0,void 0,function(){return u(this,function(P){switch(P.label){case 0:return null==this.trainEnd?[3,3]:[4,bb(x)];case 1:return P.sent(),[4,this.trainEnd(x)];case 2:P.sent(),P.label=3;case 3:return[2]}})})};return R}(Ae),Bc=function(){function na(){}
na.registerCallbackConstructor=function(R,x){Kb.util.assert(0<=R&&Number.isInteger(R),function(){return"Verbosity level is expected to be an integer \x3e\x3d 0, but got "+R});na.checkForDuplicate(x);null==na.constructors[R]&&(na.constructors[R]=[]);na.constructors[R].push(x)};na.checkForDuplicate=function(R){for(var x in na.constructors)na.constructors[+x].forEach(function(P){if(P===R)throw new ad("Duplicate callback constructor.");})};na.clear=function(){na.constructors={}};na.createCallbacks=function(R){var x=
[],P;for(P in na.constructors){var ca=+P;R>=ca&&x.push.apply(x,na.constructors[ca])}return x.map(function(Ka){return new Ka})};na.constructors={};return na}(),Sc={meanSquaredError:Yc,meanAbsoluteError:yd,meanAbsolutePercentageError:pd,meanSquaredLogarithmicError:function(na,R){return Kb.tidy(function(){var x=Kb.clipByValue(R,f(),Number.MAX_VALUE);x=Kb.log(Kb.add(1,x));var P=Kb.clipByValue(na,f(),Number.MAX_VALUE);P=Kb.log(Kb.add(1,P));return Kb.mean(oa(Kb.sub(x,P)),-1)})},squaredHinge:function(na,
R){return Kb.tidy(function(){var x=Kb.maximum(0,Kb.sub(1,Kb.mul(na,R)));return Kb.mean(oa(x),-1)})},hinge:function(na,R){return Kb.tidy(function(){var x=Kb.maximum(0,Kb.sub(1,Kb.mul(na,R)));return Kb.mean(x,-1)})},categoricalHinge:function(na,R){return Kb.tidy(function(){var x=Kb.sum(Kb.mul(na,R),-1),P=Kb.max(Kb.mul(Kb.sub(1,na),R),-1);return Kb.maximum(0,Kb.add(1,Kb.sub(P,x)))})},logcosh:function(na,R){return Kb.tidy(function(){var x=Math.log(2),P=Kb.sub(R,na);x=Kb.sub(Kb.add(P,Kb.softplus(Kb.mul(-2,
P))),x);return Kb.mean(x,-1)})},categoricalCrossentropy:sc,sparseCategoricalCrossentropy:tc,binaryCrossentropy:$c,kullbackLeiblerDivergence:function(na,R){return Kb.tidy(function(){var x=Kb.clipByValue(na,f(),1),P=Kb.clipByValue(R,f(),1);return Kb.sum(Kb.mul(na,Kb.log(Kb.div(x,P))),-1)})},poisson:function(na,R){return Kb.tidy(function(){var x=Kb.log(Kb.add(f(),R));return Kb.mean(Kb.sub(R,Kb.mul(na,x)),-1)})},cosineProximity:xd},Uc={binaryAccuracy:Ta,categoricalAccuracy:jb,precision:dd,categoricalCrossentropy:sc,
sparseCategoricalCrossentropy:tc,mse:Yc,MSE:Yc,mae:yd,MAE:yd,mape:pd,MAPE:pd,cosine:xd},Ed=function(){function na(R){this.id2Value={};this.id2Mask={};this.name2Id={};if(R instanceof na)for(var x in R.id2Value)this.id2Value[x]=R.id2Value[x],x in R.id2Mask&&(this.id2Mask[x]=R.id2Mask[x]);else if(null!=R)for(x=0;x<R.length;x++){var P=R[x];this.add(P.key,P.value)}}na.prototype.add=function(R,x,P){if(null==this.id2Value[R.id]){var ca=this.id2Value,Ka=R.id;if(null==R.dtype||R.dtype===x.dtype)var rb=x;else try{rb=
Kb.cast(x,R.dtype)}catch(Mb){throw new ad("The dtype of the feed ("+x.dtype+") can not be cast to the dtype of the key '"+(R.name+"' ("+R.dtype+")."));}ca[Ka]=rb;this.name2Id[R.name]=R.id;null!=P&&(this.id2Mask[R.id]=P)}else throw new ad("Duplicate key: name\x3d"+R.name+", id\x3d"+R.id);return this};na.prototype.addFeed=function(R){this.add(R.key,R.value)};na.prototype.hasKey=function(R){return null!=this.id2Value[R.id]};na.prototype.names=function(){return Object.keys(this.name2Id)};na.prototype.getValue=
function(R){if(R instanceof Nd){if(null==this.id2Value[R.id])throw new ad("Nonexistent key: "+R.name);return this.id2Value[R.id]}var x=this.name2Id[R];if(null==x)throw new ad("Feed dict has no SymbolicTensor name: "+R);return this.id2Value[x]};na.prototype.getMask=function(R){if(R instanceof Nd){if(null==this.id2Value[R.id])throw new ad("Nonexistent key: "+R.name);return this.id2Mask[R.id]}var x=this.name2Id[R];if(null==x)throw new ad("Feed dict has no SymbolicTensor name: "+R);return this.id2Mask[x]};
na.prototype.disposeMasks=function(){null!=this.id2Mask&&Kb.dispose(this.id2Mask)};return na}(),Sd={},Xe={},pf=function(na){function R(x){x=na.call(this,x)||this;x.isTraining=!1;return x}t(R,na);R.prototype.summary=function(x,P,ca){void 0===ca&&(ca=console.log);if(!this.built)throw new ad("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Kc(this,x,P,ca)};R.prototype.compile=
function(x){var P=this;null==x.loss&&(x.loss=[]);this.loss=x.loss;if("string"===typeof x.optimizer)this.optimizer_=Sb(x.optimizer),this.isOptimizerOwned=!0;else{if(!(x.optimizer instanceof Kb.Optimizer))throw new ad("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=x.optimizer;this.isOptimizerOwned=!1}var ca=[];if(Array.isArray(x.loss)||"string"===typeof x.loss||"function"===typeof x.loss)if(Array.isArray(x.loss)){if(x.loss.length!==this.outputs.length)throw new ad("When passing an Array as loss, it should have one entry per model output. The model has "+
(this.outputs.length+" output(s), but you passed loss\x3d")+(x.loss+"."));ca=x.loss.map(function(rd){return ab(rd)})}else{var Ka=ab(x.loss);this.outputs.forEach(function(rd){ca.push(Ka)})}else{x.loss=x.loss;for(var rb in x.loss)if(-1===this.outputNames.indexOf(rb))throw new ad('Unknown entry in loss dictionary: "'+rb+'". Only expected the following keys: '+this.outputNames);rb=0;for(var Mb=this.outputNames;rb<Mb.length;rb++){var Zb=Mb[rb];null==x.loss[Zb]&&console.warn('Output "'+Zb+'" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to '+
(Zb+" during training"));ca.push(ab(x.loss[Zb]))}}this.lossFunctions=ca;this.feedOutputNames=[];this.feedOutputShapes=[];this.feedLossFns=[];for(rb=0;rb<this.outputs.length;++rb)Mb=this.internalOutputShapes[rb],this.feedOutputNames.push(this.outputNames[rb]),this.feedOutputShapes.push(Mb),this.feedLossFns.push(this.lossFunctions[rb]);var Yb=[];this.metrics=x.metrics;this.metricsNames=["loss"];this.metricsTensors=[];D("loss",function(){for(var rd=0;rd<P.outputs.length;++rd)if(-1===Yb.indexOf(rd)){var Pd=
P.lossFunctions[rd];1<P.outputs.length&&(P.metricsTensors.push([Pd,rd]),P.metricsNames.push(P.outputNames[rd]+"_loss"))}});var Gc=Ad(x.metrics,this.outputNames),cd=function(rd,Pd,Od){1<P.outputNames.length&&(Pd=P.outputNames[rd]+"_"+Pd);P.metricsNames.push(Pd);P.metricsTensors.push([Od,rd])};D("metric",function(){var rd=function(Od){if(-1!==Yb.indexOf(Od))return"continue";(function(ce){var Yd,ve,Ye,jf=function(Af){if("string"===typeof Af&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(Af)){var Mf=
P.internalOutputShapes[Od];1===Mf[Mf.length-1]||P.lossFunctions[Od]===$c?-1!==["accuracy","acc"].indexOf(Af)?ve=Ta:-1!==["crossentropy","ce"].indexOf(Af)&&(ve=kd):P.lossFunctions[Od]===tc?-1!==["accuracy","acc"].indexOf(Af)?ve=ld:-1!==["crossentropy","ce"].indexOf(Af)&&(ve=tc):-1!==["accuracy","acc"].indexOf(Af)?ve=jb:-1!==["crossentropy","ce"].indexOf(Af)&&(ve=sc);Mf=void 0;-1!==["accuracy","acc"].indexOf(Af)?Mf="acc":-1!==["crossentropy","ce"].indexOf(Af)&&(Mf="ce");Ye=ve;Yd=""+Mf}else{if("string"===
typeof Af&&Af in Uc)Mf=Uc[Af];else if("string"!==typeof Af&&null!=Af)Mf=Af;else throw new ad("Unknown metric "+Af);Ye=Mf;Yd=""+Nb(Af)}var Rf;D(Yd,function(){Rf=Ye});cd(Od,Yd,Rf)},kf=0;for(;kf<ce.length;kf++)jf(ce[kf])})(Gc[Od])},Pd=0;for(;Pd<P.outputs.length;++Pd)rd(Pd)});this.collectedTrainableWeights=this.trainableWeights};R.prototype.checkTrainableWeightsConsistency=function(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")};
R.prototype.evaluate=function(x,P,ca){void 0===ca&&(ca={});var Ka=null==ca.batchSize?32:ca.batchSize;Ga(Ka);var rb=this.standardizeUserDataXY(x,P,!0,Ka);try{var Mb=rb[0].concat(rb[1]);this.makeTestFunction();var Zb=this.testLoop(this.testFunction,Mb,Ka,ca.verbose,ca.steps);return d(Zb)}finally{Ob(rb[0],x),Ob(rb[1],P)}};R.prototype.evaluateDataset=function(x,P){return r(this,void 0,void 0,function(){return u(this,function(ca){this.makeTestFunction();return[2,Ib(this,x,P)]})})};R.prototype.checkNumSamples=
function(x,P,ca,Ka){void 0===Ka&&(Ka="steps");if(null!=ca){if(x=null,null!=P)throw new ad("If "+Ka+" is set, batchSize must be null or undefined.Got batchSize \x3d "+P);}else if(null!=x)x=Array.isArray(x)?x[0].shape[0]:x.shape[0];else throw new ad("Either the input data should have a defined shape, or "+(Ka+" shoud be specified."));return x};R.prototype.execute=function(x,P){if(Array.isArray(P)&&0===P.length)throw new ad("`outputs` is an empty Array, which is not allowed.");var ca=Array.isArray(P);
P=this.retrieveSymbolicTensors(ca?P:[P]);var Ka=new Ed;x instanceof Kb.Tensor&&(x=[x]);if(Array.isArray(x)){if(x.length!==this.inputs.length)throw new ad("The number of inputs provided ("+x.length+") does not match the number of inputs of this model ("+(this.inputs.length+")."));for(var rb=0;rb<this.inputs.length;++rb)Ka.add(this.inputs[rb],x[rb])}else{rb=0;for(var Mb=this.inputs;rb<Mb.length;rb++){var Zb=Mb[rb],Yb=x[Zb.name];if(null==Yb)throw new ad("No value is provided for the model's input "+
Zb.name);Ka.add(Zb,Yb)}}x=Qe(P,Ka);return ca?x:x[0]};R.prototype.retrieveSymbolicTensors=function(x){for(var P=b(null,x.length),ca=x.length,Ka=0,rb=this.layers;Ka<rb.length;Ka++){var Mb=rb[Ka];Mb=Array.isArray(Mb.output)?Mb.output:[Mb.output];for(var Zb=Mb.map(function(rd){return rd.name}),Yb=0;Yb<x.length;++Yb){var Gc=Zb.indexOf(x[Yb]);-1!==Gc&&(P[Yb]=Mb[Gc],ca--);if(0===ca)break}if(0===ca)break}if(0<ca){var cd=[];P.forEach(function(rd,Pd){null==rd&&cd.push(x[Pd])});throw new ad("Cannot find SymbolicTensors for output name(s): "+
JSON.stringify(cd));}return P};R.prototype.predictLoop=function(x,P,ca){var Ka=this;void 0===P&&(P=32);void 0===ca&&(ca=!1);return Kb.tidy(function(){var rb=Ka.checkNumSamples(x);if(ca)throw new $e("Verbose predictLoop() is not implemented yet.");var Mb=mc(rb,P),Zb=Ka.outputs.map(function(Gc){return[]});rb=function(Gc){Kb.tidy(function(){var cd=hb(x,Mb[Gc][0],Mb[Gc][1]),rd=[];if(Array.isArray(cd))for(var Pd=0;Pd<cd.length;++Pd)rd.push({key:Ka.inputs[Pd],value:cd[Pd]});else rd.push({key:Ka.inputs[0],
value:cd});cd=new Ed(rd);return Qe(Ka.outputs,cd)}).forEach(function(cd,rd){return Zb[rd].push(cd)})};for(var Yb=0;Yb<Mb.length;++Yb)rb(Yb);return d(Zb.map(function(Gc){return Kb.concat(Gc,0)}))})};R.prototype.predict=function(x,P){void 0===P&&(P={});var ca=jc(x);fd(ca,this.inputNames,this.feedInputShapes,!1);try{var Ka=null==P.batchSize?32:P.batchSize;Ga(Ka);return this.predictLoop(ca,Ka)}finally{Ob(ca,x)}};R.prototype.predictOnBatch=function(x){fd(x,this.inputNames,this.feedInputShapes,!0);var P=
(Array.isArray(x)?x[0]:x).shape[0];return this.predictLoop(x,P)};R.prototype.standardizeUserDataXY=function(x,P,ca,Ka){if(null==this.optimizer_)throw new Gf("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");ca=[];for(var rb=0;rb<this.feedOutputShapes.length;++rb){var Mb=this.feedOutputShapes[rb];this.feedLossFns[rb]===tc?ca.push(Mb.slice(0,Mb.length-1).concat([1])):ca.push(Mb)}x=fc(x,this.feedInputNames,this.feedInputShapes,!1,"input");P=fc(P,this.feedOutputNames,
ca,!1,"target");yc(x,P);ca=P;rb=this.feedLossFns;Mb=this.feedOutputShapes;for(var Zb=[Yc,$c,sc],Yb=0;Yb<ca.length;++Yb){var Gc=ca[Yb],cd=rb[Yb],rd=Mb[Yb];if(null!=cd){if(cd===sc&&1===Gc.shape[Gc.shape.length-1])throw new ad("You are passing a target array of shape "+Gc.shape+" while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==Zb.indexOf(cd)){cd=Gc.shape.slice(1);for(var Pd=rd.slice(1),Od=
0;Od<cd.length;++Od){var ce=cd[Od],Yd=Pd[Od];if(null!=Yd&&ce!==Yd)throw new ad("A target Tensor with shape "+Gc.shape+" was passed for an output of shape "+(rd+", while using a loss function that expects targets to have the same shape as the output."));}}}}if(this.stateful&&null!=Ka&&0<Ka&&0!==x[0].shape[0]%Ka)throw new ad("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+(Ka+". Found: "+x[0].shape[0]+" sample(s)."));return[x,P]};R.prototype.standardizeUserData=
function(x,P,ca,Ka,rb,Mb){void 0===rb&&(rb=!0);return r(this,void 0,void 0,function(){var Zb,Yb,Gc,cd,rd,Pd,Od,ce;return u(this,function(Yd){switch(Yd.label){case 0:Zb=this.standardizeUserDataXY(x,P,rb,Mb);Yb=Zb[0];Gc=Zb[1];if(null!=ca)throw Error("sample weight is not supported yet.");cd=null;if(null==Ka)return[3,4];rd=Rd(Ka,this.outputNames,"classWeight");cd=[];Pd=0;Yd.label=1;case 1:if(!(Pd<rd.length))return[3,4];ce=(Od=cd).push;return[4,pc(Gc[Pd],null,rd[Pd])];case 2:ce.apply(Od,[Yd.sent()]),
Yd.label=3;case 3:return++Pd,[3,1];case 4:return[2,[Yb,Gc,cd]]}})})};R.prototype.testLoop=function(x,P,ca,Ka,rb){var Mb=this;void 0===Ka&&(Ka=0);return Kb.tidy(function(){var Zb=Mb.checkNumSamples(P,ca,rb,"steps"),Yb=[];if(0<Ka)throw new $e("Verbose mode is not implemented yet.");if(null!=rb)throw new $e("steps mode in testLoop() is not implemented yet");for(var Gc=mc(Zb,ca),cd=Kb.tensor1d(ba(0,Zb)),rd=0;rd<Gc.length;++rd){var Pd=Gc[rd][0],Od=Gc[rd][1],ce=fa(cd,Pd,Od-Pd);ce=Rb(P,ce);ce=x(ce);if(0===
rd)for(var Yd=0;Yd<ce.length;++Yd)Yb.push(Kb.scalar(0));for(Yd=0;Yd<ce.length;++Yd)Yb[Yd]=Kb.add(Yb[Yd],Kb.mul(Od-Pd,ce[Yd]))}for(Yd=0;Yd<Yb.length;++Yd)Yb[Yd]=Kb.div(Yb[Yd],Zb);return Yb})};R.prototype.getDedupedMetricsNames=function(){for(var x=this.metricsNames,P=[],ca=0;ca<x.length;++ca){var Ka=x[ca],rb=Ka;1<g(x,Ka)&&(Ka=g(x.slice(0,ca),Ka),rb+="_"+Ka);P.push(rb)}return P};R.prototype.makeTrainFunction=function(){var x=this;return function(P){var ca=[],Ka=P.slice(0,x.inputs.length),rb=P.slice(x.inputs.length,
x.inputs.length+x.outputs.length),Mb=P.slice(x.inputs.length+x.outputs.length,x.inputs.length+2*x.outputs.length),Zb=[];P=x.collectedTrainableWeights.map(function(Yb){return Yb.read()});return[x.optimizer_.minimize(function(){for(var Yb=[],Gc=0;Gc<x.inputs.length;++Gc)Yb.push({key:x.inputs[Gc],value:Ka[Gc]});Gc=new Ed(Yb);Yb=Qe(x.outputs,Gc,{training:!0});for(Gc=0;Gc<x.lossFunctions.length;++Gc){var cd=(0,x.lossFunctions[Gc])(rb[Gc],Yb[Gc]);null!=Mb[Gc]&&(cd=Kb.mul(cd,Mb[Gc]));var rd=Kb.mean(cd);
ca.push(rd);var Pd=0===Gc?cd:Kb.add(Pd,cd)}for(Gc=0;Gc<x.metricsTensors.length;++Gc)cd=void 0,1<x.outputs.length&&Gc<x.outputs.length?cd=ca[Gc]:(cd=x.metricsTensors[Gc][1],cd=Kb.mean((0,x.metricsTensors[Gc][0])(rb[cd],Yb[cd]))),Kb.keep(cd),Zb.push(cd);Pd=Kb.mean(Pd);x.calculateLosses().forEach(function(Od){Pd=Kb.add(Pd,Od)});return Pd},!0,P)].concat(Zb)}};R.prototype.makeTestFunction=function(){var x=this;this.testFunction=function(P){return Kb.tidy(function(){for(var ca=[],Ka,rb=P.slice(0,x.inputs.length),
Mb=P.slice(x.inputs.length,x.inputs.length+x.outputs.length),Zb=[],Yb=0;Yb<x.inputs.length;++Yb)Zb.push({key:x.inputs[Yb],value:rb[Yb]});Yb=new Ed(Zb);rb=Qe(x.outputs,Yb);for(Yb=0;Yb<x.lossFunctions.length;++Yb)Zb=Kb.mean((0,x.lossFunctions[Yb])(Mb[Yb],rb[Yb])),Ka=0===Yb?Zb:Kb.add(Ka,Zb),ca.push(Ka);for(Yb=0;Yb<x.metricsTensors.length;++Yb)Ka=x.metricsTensors[Yb][1],Ka=Kb.mean((0,x.metricsTensors[Yb][0])(Mb[Ka],rb[Ka])),ca.push(Ka);return ca})}};R.prototype.fit=function(x,P,ca){void 0===ca&&(ca={});
return r(this,void 0,void 0,function(){return u(this,function(Ka){return[2,ic(this,x,P,ca)]})})};R.prototype.fitDataset=function(x,P){return r(this,void 0,void 0,function(){return u(this,function(ca){return[2,rc(this,x,P)]})})};R.prototype.trainOnBatch=function(x,P){return r(this,void 0,void 0,function(){var ca,Ka,rb,Mb,Zb,Yb,Gc,cd,rd,Pd;return u(this,function(Od){switch(Od.label){case 0:return[4,this.standardizeUserData(x,P)];case 1:ca=Od.sent(),Ka=ca[0],rb=ca[1],Mb=this.makeTrainFunction(),Zb=Mb(Ka.concat(rb)),
Yb=[],Gc=0,cd=Zb,Od.label=2;case 2:if(!(Gc<cd.length))return[3,5];rd=cd[Gc];return[4,rd.data()];case 3:Pd=Od.sent(),Yb.push(Pd[0]),Od.label=4;case 4:return Gc++,[3,2];case 5:return Kb.dispose(Zb),[2,d(Yb)]}})})};R.prototype.getNamedWeights=function(x){for(var P=[],ca=(x=null!=x&&x.trainableOnly)?this.trainableWeights:this.weights,Ka=this.getWeights(x),rb=0;rb<ca.length;++rb)x&&!ca[rb].trainable||P.push({name:ca[rb].originalName,tensor:Ka[rb]});return P};Object.defineProperty(R.prototype,"stopTraining",
{get:function(){return this.stopTraining_},set:function(x){this.stopTraining_=x},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"optimizer",{get:function(){return this.optimizer_},set:function(x){this.optimizer_!==x&&(this.optimizer_=x,this.isOptimizerOwned=!1)},enumerable:!0,configurable:!0});R.prototype.dispose=function(){var x=na.prototype.dispose.call(this);if(0===x.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){var P=Kb.memory().numTensors;this.optimizer_.dispose();
x.numDisposedVariables+=P-Kb.memory().numTensors}return x};R.prototype.getLossIdentifiers=function(){if("string"===typeof this.loss)var x=c(this.loss);else if(Array.isArray(this.loss)){x=0;for(var P=this.loss;x<P.length;x++)if("string"!==typeof P[x])throw Error("Serialization of non-string loss is not supported.");x=this.loss.map(function(Mb){return c(Mb)})}else{P=Object.keys(this.loss);x={};for(var ca=this.loss,Ka=0;Ka<P.length;Ka++){var rb=P[Ka];if("string"===typeof ca[rb])x[rb]=c(ca[rb]);else throw Error("Serialization of non-string loss is not supported.");
}}return x};R.prototype.getMetricIdentifiers=function(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[c(Nb(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(function(ca){return c(Nb(ca))});var x={},P;for(P in this.metrics)x[P]=c(Nb(this.metrics[P]));return x};R.prototype.getTrainingConfig=function(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}};
R.prototype.loadTrainingConfig=function(x){if(null!=x.weighted_metrics)throw Error("Loading weight_metrics is not supported yet.");if(null!=x.loss_weights)throw Error("Loading loss_weights is not supported yet.");if(null!=x.sample_weight_mode)throw Error("Loading sample_weight_mode is not supported yet.");var P=Ne(x.optimizer_config);P=Xb(P);if("string"===typeof x.loss)var ca=l(x.loss);else if(Array.isArray(x.loss))ca=x.loss.map(function(Mb){return l(Mb)});else if(null!=x.loss){ca={};for(var Ka in x.loss)ca[Ka]=
l(x.loss[Ka])}if(Array.isArray(x.metrics))var rb=x.metrics.map(function(Mb){return l(Mb)});else if(null!=x.metrics)for(Ka in rb={},x.metrics)rb[Ka]=l(x.metrics[Ka]);this.compile({loss:ca,metrics:rb,optimizer:P})};R.prototype.save=function(x,P){return r(this,void 0,void 0,function(){var ca,Ka,rb,Mb,Zb,Yb,Gc,cd,rd,Pd,Od,ce;return u(this,function(Yd){switch(Yd.label){case 0:if("string"===typeof x){ca=Kb.io.getSaveHandlers(x);if(0===ca.length)throw new ad("Cannot find any save handlers for URL '"+x+"'");
if(1<ca.length)throw new ad("Found more than one ("+ca.length+") save handlers for URL '"+(x+"'"));x=ca[0]}if(null==x.save)throw new ad("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return[4,Kb.io.encodeWeights(this.getNamedWeights(P))];case 1:Ka=Yd.sent();rb=this.toJSON(null,!1);Mb={modelTopology:rb,format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v2.7.0",convertedBy:null};Zb=null==P?!1:P.includeOptimizer;if(!Zb||null==
this.optimizer)return[3,4];Mb.trainingConfig=this.getTrainingConfig();Yb="optimizer";Od=(Pd=Kb.io).encodeWeights;return[4,this.optimizer.getWeights()];case 2:return[4,Od.apply(Pd,[Yd.sent(),Yb])];case 3:Gc=Yd.sent(),cd=Gc.data,rd=Gc.specs,(ce=Ka.specs).push.apply(ce,rd),Ka.data=Kb.io.concatenateArrayBuffers([Ka.data,cd]),Yd.label=4;case 4:return null!=this.userDefinedMetadata&&(Tb(this.userDefinedMetadata,this.name,!0),Mb.userDefinedMetadata=this.userDefinedMetadata),Mb.weightData=Ka.data,Mb.weightSpecs=
Ka.specs,[2,x.save(Mb)]}})})};R.prototype.setUserDefinedMetadata=function(x){Tb(x,this.name);this.userDefinedMetadata=x};R.prototype.getUserDefinedMetadata=function(){return this.userDefinedMetadata};R.className="Model";return R}(function(na){function R(x){var P=na.call(this,{})||this;P.containerNodes=new Set;P.name=x.name;if(null==P.name){var ca=P.getClassName().toLowerCase();P.name=ha(ca)}P.supportsMasking=!1;P.trainable_=!0;Array.isArray(x.inputs)?P.inputs=x.inputs.slice():P.inputs=[x.inputs];
Array.isArray(x.outputs)?P.outputs=x.outputs.slice():P.outputs=[x.outputs];if(q(P.inputs).length!==P.inputs.length)throw new ad("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+P.inputs.map(function(kf){return kf.name}));q(P.outputs).length!==P.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+P.outputs.map(function(kf){return kf.name}));P.inputLayers=[];P.inputLayersNodeIndices=
[];P.inputLayersTensorIndices=[];P.outputLayers=[];P.outputLayersNodeIndices=[];P.outputLayersTensorIndices=[];P.layers=[];P.internalContainerRefs=[];for(var Ka=0,rb=P.outputs;Ka<rb.length;Ka++){var Mb=rb[Ka];ca=Mb.sourceLayer;var Zb=Mb.nodeIndex;Mb=Mb.tensorIndex;P.outputLayers.push(ca);P.outputLayersNodeIndices.push(Zb);P.outputLayersTensorIndices.push(Mb)}Ka=0;for(rb=P.inputs;Ka<rb.length;Ka++)Mb=rb[Ka],ca=Mb.sourceLayer,Zb=Mb.nodeIndex,Mb=Mb.tensorIndex,e(0===Zb,"input layer has \x3e1 nodes"),
e(0===Mb,"input layer has \x3e1 tensors"),P.inputLayers.push(ca),P.inputLayersNodeIndices.push(Zb),P.inputLayersTensorIndices.push(Mb);P.inputNames=[];P.outputNames=[];P.feedInputShapes=[];P.feedInputNames=[];P.feedOutputNames=[];for(Mb=0;Mb<P.inputLayers.length;Mb++){ca=P.inputLayers[Mb];if(!(ca instanceof le))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: "+(x.inputs+". Input ")+(Mb+" (0-based) originates from layer type ")+(ca.getClassName()+"."));
P.inputNames.push(ca.name);P.feedInputShapes.push(ca.batchInputShape);P.feedInputNames.push(ca.name)}Mb=0;for(Zb=P.outputLayers;Mb<Zb.length;Mb++)ca=Zb[Mb],P.outputNames.push(ca.name);P.internalInputShapes=P.inputs.map(function(kf){return kf.shape});P.internalOutputShapes=P.outputs.map(function(kf){return kf.shape});var Yb={},Gc={};Ka={};rb={};var cd={},rd=[],Pd=function(kf,Af,Mf,Rf,Bf,lg){if(null==Rf||null==Bf||null==lg)Rf=kf.sourceLayer,Bf=kf.nodeIndex;lg=Rf.inboundNodes[Bf];if(-1!==Mf.indexOf(lg))throw new Gf("The tensor "+
kf.name+' at layer "'+Rf.name+'" is part of a cycle.');if(-1===Af.indexOf(lg)){P.containerNodes.add(R.nodeKey(Rf,Bf));Rf.id in cd||(cd[Rf.id]=Object.keys(cd).length);-1===Mf.indexOf(lg)&&Mf.push(lg);kf=lg.inboundLayers.length;for(Rf=0;Rf<kf;Rf++)Pd(lg.inputTensors[Rf],Af,Mf,lg.inboundLayers[Rf],lg.nodeIndices[Rf],lg.tensorIndices[Rf]);for(Af.push(lg);0<=Mf.indexOf(lg);)Mf.splice(Mf.indexOf(lg),1);rd.push(lg)}};ca=[];Zb=[];x=0;for(var Od=P.outputs;x<Od.length;x++)Mb=Od[x],Pd(Mb,ca,Zb);Od=0;for(var ce=
rd.slice().reverse();Od<ce.length;Od++)for(x=ce[Od],Gc[x.id]=x,(x.id in Yb)||(Yb[x.id]=0),ca=Yb[x.id],ca=Math.max(ca,null==Ka[x.outboundLayer.id]?0:Ka[x.outboundLayer.id]),Ka[x.outboundLayer.id]=ca,rb[x.outboundLayer.id]=x.outboundLayer,Yb[x.id]=ca,Mb=0;Mb<x.inboundLayers.length;Mb++){var Yd=x.inboundLayers[Mb];Zb=x.nodeIndices[Mb];Zb=Yd.inboundNodes[Zb];Yb[Zb.id]=Math.max(ca+1,null==Yb[Zb.id]?0:Yb[Zb.id]);Gc[Zb.id]=Zb}Zb={};for(var ve in Yb)ca=Yb[ve],ca in Zb||(Zb[ca]=[]),Zb[ca].push(Gc[ve]);Mb=
{};for(var Ye in Ka)ca=Ka[Ye],ca in Mb||(Mb[ca]=[]),Mb[ca].push(rb[Ye]);ca=Object.keys(Mb).map(function(kf){return parseInt(kf,10)}).sort(p);P.layers=[];Ye=0;for(ve=ca;Ye<ve.length;Ye++)for(ca=ve[Ye],ca=Mb[ca],ca.sort(function(kf,Af){kf=cd[kf.id];Af=cd[Af.id];return kf<Af?-1:kf>Af?1:0}),x=0,Ka=ca;x<Ka.length;x++)ca=Ka[x],ca instanceof R&&P.internalContainerRefs.push(ca),P.layers.push(ca);P.layersByDepth=Mb;ca=Object.keys(Zb).map(function(kf){return parseInt(kf,10)}).sort(p);Ye=P.inputs.slice();ve=
[];Ka=0;for(rb=ca;Ka<rb.length;Ka++)for(ca=rb[Ka],Yb=0,Gc=Zb[ca];Yb<Gc.length;Yb++)if(x=Gc[Yb],ca=x.outboundLayer,null!=ca){Od=0;for(ce=x.inputTensors;Od<ce.length;Od++)if(Mb=ce[Od],-1===Ye.indexOf(Mb))throw new Gf("Graph disconnected: cannot obtain value for tensor "+Mb+(' at layer "'+ca.name+'". The following previous layers were accessed without issue: ')+ve);Od=0;for(x=x.outputTensors;Od<x.length;Od++)Mb=x[Od],Ye.push(Mb);ve.push(ca.name)}P.nodesByDepth=Zb;var jf=P.layers.map(function(kf){return kf.name});
ca=function(kf){var Af=jf.filter(function(Mf){return Mf===kf}).length;if(1!==Af)throw new Gf('The name "'+kf+'" is used '+Af+" times in the model. All layer names should be unique. Layer names: "+JSON.stringify(jf));};for(Ye=0;Ye<jf.length;Ye++)ca(jf[Ye]);P.outboundNodes=[];P.inboundNodes=[];new ne({outboundLayer:P,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:P.inputs,outputTensors:P.outputs,inputMasks:P.inputs.map(function(kf){return null}),outputMasks:P.outputs.map(function(kf){return null}),
inputShapes:P.inputs.map(function(kf){return kf.shape}),outputShapes:P.outputs.map(function(kf){return kf.shape})});P.built=!0;P._refCount=1;return P}t(R,na);R.prototype.assertNotDisposed=function(){if(0===this._refCount)throw Error("Container '"+this.name+"' is already disposed.");};R.prototype.dispose=function(){this.assertNotDisposed();var x={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(var P=0,ca=this.layers;P<ca.length;P++)x.numDisposedVariables+=ca[P].dispose().numDisposedVariables;
P=0;for(ca=this.internalContainerRefs;P<ca.length;P++)x.numDisposedVariables+=ca[P].dispose().numDisposedVariables}x.refCountAfterDispose=this._refCount;return x};Object.defineProperty(R.prototype,"trainable",{get:function(){return this.trainable_},set:function(x){this.layers.forEach(function(P){P._trainableWeights.forEach(function(ca){return ca.trainable=x})});this.trainable_=x},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"trainableWeights",{get:function(){if(0<this._trainableWeights.length)throw new ad("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
if(!this.trainable)return[];for(var x=[],P=0,ca=this.layers;P<ca.length;P++)x=x.concat(ca[P].trainableWeights);return x},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"nonTrainableWeights",{get:function(){for(var x=[],P=0,ca=this.layers;P<ca.length;P++){var Ka=ca[P];x.push.apply(x,Ka.nonTrainableWeights)}if(!this.trainable){P=[];ca=0;for(var rb=this.layers;ca<rb.length;ca++)Ka=rb[ca],P.push.apply(P,Ka.trainableWeights);return P.concat(x)}return x},enumerable:!0,configurable:!0});
Object.defineProperty(R.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0});R.prototype.loadWeights=function(x,P){void 0===P&&(P=!0);for(var ca={},Ka=0,rb=0,Mb=this.layers;rb<Mb.length;rb++)for(var Zb=0,Yb=Mb[rb].weights;Zb<Yb.length;Zb++){var Gc=Yb[Zb];if(null!=ca[Gc.originalName])throw new ad("Duplicate weight name: "+Gc.originalName);ca[Gc.originalName]=Gc;Ka++}rb=[];for(var cd in x){Mb=cd;null==ca[cd]&&(Mb=cd.split("/"),
Mb=Mb.slice(0,-2).concat([Mb[Mb.length-1]]).join("/"));if(null!=ca[Mb])rb.push([ca[Mb],x[cd]]);else if(P)throw new ad("Provided weight data has no target variable: "+cd);delete ca[Mb]}if(P){x=[];for(var rd in ca)x.push(rd);if(0<x.length)throw new ad(x.length+" of "+Ka+" weights are not set: "+x);}lb(rb)};R.prototype.updatedConfig=function(){var x=this.getConfig(),P={};P.className=this.getClassName();P.config=x;P.kerasVersion="tfjs-layers 2.7.0";P.backend="TensorFlow.js";return P};R.prototype.toJSON=
function(x,P){void 0===P&&(P=!0);x=Je(this.updatedConfig());return P?JSON.stringify(x):x};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){x=h(x);for(var Ka=new Ed,rb=0;rb<ca.inputs.length;++rb)Ka.add(ca.inputs[rb],x[rb]);return Qe(ca.outputs,Ka,P)})};R.prototype.computeMask=function(x,P){var ca=this;return Kb.tidy(function(){x=h(x);var Ka=null==P?b(null,x.length):h(P);return ca.runInternalGraph(x,Ka)[1]})};R.prototype.computeOutputShape=function(x){var P=Qa(x);if(P.length!==this.inputLayers.length)throw new ad("Invalid inputShape argument "+
x+": model has "+(this.inputLayers.length+" tensor inputs."));x={};for(var ca=0;ca<P.length;ca++){var Ka=this.inputLayers[ca],rb=Ka.name+"_0_0";x[rb]=P[ca]}ca=Object.keys(this.nodesByDepth).map(function(rd){return parseInt(rd,10)}).sort(p);if(1<ca.length)for(P=0;P<ca.length;P++)for(var Mb=0,Zb=this.nodesByDepth[ca[P]];Mb<Zb.length;Mb++){var Yb=Zb[Mb];Ka=Yb.outboundLayer;if(-1===this.inputLayers.map(function(rd){return rd.id}).indexOf(Ka.id)){for(var Gc=[],cd=0;cd<Yb.inboundLayers.length;cd++)rb=Yb.tensorIndices[cd],
rb=Yb.inboundLayers[cd].name+"_"+Yb.nodeIndices[cd]+"_"+rb,Gc.push(x[rb]);rb=Ka.computeOutputShape(d(Gc));Gc=Qa(rb);Yb=Ka.inboundNodes.indexOf(Yb);for(cd=0;cd<Gc.length;cd++)rb=Ka.name+"_"+Yb+"_"+cd,x[rb]=Gc[cd]}}P=[];Mb=[];for(ca=0;ca<this.outputLayers.length;ca++)Ka=this.outputLayers[ca],Yb=this.outputLayersNodeIndices[ca],rb=this.outputLayersTensorIndices[ca],rb=Ka.name+"_"+Yb+"_"+rb,Mb.push(rb);for(ca=0;ca<Mb.length;ca++)Ka=Mb[ca],e(Ka in x),P.push(x[Ka]);return d(P)};R.prototype.runInternalGraph=
function(x,P){null==P&&(P=b(null,x.length));for(var ca={},Ka=0;Ka<this.inputs.length;++Ka){var rb=this.inputs[Ka],Mb=x[Ka],Zb=P[Ka];ca[rb.id]=[Mb,Zb]}x=0;for(P=Object.keys(this.nodesByDepth).map(function(Yd){return parseInt(Yd,10)}).sort(p);x<P.length;x++)for(var Yb=0,Gc=this.nodesByDepth[P[x]];Yb<Gc.length;Yb++){Ka=Gc[Yb];Zb=Ka.outboundLayer;var cd=Ka.inputTensors,rd=Ka.outputTensors;Mb=[];for(var Pd=0,Od=cd;Pd<Od.length;Pd++)rb=Od[Pd],rb.id in ca&&Mb.push(ca[rb.id]);if(Mb.length===cd.length){rb=
{};var ce=Od=void 0;Pd=cd=void 0;null!=Ka.callArgs&&(rb=Ka.callArgs);1===Mb.length?(cd=Mb[0],Ka=cd[0],Mb=cd[1],null==rb.mask&&(rb.mask=Mb),cd=h(Zb.call(Ka,rb)),Pd=h(Zb.computeMask(Ka,Mb)),Od=[Ka],ce=[Mb]):(Od=Mb.map(function(Yd){return Yd[0]}),ce=Mb.map(function(Yd){return Yd[1]}),null==rb.mask&&(rb.mask=ce),cd=h(Zb.call(Od,rb)),Pd=h(Zb.computeMask(Od,ce)));if(Zb.activityRegularizer)throw new $e("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
for(Ka=0;Ka<rd.length;++Ka)rb=rd[Ka],Mb=cd[Ka],Zb=Pd[Ka],ca[rb.id]=[Mb,Zb]}}x=[];P=[];Yb=[];Gc=0;for(rd=this.outputs;Gc<rd.length;Gc++)rb=rd[Gc],e(rb.id in ca,"Could not compute output "+rb.name+" : "+rb.id),Zb=ca[rb.id],rb=Zb[0],Zb=Zb[1],Yb.push(rb.shape),x.push(rb),P.push(Zb);return[x,P,Yb]};R.prototype.buildNodeConversionMap=function(x){x={};for(var P,ca=0,Ka=this.layers;ca<Ka.length;ca++){var rb=Ka[ca];P=rb instanceof R?1:0;for(var Mb=0;Mb<rb.inboundNodes.length;Mb++){var Zb=R.nodeKey(rb,Mb);
this.containerNodes.has(Zb)&&(x[Zb]=P,P+=1)}}return x};R.prototype.getLayer=function(x,P){if(null!=P){if(this.layers.length<=P)throw new ad("Was asked to retrieve layer at index "+P+", but model only has "+(this.layers.length+" layer(s)."));return this.layers[P]}if(null==x)throw new ad("Provide either a layer name or layer index");P=0;for(var ca=this.layers;P<ca.length;P++){var Ka=ca[P];if(Ka.name===x)return Ka}throw new ad("No such layer: "+x);};R.prototype.calculateLosses=function(){var x=this;
return Kb.tidy(function(){for(var P=[],ca=0,Ka=x.layers;ca<Ka.length;ca++)for(var rb=Ka[ca],Mb=0;Mb<rb.inboundNodes.length;++Mb){var Zb=R.nodeKey(rb,Mb);x.containerNodes.has(Zb)&&P.push.apply(P,rb.calculateLosses())}return P})};R.prototype.getConfig=function(){for(var x={name:this.name},P=this.buildNodeConversionMap(this.layers),ca=[],Ka=0,rb=this.layers;Ka<rb.length;Ka++){for(var Mb=rb[Ka],Zb=Mb.getClassName(),Yb=Mb.getConfig(),Gc=[],cd=0;cd<Mb.inboundNodes.length;cd++){var rd=Mb.inboundNodes[cd],
Pd=R.nodeKey(Mb,cd),Od={};if(this.containerNodes.has(Pd)){if(rd.callArgs)try{JSON.stringify(rd.callArgs),Od=rd.callArgs}catch(jf){console.warn("Layer "+Mb.name+" was passed non-serializable keyword arguments: "+(rd.callArgs+". They will not be included in the serialized model (and thus will be missing at deserialization time).")),Od={}}if(0<rd.inboundLayers.length){for(var ce=[],Yd=0;Yd<rd.inboundLayers.length;Yd++){var ve=rd.inboundLayers[Yd],Ye=rd.nodeIndices[Yd];Pd=rd.tensorIndices[Yd];Ye=R.nodeKey(ve,
Ye);Ye=P[Ye];null==Ye&&(Ye=0);ce.push([ve.name,Ye,Pd,Od])}Gc.push(ce)}}}Yd={};Yd.name=Mb.name;Yd.className=Zb;Yd.config=Yb;Yd.inboundNodes=Gc;ca.push(Yd)}x.layers=ca;ca=[];for(Yd=0;Yd<this.inputLayers.length;Yd++)if(Mb=this.inputLayers[Yd],Ye=this.inputLayersNodeIndices[Yd],Pd=R.nodeKey(Mb,Ye),this.containerNodes.has(Pd)){Ye=P[Pd];if(null===Ye||void 0===Ye)Ye=0;Pd=this.inputLayersTensorIndices[Yd];ca.push([Mb.name,Ye,Pd])}x.inputLayers=ca;ca=[];for(Yd=0;Yd<this.outputLayers.length;Yd++)if(Mb=this.outputLayers[Yd],
Ye=this.outputLayersNodeIndices[Yd],Pd=R.nodeKey(Mb,Ye),this.containerNodes.has(Pd)){Ye=P[Pd];if(null===Ye||void 0===Ye)Ye=0;Pd=this.outputLayersTensorIndices[Yd];ca.push([Mb.name,Ye,Pd])}x.outputLayers=ca;return x};R.fromConfig=function(x,P,ca,Ka){function rb(jf,kf){jf.name in Gc?Gc[jf.name].push(kf):Gc[jf.name]=[kf]}function Mb(jf,kf){for(var Af=[],Mf,Rf=0;Rf<kf.length;Rf++){Mf=kf[Rf];var Bf=Mf[0],lg=Mf[1],eh=Mf[2];Mf=null==Mf[3]?{}:Mf[3];if(!(Bf in Yb)){rb(jf,kf);return}Bf=Yb[Bf];if(Bf.inboundNodes.length<=
lg){rb(jf,kf);return}Af.push(Bf.inboundNodes[lg].outputTensors[eh])}0<Af.length&&jf.apply(d(Af),Mf)}function Zb(jf){var kf=jf.name,Af=Xb(jf,null!=P.customObjects?P.customObjects:{});Af.setFastWeightInitDuringBuild(Ka);Yb[kf]=Af;jf.inboundNodes.forEach(function(Mf){if(!(Mf instanceof Array))throw new ad("Corrupted configuration, expected array for nodeData: "+Mf);rb(Af,Mf)})}void 0===Ka&&(Ka=!1);var Yb={},Gc={};ca=P.name;for(var cd=P.layers,rd=0;rd<cd.length;rd++){var Pd=cd[rd];Zb(Pd)}for(;!w(Gc);){rd=
0;for(var Od=cd;rd<Od.length;rd++)if(Pd=Od[rd],Pd=Yb[Pd.name],Pd.name in Gc){var ce=Gc[Pd.name];delete Gc[Pd.name];for(var Yd=0;Yd<ce.length;Yd++)Mb(Pd,ce[Yd])}}cd=[];rd=[];ce=0;for(var ve=P.inputLayers;ce<ve.length;ce++){Pd=ve[ce];var Ye=Pd[0];Od=Pd[1];Yd=Pd[2];e(Ye in Yb);Pd=Yb[Ye];Pd=Pd.inboundNodes[Od].outputTensors;cd.push(Pd[Yd])}ce=0;for(ve=P.outputLayers;ce<ve.length;ce++)Pd=ve[ce],Ye=Pd[0],Od=Pd[1],Yd=Pd[2],e(Ye in Yb),Pd=Yb[Ye],Pd=Pd.inboundNodes[Od].outputTensors,rd.push(Pd[Yd]);return new x({inputs:cd,
outputs:rd,name:ca})};Object.defineProperty(R.prototype,"stateful",{get:function(){if(this._stateful)throw new ad("Container instance unexpectedly has _stateful \x3d true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(var x=0,P=this.layers;x<P.length;x++)if(P[x].stateful)return!0;return!1},enumerable:!0,configurable:!0});R.prototype.resetStates=function(){var x=this;Kb.tidy(function(){x.layers.forEach(function(P){P.stateful&&
P.resetStates()})})};return R}(Vd));Kb.serialization.registerClass(pf);var wf=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.className="Functional";return R}(pf);Kb.serialization.registerClass(wf);var Yf=function(na){function R(x){var P=na.call(this,{inputs:[],outputs:[]})||this;x=x||{};P.trainable=!0;P.built=!1;P.name=null!=x.name?x.name:ha("sequential_");if(null!=x.layers){var ca=0;for(x=x.layers;ca<x.length;ca++)P.add(x[ca])}return P}t(R,na);R.prototype.checkShape=
function(x){if(x.inboundNodes[0].outputTensors[0].shape.some(function(P){return 0>P}))throw new ad("Negative dimension size caused by adding layer "+(x.name+" with input shape [")+(x.inboundNodes[0].inputTensors[0].shape+"]"));};R.prototype.add=function(x){var P=x instanceof R||x instanceof pf;if(P){var ca=x;if(1!==ca.outputs.length)throw new ad("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==ca.inputs.length)throw new ad("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
}if(0===this.outputs.length){if(0===x.inboundNodes.length){if(null==x.batchInputShape)throw new ad("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");var Ka=tb({batchShape:x.batchInputShape,dtype:x.dtype,name:x.name+"_input"});x.apply(Ka)}if(P)this.outputs=ca.outputs,this.inputs=ca.inputs;else{if(1!==x.inboundNodes.length)throw new ad("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer "+(x.name+
" which has ")+(x.inboundNodes.length+" pre-existing inbound connections."));if(1!==x.inboundNodes[0].outputTensors.length)throw new ad("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(x);this.outputs=[x.inboundNodes[0].outputTensors[0]];this.inputs=Pb(this.outputs[0])}this.inboundNodes=[];new ne({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,
inputMasks:b(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(function(rb){return rb.shape}),outputShapes:this.outputs[0].shape})}else{P=x.apply(this.outputs[0]);if(Array.isArray(P))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(x);this.outputs=[P];this.inboundNodes[0].outputTensors=this.outputs;this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(x);
this.built=!1};R.prototype.pop=function(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");this.layers.pop();if(0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{var x=this.layers.length-1;this.layers[x].outboundNodes=[];this.outputs=[this.layers[x].output];this.inboundNodes[0].outputTensors=this.outputs;this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}};R.prototype.call=function(x,P){null==this.model&&this.build();return this.model.call(x,
P)};R.prototype.build=function(x){cb(x);if(0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new pf({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"});this.model.trainable=this.trainable;this.supportsMasking=this.model.supportsMasking;this.inputLayers=this.model.inputLayers;this.inputLayersNodeIndices=this.model.inputLayersNodeIndices;this.inputLayersTensorIndices=this.model.inputLayersTensorIndices;
this.outputLayers=this.model.outputLayers;this.outputLayersNodeIndices=this.model.outputLayersNodeIndices;this.outputLayersTensorIndices=this.model.outputLayersTensorIndices;this.nodesByDepth=this.model.nodesByDepth;this.containerNodes=this.model.containerNodes;this.outputNames=this.model.outputNames;this.inputNames=this.model.inputNames;this.built=!0};R.prototype.countParams=function(){this.built||this.build();return na.prototype.countParams.call(this)};R.prototype.summary=function(x,P,ca){void 0===
ca&&(ca=console.log);this.built||this.build();na.prototype.summary.call(this,x,P,ca)};R.prototype.setWeights=function(x){null==this.model&&this.build();this.model.setWeights(x)};R.prototype.evaluate=function(x,P,ca){void 0===ca&&(ca={});if(!this.built)throw new Gf("The model needs to be compiled before being used.");return this.model.evaluate(x,P,ca)};R.prototype.evaluateDataset=function(x,P){return r(this,void 0,void 0,function(){return u(this,function(ca){if(!this.built)throw new Gf("The model needs to be compiled before being used.");
return[2,this.model.evaluateDataset(x,P)]})})};R.prototype.predict=function(x,P){void 0===P&&(P={});null==this.model&&this.build();return this.model.predict(x,P)};R.prototype.predictOnBatch=function(x){null==this.model&&this.build();return this.model.predictOnBatch(x)};R.prototype.compile=function(x){this.build();this.model.compile(x);this.optimizer_=this.model.optimizer;this.isOptimizerOwned=this.model.isOptimizerOwned;this.loss=this.model.loss;this.metrics=this.model.metrics;this.metricsTensors=
this.model.metricsTensors;this.metricsNames=this.model.metricsNames};Object.defineProperty(R.prototype,"optimizer",{get:function(){return null==this.model?void 0:this.model.optimizer},set:function(x){this.model.optimizer=x},enumerable:!0,configurable:!0});R.prototype.fit=function(x,P,ca){void 0===ca&&(ca={});return r(this,void 0,void 0,function(){return u(this,function(Ka){if(!this.built)throw new Gf("The model needs to be compiled before being used.");return[2,this.model.fit(x,P,ca)]})})};R.prototype.fitDataset=
function(x,P){return r(this,void 0,void 0,function(){return u(this,function(ca){if(!this.built)throw new Gf("The model needs to be compiled before being used.");return[2,this.model.fitDataset(x,P)]})})};R.prototype.trainOnBatch=function(x,P){return r(this,void 0,void 0,function(){return u(this,function(ca){return[2,this.model.trainOnBatch(x,P)]})})};R.fromConfig=function(x,P,ca,Ka){void 0===Ka&&(Ka=!1);var rb={};if(P instanceof Array){if(null==P[0].className||"Merge"===P[0].className)throw new ad("Legacy serialization format not supported yet.");
ca=P}else Kb.util.assert(null!=P.layers,function(){return"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."}),ca=P.layers,delete P.layers,rb=P;x=new x(rb);if(!(x instanceof R))throw new $e("Sequential.fromConfig called on non-Sequential input: "+x);for(P=0;P<ca.length;P++)rb=Xb(ca[P],void 0,Ka),Ka&&rb.setFastWeightInitDuringBuild(!0),x.add(rb);return x};Object.defineProperty(R.prototype,"stopTraining",{get:function(){if(null==this.model)throw new ad("Cannot get the stopTraining property of a sequential model before it is compiled.");
return this.model.stopTraining},set:function(x){if(null==this.model)throw new ad("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=x},enumerable:!0,configurable:!0});R.prototype.getConfig=function(){for(var x=[],P=0,ca=this.layers;P<ca.length;P++){var Ka=ca[P],rb={};rb.className=Ka.getClassName();rb.config=Ka.getConfig();x.push(rb)}return{name:this.name,layers:x}};R.className="Sequential";return R}(pf);Kb.serialization.registerClass(Yf);var of=
function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.getConfig=function(){return{}};return R}(Kb.serialization.Serializable),fg=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.apply=function(x,P){void 0===P&&(P=1);void 0===P&&(P=1);if(1!==P)throw new $e("Support for alpha values other than 1 ("+P+") is not implemented yet.");return Kb.elu(x)};R.className="elu";return R}(of);Kb.serialization.registerClass(fg);
var zd=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.apply=function(x){return Kb.selu(x)};R.className="selu";return R}(of);Kb.serialization.registerClass(zd);var uf=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.apply=function(x){return Kb.relu(x)};R.className="relu";return R}(of);Kb.serialization.registerClass(uf);var ng=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);
R.prototype.apply=function(x){return Kb.tidy(function(){return Kb.minimum(6,Kb.relu(x))})};R.className="relu6";return R}(of);Kb.serialization.registerClass(ng);var hg=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.apply=function(x){return x};R.className="linear";return R}(of);Kb.serialization.registerClass(hg);var Ng=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.apply=function(x){return Kb.sigmoid(x)};
R.className="sigmoid";return R}(of);Kb.serialization.registerClass(Ng);var Ig=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.apply=function(x){return ib(x)};R.className="hardSigmoid";return R}(of);Kb.serialization.registerClass(Ig);var Og=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.apply=function(x){return Kb.softplus(x)};R.className="softplus";return R}(of);Kb.serialization.registerClass(Og);var Dg=
function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.apply=function(x){return Va(x)};R.className="softsign";return R}(of);Kb.serialization.registerClass(Dg);var fh=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.apply=function(x){return Kb.tanh(x)};R.className="tanh";return R}(of);Kb.serialization.registerClass(fh);var Kg=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.apply=
function(x,P){void 0===P&&(P=-1);return Kb.softmax(x,P)};R.className="softmax";return R}(of);Kb.serialization.registerClass(Kg);var Pg=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.apply=function(x,P){void 0===P&&(P=-1);return Kb.logSoftmax(x,P)};R.className="logSoftmax";return R}(of);Kb.serialization.registerClass(Pg);var gh=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.apply=function(x,P){void 0===
P&&(P=1);return Kb.tidy(function(){return Kb.sigmoid(x.mul(P)).mul(x)})};R.className="swish";return R}(of);Kb.serialization.registerClass(gh);var bh=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);return R}(Kb.serialization.Serializable),Cg=function(na){function R(x){var P=na.call(this)||this;wb(x);P.l1=null==x||null==x.l1?.01:x.l1;P.l2=null==x||null==x.l2?.01:x.l2;P.hasL1=0!==P.l1;P.hasL2=0!==P.l2;return P}t(R,na);R.prototype.apply=function(x){var P=this;return Kb.tidy(function(){var ca=
Kb.zeros([1]);P.hasL1&&(ca=Kb.add(ca,Kb.sum(Kb.mul(P.l1,Kb.abs(x)))));P.hasL2&&(ca=Kb.add(ca,Kb.sum(Kb.mul(P.l2,oa(x)))));return ca.asScalar()})};R.prototype.getConfig=function(){return{l1:this.l1,l2:this.l2}};R.fromConfig=function(x,P){return new x({l1:P.l1,l2:P.l2})};R.className="L1L2";return R}(bh);Kb.serialization.registerClass(Cg);var vf={l1l2:"L1L2"},Qg=function(na){function R(x){var P=na.call(this,null==x?{}:x)||this;P.supportsMasking=!0;null!=x&&(P.maxValue=x.maxValue);return P}t(R,na);R.prototype.call=
function(x,P){x=$a(x);x=Kb.relu(x);null!=this.maxValue&&(x=Kb.clipByValue(x,0,this.maxValue));return x};R.prototype.computeOutputShape=function(x){return x};R.prototype.getConfig=function(){var x={maxValue:this.maxValue},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="ReLU";return R}(Vd);Kb.serialization.registerClass(Qg);var xf=function(na){function R(x){var P=na.call(this,null==x?{}:x)||this;P.DEFAULT_ALPHA=.3;null==x&&(x={});P.alpha=null==x.alpha?P.DEFAULT_ALPHA:x.alpha;
return P}t(R,na);R.prototype.call=function(x,P){x=$a(x);return Kb.leakyRelu(x,this.alpha)};R.prototype.computeOutputShape=function(x){return x};R.prototype.getConfig=function(){var x={alpha:this.alpha},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="LeakyReLU";return R}(Vd);Kb.serialization.registerClass(xf);var se=function(na){function R(x){var P=na.call(this,null==x?{}:x)||this;P.DEFAULT_ALPHA_INITIALIZER="zeros";null==x&&(x={});P.supportsMasking=!0;P.alphaInitializer=
S(x.alphaInitializer||P.DEFAULT_ALPHA_INITIALIZER);P.alphaRegularizer=oc(x.alphaRegularizer);P.alphaConstraint=V(x.alphaConstraint);if(null==x.sharedAxes)P.sharedAxes=null;else if(Array.isArray(x.sharedAxes))P.sharedAxes=x.sharedAxes;else if("number"===typeof x.sharedAxes)P.sharedAxes=[x.sharedAxes];else throw new ad("Expected sharedAxes to be a number or an array of numbers, but got "+x.sharedAxes);return P}t(R,na);R.prototype.build=function(x){x=cb(x);var P=x.slice(1);if(null!=this.sharedAxes)for(var ca=
0,Ka=this.sharedAxes;ca<Ka.length;ca++){var rb=Ka[ca];P[rb-1]=1}this.alpha=this.addWeight("alpha",P,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);P={};if(null!=this.sharedAxes)for(rb=1;rb<x.length;++rb)P[rb]=x[rb];this.inputSpec=[new vd({ndim:x.length,axes:P})];this.built=!0};R.prototype.call=function(x,P){x=$a(x);return Kb.prelu(x,this.alpha.read())};R.prototype.getConfig=function(){var x={alphaInitializer:m(this.alphaInitializer),alphaRegularizer:m(this.alphaRegularizer),
alphaConstraint:m(this.alphaConstraint),sharedAxes:this.sharedAxes},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="PReLU";return R}(Vd);Kb.serialization.registerClass(se);var sg=function(na){function R(x){var P=na.call(this,null==x?{}:x)||this;P.DEFAULT_ALPHA=1;null==x&&(x={});if(null!=x.alpha&&x.alpha!==P.DEFAULT_ALPHA)throw new $e("Non-default alpha value ("+x.alpha+") is not supported by the ELU layer yet.");P.alpha=null==x.alpha?P.DEFAULT_ALPHA:x.alpha;return P}
t(R,na);R.prototype.call=function(x,P){x=$a(x);return Kb.elu(x)};R.prototype.computeOutputShape=function(x){return x};R.prototype.getConfig=function(){var x={alpha:this.alpha},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="ELU";return R}(Vd);Kb.serialization.registerClass(sg);var Sg=function(na){function R(x){var P=na.call(this,null==x?{}:x)||this;P.DEFAULT_THETA=1;null==x&&(x={});P.theta=null==x.theta?P.DEFAULT_THETA:x.theta;return P}t(R,na);R.prototype.call=function(x,
P){x=$a(x);return x.mul(Z(x.greater(this.theta),"float32"))};R.prototype.computeOutputShape=function(x){return x};R.prototype.getConfig=function(){var x={theta:this.theta},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="ThresholdedReLU";return R}(Vd);Kb.serialization.registerClass(Sg);var Ch=function(na){function R(x){var P=na.call(this,null==x?{}:x)||this;P.DEFAULT_AXIS=1;null==x&&(x={});P.softmax=(new Kg).apply;P.axis=null==x.axis?P.DEFAULT_AXIS:x.axis;return P}t(R,
na);R.prototype.call=function(x,P){x=$a(x);return this.softmax(x,this.axis)};R.prototype.computeOutputShape=function(x){return x};R.prototype.getConfig=function(){var x={axis:this.axis},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="Softmax";return R}(Vd);Kb.serialization.registerClass(Ch);var dh=function(na){function R(x,P){var ca=na.call(this,P)||this;ca.bias=null;ca.DEFAULT_KERNEL_INITIALIZER="glorotNormal";ca.DEFAULT_BIAS_INITIALIZER="zeros";R.verifyArgs(P);ca.rank=
x;z(ca.rank,"rank");if(1!==ca.rank&&2!==ca.rank&&3!==ca.rank)throw new $e("Convolution layer for rank other than 1, 2, or 3 ("+ca.rank+") is not implemented yet.");ca.kernelSize=Lc(P.kernelSize,x,"kernelSize");ca.strides=Lc(null==P.strides?1:P.strides,x,"strides");ca.padding=null==P.padding?"valid":P.padding;F(ca.padding);ca.dataFormat=null==P.dataFormat?"channelsLast":P.dataFormat;M(ca.dataFormat);ca.activation=Jb(P.activation);ca.useBias=null==P.useBias?!0:P.useBias;ca.biasInitializer=S(P.biasInitializer||
ca.DEFAULT_BIAS_INITIALIZER);ca.biasConstraint=V(P.biasConstraint);ca.biasRegularizer=oc(P.biasRegularizer);ca.activityRegularizer=oc(P.activityRegularizer);ca.dilationRate=Lc(null==P.dilationRate?1:P.dilationRate,x,"dilationRate");if(1===ca.rank&&Array.isArray(ca.dilationRate)&&1!==ca.dilationRate.length)throw new ad("dilationRate must be a number or an array of a single number for 1D convolution, but received "+JSON.stringify(ca.dilationRate));if(2===ca.rank)if("number"===typeof ca.dilationRate)ca.dilationRate=
[ca.dilationRate,ca.dilationRate];else{if(2!==ca.dilationRate.length)throw new ad("dilationRate must be a number or array of two numbers for 2D convolution, but received "+JSON.stringify(ca.dilationRate));}else if(3===ca.rank)if("number"===typeof ca.dilationRate)ca.dilationRate=[ca.dilationRate,ca.dilationRate,ca.dilationRate];else if(3!==ca.dilationRate.length)throw new ad("dilationRate must be a number or array of three numbers for 3D convolution, but received "+JSON.stringify(ca.dilationRate));
return ca}t(R,na);R.verifyArgs=function(x){e("kernelSize"in x,"required key 'kernelSize' not in config");if("number"!==typeof x.kernelSize&&!C(x.kernelSize,"number",1,3))throw new ad("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received "+(JSON.stringify(x.kernelSize)+"."));};R.prototype.getConfig=function(){var x={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:this.activation.getClassName(),
useBias:this.useBias,biasInitializer:m(this.biasInitializer),biasRegularizer:m(this.biasRegularizer),activityRegularizer:m(this.activityRegularizer),biasConstraint:m(this.biasConstraint)},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};return R}(Vd),ch=function(na){function R(x,P){x=na.call(this,x,P)||this;x.kernel=null;R.verifyArgs(P);x.filters=P.filters;z(x.filters,"filters");x.kernelInitializer=S(P.kernelInitializer||x.DEFAULT_KERNEL_INITIALIZER);x.kernelConstraint=V(P.kernelConstraint);
x.kernelRegularizer=oc(P.kernelRegularizer);return x}t(R,na);R.prototype.build=function(x){var P;x=cb(x);var ca="channelsFirst"===this.dataFormat?1:x.length-1;if(null==x[ca])throw new ad("The channel dimension of the input should be defined. Found "+x[ca]);x=x[ca];var Ka=this.kernelSize.concat([x,this.filters]);this.kernel=this.addWeight("kernel",Ka,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,
this.biasRegularizer,!0,this.biasConstraint));this.inputSpec=[{ndim:this.rank+2,axes:(P={},P[ca]=x,P)}];this.built=!0};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){x=$a(x);var Ka=null==ca.bias?null:ca.bias.read();var rb=B(ca.activation.getClassName());if(null!=rb&&2===ca.rank)Ka=qe(x,ca.kernel.read(),Ka,ca.strides,ca.padding,ca.dataFormat,ca.dilationRate,rb);else{if(1===ca.rank)Ka=cf(x,ca.kernel.read(),Ka,ca.strides[0],ca.padding,ca.dataFormat,ca.dilationRate[0]);else if(2===
ca.rank)Ka=qe(x,ca.kernel.read(),Ka,ca.strides,ca.padding,ca.dataFormat,ca.dilationRate);else if(3===ca.rank)Ka=ie(x,ca.kernel.read(),Ka,ca.strides,ca.padding,ca.dataFormat,ca.dilationRate);else throw new $e("convolutions greater than 3D are not implemented yet.");null!=ca.activation&&(Ka=ca.activation.apply(Ka))}return Ka})};R.prototype.computeOutputShape=function(x){x=cb(x);for(var P=[],ca="channelsLast"===this.dataFormat?x.slice(1,x.length-1):x.slice(2),Ka=0;Ka<ca.length;++Ka){var rb=ed(ca[Ka],
this.kernelSize[Ka],this.padding,this.strides[Ka],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[Ka]);P.push(rb)}x=[x[0]];"channelsLast"===this.dataFormat?(x=x.concat(P),x.push(this.filters)):(x.push(this.filters),x=x.concat(P));return x};R.prototype.getConfig=function(){var x={filters:this.filters,kernelInitializer:m(this.kernelInitializer),kernelRegularizer:m(this.kernelRegularizer),kernelConstraint:m(this.kernelConstraint)},P=na.prototype.getConfig.call(this);Object.assign(x,
P);return x};R.verifyArgs=function(x){if(!("filters"in x)||"number"!==typeof x.filters||1>x.filters)throw new ad("Convolution layer expected config.filters to be a 'number' \x3e 0 but got "+JSON.stringify(x.filters));};return R}(dh),Dh=function(na){function R(x){var P=na.call(this,2,x)||this;R.verifyArgs(x);return P}t(R,na);R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this);delete x.rank;return x};R.verifyArgs=function(x){if("number"!==typeof x.kernelSize&&!C(x.kernelSize,"number",
1,2))throw new ad("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received "+(JSON.stringify(x.kernelSize)+"."));};R.className="Conv2D";return R}(ch);Kb.serialization.registerClass(Dh);var Eh=function(na){function R(x){var P=na.call(this,3,x)||this;R.verifyArgs(x);return P}t(R,na);R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this);delete x.rank;return x};R.verifyArgs=function(x){if("number"!==typeof x.kernelSize&&(!Array.isArray(x.kernelSize)||
1!==x.kernelSize.length&&3!==x.kernelSize.length))throw new ad("Conv3D expects config.kernelSize to be number or [number, number, number], but received "+(JSON.stringify(x.kernelSize)+"."));};R.className="Conv3D";return R}(ch);Kb.serialization.registerClass(Eh);var jh=function(na){function R(x){x=na.call(this,x)||this;x.inputSpec=[new vd({ndim:4})];if("same"!==x.padding&&"valid"!==x.padding)throw new ad("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode "+
x.padding);return x}t(R,na);R.prototype.build=function(x){var P;x=cb(x);if(4!==x.length)throw new ad("Input should have rank 4; Received input shape: "+JSON.stringify(x));var ca="channelsFirst"===this.dataFormat?1:x.length-1;if(null==x[ca])throw new ad("The channel dimension of the inputs should be defined. Found `None`.");x=x[ca];var Ka=this.kernelSize.concat([this.filters,x]);this.kernel=this.addWeight("kernel",Ka,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);
this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint));this.inputSpec=[new vd({ndim:4,axes:(P={},P[ca]=x,P)})];this.built=!0};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){var Ka=$a(x);if(4!==Ka.shape.length)throw new ad("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-"+Ka.shape.length);var rb=Ka.shape,Mb=rb[0];if("channelsFirst"===ca.dataFormat){var Zb=
2;var Yb=3}else Zb=1,Yb=2;Yb=rb[Yb];var Gc=ca.kernelSize[1],cd=ca.strides[1];rb=ge(rb[Zb],ca.strides[0],ca.kernelSize[0],ca.padding);Zb=ge(Yb,cd,Gc,ca.padding);Mb=[Mb,rb,Zb,ca.filters];"channelsLast"!==ca.dataFormat&&(Ka=Kb.transpose(Ka,[0,2,3,1]));Ka=Kb.conv2dTranspose(Ka,ca.kernel.read(),Mb,ca.strides,ca.padding);"channelsLast"!==ca.dataFormat&&(Ka=Kb.transpose(Ka,[0,3,1,2]));null!=ca.bias&&(Ka=gb(Ka,ca.bias.read(),ca.dataFormat));null!=ca.activation&&(Ka=ca.activation.apply(Ka));return Ka})};R.prototype.computeOutputShape=
function(x){x=cb(x);x=x.slice();if("channelsFirst"===this.dataFormat){var P=1;var ca=2;var Ka=3}else P=3,ca=1,Ka=2;var rb=this.kernelSize[0],Mb=this.kernelSize[1],Zb=this.strides[0],Yb=this.strides[1];x[P]=this.filters;x[ca]=ge(x[ca],Zb,rb,this.padding);x[Ka]=ge(x[Ka],Yb,Mb,this.padding);return x};R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this);delete x.dilationRate;return x};R.className="Conv2DTranspose";return R}(Dh);Kb.serialization.registerClass(jh);var rh=function(na){function R(x){return na.call(this,
2,x)||this}t(R,na);R.className="SeparableConv2D";return R}(function(na){function R(x,P){x=na.call(this,x,P)||this;x.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform";x.DEFAULT_POINTWISE_INITIALIZER="glorotUniform";x.depthwiseKernel=null;x.pointwiseKernel=null;if(null==P.filters)throw new ad("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=P.kernelInitializer||null!=P.kernelRegularizer||null!=P.kernelConstraint)throw new ad("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
if(null!=P.padding&&"same"!==P.padding&&"valid"!==P.padding)throw new ad("SeparableConv"+x.rank+"D supports only padding modes: 'same' and 'valid', but received "+JSON.stringify(P.padding));x.depthMultiplier=null==P.depthMultiplier?1:P.depthMultiplier;x.depthwiseInitializer=S(P.depthwiseInitializer||x.DEFAULT_DEPTHWISE_INITIALIZER);x.depthwiseRegularizer=oc(P.depthwiseRegularizer);x.depthwiseConstraint=V(P.depthwiseConstraint);x.pointwiseInitializer=S(P.depthwiseInitializer||x.DEFAULT_POINTWISE_INITIALIZER);
x.pointwiseRegularizer=oc(P.pointwiseRegularizer);x.pointwiseConstraint=V(P.pointwiseConstraint);return x}t(R,na);R.prototype.build=function(x){var P;x=cb(x);if(x.length<this.rank+2)throw new ad("Inputs to SeparableConv"+this.rank+"D should have rank "+(this.rank+2+", but received input shape: ")+JSON.stringify(x));var ca="channelsFirst"===this.dataFormat?1:x.length-1;if(null==x[ca]||0>x[ca])throw new ad("The channel dimension of the inputs should be defined, but found "+JSON.stringify(x[ca]));x=
x[ca];for(var Ka=this.kernelSize.concat([x,this.depthMultiplier]),rb=[],Mb=0;Mb<this.rank;++Mb)rb.push(1);rb.push(x*this.depthMultiplier,this.filters);this.depthwiseKernel=this.addWeight("depthwise_kernel",Ka,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint);this.pointwiseKernel=this.addWeight("pointwise_kernel",rb,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint);this.bias=this.useBias?this.addWeight("bias",[this.filters],
"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null;this.inputSpec=[new vd({ndim:this.rank+2,axes:(P={},P[ca]=x,P)})];this.built=!0};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){x=$a(x);if(1===ca.rank)throw new $e("1D separable convolution is not implemented yet.");if(2===ca.rank){"channelsFirst"===ca.dataFormat&&(x=Kb.transpose(x,[0,2,3,1]));var Ka=Kb.separableConv2d(x,ca.depthwiseKernel.read(),ca.pointwiseKernel.read(),ca.strides,ca.padding,ca.dilationRate,
"NHWC")}ca.useBias&&(Ka=gb(Ka,ca.bias.read(),ca.dataFormat));null!=ca.activation&&(Ka=ca.activation.apply(Ka));"channelsFirst"===ca.dataFormat&&(Ka=Kb.transpose(Ka,[0,3,1,2]));return Ka})};R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this);delete x.rank;delete x.kernelInitializer;delete x.kernelRegularizer;delete x.kernelConstraint;x.depthwiseInitializer=m(this.depthwiseInitializer);x.pointwiseInitializer=m(this.pointwiseInitializer);x.depthwiseRegularizer=m(this.depthwiseRegularizer);
x.pointwiseRegularizer=m(this.pointwiseRegularizer);x.depthwiseConstraint=m(this.depthwiseConstraint);x.pointwiseConstraint=m(this.pointwiseConstraint);return x};R.className="SeparableConv";return R}(ch));Kb.serialization.registerClass(rh);var yh=function(na){function R(x){var P=na.call(this,1,x)||this;R.verifyArgs(x);P.inputSpec=[{ndim:3}];return P}t(R,na);R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this);delete x.rank;delete x.dataFormat;return x};R.verifyArgs=function(x){if("number"!==
typeof x.kernelSize&&!C(x.kernelSize,"number",1,1))throw new ad("Conv1D expects config.kernelSize to be number or number[] with length 1, but received "+(JSON.stringify(x.kernelSize)+"."));};R.className="Conv1D";return R}(ch);Kb.serialization.registerClass(yh);var kh=function(na){function R(x){var P=na.call(this,x)||this;P.cropping="number"===typeof x.cropping?[[x.cropping,x.cropping],[x.cropping,x.cropping]]:"number"===typeof x.cropping[0]?[[x.cropping[0],x.cropping[0]],[x.cropping[1],x.cropping[1]]]:
x.cropping;P.dataFormat=void 0===x.dataFormat?"channelsLast":x.dataFormat;P.inputSpec=[{ndim:4}];return P}t(R,na);R.prototype.computeOutputShape=function(x){return"channelsFirst"===this.dataFormat?[x[0],x[1],x[2]-this.cropping[0][0]-this.cropping[0][1],x[3]-this.cropping[1][0]-this.cropping[1][1]]:[x[0],x[1]-this.cropping[0][0]-this.cropping[0][1],x[2]-this.cropping[1][0]-this.cropping[1][1],x[3]]};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){x=$a(x);if("channelsLast"===ca.dataFormat){var Ka=
ma(x,ca.cropping[0][0],x.shape[1]-ca.cropping[0][0]-ca.cropping[0][1],2);return ma(Ka,ca.cropping[1][0],x.shape[2]-ca.cropping[1][1]-ca.cropping[1][0],3)}Ka=ma(x,ca.cropping[0][0],x.shape[2]-ca.cropping[0][0]-ca.cropping[0][1],3);return ma(Ka,ca.cropping[1][0],x.shape[3]-ca.cropping[1][1]-ca.cropping[1][0],4)})};R.prototype.getConfig=function(){var x={cropping:this.cropping,dataFormat:this.dataFormat},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="Cropping2D";return R}(Vd);
Kb.serialization.registerClass(kh);var nh=function(na){function R(x){var P=na.call(this,x)||this;P.DEFAULT_SIZE=[2,2];P.inputSpec=[{ndim:4}];P.size=null==x.size?P.DEFAULT_SIZE:x.size;P.dataFormat=null==x.dataFormat?"channelsLast":x.dataFormat;return P}t(R,na);R.prototype.computeOutputShape=function(x){if("channelsFirst"===this.dataFormat){var P=null==x[2]?null:this.size[0]*x[2],ca=null==x[3]?null:this.size[1]*x[3];return[x[0],x[1],P,ca]}P=null==x[1]?null:this.size[0]*x[1];ca=null==x[2]?null:this.size[1]*
x[2];return[x[0],P,ca,x[3]]};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){var Ka=$a(x),rb=Ka.shape;if("channelsFirst"===ca.dataFormat){Ka=Kb.transpose(Ka,[0,2,3,1]);var Mb=ca.size[0]*rb[2];rb=ca.size[1]*rb[3];Ka=Ka.resizeNearestNeighbor([Mb,rb]);return Kb.transpose(Ka,[0,3,1,2])}Mb=ca.size[0]*rb[1];rb=ca.size[1]*rb[2];return Ka.resizeNearestNeighbor([Mb,rb])})};R.prototype.getConfig=function(){var x={size:this.size,dataFormat:this.dataFormat},P=na.prototype.getConfig.call(this);
Object.assign(x,P);return x};R.className="UpSampling2D";return R}(Vd);Kb.serialization.registerClass(nh);var sh=function(na){function R(x){var P=na.call(this,2,x)||this;P.depthwiseKernel=null;P.depthMultiplier=null==x.depthMultiplier?1:x.depthMultiplier;P.depthwiseInitializer=S(x.depthwiseInitializer||P.DEFAULT_KERNEL_INITIALIZER);P.depthwiseConstraint=V(x.depthwiseConstraint);P.depthwiseRegularizer=oc(x.depthwiseRegularizer);return P}t(R,na);R.prototype.build=function(x){x=cb(x);if(4>x.length)throw new ad("Inputs to DepthwiseConv2D should have rank 4. Received input shape: "+
(JSON.stringify(x)+"."));var P="channelsFirst"===this.dataFormat?1:3;if(null==x[P]||0>x[P])throw new ad("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not ("+(x[P]+")."));x=x[P];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],x,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint);this.bias=this.useBias?this.addWeight("bias",[x*this.depthMultiplier],null,this.biasInitializer,
this.biasRegularizer,!0,this.biasConstraint):null;this.built=!0};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){x=$a(x);var Ka=Za(x,ca.depthwiseKernel.read(),ca.strides,ca.padding,ca.dataFormat,null);ca.useBias&&(Ka=gb(Ka,ca.bias.read(),ca.dataFormat));null!=ca.activation&&(Ka=ca.activation.apply(Ka));return Ka})};R.prototype.computeOutputShape=function(x){x=cb(x);var P="channelsFirst"===this.dataFormat?x[3]:x[2],ca="channelsFirst"===this.dataFormat?x[1]*this.depthMultiplier:
x[3]*this.depthMultiplier,Ka=ed("channelsFirst"===this.dataFormat?x[2]:x[1],this.kernelSize[0],this.padding,this.strides[0]);P=ed(P,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[x[0],ca,Ka,P]:[x[0],Ka,P,ca]};R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this);x.depthMultiplier=this.depthMultiplier;x.depthwiseInitializer=m(this.depthwiseInitializer);x.depthwiseRegularizer=m(this.depthwiseRegularizer);x.depthwiseConstraint=m(this.depthwiseRegularizer);
return x};R.className="DepthwiseConv2D";return R}(dh);Kb.serialization.registerClass(sh);var Fg=function(na){function R(x){var P=na.call(this,x)||this;if(null==x.cell)throw new ad("cell property is missing for the constructor of RNN.");var ca=Array.isArray(x.cell)?new Nc({cells:x.cell}):x.cell;if(null==ca.stateSize)throw new ad("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");P.cell=ca;P.returnSequences=null==x.returnSequences?!1:x.returnSequences;
P.returnState=null==x.returnState?!1:x.returnState;P.goBackwards=null==x.goBackwards?!1:x.goBackwards;P._stateful=null==x.stateful?!1:x.stateful;P.unroll=null==x.unroll?!1:x.unroll;P.supportsMasking=!0;P.inputSpec=[new vd({ndim:3})];P.stateSpec=null;P.states_=null;P.numConstants=null;P.keptStates=[];return P}t(R,na);R.prototype.getStates=function(){if(null==this.states_){var x=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return ba(0,x).map(function(P){return null})}return this.states_};
R.prototype.setStates=function(x){this.states_=x};R.prototype.computeOutputShape=function(x){ya(x)&&(x=x[0]);var P=this.cell.stateSize;Array.isArray(P)||(P=[P]);var ca=P[0];ca=this.returnSequences?[x[0],x[1],ca]:[x[0],ca];if(this.returnState){for(var Ka=[],rb=0;rb<P.length;rb++)Ka.push([x[0],P[rb]]);return[ca].concat(Ka)}return ca};R.prototype.computeMask=function(x,P){var ca=this;return Kb.tidy(function(){Array.isArray(P)&&(P=P[0]);var Ka=ca.returnSequences?P:null;if(ca.returnState){var rb=ca.states.map(function(Mb){return null});
return[Ka].concat(rb)}return Ka})};Object.defineProperty(R.prototype,"states",{get:function(){if(null==this.states_){for(var x=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,P=[],ca=0;ca<x;++ca)P.push(null);return P}return this.states_},set:function(x){this.states_=x},enumerable:!0,configurable:!0});R.prototype.build=function(x){if(null!=this.numConstants)throw new $e("Constants support is not implemented in RNN yet.");ya(x)&&(x=x[0]);var P=this.stateful?x[0]:null,ca=x.slice(2);this.inputSpec[0]=
new vd({shape:[P,null].concat(ca)});x=[x[0]].concat(x.slice(2));this.cell.build(x);x=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize];if(null!=this.stateSpec){if(!Kb.util.arraysEqual(this.stateSpec.map(function(Ka){return Ka.shape[Ka.shape.length-1]}),x))throw new ad("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec\x3d"+(this.stateSpec+"; However cell.stateSize is ")+this.cell.stateSize);}else this.stateSpec=x.map(function(Ka){return new vd({shape:[null,
Ka]})});this.stateful&&this.resetStates()};R.prototype.resetStates=function(x,P){var ca=this;void 0===P&&(P=!1);Kb.tidy(function(){if(!ca.stateful)throw new gf("Cannot call resetStates() on an RNN Layer that is not stateful.");var Ka=ca.inputSpec[0].shape[0];if(null==Ka)throw new ad("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
if(null==ca.states_)Array.isArray(ca.cell.stateSize)?ca.states_=ca.cell.stateSize.map(function(Yb){return Kb.zeros([Ka,Yb])}):ca.states_=[Kb.zeros([Ka,ca.cell.stateSize])];else if(null==x)Kb.dispose(ca.states_),null!=ca.keptStates&&(Kb.dispose(ca.keptStates),ca.keptStates=[]),Array.isArray(ca.cell.stateSize)?ca.states_=ca.cell.stateSize.map(function(Yb){return Kb.zeros([Ka,Yb])}):ca.states_[0]=Kb.zeros([Ka,ca.cell.stateSize]);else{Array.isArray(x)||(x=[x]);if(x.length!==ca.states_.length)throw new ad("Layer "+
ca.name+" expects "+ca.states_.length+" state(s), but it received "+(x.length+" state value(s). Input received: ")+x);!0===P?ca.keptStates.push(ca.states_.slice()):Kb.dispose(ca.states_);for(var rb=0;rb<ca.states_.length;++rb){var Mb=x[rb],Zb=Array.isArray(ca.cell.stateSize)?ca.cell.stateSize[rb]:ca.cell.stateSize;Zb=[Ka,Zb];if(!Kb.util.arraysEqual(Mb.shape,Zb))throw new ad("State "+rb+" is incompatible with layer "+ca.name+": expected shape\x3d"+(Zb+", received shape\x3d"+Mb.shape));ca.states_[rb]=
Mb}}ca.states_=ca.states_.map(function(Yb){return Kb.keep(Yb.clone())})})};R.prototype.apply=function(x,P){var ca=null==P?null:P.initialState,Ka=null==P?null:P.constants;null==P&&(P={});var rb=nb(x,ca,Ka,this.numConstants);x=rb.inputs;ca=rb.initialState;Ka=rb.constants;var Mb=[];rb=[];if(null!=ca){P.initialState=ca;Mb=Mb.concat(ca);this.stateSpec=[];for(var Zb=0;Zb<ca.length;Zb++)this.stateSpec.push(new vd({shape:ca[Zb].shape}));rb=rb.concat(this.stateSpec)}null!=Ka&&(P.constants=Ka,Mb=Mb.concat(Ka),
this.numConstants=Ka.length);return Mb[0]instanceof Nd?(x=[x].concat(Mb),ca=this.inputSpec.concat(rb),rb=this.inputSpec,this.inputSpec=ca,P=na.prototype.apply.call(this,x,P),this.inputSpec=rb,P):na.prototype.apply.call(this,x,P)};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){var Ka=null==P?null:P.mask,rb=null==P?null:P.training,Mb=null==P?null:P.initialState;x=$a(x);null==Mb&&(Mb=ca.stateful?ca.states_:ca.getInitialState(x));var Zb=Array.isArray(ca.cell.stateSize)?ca.cell.stateSize.length:
1;if(Mb.length!==Zb)throw new ad("RNN Layer has "+Zb+" state(s) but was passed "+(Mb.length+" initial state(s)."));ca.unroll&&console.warn("Ignoring unroll \x3d true for RNN layer, due to imperative backend.");var Yb={training:rb};Zb=Db(function(Gc,cd){Gc=ca.cell.call([Gc].concat(cd),Yb);return[Gc[0],Gc.slice(1)]},x,Mb,ca.goBackwards,Ka,null,ca.unroll,ca.returnSequences);Ka=Zb[0];Mb=Zb[1];Zb=Zb[2];ca.stateful&&ca.resetStates(Zb,rb);rb=ca.returnSequences?Mb:Ka;return ca.returnState?[rb].concat(Zb):
rb})};R.prototype.getInitialState=function(x){var P=this;return Kb.tidy(function(){var ca=Kb.zeros(x.shape);ca=Kb.sum(ca,[1,2]);ca=da(ca);return Array.isArray(P.cell.stateSize)?P.cell.stateSize.map(function(Ka){return 1<Ka?Fa(ca,[1,Ka]):ca}):1<P.cell.stateSize?[Fa(ca,[1,P.cell.stateSize])]:[ca]})};Object.defineProperty(R.prototype,"trainableWeights",{get:function(){return this.trainable?this.cell.trainableWeights:[]},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"nonTrainableWeights",
{get:function(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights},enumerable:!0,configurable:!0});R.prototype.setFastWeightInitDuringBuild=function(x){na.prototype.setFastWeightInitDuringBuild.call(this,x);null!=this.cell&&this.cell.setFastWeightInitDuringBuild(x)};R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this),P={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};
null!=this.numConstants&&(P.numConstants=this.numConstants);var ca=this.cell.getConfig();this.getClassName()===R.className&&(P.cell={className:this.cell.getClassName(),config:ca});return sf({},ca,x,P)};R.fromConfig=function(x,P,ca){void 0===ca&&(ca={});ca=Xb(P.cell,ca);return new x(Object.assign(P,{cell:ca}))};R.className="RNN";return R}(Vd);Kb.serialization.registerClass(Fg);var Rg=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);return R}(Vd),Pa=function(na){function R(x){var P=
na.call(this,x)||this;P.DEFAULT_ACTIVATION="tanh";P.DEFAULT_KERNEL_INITIALIZER="glorotNormal";P.DEFAULT_RECURRENT_INITIALIZER="orthogonal";P.DEFAULT_BIAS_INITIALIZER="zeros";P.units=x.units;z(P.units,"units");P.activation=Jb(null==x.activation?P.DEFAULT_ACTIVATION:x.activation);P.useBias=null==x.useBias?!0:x.useBias;P.kernelInitializer=S(x.kernelInitializer||P.DEFAULT_KERNEL_INITIALIZER);P.recurrentInitializer=S(x.recurrentInitializer||P.DEFAULT_RECURRENT_INITIALIZER);P.biasInitializer=S(x.biasInitializer||
P.DEFAULT_BIAS_INITIALIZER);P.kernelRegularizer=oc(x.kernelRegularizer);P.recurrentRegularizer=oc(x.recurrentRegularizer);P.biasRegularizer=oc(x.biasRegularizer);P.kernelConstraint=V(x.kernelConstraint);P.recurrentConstraint=V(x.recurrentConstraint);P.biasConstraint=V(x.biasConstraint);P.dropout=T([1,aa([0,null==x.dropout?0:x.dropout])]);P.recurrentDropout=T([1,aa([0,null==x.recurrentDropout?0:x.recurrentDropout])]);P.stateSize=P.units;P.dropoutMask=null;P.recurrentDropoutMask=null;return P}t(R,na);
R.prototype.build=function(x){x=cb(x);this.kernel=this.addWeight("kernel",[x[x.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null;this.built=!0};R.prototype.call=
function(x,P){var ca=this;return Kb.tidy(function(){if(2!==x.length)throw new ad("SimpleRNNCell expects 2 input Tensors, got "+x.length+".");var Ka=x[1];x=x[0];var rb=null==P.training?!1:P.training;0<ca.dropout&&1>ca.dropout&&null==ca.dropoutMask&&(ca.dropoutMask=dc({ones:function(){return Kb.onesLike(x)},rate:ca.dropout,training:rb}));0<ca.recurrentDropout&&1>ca.recurrentDropout&&null==ca.recurrentDropoutMask&&(ca.recurrentDropoutMask=dc({ones:function(){return Kb.onesLike(Ka)},rate:ca.recurrentDropout,
training:rb}));var Mb=ca.dropoutMask;rb=ca.recurrentDropoutMask;Mb=null!=Mb?Ra(Kb.mul(x,Mb),ca.kernel.read()):Ra(x,ca.kernel.read());null!=ca.bias&&(Mb=gb(Mb,ca.bias.read()));null!=rb&&(Ka=Kb.mul(Ka,rb));rb=Kb.add(Mb,Ra(Ka,ca.recurrentKernel.read()));null!=ca.activation&&(rb=ca.activation.apply(rb));return[rb,rb]})};R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this),P={units:this.units,activation:this.activation.getClassName(),useBias:this.useBias,kernelInitializer:m(this.kernelInitializer),
recurrentInitializer:m(this.recurrentInitializer),biasInitializer:m(this.biasInitializer),kernelRegularizer:m(this.kernelRegularizer),recurrentRegularizer:m(this.recurrentRegularizer),biasRegularizer:m(this.biasRegularizer),activityRegularizer:m(this.activityRegularizer),kernelConstraint:m(this.kernelConstraint),recurrentConstraint:m(this.recurrentConstraint),biasConstraint:m(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return sf({},x,P)};R.className="SimpleRNNCell";
return R}(Rg);Kb.serialization.registerClass(Pa);var Ab=function(na){function R(x){x.cell=new Pa(x);return na.call(this,x)||this}t(R,na);R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){null!=ca.cell.dropoutMask&&(Kb.dispose(ca.cell.dropoutMask),ca.cell.dropoutMask=null);null!=ca.cell.recurrentDropoutMask&&(Kb.dispose(ca.cell.recurrentDropoutMask),ca.cell.recurrentDropoutMask=null);return na.prototype.call.call(ca,x,{mask:null==P?null:P.mask,training:null==P?null:P.training,initialState:null==
P?null:P.initialState})})};R.fromConfig=function(x,P){return new x(P)};R.className="SimpleRNN";return R}(Fg);Kb.serialization.registerClass(Ab);var Qb=function(na){function R(x){var P=na.call(this,x)||this;P.DEFAULT_ACTIVATION="tanh";P.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";P.DEFAULT_KERNEL_INITIALIZER="glorotNormal";P.DEFAULT_RECURRENT_INITIALIZER="orthogonal";P.DEFAULT_BIAS_INITIALIZER="zeros";if(x.resetAfter)throw new ad("GRUCell does not support reset_after parameter set to true.");P.units=
x.units;z(P.units,"units");P.activation=Jb(void 0===x.activation?P.DEFAULT_ACTIVATION:x.activation);P.recurrentActivation=Jb(void 0===x.recurrentActivation?P.DEFAULT_RECURRENT_ACTIVATION:x.recurrentActivation);P.useBias=null==x.useBias?!0:x.useBias;P.kernelInitializer=S(x.kernelInitializer||P.DEFAULT_KERNEL_INITIALIZER);P.recurrentInitializer=S(x.recurrentInitializer||P.DEFAULT_RECURRENT_INITIALIZER);P.biasInitializer=S(x.biasInitializer||P.DEFAULT_BIAS_INITIALIZER);P.kernelRegularizer=oc(x.kernelRegularizer);
P.recurrentRegularizer=oc(x.recurrentRegularizer);P.biasRegularizer=oc(x.biasRegularizer);P.kernelConstraint=V(x.kernelConstraint);P.recurrentConstraint=V(x.recurrentConstraint);P.biasConstraint=V(x.biasConstraint);P.dropout=T([1,aa([0,null==x.dropout?0:x.dropout])]);P.recurrentDropout=T([1,aa([0,null==x.recurrentDropout?0:x.recurrentDropout])]);P.implementation=x.implementation;P.stateSize=P.units;P.dropoutMask=null;P.recurrentDropoutMask=null;return P}t(R,na);R.prototype.build=function(x){x=cb(x);
this.kernel=this.addWeight("kernel",[x[x.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null;this.built=!0};R.prototype.call=function(x,P){var ca=this;
return Kb.tidy(function(){if(2!==x.length)throw new ad("GRUCell expects 2 input Tensors (inputs, h, c), got "+(x.length+"."));var Ka=null==P.training?!1:P.training,rb=x[1];x=x[0];0<ca.dropout&&1>ca.dropout&&null==ca.dropoutMask&&(ca.dropoutMask=dc({ones:function(){return Kb.onesLike(x)},rate:ca.dropout,training:Ka,count:3}));0<ca.recurrentDropout&&1>ca.recurrentDropout&&null==ca.recurrentDropoutMask&&(ca.recurrentDropoutMask=dc({ones:function(){return Kb.onesLike(rb)},rate:ca.recurrentDropout,training:Ka,
count:3}));var Mb=ca.dropoutMask;Ka=ca.recurrentDropoutMask;0<ca.dropout&&1>ca.dropout&&(x=Kb.mul(x,Mb[0]));Mb=Ra(x,ca.kernel.read());ca.useBias&&(Mb=gb(Mb,ca.bias.read()));0<ca.recurrentDropout&&1>ca.recurrentDropout&&(rb=Kb.mul(rb,Ka[0]));Ka=ca.recurrentKernel.read();var Zb=Kb.split(Ka,[2*ca.units,ca.units],Ka.rank-1);Ka=Zb[1];var Yb=Ra(rb,Zb[0]);Mb=Kb.split(Mb,3,Mb.rank-1);var Gc=Mb[0];Zb=Mb[1];Mb=Mb[2];var cd=Kb.split(Yb,2,Yb.rank-1);Yb=cd[1];Gc=ca.recurrentActivation.apply(Kb.add(Gc,cd[0]));
Zb=ca.recurrentActivation.apply(Kb.add(Zb,Yb));Ka=Ra(Kb.mul(Zb,rb),Ka);Ka=ca.activation.apply(Kb.add(Mb,Ka));Ka=Kb.add(Kb.mul(Gc,rb),Kb.mul(Kb.add(1,Kb.neg(Gc)),Ka));return[Ka,Ka]})};R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this),P={units:this.units,activation:this.activation.getClassName(),recurrentActivation:this.recurrentActivation.getClassName(),useBias:this.useBias,kernelInitializer:m(this.kernelInitializer),recurrentInitializer:m(this.recurrentInitializer),biasInitializer:m(this.biasInitializer),
kernelRegularizer:m(this.kernelRegularizer),recurrentRegularizer:m(this.recurrentRegularizer),biasRegularizer:m(this.biasRegularizer),activityRegularizer:m(this.activityRegularizer),kernelConstraint:m(this.kernelConstraint),recurrentConstraint:m(this.recurrentConstraint),biasConstraint:m(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return sf({},x,P)};R.className="GRUCell";return R}(Rg);Kb.serialization.registerClass(Qb);
var cc=function(na){function R(x){0===x.implementation&&console.warn("`implementation\x3d0` has been deprecated, and now defaults to `implementation\x3d1`. Please update your layer call.");x.cell=new Qb(x);return na.call(this,x)||this}t(R,na);R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){null!=ca.cell.dropoutMask&&(Kb.dispose(ca.cell.dropoutMask),ca.cell.dropoutMask=null);null!=ca.cell.recurrentDropoutMask&&(Kb.dispose(ca.cell.recurrentDropoutMask),ca.cell.recurrentDropoutMask=
null);return na.prototype.call.call(ca,x,{mask:null==P?null:P.mask,training:null==P?null:P.training,initialState:null==P?null:P.initialState})})};R.fromConfig=function(x,P){0===P.implmentation&&(P.implementation=1);return new x(P)};R.className="GRU";return R}(Fg);Kb.serialization.registerClass(cc);var zc=function(na){function R(x){var P=na.call(this,x)||this;P.DEFAULT_ACTIVATION="tanh";P.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";P.DEFAULT_KERNEL_INITIALIZER="glorotNormal";P.DEFAULT_RECURRENT_INITIALIZER=
"orthogonal";P.DEFAULT_BIAS_INITIALIZER="zeros";P.units=x.units;z(P.units,"units");P.activation=Jb(void 0===x.activation?P.DEFAULT_ACTIVATION:x.activation);P.recurrentActivation=Jb(void 0===x.recurrentActivation?P.DEFAULT_RECURRENT_ACTIVATION:x.recurrentActivation);P.useBias=null==x.useBias?!0:x.useBias;P.kernelInitializer=S(x.kernelInitializer||P.DEFAULT_KERNEL_INITIALIZER);P.recurrentInitializer=S(x.recurrentInitializer||P.DEFAULT_RECURRENT_INITIALIZER);P.biasInitializer=S(x.biasInitializer||P.DEFAULT_BIAS_INITIALIZER);
P.unitForgetBias=x.unitForgetBias;P.kernelRegularizer=oc(x.kernelRegularizer);P.recurrentRegularizer=oc(x.recurrentRegularizer);P.biasRegularizer=oc(x.biasRegularizer);P.kernelConstraint=V(x.kernelConstraint);P.recurrentConstraint=V(x.recurrentConstraint);P.biasConstraint=V(x.biasConstraint);P.dropout=T([1,aa([0,null==x.dropout?0:x.dropout])]);P.recurrentDropout=T([1,aa([0,null==x.recurrentDropout?0:x.recurrentDropout])]);P.implementation=x.implementation;P.stateSize=[P.units,P.units];P.dropoutMask=
null;P.recurrentDropoutMask=null;return P}t(R,na);R.prototype.build=function(x){var P;x=cb(x);this.kernel=this.addWeight("kernel",[x[x.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);if(this.useBias){if(this.unitForgetBias){var ca=this.biasInitializer,Ka=this.units;x=new (P=function(rb){function Mb(){return null!==
rb&&rb.apply(this,arguments)||this}t(Mb,rb);Mb.prototype.apply=function(Zb,Yb){Zb=ca.apply([Ka]);Yb=(new If).apply([Ka]);var Gc=ca.apply([2*Ka]);return qa(qa(Zb,Yb),Gc)};return Mb}(Df),P.className="CustomInit",P)}else x=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,x,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){var Ka=null==P.training?!1:P.training;if(3!==x.length)throw new ad("LSTMCell expects 3 input Tensors (inputs, h, c), got "+
(x.length+"."));var rb=x[1],Mb=x[2];x=x[0];0<ca.dropout&&1>ca.dropout&&null==ca.dropoutMask&&(ca.dropoutMask=dc({ones:function(){return Kb.onesLike(x)},rate:ca.dropout,training:Ka,count:4}));0<ca.recurrentDropout&&1>ca.recurrentDropout&&null==ca.recurrentDropoutMask&&(ca.recurrentDropoutMask=dc({ones:function(){return Kb.onesLike(rb)},rate:ca.recurrentDropout,training:Ka,count:4}));var Zb=ca.dropoutMask;Ka=ca.recurrentDropoutMask;0<ca.dropout&&1>ca.dropout&&(x=Kb.mul(x,Zb[0]));Zb=Ra(x,ca.kernel.read());
0<ca.recurrentDropout&&1>ca.recurrentDropout&&(rb=Kb.mul(rb,Ka[0]));Zb=Kb.add(Zb,Ra(rb,ca.recurrentKernel.read()));ca.useBias&&(Zb=gb(Zb,ca.bias.read()));var Yb=Kb.split(Zb,4,Zb.rank-1);var Gc=Yb[1];Zb=Yb[2];Ka=Yb[3];Yb=ca.recurrentActivation.apply(Yb[0]);Gc=ca.recurrentActivation.apply(Gc);Mb=Kb.add(Kb.mul(Gc,Mb),Kb.mul(Yb,ca.activation.apply(Zb)));Ka=ca.recurrentActivation.apply(Ka);Ka=Kb.mul(Ka,ca.activation.apply(Mb));return[Ka,Ka,Mb]})};R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this),
P={units:this.units,activation:this.activation.getClassName(),recurrentActivation:this.recurrentActivation.getClassName(),useBias:this.useBias,kernelInitializer:m(this.kernelInitializer),recurrentInitializer:m(this.recurrentInitializer),biasInitializer:m(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:m(this.kernelRegularizer),recurrentRegularizer:m(this.recurrentRegularizer),biasRegularizer:m(this.biasRegularizer),activityRegularizer:m(this.activityRegularizer),kernelConstraint:m(this.kernelConstraint),
recurrentConstraint:m(this.recurrentConstraint),biasConstraint:m(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return sf({},x,P)};R.className="LSTMCell";return R}(Rg);Kb.serialization.registerClass(zc);var kc=function(na){function R(x){0===x.implementation&&console.warn("`implementation\x3d0` has been deprecated, and now defaults to `implementation\x3d1`. Please update your layer call.");x.cell=new zc(x);return na.call(this,x)||
this}t(R,na);R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){null!=ca.cell.dropoutMask&&(Kb.dispose(ca.cell.dropoutMask),ca.cell.dropoutMask=null);null!=ca.cell.recurrentDropoutMask&&(Kb.dispose(ca.cell.recurrentDropoutMask),ca.cell.recurrentDropoutMask=null);return na.prototype.call.call(ca,x,{mask:null==P?null:P.mask,training:null==P?null:P.training,initialState:null==P?null:P.initialState})})};R.fromConfig=function(x,P){0===P.implmentation&&(P.implementation=1);return new x(P)};
R.className="LSTM";return R}(Fg);Kb.serialization.registerClass(kc);var Nc=function(na){function R(x){var P=na.call(this,x)||this;P.cells=x.cells;return P}t(R,na);Object.defineProperty(R.prototype,"stateSize",{get:function(){for(var x=[],P=0,ca=this.cells.slice().reverse();P<ca.length;P++){var Ka=ca[P];Array.isArray(Ka.stateSize)?x.push.apply(x,Ka.stateSize):x.push(Ka.stateSize)}return x},enumerable:!0,configurable:!0});R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){for(var Ka=
x.slice(1),rb=[],Mb=0,Zb=ca.cells.slice().reverse();Mb<Zb.length;Mb++){var Yb=Zb[Mb];Array.isArray(Yb.stateSize)?rb.push(Ka.splice(0,Yb.stateSize.length)):rb.push(Ka.splice(0,1))}rb.reverse();Mb=[];for(Zb=0;Zb<ca.cells.length;++Zb){Yb=ca.cells[Zb];Ka=rb[Zb];var Gc=0===Zb?[x[0]].concat(Ka):[Gc[0]].concat(Ka);Gc=Yb.call(Gc,P);Mb.push(Gc.slice(1))}Ka=[];rb=0;for(Yb=Mb.slice().reverse();rb<Yb.length;rb++)Ka.push.apply(Ka,Yb[rb]);return[Gc[0]].concat(Ka)})};R.prototype.build=function(x){ya(x)&&(x=x[0]);
var P;this.cells.forEach(function(ca,Ka){D("RNNCell_"+Ka,function(){ca.build(x);P=Array.isArray(ca.stateSize)?ca.stateSize[0]:ca.stateSize;x=[x[0],P]})});this.built=!0};R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this),P={cells:this.cells.map(function(ca){return{className:ca.getClassName(),config:ca.getConfig()}})};return sf({},x,P)};R.fromConfig=function(x,P,ca){void 0===ca&&(ca={});var Ka=[],rb=0;for(P=P.cells;rb<P.length;rb++)Ka.push(Xb(P[rb],ca));return new x({cells:Ka})};
Object.defineProperty(R.prototype,"trainableWeights",{get:function(){if(!this.trainable)return[];for(var x=[],P=0,ca=this.cells;P<ca.length;P++)x.push.apply(x,ca[P].trainableWeights);return x},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"nonTrainableWeights",{get:function(){for(var x=[],P=0,ca=this.cells;P<ca.length;P++){var Ka=ca[P];x.push.apply(x,Ka.nonTrainableWeights)}if(!this.trainable){P=[];ca=0;for(var rb=this.cells;ca<rb.length;ca++)Ka=rb[ca],P.push.apply(P,Ka.trainableWeights);
return P.concat(x)}return x},enumerable:!0,configurable:!0});R.prototype.getWeights=function(){for(var x=[],P=0,ca=this.cells;P<ca.length;P++)x.push.apply(x,ca[P].weights);return Aa(x)};R.prototype.setWeights=function(x){for(var P=[],ca=0,Ka=this.cells;ca<Ka.length;ca++)for(var rb=Ka[ca],Mb=x.splice(rb.weights.length),Zb=0;Zb<rb.weights.length;++Zb)P.push([rb.weights[Zb],Mb[Zb]]);lb(P)};R.className="StackedRNNCells";return R}(Rg);Kb.serialization.registerClass(Nc);(function(na){function R(){return null!==
na&&na.apply(this,arguments)||this}t(R,na);return R})(Rg);var jd=function(na){function R(x){if(x.unroll)throw new $e("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(x.cell))throw new $e("It is not possible at the moment to stack convolutional cells.");x=na.call(this,x)||this;x.inputSpec=[new vd({ndim:5})];return x}t(R,na);R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){null!=ca.cell.dropoutMask&&(Kb.dispose(ca.cell.dropoutMask),ca.cell.dropoutMask=null);
null!=ca.cell.recurrentDropoutMask&&(Kb.dispose(ca.cell.recurrentDropoutMask),ca.cell.recurrentDropoutMask=null);if(P&&P.constants)throw new ad("ConvRNN2D cell does not support constants");return na.prototype.call.call(ca,x,{mask:null==P?null:P.mask,training:null==P?null:P.training,initialState:null==P?null:P.initialState})})};R.prototype.computeOutputShape=function(x){var P=this.computeSingleOutputShape(x);this.returnSequences||(P=[P[0]].concat(P.slice(2)));this.returnState&&(P=[P].concat(Array(2).fill([x[0]].concat(P.slice(-3)))));
return P};R.prototype.getInitialState=function(x){var P=this;return Kb.tidy(function(){var ca=P.cell.stateSize,Ka=P.computeSingleOutputShape(x.shape);Ka=[Ka[0]].concat(Ka.slice(2));Ka=Kb.zeros(Ka);return Array.isArray(ca)?Array(ca.length).fill(Ka):[Ka]})};R.prototype.resetStates=function(x,P){var ca=this;void 0===P&&(P=!1);Kb.tidy(function(){if(!ca.stateful)throw new gf("Cannot call resetStates() on an RNN Layer that is not stateful.");var Ka=ca.inputSpec[0].shape,rb=ca.computeSingleOutputShape(Ka),
Mb=[rb[0]].concat(rb.slice(2));if(null==Ka[0])throw new ad("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==ca.getStates())Array.isArray(ca.cell.stateSize)?ca.states_=ca.cell.stateSize.map(function(){return Kb.zeros(Mb)}):
ca.states_=[Kb.zeros(Mb)];else if(null==x)Kb.dispose(ca.states_),null!=ca.keptStates&&(Kb.dispose(ca.keptStates),ca.keptStates=[]),Array.isArray(ca.cell.stateSize)?ca.states_=ca.cell.stateSize.map(function(){return Kb.zeros(Mb)}):ca.states_[0]=Kb.zeros(Mb);else{Array.isArray(x)||(x=[x]);if(x.length!==ca.states_.length)throw new ad("Layer "+ca.name+" expects "+ca.states_.length+" state(s), but it received "+(x.length+" state value(s). Input received: ")+x);P?ca.keptStates.push(ca.states_.slice()):
Kb.dispose(ca.states_);for(Ka=0;Ka<ca.states_.length;++Ka){rb=x[Ka];var Zb=Mb;if(!Kb.util.arraysEqual(rb.shape,Zb))throw new ad("State "+Ka+" is incompatible with layer "+ca.name+": expected shape\x3d"+(Zb+", received shape\x3d"+rb.shape));ca.states_[Ka]=rb}}ca.states_=ca.states_.map(function(Yb){return Kb.keep(Yb.clone())})})};R.prototype.computeSingleOutputShape=function(x){var P=this.cell,ca=P.filters,Ka=P.kernelSize,rb=P.padding,Mb=P.strides,Zb=P.dilationRate;P="channelsFirst"===P.dataFormat;
var Yb=x[P?4:3],Gc=ed(x[P?3:2],Ka[0],rb,Mb[0],Zb[0]);Ka=ed(Yb,Ka[1],rb,Mb[1],Zb[1]);return x.slice(0,2).concat(P?[ca,Gc,Ka]:[Gc,Ka,ca])};R.className="ConvRNN2D";return R}(Fg),Td=function(na){function R(x){var P=this,ca=x.filters,Ka=x.kernelSize,rb=x.strides,Mb=x.padding,Zb=x.dataFormat,Yb=x.dilationRate;P=na.call(this,sf({},x,{units:ca}))||this;P.filters=ca;z(P.filters,"filters");P.kernelSize=Lc(Ka,2,"kernelSize");P.kernelSize.forEach(function(Gc){return z(Gc,"kernelSize")});P.strides=Lc(rb||1,2,
"strides");P.strides.forEach(function(Gc){return z(Gc,"strides")});P.padding=Mb||"valid";F(P.padding);P.dataFormat=Zb||"channelsLast";M(P.dataFormat);P.dilationRate=Lc(Yb||1,2,"dilationRate");P.dilationRate.forEach(function(Gc){return z(Gc,"dilationRate")});return P}t(R,na);R.prototype.build=function(x){var P;x=cb(x);var ca="channelsFirst"===this.dataFormat?1:x.length-1;if(null==x[ca])throw new ad("The channel dimension of the input should be defined. Found "+x[ca]);x=this.kernelSize.concat([x[ca],
4*this.filters]);this.kernel=this.addWeight("kernel",x,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);x=this.kernelSize.concat([this.filters,4*this.filters]);this.recurrentKernel=this.addWeight("recurrent_kernel",x,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);if(this.useBias){x=void 0;if(this.unitForgetBias){var Ka=this.biasInitializer,rb=this.filters;x=new (P=function(Mb){function Zb(){return null!==Mb&&Mb.apply(this,arguments)||
this}t(Zb,Mb);Zb.prototype.apply=function(Yb,Gc){Yb=Ka.apply([rb]);Gc=Kb.ones([rb]);var cd=Ka.apply([2*rb]);return ja([Yb,Gc,cd])};return Zb}(Df),P.className="CustomInit",P)}else x=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,x,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){if(3!==x.length)throw new ad("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+(x.length+"."));var Ka=
P.training||!1,rb=x[0],Mb=x[1],Zb=x[2];0<ca.dropout&&1>ca.dropout&&null==ca.dropoutMask&&(ca.dropoutMask=dc({ones:function(){return Kb.onesLike(rb)},rate:ca.dropout,training:Ka,count:4}));var Yb=ca.dropoutMask,Gc=function(Bf,lg,eh){return lg&&lg[eh]?Kb.mul(lg[eh],Bf):Bf},cd=Gc(rb,Yb,0),rd=Gc(rb,Yb,1),Pd=Gc(rb,Yb,2);Yb=Gc(rb,Yb,3);0<ca.recurrentDropout&&1>ca.recurrentDropout&&null==ca.recurrentDropoutMask&&(ca.recurrentDropoutMask=dc({ones:function(){return Kb.onesLike(Mb)},rate:ca.recurrentDropout,
training:Ka,count:4}));var Od=ca.recurrentDropoutMask,ce=Gc(Mb,Od,0),Yd=Gc(Mb,Od,1);Ka=Gc(Mb,Od,2);Gc=Gc(Mb,Od,3);var ve=Kb.split(ca.kernel.read(),4,3);Od=ve[0];var Ye=ve[1],jf=ve[2];ve=ve[3];var kf=ca.useBias?Kb.split(ca.bias.read(),4):[null,null,null,null],Af=kf[1],Mf=kf[2],Rf=kf[3];cd=ca.inputConv(cd,Od,kf[0],ca.padding);rd=ca.inputConv(rd,Ye,Af,ca.padding);Pd=ca.inputConv(Pd,jf,Mf,ca.padding);Yb=ca.inputConv(Yb,ve,Rf,ca.padding);Od=Kb.split(ca.recurrentKernel.read(),4,3);Ye=Od[1];jf=Od[2];ve=
Od[3];ce=ca.recurrentConv(ce,Od[0]);Yd=ca.recurrentConv(Yd,Ye);Ka=ca.recurrentConv(Ka,jf);Gc=ca.recurrentConv(Gc,ve);cd=ca.recurrentActivation.apply(Kb.add(cd,ce));rd=ca.recurrentActivation.apply(Kb.add(rd,Yd));Zb=Kb.add(Kb.mul(rd,Zb),Kb.mul(cd,ca.activation.apply(Kb.add(Pd,Ka))));Pd=Kb.mul(ca.recurrentActivation.apply(Kb.add(Yb,Gc)),ca.activation.apply(Zb));return[Pd,Pd,Zb]})};R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this),P=["units"],ca={},Ka;for(Ka in x)Object.prototype.hasOwnProperty.call(x,
Ka)&&0>P.indexOf(Ka)&&(ca[Ka]=x[Ka]);if(null!=x&&"function"===typeof Object.getOwnPropertySymbols){var rb=0;for(Ka=Object.getOwnPropertySymbols(x);rb<Ka.length;rb++)0>P.indexOf(Ka[rb])&&(ca[Ka[rb]]=x[Ka[rb]])}return sf({},ca,{filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides})};R.prototype.inputConv=function(x,P,ca,Ka){x=Kb.conv2d(x,P,this.strides,Ka||"valid","channelsFirst"===this.dataFormat?"NCHW":
"NHWC",this.dilationRate);return ca?gb(x,ca,this.dataFormat):x};R.prototype.recurrentConv=function(x,P){return Kb.conv2d(x,P,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")};R.className="ConvLSTM2DCell";return R}(zc);Kb.serialization.registerClass(Td);var Wd=function(na){function R(x){var P=new Td(x);return na.call(this,sf({},x,{cell:P}))||this}t(R,na);R.fromConfig=function(x,P){return new x(P)};R.className="ConvLSTM2D";return R}(jd);Kb.serialization.registerClass(Wd);var Ld=function(na){function R(x){var P=
na.call(this,x)||this;P.rate=Math.max(Math.min(x.rate,1),0);P.noiseShape=x.noiseShape;P.seed=x.seed;P.supportsMasking=!0;return P}t(R,na);R.prototype.getNoiseShape=function(x){if(null==this.noiseShape)return this.noiseShape;x=x.shape;for(var P=[],ca=0;ca<this.noiseShape.length;++ca)P.push(null==this.noiseShape[ca]?x[ca]:this.noiseShape[ca]);return P};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){ca.invokeCallHook(x,P);var Ka=$a(x);if(0<ca.rate&&1>ca.rate){var rb=null==P.training?
!1:P.training,Mb=ca.getNoiseShape(Ka);return Ja(function(){return Ma(Ka,ca.rate,Mb,ca.seed)},function(){return Ka},rb)}return x})};R.prototype.getConfig=function(){var x={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.prototype.dispose=function(){return na.prototype.dispose.call(this)};R.className="Dropout";return R}(Vd);Kb.serialization.registerClass(Ld);var me=function(na){function R(x){x=na.call(this,x)||this;x.inputSpec=
[{ndim:3}];return x}t(R,na);R.prototype.getNoiseShape=function(x){x=x.shape;return[x[0],1,x[2]]};R.className="SpatialDropout1D";return R}(Ld);Kb.serialization.registerClass(me);var Ie=function(na){function R(x){var P=na.call(this,x)||this;P.activation=null;P.useBias=!0;P.kernel=null;P.bias=null;P.DEFAULT_KERNEL_INITIALIZER="glorotNormal";P.DEFAULT_BIAS_INITIALIZER="zeros";if(null==x.batchInputShape&&null==x.inputShape&&null!=x.inputDim){var ca=null;null!=x.batchSize&&(ca=x.batchSize);P.batchInputShape=
[ca,x.inputDim]}P.units=x.units;z(P.units,"units");P.activation=Jb(x.activation);null!=x.useBias&&(P.useBias=x.useBias);P.kernelInitializer=S(x.kernelInitializer||P.DEFAULT_KERNEL_INITIALIZER);P.biasInitializer=S(x.biasInitializer||P.DEFAULT_BIAS_INITIALIZER);P.kernelConstraint=V(x.kernelConstraint);P.biasConstraint=V(x.biasConstraint);P.kernelRegularizer=oc(x.kernelRegularizer);P.biasRegularizer=oc(x.biasRegularizer);P.activityRegularizer=oc(x.activityRegularizer);P.supportsMasking=!0;P.inputSpec=
[{minNDim:2}];return P}t(R,na);R.prototype.build=function(x){var P;x=cb(x);x=x[x.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[x,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)));this.inputSpec=[{minNDim:2,axes:(P={},P[-1]=x,P)}];this.built=!0};R.prototype.computeOutputShape=function(x){x=cb(x);x=x.slice();
x[x.length-1]=this.units;return x};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){ca.invokeCallHook(x,P);var Ka=$a(x),rb=B(ca.activation.getClassName());null!=rb?Ka=Ra(Ka,ca.kernel.read(),rb,ca.bias?ca.bias.read():null):(Ka=Ra(Ka,ca.kernel.read()),null!=ca.bias&&(Ka=gb(Ka,ca.bias.read())),null!=ca.activation&&(Ka=ca.activation.apply(Ka)));return Ka})};R.prototype.getConfig=function(){var x={units:this.units,activation:this.activation.getClassName(),useBias:this.useBias,kernelInitializer:m(this.kernelInitializer),
biasInitializer:m(this.biasInitializer),kernelRegularizer:m(this.kernelRegularizer),biasRegularizer:m(this.biasRegularizer),activityRegularizer:m(this.activityRegularizer),kernelConstraint:m(this.kernelConstraint),biasConstraint:m(this.biasConstraint)},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="Dense";return R}(Vd);Kb.serialization.registerClass(Ie);var Ee=function(na){function R(x){x=x||{};var P=na.call(this,x)||this;P.inputSpec=[{minNDim:3}];P.dataFormat=x.dataFormat;
return P}t(R,na);R.prototype.computeOutputShape=function(x){x=cb(x);for(var P=0,ca=x.slice(1);P<ca.length;P++)if(null==ca[P])throw new ad('The shape of the input to "Flatten" is not fully defined (got '+(x.slice(1)+'). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.'));return[x[0],L(x,1)]};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){ca.invokeCallHook(x,P);var Ka=$a(x);if("channelsFirst"===ca.dataFormat&&1<Ka.rank){for(var rb=
[0],Mb=2;Mb<Ka.rank;++Mb)rb.push(Mb);rb.push(1);Ka=Ka.transpose(rb)}if(1>=Ka.rank)throw new ad("batchFlatten requires a minimum rank of 2. Got rank: "+Ka.rank+".");rb=[Ka.shape[0],L(Ka.shape,1)];return Ka.reshape(rb)})};R.prototype.getConfig=function(){var x={};null!=this.dataFormat&&(x.dataFormat=this.dataFormat);var P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="Flatten";return R}(Vd);Kb.serialization.registerClass(Ee);var Ff=function(na){function R(x){var P=na.call(this,
x)||this;P.supportsMasking=!0;P.activation=Jb(x.activation);return P}t(R,na);R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){ca.invokeCallHook(x,P);var Ka=$a(x);return ca.activation.apply(Ka)})};R.prototype.getConfig=function(){var x={activation:this.activation.getClassName()},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="Activation";return R}(Vd);Kb.serialization.registerClass(Ff);var Kf=function(na){function R(x){var P=na.call(this,x)||this;P.n=
x.n;P.inputSpec=[{ndim:2}];return P}t(R,na);R.prototype.computeOutputShape=function(x){return[x[0],this.n,x[1]]};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){x=$a(x);return pa(x,ca.n)})};R.prototype.getConfig=function(){var x={n:this.n},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="RepeatVector";return R}(Vd);Kb.serialization.registerClass(Kf);var ea=function(na){function R(x){var P=na.call(this,x)||this;P.targetShape=x.targetShape;for(x=0;x<
P.targetShape.length;++x)P.isUnknown(P.targetShape[x])&&(P.targetShape[x]=null);return P}t(R,na);R.prototype.isUnknown=function(x){return 0>x||null==x};R.prototype.fixUnknownDimension=function(x,P){P=P.slice();for(var ca=1,Ka=null,rb=0;rb<P.length;++rb){var Mb=P[rb];if(this.isUnknown(Mb))if(null===Ka)Ka=rb;else throw new ad("Can only specifiy one unknown dimension.");else ca*=Mb}x=L(x);if(null!==Ka){if(0===ca||0!==x%ca)throw new ad("Total size of new array must be unchanged.");P[Ka]=x/ca}else if(x!==
ca)throw new ad("Total size of new array must be unchanged.");return P};R.prototype.computeOutputShape=function(x){for(var P=!1,ca=0;ca<x.length;++ca)if(this.isUnknown(x[ca])){P=!0;break}return P?x.slice(0,1).concat(this.targetShape):x.slice(0,1).concat(this.fixUnknownDimension(x.slice(1),this.targetShape))};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){ca.invokeCallHook(x,P);var Ka=$a(x),rb=Ka.shape;rb=rb.slice(0,1).concat(ca.fixUnknownDimension(rb.slice(1),ca.targetShape));
return Ka.reshape(rb)})};R.prototype.getConfig=function(){var x={targetShape:this.targetShape},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="Reshape";return R}(Vd);Kb.serialization.registerClass(ea);var sa=function(na){function R(x){var P=na.call(this,x)||this;if(null==x.dims)throw Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(x.dims))throw Error("Permute constructor requires `dims` to be an Array, but received "+
(x.dims+" instead."));var ca=ba(1,x.dims.length+1);if(!Kb.util.arraysEqual(x.dims.slice().sort(),ca))throw Error("Invalid permutation `dims`: "+JSON.stringify(x.dims)+" `dims` must contain consecutive integers starting from 1.");P.dims=x.dims;P.dimsIncludingBatch=[0].concat(P.dims);P.inputSpec=[new vd({ndim:P.dims.length+1})];return P}t(R,na);R.prototype.computeOutputShape=function(x){x=cb(x);var P=x.slice();this.dims.forEach(function(ca,Ka){P[Ka+1]=x[ca]});return P};R.prototype.call=function(x,P){return Kb.transpose($a(x),
this.dimsIncludingBatch)};R.prototype.getConfig=function(){var x={dims:this.dims},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="Permute";return R}(Vd);Kb.serialization.registerClass(sa);var ia=function(na){function R(x){var P=na.call(this,null==x?{}:x)||this;P.supportsMasking=!0;P.maskValue=null!=x?null==x.maskValue?0:x.maskValue:0;return P}t(R,na);R.prototype.computeOutputShape=function(x){return x};R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this),
P={maskValue:this.maskValue};Object.assign(P,x);return P};R.prototype.computeMask=function(x,P){x=$a(x);return Kb.any(Kb.notEqual(x,this.maskValue),-1)};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){ca.invokeCallHook(x,P);var Ka=$a(x),rb=Kb.any(Kb.notEqual(Ka,ca.maskValue),-1,!0);return Ka.mul(rb.asType(Ka.dtype))})};R.className="Masking";return R}(Vd);Kb.serialization.registerClass(ia);var za=function(na){function R(x){var P=na.call(this,x)||this;P.embeddings=null;P.DEFAULT_EMBEDDINGS_INITIALIZER=
"randomUniform";if(null==x.batchInputShape&&null==x.inputShape){var ca=null;null!=x.batchSize&&(ca=x.batchSize);P.batchInputShape=null==x.inputLength?[ca,null]:[ca].concat(h(x.inputLength))}P.inputDim=x.inputDim;z(P.inputDim,"inputDim");P.outputDim=x.outputDim;z(P.outputDim,"outputDim");P.embeddingsInitializer=S(x.embeddingsInitializer||P.DEFAULT_EMBEDDINGS_INITIALIZER);P.embeddingsRegularizer=oc(x.embeddingsRegularizer);P.activityRegularizer=oc(x.activityRegularizer);P.embeddingsConstraint=V(x.embeddingsConstraint);
P.maskZero=x.maskZero;P.supportsMasking=x.maskZero;P.inputLength=x.inputLength;return P}t(R,na);R.prototype.build=function(x){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint);this.built=!0};R.prototype.warnOnIncompatibleInputShape=function(x){};R.prototype.computeMask=function(x,P){var ca=this;return Kb.tidy(function(){return ca.maskZero?(x=$a(x),Kb.notEqual(x,Kb.zerosLike(x))):
null})};R.prototype.computeOutputShape=function(x){x=cb(x);if(null==this.inputLength)return x.concat([this.outputDim]);var P=h(this.inputLength);if(P.length!==x.length-1)throw new ad('"inputLength" is '+this.inputLength+", but received input shape has shape "+x);for(var ca=0,Ka=0;Ka<P.length;++Ka){var rb=P[Ka],Mb=x[Ka+1];if(null!=rb&&null!=Mb&&rb!==Mb)throw new ad('"inputLength" is '+this.inputLength+", but received input shape has shape "+x);null==rb&&(P[ca]=Mb);ca++}return[x[0]].concat(P,[this.outputDim])};
R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){ca.invokeCallHook(x,P);var Ka=$a(x);"int32"!==Ka.dtype&&(Ka=Ka.asType("int32"));return Ia(ca.embeddings.read(),Ka.as1D()).reshape(cb(ca.computeOutputShape(Ka.shape)))})};R.prototype.getConfig=function(){var x={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:m(this.embeddingsInitializer),embeddingsRegularizer:m(this.embeddingsRegularizer),activityRegularizer:m(this.activityRegularizer),embeddingsConstraint:m(this.embeddingsConstraint),
maskZero:this.maskZero,inputLength:this.inputLength},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="Embedding";return R}(Vd);Kb.serialization.registerClass(za);var Xa=function(na){function R(x){x=na.call(this,x||{})||this;x.supportsMasking=!0;return x}t(R,na);R.prototype.mergeFunction=function(x){throw new $e;};R.prototype.computeElementwiseOpOutputShape=function(x,P){if(null==x||null==P)return null;if(x.length<P.length)return this.computeElementwiseOpOutputShape(P,
x);if(0===P.length)return x;for(var ca=x.slice(0,x.length-P.length),Ka=0;Ka<P.length;++Ka){var rb=x[x.length-P.length+Ka],Mb=P[Ka];if(null==rb||null==Mb||0>rb||0>Mb)ca.push(null);else if(1===rb)ca.push(Mb);else{if(1!==Mb&&rb!==Mb)throw new ad("Operands could not be broadcast together with shapes "+JSON.stringify(x)+" "+JSON.stringify(P));ca.push(rb)}}return ca};R.prototype.build=function(x){Array.isArray(x)&&!Array.isArray(x[0])&&(x=[cb(x)]);if(2>x.length)throw new ad("A merge layer should be called on an Array of at least 2 inputs. Got "+
(x.length+" input(s)."));for(var P=[],ca=0,Ka=x;ca<Ka.length;ca++){var rb=Ka[ca];null!=rb&&null!==rb[0]&&P.push(rb[0])}P=q(P);if(1<P.length)throw new ad("Can not merge tensors with different batch sizes. Got tensors with shapes: "+(JSON.stringify(x)+"."));P=null==x[0]?null:x[0].slice(1);for(ca=1;ca<x.length;++ca)rb=null==x[ca]?null:x[ca].slice(1),P=this.computeElementwiseOpOutputShape(P,rb);rb=x.map(function(Mb){return Mb.length});-1===x.indexOf(null)&&1===q(rb).length?this.reshapeRequired=!1:this.reshapeRequired=
!0};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){if(ca.reshapeRequired){var Ka=[],rb=x.map(function(cd){return cd.rank});if(-1===rb.indexOf(null)){for(var Mb=aa(rb),Zb=0;Zb<x.length;Zb++){rb=x[Zb];for(var Yb=rb.rank,Gc=0;Gc<Mb-Yb;++Gc)rb=da(rb,1);Ka.push(rb)}return ca.mergeFunction(Ka)}Zb=!1;for(Mb=0;Mb<x.length;Mb++)rb=x[Mb],Yb=rb.rank,null==Yb?(Gc=rb.shape,Yb=Gc[0],Zb=Gc.slice(1).concat([Yb]),rb=rb.reshape([Yb].concat(L(Gc.slice(1)))),rb=Kb.transpose(rb,[1,0]),rb=rb.reshape(Zb),
Ka.push(rb),Zb=!0):1<Yb?(Yb=ba(1,Yb).concat([0]),Ka.push(Kb.transpose(rb,Yb)),Zb=!0):Ka.push(rb);Ka=ca.mergeFunction(Ka);rb=Ka.rank;Zb&&(null==rb?(rb=Ka.shape,Yb=rb[rb.length-1],Zb=[Yb].concat(rb.slice(0,rb.length-1)),Ka=Kb.transpose(Ka.reshape([-1,Yb]),[1,0]).reshape(Zb)):1<rb&&(Yb=[rb-1].concat(ba(0,rb-1)),Ka=Kb.transpose(Ka,Yb)));return Ka}return ca.mergeFunction(x)})};R.prototype.computeOutputShape=function(x){var P=null==x[0]?null:x[0].slice(1);for(var ca=1;ca<x.length;++ca){var Ka=null==x[ca]?
null:x[ca].slice(1);P=this.computeElementwiseOpOutputShape(P,Ka)}ca=[];for(var rb=0;rb<x.length;rb++)Ka=x[rb],null!=Ka&&null!==Ka[0]&&ca.push(Ka[0]);ca=q(ca);return P=1===ca.length?ca.concat(P):[null].concat(P)};R.prototype.computeMask=function(x,P){return Kb.tidy(function(){if(null==P)return null;if(!Array.isArray(P))throw new ad("`mask` should be an Array");if(!Array.isArray(x))throw new ad("`inputs` should be an Array");if(P.length!==x.length)throw new ad("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths ("+
(x.length+" vs "+P.length+")"));if(P.every(function(rb){return null==rb}))return null;P=P.map(function(rb){return null==rb?rb:Kb.expandDims(rb,0)});for(var ca=P[0],Ka=1;Ka<P.length-1;++Ka)ca=Kb.logicalAnd(ca,P[Ka]);return ca})};return R}(Vd),Cb=function(na){function R(x){return na.call(this,x)||this}t(R,na);R.prototype.mergeFunction=function(x){return Kb.tidy(function(){for(var P=x[0].clone(),ca=1;ca<x.length;++ca)P=Kb.add(P,x[ca]);return P})};R.className="Add";return R}(Xa);Kb.serialization.registerClass(Cb);
var gc=function(na){function R(x){return na.call(this,x)||this}t(R,na);R.prototype.mergeFunction=function(x){return Kb.tidy(function(){for(var P=x[0].clone(),ca=1;ca<x.length;++ca)P=Kb.mul(P,x[ca]);return P})};R.className="Multiply";return R}(Xa);Kb.serialization.registerClass(gc);var nc=function(na){function R(x){return na.call(this,x)||this}t(R,na);R.prototype.mergeFunction=function(x){return Kb.tidy(function(){for(var P=x[0].clone(),ca=1;ca<x.length;++ca)P=Kb.add(P,x[ca]);return Kb.mul(1/x.length,
P)})};R.className="Average";return R}(Xa);Kb.serialization.registerClass(nc);var Tc=function(na){function R(x){return na.call(this,x)||this}t(R,na);R.prototype.mergeFunction=function(x){return Kb.tidy(function(){for(var P=x[0],ca=1;ca<x.length;++ca)P=Kb.maximum(P,x[ca]);return P})};R.className="Maximum";return R}(Xa);Kb.serialization.registerClass(Tc);var hd=function(na){function R(x){return na.call(this,x)||this}t(R,na);R.prototype.mergeFunction=function(x){return Kb.tidy(function(){for(var P=x[0],
ca=1;ca<x.length;++ca)P=Kb.minimum(P,x[ca]);return P})};R.className="Minimum";return R}(Xa);Kb.serialization.registerClass(hd);var Hd=function(na){function R(x){var P=na.call(this,x)||this;P.DEFAULT_AXIS=-1;null==x&&(x={});P.axis=null==x.axis?P.DEFAULT_AXIS:x.axis;P.supportsMasking=!0;P.reshapeRequired=!1;return P}t(R,na);R.prototype.build=function(x){if(!Array.isArray(x)||!Array.isArray(x[0])||1===x.length)throw new ad("A `Concatenate` layer should be called on a list of at least 2 inputs");for(var P=
!0,ca=0;ca<x.length;ca++){var Ka=x[ca];if(null!=Ka){P=!1;break}}if(!P){P=[];for(ca=0;ca<x.length;++ca){var rb=x[ca].slice();rb.splice(this.axis,1);for(var Mb=!1,Zb=0,Yb=P;Zb<Yb.length;Zb++)if(Ka=Yb[Zb],Kb.util.arraysEqual(Ka,rb)){Mb=!0;break}Mb||P.push(rb)}if(1<P.length)throw new ad("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(x));}};R.prototype.mergeFunction=function(x){var P=this;return Kb.tidy(function(){return ja(x,
P.axis)})};R.prototype.computeOutputShape=function(x){if(!Array.isArray(x)||!Array.isArray(x[0]))throw new ad("A `Concatenate` layer should be called on a list of inputs.");var P=x[0].slice(),ca=0>this.axis?P.length+this.axis:this.axis,Ka=0;for(x=x.slice(1);Ka<x.length;Ka++){var rb=x[Ka];if(null==P[ca]||null==rb[ca]){P[ca]=null;break}P[ca]+=rb[ca]}return P};R.prototype.computeMask=function(x,P){var ca=this;if(null==P)return null;if(!Array.isArray(P))throw new ad("`mask` should be an array for Concatenate");
if(!Array.isArray(x))throw new ad("`inputs` should be an array for Concatenate");if(P.length!==x.length)throw new ad("Mismatch in the length of mask ("+P.length+") and the legnth of inputs ("+(x.length+")"));return Kb.tidy(function(){var Ka=!0;P.forEach(function(Zb){null!=Zb&&(Ka=!1)});if(Ka)return null;for(var rb=[],Mb=0;Mb<x.length;++Mb)null==P[Mb]?rb.push(Kb.onesLike(x[Mb]).asType("bool")):P[Mb].rank<x[Mb].rank?rb.push(Kb.expandDims(P[Mb],-1)):rb.push(P[Mb]);rb=Kb.concat(rb,ca.axis);return Kb.all(rb,
-1,!1)})};R.prototype.getConfig=function(){var x={axis:this.axis},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="Concatenate";return R}(Xa);Kb.serialization.registerClass(Hd);var $d=function(na){function R(x){var P=na.call(this,x)||this;P.axes=x.axes;P.normalize=null==x.normalize?!1:x.normalize;P.supportsMasking=!0;P.reshapeRequired=!1;return P}t(R,na);R.prototype.build=function(x){Kb.util.assert(Array.isArray(x)&&2===x.length&&Array.isArray(x[0])&&Array.isArray(x[1]),
function(){return"A `Dot` layer should be called on a list of exactly 2 inputs."});var P=x[0];x=x[1];if(3<P.length||3<x.length)throw new $e("Dot layer does not support tensors of 4D or higher rank yet.");var ca=this.interpretAxes(P,x);if(P[ca[0]]!==x[ca[1]])throw new ad("Dimension incompatibility: "+(P[ca[0]]+" !\x3d\x3d "+x[ca[1]]));};R.prototype.mergeFunction=function(x){if(2!==x.length)throw new ad("A `Dot` layer must be called on exactly 2 inputs, but received "+(x.length+" input(s)."));var P=
x[0],ca=x[1];var Ka=Array.isArray(this.axes)?this.axes.map(function(rb,Mb){return uc(rb,x[Mb].shape.length)}):[uc(this.axes,P.shape.length),uc(this.axes,ca.shape.length)];this.normalize&&(P=Mc(P,Ka[0]),ca=Mc(ca,Ka[1]));return Qc(P,ca,Ka)};R.prototype.interpretAxes=function(x,P){return Array.isArray(this.axes)?this.axes:[uc(this.axes,x.length),uc(this.axes,P.length)]};R.prototype.computeOutputShape=function(x){Kb.util.assert(Array.isArray(x)&&2===x.length&&Array.isArray(x[0])&&Array.isArray(x[1]),
function(){return"A `Dot` layer should be called on a list of exactly 2 inputs."});var P=x[0].slice();x=x[1].slice();if(3<P.length||3<x.length)throw new $e("Dot layer does not support tensors of 4D or higher rank yet.");var ca=this.interpretAxes(P,x);P.splice(ca[0],1);x.splice(ca[1],1);x.splice(0,1);P=P.concat(x);1===P.length&&P.push(1);return P};R.prototype.computeMask=function(x,P){return null};R.prototype.getConfig=function(){var x={axes:this.axes,normalize:this.normalize},P=na.prototype.getConfig.call(this);
Object.assign(x,P);return x};R.className="Dot";return R}(Xa);Kb.serialization.registerClass($d);var te=function(na){function R(x){var P=na.call(this,x)||this;P.supportsMasking=!0;P.stddev=x.stddev;return P}t(R,na);R.prototype.computeOutputShape=function(x){return x};R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this),P={stddev:this.stddev};Object.assign(P,x);return P};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){ca.invokeCallHook(x,P);var Ka=$a(x);return Ja(function(){return ua(Ka.shape,
0,ca.stddev).add(Ka)},function(){return Ka},P.training||!1)})};R.className="GaussianNoise";return R}(Vd);Kb.serialization.registerClass(te);var He=function(na){function R(x){var P=na.call(this,x)||this;P.supportsMasking=!0;P.rate=x.rate;return P}t(R,na);R.prototype.computeOutputShape=function(x){return x};R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this),P={rate:this.rate};Object.assign(P,x);return P};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){ca.invokeCallHook(x,
P);var Ka=$a(x);return 0<ca.rate&&1>ca.rate?Ja(function(){return Ka.mul(ua(Ka.shape,1,Math.sqrt(ca.rate/(1-ca.rate))))},function(){return Ka},P.training||!1):Ka})};R.className="GaussianDropout";return R}(Vd);Kb.serialization.registerClass(He);var Xd=function(na){function R(x){var P=na.call(this,x)||this;P.supportsMasking=!0;P.rate=x.rate;P.noiseShape=x.noiseShape;return P}t(R,na);R.prototype._getNoiseShape=function(x){return this.noiseShape||$a(x).shape};R.prototype.computeOutputShape=function(x){return x};
R.prototype.getConfig=function(){var x=na.prototype.getConfig.call(this),P={rate:this.rate};Object.assign(P,x);return P};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){if(1>ca.rate&&0<ca.rate){var Ka=ca._getNoiseShape(x);return Ja(function(){var rb=$a(x),Mb=Kb.greaterEqual(Kb.randomUniform(Ka),ca.rate);Mb=Mb.asType("float32");var Zb=Math.pow((1-ca.rate)*(1+ca.rate*Math.pow(-1.7580993408473766,2)),-.5),Yb=-1.7580993408473766*-Zb*ca.rate;return rb.mul(Mb).add(Mb.add(-1).mul(-1.7580993408473766)).mul(Zb).add(Yb)},
function(){return $a(x)},P.training||!1)}return x})};R.className="AlphaDropout";return R}(Vd);Kb.serialization.registerClass(Xd);var ye=function(na){function R(x){null==x&&(x={});var P=na.call(this,x)||this;P.supportsMasking=!0;P.axis=null==x.axis?-1:x.axis;P.momentum=null==x.momentum?.99:x.momentum;P.epsilon=null==x.epsilon?.001:x.epsilon;P.center=null==x.center?!0:x.center;P.scale=null==x.scale?!0:x.scale;P.betaInitializer=S(x.betaInitializer||"zeros");P.gammaInitializer=S(x.gammaInitializer||"ones");
P.movingMeanInitializer=S(x.movingMeanInitializer||"zeros");P.movingVarianceInitializer=S(x.movingVarianceInitializer||"ones");P.betaConstraint=V(x.betaConstraint);P.gammaConstraint=V(x.gammaConstraint);P.betaRegularizer=oc(x.betaRegularizer);P.gammaRegularizer=oc(x.gammaRegularizer);return P}t(R,na);R.prototype.build=function(x){var P;x=cb(x);var ca=0<=this.axis?this.axis:this.axis+x.length,Ka=x[ca];if(null==Ka)throw new ad("Axis "+ca+" of input tensor should have a defined dimension but the layer received an input with shape "+
(JSON.stringify(x)+"."));this.inputSpec=[new vd({ndim:x.length,axes:(P={},P[ca]=Ka,P)})];x=[Ka];this.scale&&(this.gamma=this.addWeight("gamma",x,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint));this.center&&(this.beta=this.addWeight("beta",x,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint));this.movingMean=this.addWeight("moving_mean",x,null,this.movingMeanInitializer,null,!1);this.movingVariance=this.addWeight("moving_variance",x,null,this.movingVarianceInitializer,
null,!1);this.built=!0};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){var Ka=null==P.training?!1:P.training,rb=$a(x),Mb=rb.shape,Zb=Mb.length,Yb=ba(0,Zb),Gc=0<=ca.axis?ca.axis:ca.axis+Zb;Yb.splice(Gc,1);var cd=b(1,Zb);cd[Gc]=Mb[Gc];Mb=Yb.slice();Mb.sort();var rd=!Kb.util.arraysEqual(Mb,ba(0,Zb).slice(0,Zb-1));Zb=function(){if(rd){var Pd=ca.movingMean.read().reshape(cd),Od=ca.movingVariance.read().reshape(cd),ce=ca.center?ca.beta.read().reshape(cd):null,Yd=ca.scale?ca.gamma.read().reshape(cd):
null;return ud(rb,Pd,Od,ce,Yd,ca.epsilon)}return ud(rb,ca.movingMean.read(),ca.movingVariance.read(),null==ca.beta?null:ca.beta.read(),null==ca.gamma?null:ca.gamma.read(),ca.epsilon)};if(!Ka)return Zb();Ka=sd(rb,ca.gamma.read(),ca.beta.read(),Yb,ca.epsilon);Yb=Ka[0];Zb=Ka[2];Mb=function(Pd,Od,ce){Kb.tidy(function(){var Yd=1-ce,ve=Pd.read();Yd=ve.sub(Od).mul(Yd);Pd.write(ve.sub(Yd))})};Mb(ca.movingMean,Ka[1],ca.momentum);Mb(ca.movingVariance,Zb,ca.momentum);return Yb})};R.prototype.getConfig=function(){var x=
{axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:m(this.betaInitializer),gammaInitializer:m(this.gammaInitializer),movingMeanInitializer:m(this.movingMeanInitializer),movingVarianceInitializer:m(this.movingVarianceInitializer),betaRegularizer:m(this.betaRegularizer),gammaRegularizer:m(this.gammaRegularizer),betaConstraint:m(this.betaConstraint),gammaConstraint:m(this.gammaConstraint)},P=na.prototype.getConfig.call(this);Object.assign(x,
P);return x};R.className="BatchNormalization";return R}(Vd);Kb.serialization.registerClass(ye);var cg=function(na){function R(x){null==x&&(x={});var P=na.call(this,x)||this;P.axis=null==x.axis?-1:x.axis;if("number"===typeof P.axis){if(!Number.isInteger(P.axis))throw Error("Expected axis to be an integer, but received "+P.axis);}else if(Array.isArray(P.axis))for(var ca=0,Ka=P.axis;ca<Ka.length;ca++){if(!Number.isInteger(Ka[ca]))throw Error("Expected axis to be an array of integers, but received "+
JSON.stringify(P.axis));}else throw Error("Expected axis to be an integer or an array of integers, but received "+JSON.stringify(P.axis));P.epsilon=null==x.epsilon?.001:x.epsilon;P.center=null==x.center?!0:x.center;P.scale=null==x.scale?!0:x.scale;P.betaInitializer=S(x.betaInitializer||"zeros");P.gammaInitializer=S(x.gammaInitializer||"ones");P.betaRegularizer=oc(x.betaRegularizer);P.gammaRegularizer=oc(x.gammaRegularizer);P.supportsMasking=!0;return P}t(R,na);R.prototype.build=function(x){x=cb(x);
var P=x.length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(var ca=0;ca<this.axis.length;++ca)0>this.axis[ca]&&(this.axis[ca]+=P);ca=0;for(var Ka=this.axis;ca<Ka.length;ca++){var rb=Ka[ca];if(0>rb||rb>=P)throw Error("Invalid axis: "+rb);}if(this.axis.length!==q(this.axis).length)throw Error("Found duplicate axes in: "+this.axis);P=this.axis.map(function(Mb){return x[Mb]});this.gamma=this.scale?this.addWeight("gamma",P,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null;this.beta=
this.center?this.addWeight("beta",P,"float32",this.betaInitializer,this.betaRegularizer,!0):null;this.built=!0};R.prototype.call=function(x,P){var ca=this,Ka=$a(x),rb=Ka.shape,Mb=rb.length;return Kb.tidy(function(){var Zb=Kb.moments(Ka,ca.axis,!0),Yb=Zb.mean;Zb=Zb.variance;for(var Gc=b(1,Mb),cd=0,rd=ca.axis;cd<rd.length;cd++){var Pd=rd[cd];Gc[Pd]=rb[Pd]}rd=function(Yd){return null!=Yd&&Yd.shape.length!==Mb&&ca.axis!==[Mb-1]?Yd.reshape(Gc):Yd};cd=rd(ca.gamma.read());rd=rd(ca.beta.read());Pd=[];for(var Od=
[],ce=0;ce<Mb;++ce)-1!==ca.axis.indexOf(ce)?(Pd.push(rb[ce]),Od.push(1)):(Pd.push(1),Od.push(rb[ce]));Yb=Yb.tile(Pd);Zb=Zb.tile(Pd);cd=cd.tile(Od);rd=rd.tile(Od);return ud(Ka,Yb,Zb,rd,cd,ca.epsilon)})};R.prototype.getConfig=function(){var x={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:m(this.betaInitializer),gammaInitializer:m(this.gammaInitializer),betaRegularizer:m(this.betaRegularizer),gammaRegularizer:m(this.gammaRegularizer)},P=na.prototype.getConfig.call(this);
Object.assign(x,P);return x};R.className="LayerNormalization";return R}(Vd);Kb.serialization.registerClass(cg);var Ef=function(na){function R(x){null==x&&(x={});var P=na.call(this,x)||this;P.dataFormat=null==x.dataFormat?a():x.dataFormat;if(null==x.padding)P.padding=[[1,1],[1,1]];else if("number"===typeof x.padding)P.padding=[[x.padding,x.padding],[x.padding,x.padding]];else{x.padding=x.padding;if(2!==x.padding.length)throw new ad("ZeroPadding2D expects padding to be a length-2 array, but received a length-"+
(x.padding.length+" array."));if("number"===typeof x.padding[0]){var ca=[x.padding[0],x.padding[0]];x=[x.padding[1],x.padding[1]]}else{x.padding=x.padding;if(2!==x.padding[0].length)throw new ad("ZeroPadding2D expects height padding to be a length-2 array, but received a length-"+(x.padding[0].length+" array."));ca=x.padding[0];if(2!==x.padding[1].length)throw new ad("ZeroPadding2D expects width padding to be a length-2 array, but received a length-"+(x.padding[1].length+" array."));x=x.padding[1]}P.padding=
[ca,x]}P.inputSpec=[new vd({ndim:4})];return P}t(R,na);R.prototype.computeOutputShape=function(x){x=cb(x);if("channelsFirst"===this.dataFormat){var P=null!=x[2]&&0<=x[2]?x[2]+this.padding[0][0]+this.padding[0][1]:null;var ca=null!=x[3]&&0<=x[3]?x[3]+this.padding[1][0]+this.padding[1][1]:null;return[x[0],x[1],P,ca]}P=null!=x[1]&&0<=x[1]?x[1]+this.padding[0][0]+this.padding[0][1]:null;ca=null!=x[2]&&0<=x[2]?x[2]+this.padding[1][0]+this.padding[1][1]:null;return[x[0],P,ca,x[3]]};R.prototype.call=function(x,
P){var ca=this;return Kb.tidy(function(){return wd($a(x),ca.padding,ca.dataFormat)})};R.prototype.getConfig=function(){var x={padding:this.padding,dataFormat:this.dataFormat},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.className="ZeroPadding2D";return R}(Vd);Kb.serialization.registerClass(Ef);var Hg=function(na){function R(x){null==x.poolSize&&(x.poolSize=2);var P=na.call(this,x)||this;if("number"===typeof x.poolSize)P.poolSize=[x.poolSize];else if(Array.isArray(x.poolSize)&&
1===x.poolSize.length&&"number"===typeof x.poolSize[0])P.poolSize=x.poolSize;else throw new ad("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(x.poolSize));z(P.poolSize,"poolSize");if(null==x.strides)P.strides=P.poolSize;else if("number"===typeof x.strides)P.strides=[x.strides];else if(Array.isArray(x.strides)&&1===x.strides.length&&"number"===typeof x.strides[0])P.strides=x.strides;else throw new ad("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+
JSON.stringify(x.strides));z(P.strides,"strides");P.padding=null==x.padding?"valid":x.padding;F(P.padding);P.inputSpec=[new vd({ndim:3})];return P}t(R,na);R.prototype.computeOutputShape=function(x){x=cb(x);var P=ed(x[1],this.poolSize[0],this.padding,this.strides[0]);return[x[0],P,x[2]]};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){ca.invokeCallHook(x,P);x=da($a(x),2);var Ka=ca.poolingFunction($a(x),[ca.poolSize[0],1],[ca.strides[0],1],ca.padding,"channelsLast");return Kb.squeeze(Ka,
[2])})};R.prototype.getConfig=function(){var x={poolSize:this.poolSize,padding:this.padding,strides:this.strides},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};return R}(Vd),jg=function(na){function R(x){return na.call(this,x)||this}t(R,na);R.prototype.poolingFunction=function(x,P,ca,Ka,rb){M(rb);F(Ka);return Zd(x,P,ca,Ka,rb,"max")};R.className="MaxPooling1D";return R}(Hg);Kb.serialization.registerClass(jg);var gg=function(na){function R(x){return na.call(this,x)||this}t(R,na);
R.prototype.poolingFunction=function(x,P,ca,Ka,rb){M(rb);F(Ka);return Zd(x,P,ca,Ka,rb,"avg")};R.className="AveragePooling1D";return R}(Hg);Kb.serialization.registerClass(gg);var th=function(na){function R(x){null==x.poolSize&&(x.poolSize=[2,2]);var P=na.call(this,x)||this;P.poolSize=Array.isArray(x.poolSize)?x.poolSize:[x.poolSize,x.poolSize];if(null==x.strides)P.strides=P.poolSize;else if(Array.isArray(x.strides)){if(2!==x.strides.length)throw new ad("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+
(x.strides.length+"."));P.strides=x.strides}else P.strides=[x.strides,x.strides];z(P.poolSize,"poolSize");z(P.strides,"strides");P.padding=null==x.padding?"valid":x.padding;P.dataFormat=null==x.dataFormat?"channelsLast":x.dataFormat;M(P.dataFormat);F(P.padding);P.inputSpec=[new vd({ndim:4})];return P}t(R,na);R.prototype.computeOutputShape=function(x){x=cb(x);var P="channelsFirst"===this.dataFormat?x[2]:x[1],ca="channelsFirst"===this.dataFormat?x[3]:x[2];P=ed(P,this.poolSize[0],this.padding,this.strides[0]);
ca=ed(ca,this.poolSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[x[0],x[1],P,ca]:[x[0],P,ca,x[3]]};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){ca.invokeCallHook(x,P);return ca.poolingFunction($a(x),ca.poolSize,ca.strides,ca.padding,ca.dataFormat)})};R.prototype.getConfig=function(){var x={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};
return R}(Vd),Xg=function(na){function R(x){return na.call(this,x)||this}t(R,na);R.prototype.poolingFunction=function(x,P,ca,Ka,rb){M(rb);F(Ka);return Zd(x,P,ca,Ka,rb,"max")};R.className="MaxPooling2D";return R}(th);Kb.serialization.registerClass(Xg);var Tg=function(na){function R(x){return na.call(this,x)||this}t(R,na);R.prototype.poolingFunction=function(x,P,ca,Ka,rb){M(rb);F(Ka);return Zd(x,P,ca,Ka,rb,"avg")};R.className="AveragePooling2D";return R}(th);Kb.serialization.registerClass(Tg);var zh=
function(na){function R(x){null==x.poolSize&&(x.poolSize=[2,2,2]);var P=na.call(this,x)||this;P.poolSize=Array.isArray(x.poolSize)?x.poolSize:[x.poolSize,x.poolSize,x.poolSize];if(null==x.strides)P.strides=P.poolSize;else if(Array.isArray(x.strides)){if(3!==x.strides.length)throw new ad("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+(x.strides.length+"."));P.strides=x.strides}else P.strides=[x.strides,x.strides,x.strides];z(P.poolSize,
"poolSize");z(P.strides,"strides");P.padding=null==x.padding?"valid":x.padding;P.dataFormat=null==x.dataFormat?"channelsLast":x.dataFormat;M(P.dataFormat);F(P.padding);P.inputSpec=[new vd({ndim:5})];return P}t(R,na);R.prototype.computeOutputShape=function(x){x=cb(x);var P="channelsFirst"===this.dataFormat?x[2]:x[1],ca="channelsFirst"===this.dataFormat?x[3]:x[2],Ka="channelsFirst"===this.dataFormat?x[4]:x[3];P=ed(P,this.poolSize[0],this.padding,this.strides[0]);ca=ed(ca,this.poolSize[1],this.padding,
this.strides[1]);Ka=ed(Ka,this.poolSize[2],this.padding,this.strides[2]);return"channelsFirst"===this.dataFormat?[x[0],x[1],P,ca,Ka]:[x[0],P,ca,Ka,x[4]]};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){ca.invokeCallHook(x,P);return ca.poolingFunction($a(x),ca.poolSize,ca.strides,ca.padding,ca.dataFormat)})};R.prototype.getConfig=function(){var x={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},P=na.prototype.getConfig.call(this);Object.assign(x,
P);return x};return R}(Vd),og=function(na){function R(x){return na.call(this,x)||this}t(R,na);R.prototype.poolingFunction=function(x,P,ca,Ka,rb){M(rb);F(Ka);return Te(x,P,ca,Ka,rb,"max")};R.className="MaxPooling3D";return R}(zh);Kb.serialization.registerClass(og);var Fh=function(na){function R(x){return na.call(this,x)||this}t(R,na);R.prototype.poolingFunction=function(x,P,ca,Ka,rb){M(rb);F(Ka);return Te(x,P,ca,Ka,rb,"avg")};R.className="AveragePooling3D";return R}(zh);Kb.serialization.registerClass(Fh);
var Gh=function(na){function R(x){x=na.call(this,x)||this;x.inputSpec=[new vd({ndim:3})];return x}t(R,na);R.prototype.computeOutputShape=function(x){return[x[0],x[2]]};R.prototype.call=function(x,P){throw new $e;};return R}(Vd),Jg=function(na){function R(x){return na.call(this,x||{})||this}t(R,na);R.prototype.call=function(x,P){return Kb.tidy(function(){var ca=$a(x);return Kb.mean(ca,1)})};R.className="GlobalAveragePooling1D";return R}(Gh);Kb.serialization.registerClass(Jg);var Hh=function(na){function R(x){return na.call(this,
x||{})||this}t(R,na);R.prototype.call=function(x,P){return Kb.tidy(function(){var ca=$a(x);return Kb.max(ca,1)})};R.className="GlobalMaxPooling1D";return R}(Gh);Kb.serialization.registerClass(Hh);var Ug=function(na){function R(x){var P=na.call(this,x)||this;P.dataFormat=null==x.dataFormat?"channelsLast":x.dataFormat;M(P.dataFormat);P.inputSpec=[new vd({ndim:4})];return P}t(R,na);R.prototype.computeOutputShape=function(x){return"channelsLast"===this.dataFormat?[x[0],x[3]]:[x[0],x[1]]};R.prototype.call=
function(x,P){throw new $e;};R.prototype.getConfig=function(){var x={dataFormat:this.dataFormat},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};return R}(Vd),ih=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){var Ka=$a(x);return"channelsLast"===ca.dataFormat?Kb.mean(Ka,[1,2]):Kb.mean(Ka,[2,3])})};R.className="GlobalAveragePooling2D";return R}(Ug);Kb.serialization.registerClass(ih);
var lh=function(na){function R(){return null!==na&&na.apply(this,arguments)||this}t(R,na);R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){var Ka=$a(x);return"channelsLast"===ca.dataFormat?Kb.max(Ka,[1,2]):Kb.max(Ka,[2,3])})};R.className="GlobalMaxPooling2D";return R}(Ug);Kb.serialization.registerClass(lh);var pg=function(na){function R(x){var P=na.call(this,x)||this;P.layer=x.layer;return P}t(R,na);R.prototype.build=function(x){this.built=!0};Object.defineProperty(R.prototype,
"trainable",{get:function(){return null!=this.layer?this.layer.trainable:!1},set:function(x){null!=this.layer&&(this.layer.trainable=x)},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"trainableWeights",{get:function(){return this.layer.trainableWeights},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"nonTrainableWeights",{get:function(){return this.layer.nonTrainableWeights},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"updates",{get:function(){return this.layer._updates},
enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"losses",{get:function(){return this.layer.losses},enumerable:!0,configurable:!0});R.prototype.getWeights=function(){return this.layer.getWeights()};R.prototype.setWeights=function(x){this.layer.setWeights(x)};R.prototype.getConfig=function(){var x={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.prototype.setFastWeightInitDuringBuild=function(x){na.prototype.setFastWeightInitDuringBuild.call(this,
x);null!=this.layer&&this.layer.setFastWeightInitDuringBuild(x)};R.fromConfig=function(x,P,ca){void 0===ca&&(ca={});ca=Xb(P.layer,ca);delete P.layer;ca={layer:ca};Object.assign(ca,P);return new x(ca)};return R}(Vd),Rh=function(na){function R(x){x=na.call(this,x)||this;x.supportsMasking=!0;return x}t(R,na);R.prototype.build=function(x){x=cb(x);if(3>x.length)throw new ad("TimeDistributed layer expects an input shape \x3e\x3d 3D, but received input shape "+JSON.stringify(x));this.inputSpec=[{shape:x}];
var P=[x[0]].concat(x.slice(2));this.layer.built||(this.layer.build(P),this.layer.built=!0);na.prototype.build.call(this,x)};R.prototype.computeOutputShape=function(x){x=cb(x);var P=[x[0]].concat(x.slice(2));P=this.layer.computeOutputShape(P);return[P[0],x[1]].concat(P.slice(1))};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){x=$a(x);return Db(function(Ka,rb){return[$a(ca.layer.call(Ka,P)),[]]},x,[],!1,null,null,!1,!0)[1]})};R.className="TimeDistributed";return R}(pg);Kb.serialization.registerClass(Rh);
var Ph=function(na){function R(x){var P=na.call(this,x)||this,ca=x.layer.getConfig(),Ka={};Ka.className=x.layer.getClassName();Ka.config=ca;P.forwardLayer=Xb(Ka);ca.goBackwards=!0===ca.goBackwards?!1:!0;Ka={};Ka.className=x.layer.getClassName();Ka.config=ca;P.backwardLayer=Xb(Ka);P.forwardLayer.name="forward_"+P.forwardLayer.name;P.backwardLayer.name="backward_"+P.backwardLayer.name;P.mergeMode=void 0===x.mergeMode?"concat":x.mergeMode;y(Cd,"BidirectionalMergeMode",P.mergeMode);if(x.weights)throw new $e("weights support is not implemented for Bidirectional layer yet.");
P._stateful=x.layer.stateful;P.returnSequences=x.layer.returnSequences;P.returnState=x.layer.returnState;P.supportsMasking=!0;P._trainable=!0;P.inputSpec=x.layer.inputSpec;P.numConstants=null;return P}t(R,na);Object.defineProperty(R.prototype,"trainable",{get:function(){return this._trainable},set:function(x){this._trainable=x;null!=this.forwardLayer&&(this.forwardLayer.trainable=x);null!=this.backwardLayer&&(this.backwardLayer.trainable=x)},enumerable:!0,configurable:!0});R.prototype.getWeights=
function(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())};R.prototype.setWeights=function(x){var P=Math.floor(x.length/2);this.forwardLayer.setWeights(x.slice(0,P));this.backwardLayer.setWeights(x.slice(P))};R.prototype.computeOutputShape=function(x){x=this.forwardLayer.computeOutputShape(x);Array.isArray(x)&&Array.isArray(x[0])||(x=[x]);var P;this.returnState&&(P=x.slice(1));x=x[0];if("concat"===this.mergeMode){x[x.length-1]*=2;var ca=[x]}else ca=null==this.mergeMode?
[x,x.slice()]:[x];return this.returnState?null==this.mergeMode?ca.concat(P).concat(P.slice()):[x].concat(P).concat(P.slice()):d(ca)};R.prototype.apply=function(x,P){var ca=null==P?null:P.initialState,Ka=null==P?null:P.constants;null==P&&(P={});var rb=nb(x,ca,Ka,this.numConstants);x=rb.inputs;ca=rb.initialState;Ka=rb.constants;Array.isArray(x)&&(ca=x.slice(1),x=x[0]);if((null==ca||0===ca.length)&&null==Ka)return na.prototype.apply.call(this,x,P);var Mb=[];rb=[];if(null!=ca){var Zb=ca.length;if(0<Zb%
2)throw new ad("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");P.initialState=ca;Mb.push.apply(Mb,ca);ca=ca.map(function(Yb){return new vd({shape:Yb.shape})});this.forwardLayer.stateSpec=ca.slice(0,Zb/2);this.backwardLayer.stateSpec=ca.slice(Zb/2);rb.push.apply(rb,ca)}if(null!=Ka)throw new $e("Support for constants in Bidirectional layers is not implemented yet.");ca=Mb[0]instanceof Nd;for(Ka=0;Ka<Mb.length;Ka++)if(Mb[Ka]instanceof
Nd!==ca)throw new ad("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");return ca?(x=[x].concat(Mb),Mb=this.inputSpec.concat(rb),rb=this.inputSpec,this.inputSpec=Mb,P=na.prototype.apply.call(this,x,P),this.inputSpec=rb,P):na.prototype.apply.call(this,x,P)};R.prototype.call=function(x,P){var ca=this;return Kb.tidy(function(){var Ka=P.initialState;if(null==Ka){var rb=ca.forwardLayer.call(x,P);Ka=ca.backwardLayer.call(x,P)}else rb=Ka.slice(0,
Ka.length/2),Ka=Ka.slice(Ka.length/2),rb=ca.forwardLayer.call(x,Object.assign(P,{initialState:rb})),Ka=ca.backwardLayer.call(x,Object.assign(P,{initialState:Ka}));var Mb;ca.returnState&&(Array.isArray(rb)&&(Mb=rb.slice(1).concat(Ka.slice(1))),rb=rb[0],Ka=Ka[0]);ca.returnSequences&&(Ka=Kb.reverse(Ka,1));var Zb;"concat"===ca.mergeMode?Zb=ja([rb,Ka]):"sum"===ca.mergeMode?Zb=Kb.add(rb,Ka):"ave"===ca.mergeMode?Zb=Kb.mul(.5,Kb.add(rb,Ka)):"mul"===ca.mergeMode?Zb=Kb.mul(rb,Ka):null==ca.mergeMode&&(Zb=[rb,
Ka]);return ca.returnState?null==ca.mergeMode?Zb.concat(Mb):[Zb].concat(Mb):Zb})};R.prototype.resetStates=function(x){this.forwardLayer.resetStates();this.backwardLayer.resetStates()};R.prototype.build=function(x){var P=this;D(this.forwardLayer.name,function(){P.forwardLayer.build(x)});D(this.backwardLayer.name,function(){P.backwardLayer.build(x)});this.built=!0};R.prototype.computeMask=function(x,P){Array.isArray(P)&&(P=P[0]);x=this.returnSequences?null==this.mergeMode?[P,P]:P:null==this.mergeMode?
[null,null]:null;return this.returnState?(P=this.forwardLayer.states.map(function(ca){return null}),Array.isArray(x)?x.concat(P).concat(P):[x].concat(P).concat(P)):x};Object.defineProperty(R.prototype,"trainableWeights",{get:function(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)},enumerable:!0,configurable:!0});Object.defineProperty(R.prototype,"nonTrainableWeights",{get:function(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)},
enumerable:!0,configurable:!0});R.prototype.setFastWeightInitDuringBuild=function(x){na.prototype.setFastWeightInitDuringBuild.call(this,x);null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(x);null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(x)};R.prototype.getConfig=function(){var x={mergeMode:this.mergeMode},P=na.prototype.getConfig.call(this);Object.assign(x,P);return x};R.fromConfig=function(x,P){var ca=Xb(P.layer);delete P.layer;if(null!=P.numConstants)throw new $e("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
P.layer=ca;return new x(P)};R.className="Bidirectional";return R}(pg);Kb.serialization.registerClass(Ph);var Ah={__proto__:null,inputLayer:function(na){return new le(na)},elu:function(na){return new sg(na)},reLU:function(na){return new Qg(na)},leakyReLU:function(na){return new xf(na)},prelu:function(na){return new se(na)},softmax:function(na){return new Ch(na)},thresholdedReLU:function(na){return new Sg(na)},conv1d:function(na){return new yh(na)},conv2d:function(na){return new Dh(na)},conv2dTranspose:function(na){return new jh(na)},
conv3d:function(na){return new Eh(na)},separableConv2d:function(na){return new rh(na)},cropping2D:function(na){return new kh(na)},upSampling2d:function(na){return new nh(na)},depthwiseConv2d:function(na){return new sh(na)},activation:function(na){return new Ff(na)},dense:function(na){return new Ie(na)},dropout:function(na){return new Ld(na)},spatialDropout1d:function(na){return new me(na)},flatten:function(na){return new Ee(na)},repeatVector:function(na){return new Kf(na)},reshape:function(na){return new ea(na)},
permute:function(na){return new sa(na)},embedding:function(na){return new za(na)},add:function(na){return new Cb(na)},average:function(na){return new nc(na)},concatenate:function(na){return new Hd(na)},maximum:function(na){return new Tc(na)},minimum:function(na){return new hd(na)},multiply:function(na){return new gc(na)},dot:function(na){return new $d(na)},batchNormalization:function(na){return new ye(na)},layerNormalization:function(na){return new cg(na)},zeroPadding2d:function(na){return new Ef(na)},
averagePooling1d:re,avgPool1d:function(na){return re(na)},avgPooling1d:function(na){return re(na)},averagePooling2d:We,avgPool2d:function(na){return We(na)},avgPooling2d:function(na){return We(na)},averagePooling3d:nf,avgPool3d:function(na){return nf(na)},avgPooling3d:function(na){return nf(na)},globalAveragePooling1d:function(na){return new Jg(na)},globalAveragePooling2d:function(na){return new ih(na)},globalMaxPooling1d:bg,globalMaxPooling2d:Lf,maxPooling1d:Wf,maxPooling2d:Pf,maxPooling3d:function(na){return new og(na)},
gru:function(na){return new cc(na)},gruCell:function(na){return new Qb(na)},lstm:function(na){return new kc(na)},lstmCell:function(na){return new zc(na)},simpleRNN:function(na){return new Ab(na)},simpleRNNCell:function(na){return new Pa(na)},convLstm2d:function(na){return new Wd(na)},convLstm2dCell:function(na){return new Td(na)},rnn:function(na){return new Fg(na)},stackedRNNCells:function(na){return new Nc(na)},bidirectional:function(na){return new Ph(na)},timeDistributed:function(na){return new Rh(na)},
globalMaxPool1d:bg,globalMaxPool2d:Lf,maxPool1d:Wf,maxPool2d:Pf,Layer:Vd,RNN:Fg,RNNCell:Rg,input:mf,gaussianNoise:function(na){return new te(na)},gaussianDropout:function(na){return new He(na)},alphaDropout:function(na){return new Xd(na)},masking:function(na){return new ia(na)}},Uh=function(na){function R(){var x=null!==na&&na.apply(this,arguments)||this;x.model=null;return x}t(R,na);R.prototype.setModel=function(x){if(!(x instanceof pf))throw Error("model must be a LayersModel, not some other Container");
this.model=x};return R}(Ae),Kh=function(na){function R(x){var P=na.call(this)||this;null==x&&(x={});if(x.restoreBestWeights)throw new $e("restoreBestWeights \x3d True is not implemented in EarlyStopping yet.");P.monitor=x.monitor||"val_loss";P.minDelta=Math.abs(x.minDelta||0);P.patience=x.patience||0;P.verbose=x.verbose||0;P.mode=x.mode||"auto";P.baseline=x.baseline;-1===["auto","min","max"].indexOf(P.mode)&&(console.warn("EarlyStopping mode '"+P.mode+"' is invalid. Falling back to mode 'auto'."),
P.mode="auto");"min"===P.mode?P.monitorFunc=Bg:"max"===P.mode?P.monitorFunc=Uf:-1!==P.monitor.indexOf("acc")?P.monitorFunc=Uf:P.monitorFunc=Bg;P.monitorFunc===Bg&&(P.minDelta*=-1);return P}t(R,na);R.prototype.onTrainBegin=function(x){return r(this,void 0,void 0,function(){return u(this,function(P){this.stoppedEpoch=this.wait=0;this.best=null!=this.baseline?this.baseline:this.monitorFunc===Bg?Infinity:-Infinity;return[2]})})};R.prototype.onEpochEnd=function(x,P){return r(this,void 0,void 0,function(){var ca;
return u(this,function(Ka){switch(Ka.label){case 0:return[4,bb(P)];case 1:Ka.sent();ca=this.getMonitorValue(P);if(null==ca)return[2];this.monitorFunc(ca-this.minDelta,this.best)?(this.best=ca,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=x,this.model.stopTraining=!0));return[2]}})})};R.prototype.onTrainEnd=function(x){return r(this,void 0,void 0,function(){return u(this,function(P){0<this.stoppedEpoch&&this.verbose&&console.log("Epoch "+this.stoppedEpoch+": early stopping.");
return[2]})})};R.prototype.getMonitorValue=function(x){null==x&&(x={});var P=x[this.monitor];null==P&&console.warn("Metric for EarlyStopping "+this.monitor+" is not available. Available metrics are: "+Object.keys(x));return P};return R}(Uh);v.Callback=Uh;v.CallbackList=kb;v.CustomCallback=ec;v.EarlyStopping=Kh;v.History=Hb;v.InputSpec=vd;v.LayerVariable=Bd;v.LayersModel=pf;v.RNN=Fg;v.Sequential=Yf;v.SymbolicTensor=Nd;v.callbacks={earlyStopping:function(na){return new Kh(na)}};v.constraints={__proto__:null,
maxNorm:function(na){return new pb(na)},unitNorm:function(na){return new Ea(na)},nonNeg:function(){return new db},minMaxNorm:function(na){return new fb(na)}};v.initializers={__proto__:null,zeros:function(){return new rg},ones:function(){return new If},constant:function(na){return new ag(na)},randomUniform:function(na){return new Ua(na)},randomNormal:function(na){return new xa(na)},truncatedNormal:function(na){return new Wa(na)},identity:function(na){return new Da(na)},varianceScaling:function(na){return new mb(na)},
glorotUniform:function(na){return new Bb(na)},glorotNormal:function(na){return new $b(na)},heNormal:function(na){return new wc(na)},heUniform:function(na){return new Rc(na)},leCunNormal:function(na){return new Zc(na)},leCunUniform:function(na){return new Xc(na)},orthogonal:function(na){return new bd(na)}};v.input=mf;v.layers=Ah;v.loadLayersModel=function(na,R){null==R&&(R={});return Gd(na,R)};v.metrics={__proto__:null,binaryAccuracy:function(na,R){return Ta(na,R)},binaryCrossentropy:function(na,R){return $c(na,
R)},sparseCategoricalAccuracy:function(na,R){return ld(na,R)},categoricalAccuracy:function(na,R){return jb(na,R)},categoricalCrossentropy:function(na,R){return sc(na,R)},precision:function(na,R){return dd(na,R)},recall:function(na,R){return Dc(na,R)},cosineProximity:function(na,R){return xd(na,R)},meanAbsoluteError:function(na,R){return yd(na,R)},meanAbsolutePercentageError:function(na,R){return pd(na,R)},MAPE:function(na,R){return pd(na,R)},mape:function(na,R){return pd(na,R)},meanSquaredError:function(na,
R){return Yc(na,R)},MSE:function(na,R){return Yc(na,R)},mse:function(na,R){return Yc(na,R)}};v.model=function(na){return new pf(na)};v.models={__proto__:null,modelFromJSON:function(na,R){return r(this,void 0,void 0,function(){var x,P,ca,Ka,rb,Mb,Zb,Yb;return u(this,function(Gc){switch(Gc.label){case 0:return"modelTopology"in na||(na={modelTopology:na}),x=na.modelTopology,null!=x.model_config&&(x=x.model_config),P=Ne(x),ca=Xb(P,R),null==na.weightsManifest?[3,2]:[4,Kb.io.loadWeights(na.weightsManifest,
na.pathPrefix,ca.weights.map(function(cd){return cd.originalName}))];case 1:Ka=Gc.sent();rb={};Mb=0;for(Zb=ca.weights;Mb<Zb.length;Mb++)Yb=Zb[Mb],rb[Yb.originalName]=Ka[Yb.originalName];ca.loadWeights(rb);Kb.dispose(Ka);Gc.label=2;case 2:return[2,ca]}})})}};v.registerCallbackConstructor=function(na,R){Bc.registerCallbackConstructor(na,R)};v.regularizers={__proto__:null,l1l2:function(na){return new Cg(na)},l1:function(na){wb(na);return new Cg({l1:null!=na?na.l1:null,l2:0})},l2:function(na){wb(na);
return new Cg({l2:null!=na?na.l2:null,l1:0})}};v.sequential=function(na){return new Yf(na)};v.version_layers="2.7.0"};
shadow$provide[950]=function(W,A,la,v){function t(ab,Ta,jb,Wb){return new (jb||(jb=Promise))(function(xc,Ec){function dd(ld){try{kd(Wb.next(ld))}catch(Nb){Ec(Nb)}}function Dc(ld){try{kd(Wb["throw"](ld))}catch(Nb){Ec(Nb)}}function kd(ld){ld.done?xc(ld.value):(new jb(function(Nb){Nb(ld.value)})).then(dd,Dc)}kd((Wb=Wb.apply(ab,Ta||[])).next())})}function r(ab,Ta){function jb(ld){return function(Nb){return Wb([ld,Nb])}}function Wb(ld){if(Ec)throw new TypeError("Generator is already executing.");for(;xc;)try{if(Ec=
1,dd&&(Dc=dd[ld[0]&2?"return":ld[0]?"throw":"next"])&&!(Dc=Dc.call(dd,ld[1])).done)return Dc;if(dd=0,Dc)ld=[0,Dc.value];switch(ld[0]){case 0:case 1:Dc=ld;break;case 4:return xc.label++,{value:ld[1],done:!1};case 5:xc.label++;dd=ld[1];ld=[0];continue;case 7:ld=xc.ops.pop();xc.trys.pop();continue;default:if(!(Dc=xc.trys,Dc=0<Dc.length&&Dc[Dc.length-1])&&(6===ld[0]||2===ld[0])){xc=0;continue}if(3===ld[0]&&(!Dc||ld[1]>Dc[0]&&ld[1]<Dc[3]))xc.label=ld[1];else if(6===ld[0]&&xc.label<Dc[1])xc.label=Dc[1],
Dc=ld;else if(Dc&&xc.label<Dc[2])xc.label=Dc[2],xc.ops.push(ld);else{Dc[2]&&xc.ops.pop();xc.trys.pop();continue}}ld=Ta.call(ab,xc)}catch(Nb){ld=[6,Nb],dd=0}finally{Ec=Dc=0}if(ld[0]&5)throw ld[1];return{value:ld[0]?ld[1]:void 0,done:!0}}var xc={label:0,sent:function(){if(Dc[0]&1)throw Dc[1];return Dc[1]},trys:[],ops:[]},Ec,dd,Dc,kd;return kd={next:jb(0),"throw":jb(1),"return":jb(2)},"function"===typeof Symbol&&(kd[Symbol.iterator]=function(){return this}),kd}function u(ab,Ta){var jb="function"===typeof Symbol&&
ab[Symbol.iterator];if(!jb)return ab;ab=jb.call(ab);var Wb,xc=[];try{for(;(void 0===Ta||0<Ta--)&&!(Wb=ab.next()).done;)xc.push(Wb.value)}catch(dd){var Ec={error:dd}}finally{try{Wb&&!Wb.done&&(jb=ab["return"])&&jb.call(ab)}finally{if(Ec)throw Ec.error;}}return xc}function f(){for(var ab=[],Ta=0;Ta<arguments.length;Ta++)ab=ab.concat(u(arguments[Ta]));return ab}function a(ab,Ta,jb,Wb,xc){var Ec=Ta.inputParams[ab];if(Ec&&void 0!==Ec.inputIndexStart){ab=Ec.inputIndexStart;var dd=0===Ec.inputIndexEnd?void 0:
void 0===Ec.inputIndexEnd?ab+1:Ec.inputIndexEnd;if("tensor"===Ec.type)return b(Ta.inputNames[Ec.inputIndexStart],jb,Wb,xc);if("tensors"===Ec.type)return Ta.inputNames.slice(ab,dd).map(function(Dc){return b(Dc,jb,Wb,xc)});Ta=b(Ta.inputNames.slice(ab)[0],jb,Wb,xc);ab=Ta.dataSync();return"number"===Ec.type?ab[0]:ba.util.toNestedArray(Ta.shape,ab)}return(Ec=Ta.attrParams[ab])&&Ec.value}function b(ab,Ta,jb,Wb){ab=u(d(ab),2);var xc=ab[0];ab=ab[1];if(null!=Wb&&(Wb=Wb.getHashTableHandleByName(xc),null!=Wb))return Wb;
jb=jb.currentContextIds.find(function(Ec){return!!Ta[g(xc,Ec)]});return void 0!==jb?Ta[g(xc,jb)][ab]:void 0}function e(ab,Ta){ab=u(d(ab),2);var jb=ab[1];return[g(ab[0],Ta&&Ta.currentContextId),jb]}function g(ab,Ta){return Ta?ab+"-"+Ta:ab}function d(ab){var Ta=ab.split(":");return 1===Ta.length?[ab,0]:[Ta[0],Number(Ta[Ta.length-1])]}function h(ab,Ta,jb){var Wb=a("pad",ab,Ta,jb);if("explicit"===Wb){Wb=a("explicitPaddings",ab,Ta,jb);ab=[[0,0],[0,0],[0,0],[0,0]];for(Ta=0;4>Ta;Ta++)ab[Ta][0]=Wb[2*Ta],
ab[Ta][1]=Wb[2*Ta+1];return ab}return Wb}function c(ab){return ab.kept?ab:ba.clone(ab)}function l(ab,Ta){if(Array.isArray(ab))ab=String.fromCharCode.apply(null,ab);else{var jb=ba.env().global;if("undefined"!==typeof jb.atob)ab=jb.atob(ab);else if("undefined"!==typeof aa)ab=(new aa(ab,"base64")).toString();else throw Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");}return Ta?ab:ab.toLowerCase()}function m(ab,Ta,jb,Wb){void 0===Wb&&(Wb=!1);ab=ab[Ta];return null!=
ab?l(ab.s,Wb):jb}function n(ab,Ta,jb){return(ab=ab[Ta])?ab.b:jb}function k(ab,Ta,jb){ab=ab[Ta]||{};jb=null!=ab.i?ab.i:null!=ab.f?ab.f:jb;return"number"===typeof jb?jb:parseInt(jb,10)}function p(ab){"string"===typeof ab&&(ab=da[ab]);switch(ab){case da.DT_FLOAT:return"float32";case da.DT_INT32:case da.DT_INT64:case da.DT_INT8:case da.DT_UINT8:return"int32";case da.DT_BOOL:return"bool";case da.DT_DOUBLE:return"float32";case da.DT_STRING:return"string";default:return null}}function q(ab,Ta,jb){return(ab=
ab[Ta])&&ab.func?ab.func.name:jb}function w(ab,Ta,jb){return(ab=ab[Ta])&&ab.type?p(ab.type):jb}function y(ab,Ta,jb){return(ab=ab[Ta])&&ab.list&&ab.list.type?ab.list.type.map(function(Wb){return p(Wb)}):jb}function C(ab){if(!ab.unknownRank)return null!=ab.dim?ab.dim.map(function(Ta){return"number"===typeof Ta.size?Ta.size:parseInt(Ta.size,10)}):[]}function z(ab,Ta,jb){return(ab=ab[Ta])&&ab.shape?C(ab.shape):jb}function K(ab,Ta,jb){return(ab=ab[Ta])?((ab.list.f&&ab.list.f.length?ab.list.f:ab.list.i)||
[]).map(function(Wb){return"number"===typeof Wb?Wb:parseInt(Wb,10)}):jb}function J(ab,Ta,jb,Wb){void 0===Wb&&(Wb=!1);return(ab=ab[Ta])&&ab.list&&ab.list.s?ab.list.s.map(function(xc){return l(xc,Wb)}):jb}function B(ab,Ta,jb){return(ab=ab[Ta])&&ab.list&&ab.list.shape?ab.list.shape.map(function(Wb){return C(Wb)}):jb}function O(ab,Ta,jb){return(ab=ab[Ta])&&ab.list&&ab.list.b?ab.list.b:jb}function Q(ab,Ta,jb){void 0===jb&&(jb="");ba.util.assert(V(ab,Ta),function(){return jb+(" Shapes "+ab+" and "+Ta+" must match")})}
function V(ab,Ta){if(ab.length!==Ta.length)return!1;for(var jb=0;jb<ab.length;jb++)if(-1!==ab[jb]&&-1!==Ta[jb]&&ab[jb]!==Ta[jb])return!1;return!0}function M(ab,Ta,jb){var Wb=ab.dtype;if(1>ab.shape.length)throw Error("Tensor must be at least a vector, but saw shape: "+ab.shape);if(ab.dtype!==jb)throw Error("Invalid data types; op elements "+ab.dtype+", but list elements "+jb);jb=ab.shape.slice(1);Q(jb,Ta,"TensorList shape mismatch: ");ab=ba.unstack(ab);return new wa(ab,Ta,Wb)}function F(ab,Ta,jb,Wb){if(Ta.length!==
ab.shape[0])throw Error("Expected len(indices) \x3d\x3d tensor.shape[0], but saw: "+Ta.length+" vs. "+ab.shape[0]);var xc=Math.max.apply(Math,f(Ta));if(null!=Wb&&-1!==Wb&&xc>=Wb)throw Error("Max index must be \x3c array size ("+xc+"  vs. "+Wb+")");var Ec=new wa([],jb,ab.dtype,Wb),dd=ba.unstack(ab,0);Ta.forEach(function(Dc,kd){Ec.setItem(Dc,dd[kd])});return Ec}function D(ab,Ta,jb){var Wb=0,xc=Ta.map(function(ld){return Wb+=ld});if(Wb!==ab.shape[0])throw Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        "+
Wb+", and tensor's shape is: "+ab.shape);for(var Ec=0===Wb?0:ab.size/Wb,dd=ba.tidy(function(){var ld=[];ab=ba.reshape(ab,[1,Wb,Ec]);for(var Nb=0;Nb<Ta.length;++Nb)ld[Nb]=ba.reshape(ba.slice(ab,[0,0===Nb?0:xc[Nb-1],0],[1,Ta[Nb],Ec]),jb);ab.dispose();return ld}),Dc=new wa([],jb,ab.dtype,Ta.length),kd=0;kd<dd.length;kd++)Dc.setItem(kd,dd[kd]);return Dc}function H(ab,Ta,jb){var Wb=u(a("fusedOps",ab,Ta,jb),2),xc=Wb[0];Wb=Wb[1];var Ec="biasadd"===xc,dd="prelu"===Wb;xc="fusedbatchnorm"===xc;var Dc=a("numArgs",
ab,Ta,jb);if(Ec){if(dd&&2!==Dc)throw Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!dd&&1!==Dc)throw Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");}if(xc)throw Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");Ec=a("strides",ab,Ta,jb);dd=h(ab,Ta,jb);xc=a("dataFormat",ab,Ta,jb).toUpperCase();Dc=a("dilations",ab,Ta,jb);ab=u(a("args",ab,Ta,jb),2);return{stride:Ec,
pad:dd,dataFormat:xc,dilations:Dc,biasArg:ab[0],preluArg:ab[1],activationFunc:Wb}}function U(ab,Ta,jb){var Wb=a("boxes",ab,Ta,jb),xc=a("scores",ab,Ta,jb),Ec=a("maxOutputSize",ab,Ta,jb),dd=a("iouThreshold",ab,Ta,jb),Dc=a("scoreThreshold",ab,Ta,jb);ab=a("softNmsSigma",ab,Ta,jb);return{boxes:Wb,scores:xc,maxOutputSize:Ec,iouThreshold:dd,scoreThreshold:Dc,softNmsSigma:ab}}function L(ab,Ta,jb,Wb){ab=function(xc,Ec,dd){switch(xc.category){case "arithmetic":return ba.tidy(function(){return Qa(xc,Ec,dd)});
case "basic_math":return ba.tidy(function(){return $a(xc,Ec,dd)});case "control":return Aa(xc,Ec,dd);case "convolution":return ba.tidy(function(){return lb(xc,Ec,dd)});case "creation":return ba.tidy(function(){return Ya(xc,Ec,dd)});case "dynamic":return Pb(xc,Ec,dd);case "evaluation":return ba.tidy(function(){a:switch(xc.op){case "TopKV2":var kd=a("x",xc,Ec,dd);var ld=a("k",xc,Ec,dd),Nb=a("sorted",xc,Ec,dd);kd=ba.topk(kd,ld,Nb);kd=[kd.values,kd.indices];break a;case "Unique":kd=a("x",xc,Ec,dd);kd=
ba.unique(kd);kd=[kd.values,kd.indices];break a;case "UniqueV2":kd=a("x",xc,Ec,dd);ld=a("axis",xc,Ec,dd);kd=ba.unique(kd,ld);kd=[kd.values,kd.indices];break a;default:throw TypeError("Node type "+xc.op+" is not implemented");}return kd});case "image":return ba.tidy(function(){a:switch(xc.op){case "ResizeBilinear":var kd=a("images",xc,Ec,dd);var ld=a("size",xc,Ec,dd),Nb=a("alignCorners",xc,Ec,dd);kd=[ba.image.resizeBilinear(kd,[ld[0],ld[1]],Nb)];break a;case "ResizeNearestNeighbor":kd=a("images",xc,
Ec,dd);ld=a("size",xc,Ec,dd);Nb=a("alignCorners",xc,Ec,dd);kd=[ba.image.resizeNearestNeighbor(kd,[ld[0],ld[1]],Nb)];break a;case "CropAndResize":kd=a("image",xc,Ec,dd);ld=a("boxes",xc,Ec,dd);Nb=a("boxInd",xc,Ec,dd);var Sb=a("cropSize",xc,Ec,dd),Tb=a("method",xc,Ec,dd),Ac=a("extrapolationValue",xc,Ec,dd);kd=[ba.image.cropAndResize(kd,ld,Nb,Sb,Tb,Ac)];break a;default:throw TypeError("Node type "+xc.op+" is not implemented");}return kd});case "graph":return ba.tidy(function(){return tb(xc,Ec,dd)});case "logical":return ba.tidy(function(){return Fb(xc,
Ec,dd)});case "matrices":return ba.tidy(function(){a:switch(xc.op){case "BatchMatMul":case "BatchMatMulV2":case "MatMul":var kd=[ba.matMul(a("a",xc,Ec,dd),a("b",xc,Ec,dd),a("transposeA",xc,Ec,dd),a("transposeB",xc,Ec,dd))];break a;case "Transpose":kd=[ba.transpose(a("x",xc,Ec,dd),a("perm",xc,Ec,dd))];break a;case "_FusedMatMul":var ld=u(a("fusedOps",xc,Ec,dd),2);kd=ld[1];ld="biasadd"===ld[0];var Nb="prelu"===kd,Sb=a("numArgs",xc,Ec,dd);if(ld){if(Nb&&2!==Sb)throw Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
if(!Nb&&1!==Sb)throw Error("Fused MatMul with BiasAdd must have one extra argument: bias.");}Nb=u(a("args",xc,Ec,dd),2);ld=Nb[0];Nb=Nb[1];kd=[ba.fused.matMul({a:a("a",xc,Ec,dd),b:a("b",xc,Ec,dd),transposeA:a("transposeA",xc,Ec,dd),transposeB:a("transposeB",xc,Ec,dd),bias:ld,activation:kd,preluActivationWeights:Nb})];break a;default:throw TypeError("Node type "+xc.op+" is not implemented");}return kd});case "normalization":return ba.tidy(function(){return vb(xc,Ec,dd)});case "reduction":return ba.tidy(function(){return Xb(xc,
Ec,dd)});case "slice_join":return ba.tidy(function(){return Mc(xc,Ec,dd)});case "spectral":return ba.tidy(function(){a:switch(xc.op){case "FFT":var kd=[ba.fft(a("x",xc,Ec,dd))];break a;case "IFFT":kd=[ba.ifft(a("x",xc,Ec,dd))];break a;case "RFFT":kd=[ba.rfft(a("x",xc,Ec,dd))];break a;case "IRFFT":kd=[ba.irfft(a("x",xc,Ec,dd))];break a;default:throw TypeError("Node type "+xc.op+" is not implemented");}return kd});case "transformation":return ba.tidy(function(){return Yc(xc,Ec,dd)});case "hash_table":return La(xc,
Ec,dd,Wb);case "custom":var Dc=fa[xc.op];if(Dc&&Dc.customExecutor)return Dc.customExecutor(new ya(xc,Ec,dd));throw TypeError("Custom op "+xc.op+" is not registered.");default:throw TypeError("Unknown op '"+xc.op+"'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()");}}(ab,Ta,jb);return ba.util.isPromise(ab)?ab.then(function(xc){return[].concat(xc)}):[].concat(ab)}function I(ab,Ta,jb,Wb){var xc=new Set,Ec=[],dd=null,Dc=
null,kd=new Set,ld=Object.keys(ab).map(function(Tb){return d(Tb)[0]}),Nb=[];null!=Wb&&(Nb=Wb.map(function(Tb){return d(Tb.name)[0]}));for(var Sb=f(Ta);0<Sb.length;)Wb=Sb.pop(),(0<=pd.indexOf(Wb.op)||0<=sc.indexOf(Wb.op)||0<=tc.indexOf(Wb.op))&&null==dd&&(dd=Wb,Dc=dd.children.map(function(Tb){return Tb.name}).filter(function(Tb){return xc.has(Tb)})),xc.add(Wb.name),null==jb[Wb.name]&&-1===ld.indexOf(Wb.name)&&-1===Nb.indexOf(Wb.name)&&(0===Wb.inputs.length?Ec.push(Wb.name):Wb.inputs.forEach(function(Tb){kd.has(Tb.name)||
(kd.add(Tb.name),Sb.push(Tb))}));return{inputs:ab,outputs:Ta,usedNodes:xc,missingInputs:Ec,dynamicNode:dd,syncInputs:Dc}}function T(ab,Ta,jb){var Wb=jb.usedNodes,xc=[];jb=Object.keys(jb.inputs).map(function(Dc){return d(Dc)[0]}).map(function(Dc){return ab.nodes[Dc]});var Ec=ab.initNodes;jb.forEach(function(Dc){Wb.has(Dc.name)&&xc.push(Dc)});ab.weights.forEach(function(Dc){Wb.has(Dc.name)&&xc.push(Dc)});null!=Ec&&Ec.forEach(function(Dc){Wb.has(Dc.name)&&xc.push(Dc)});var dd=new Set;for(jb=[];0<xc.length;)Ec=
xc.pop(),dd.add(Ec.name),Ta[Ec.name]||jb.push(Ec),Ec.children.forEach(function(Dc){!dd.has(Dc.name)&&Wb.has(Dc.name)&&Dc.inputs.every(function(kd){return dd.has(kd.name)})&&xc.push(Dc)});return jb}var aa=A(5).Buffer;"use strict";Object.defineProperty(v,"__esModule",{value:!0});var ba=A(948),Z=Object.assign||function(ab){for(var Ta,jb=1,Wb=arguments.length;jb<Wb;jb++){Ta=arguments[jb];for(var xc in Ta)Object.prototype.hasOwnProperty.call(Ta,xc)&&(ab[xc]=Ta[xc])}return ab},da;(function(ab){ab[ab.DT_INVALID=
0]="DT_INVALID";ab[ab.DT_FLOAT=1]="DT_FLOAT";ab[ab.DT_DOUBLE=2]="DT_DOUBLE";ab[ab.DT_INT32=3]="DT_INT32";ab[ab.DT_UINT8=4]="DT_UINT8";ab[ab.DT_INT16=5]="DT_INT16";ab[ab.DT_INT8=6]="DT_INT8";ab[ab.DT_STRING=7]="DT_STRING";ab[ab.DT_COMPLEX64=8]="DT_COMPLEX64";ab[ab.DT_INT64=9]="DT_INT64";ab[ab.DT_BOOL=10]="DT_BOOL";ab[ab.DT_QINT8=11]="DT_QINT8";ab[ab.DT_QUINT8=12]="DT_QUINT8";ab[ab.DT_QINT32=13]="DT_QINT32";ab[ab.DT_BFLOAT16=14]="DT_BFLOAT16";ab[ab.DT_FLOAT_REF=101]="DT_FLOAT_REF";ab[ab.DT_DOUBLE_REF=
102]="DT_DOUBLE_REF";ab[ab.DT_INT32_REF=103]="DT_INT32_REF";ab[ab.DT_UINT8_REF=104]="DT_UINT8_REF";ab[ab.DT_INT16_REF=105]="DT_INT16_REF";ab[ab.DT_INT8_REF=106]="DT_INT8_REF";ab[ab.DT_STRING_REF=107]="DT_STRING_REF";ab[ab.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF";ab[ab.DT_INT64_REF=109]="DT_INT64_REF";ab[ab.DT_BOOL_REF=110]="DT_BOOL_REF";ab[ab.DT_QINT8_REF=111]="DT_QINT8_REF";ab[ab.DT_QUINT8_REF=112]="DT_QUINT8_REF";ab[ab.DT_QINT32_REF=113]="DT_QINT32_REF";ab[ab.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"})(da||
(da={}));var pa;(function(ab){ab=ab.CheckpointFormatVersion||(ab.CheckpointFormatVersion={});ab[ab.LEGACY=0]="LEGACY";ab[ab.V1=1]="V1";ab[ab.V2=2]="V2"})(pa||(pa={}));var fa={},ta={__proto__:null,json:[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",
name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",
category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",
notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Minimum",
category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",
inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},ma={__proto__:null,json:[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",
category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,
name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"clip_value_min",name:"clipValueMin",type:"number"},{tfName:"clip_value_max",name:"clipValueMax",type:"number"}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,
name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],
attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",
category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",
inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",
category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"clipValueMin",name:"clipValueMin",type:"number",defaultValue:0},{tfName:"clipValueMax",name:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],
attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",
category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",
name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",
inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",
name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",
inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},ja={__proto__:null,json:[{tfOpName:"LoopCond",category:"control",inputs:[{start:0,
name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",
category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",
name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},
{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",
name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",
name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",
category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},
{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},
{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,
name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,
name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",
type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",
type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",
type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}]},qa={__proto__:null,json:[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},
{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",
category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",
name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},
{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",
inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},
{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",
type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1E-4}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",
name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",
type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",
name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},
{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},
{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]},Fa={__proto__:null,json:[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",
name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",
name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",
defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",
type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,
name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",
type:"dtype"}]}]},ua={__proto__:null,json:[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",
type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",
category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},
{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},Ra={__proto__:null,json:[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]},
Ia={__proto__:null,json:[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",
inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,
name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",
type:"number"},{tfName:"max",name:"max",type:"number"}]}]},oa={__proto__:null,json:[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",
name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,
name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",
type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]}]},Ba={__proto__:null,json:[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",
name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},
{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}]},gb={__proto__:null,json:[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",
name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",
type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",
type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",
inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},Va={__proto__:null,json:[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",
name:"epsilon",type:"number",defaultValue:1E-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},
{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",
name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},Ma={__proto__:null,json:[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},
{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],
attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",
type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",
inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}]},ib={__proto__:null,json:[{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",
type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},
{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,
name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",
name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]},Ja={__proto__:null,json:[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",
category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},
{start:1,name:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},
{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],
attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},
{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",
inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}]},Sa={__proto__:null,json:[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,
name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]},S={__proto__:null,json:[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",
name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",
type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],
attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,
name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}]},ha=function(){function ab(){this.opMappers=[].concat.apply([],f([ta,ma,ja,qa,Fa,ua,Ra,gb,Ba,Ia,Va,Ma,ib,Ja,Sa,S,oa].map(function(Ta){return Ta.json}))).reduce(function(Ta,jb){Ta[jb.tfOpName]=jb;return Ta},{})}Object.defineProperty(ab,
"Instance",{get:function(){return this._instance||(this._instance=new this)},enumerable:!0,configurable:!0});ab.prototype.transformGraph=function(Ta,jb){var Wb=this;void 0===jb&&(jb={});var xc=[],Ec=[],dd=[],Dc=Ta.node.reduce(function(Ac,Kc){Ac[Kc.name]=Wb.mapNode(Kc);Kc.op.startsWith("Placeholder")?xc.push(Ac[Kc.name]):"Const"===Kc.op?Ec.push(Ac[Kc.name]):(null==Kc.input||0===Kc.input.length)&&dd.push(Ac[Kc.name]);return Ac},{}),kd=[],ld=[],Nb={},Sb={};null!=jb&&(Nb=this.mapSignatureEntries(jb.inputs),
Sb=this.mapSignatureEntries(jb.outputs));var Tb=Object.keys(Dc);Tb.forEach(function(Ac){var Kc=Dc[Ac];Kc.inputNames.forEach(function(Vc){Vc=u(e(Vc),1)[0];Kc.inputs.push(Dc[Vc]);Dc[Vc].children.push(Kc)})});0===Object.keys(Sb).length?Tb.forEach(function(Ac){Ac=Dc[Ac];0===Ac.children.length&&ld.push(Ac)}):Object.keys(Sb).forEach(function(Ac){var Kc=u(e(Ac),1)[0];Kc=Dc[Kc];null!=Kc&&(Kc.signatureKey=Sb[Ac],ld.push(Kc))});0<Object.keys(Nb).length?Object.keys(Nb).forEach(function(Ac){var Kc=u(e(Ac),1)[0];
if(Kc=Dc[Kc])Kc.signatureKey=Nb[Ac],kd.push(Kc)}):kd=xc;Tb={};null!=Ta.library&&null!=Ta.library.function&&(Tb=Ta.library.function.reduce(function(Ac,Kc){Ac[Kc.signature.name]=Wb.mapFunction(Kc);return Ac},{}));Ta={nodes:Dc,inputs:kd,outputs:ld,weights:Ec,placeholders:xc,signature:jb,functions:Tb};0<dd.length&&(Ta.initNodes=dd);return Ta};ab.prototype.mapSignatureEntries=function(Ta){return Object.keys(Ta||{}).reduce(function(jb,Wb){jb[Ta[Wb].name]=Wb;return jb},{})};ab.prototype.mapNode=function(Ta){var jb=
fa[Ta.op]||this.opMappers[Ta.op]||{};null==Ta.attr&&(Ta.attr={});var Wb={name:Ta.name,op:Ta.op,category:jb.category,inputNames:(Ta.input||[]).map(function(xc){return xc.startsWith("^")?xc.substr(1):xc}),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:Ta.attr};null!=jb.inputs&&(Wb.inputParams=jb.inputs.reduce(function(xc,Ec){xc[Ec.name]={type:Ec.type,inputIndexStart:Ec.start,inputIndexEnd:Ec.end};return xc},{}));null!=jb.attrs&&(Wb.attrParams=jb.attrs.reduce(function(xc,Ec){var dd=Ec.type,
Dc=void 0;switch(Ec.type){case "string":Dc=m(Ta.attr,Ec.tfName,Ec.defaultValue);void 0===Dc&&Ec.tfDeprecatedName&&(Dc=m(Ta.attr,Ec.tfDeprecatedName,Ec.defaultValue));break;case "string[]":Dc=J(Ta.attr,Ec.tfName,Ec.defaultValue);void 0===Dc&&Ec.tfDeprecatedName&&(Dc=J(Ta.attr,Ec.tfDeprecatedName,Ec.defaultValue));break;case "number":Dc=k(Ta.attr,Ec.tfName,Ec.defaultValue||0);void 0===Dc&&Ec.tfDeprecatedName&&(Dc=k(Ta.attr,Ec.tfDeprecatedName,Ec.defaultValue));break;case "number[]":Dc=K(Ta.attr,Ec.tfName,
Ec.defaultValue);void 0===Dc&&Ec.tfDeprecatedName&&(Dc=K(Ta.attr,Ec.tfDeprecatedName,Ec.defaultValue));break;case "bool":Dc=n(Ta.attr,Ec.tfName,Ec.defaultValue);void 0===Dc&&Ec.tfDeprecatedName&&(Dc=n(Ta.attr,Ec.tfDeprecatedName,Ec.defaultValue));break;case "bool[]":Dc=O(Ta.attr,Ec.tfName,Ec.defaultValue);void 0===Dc&&Ec.tfDeprecatedName&&(Dc=O(Ta.attr,Ec.tfDeprecatedName,Ec.defaultValue));break;case "shape":Dc=z(Ta.attr,Ec.tfName,Ec.defaultValue);void 0===Dc&&Ec.tfDeprecatedName&&(Dc=z(Ta.attr,Ec.tfDeprecatedName,
Ec.defaultValue));break;case "shape[]":Dc=B(Ta.attr,Ec.tfName,Ec.defaultValue);void 0===Dc&&Ec.tfDeprecatedName&&(Dc=B(Ta.attr,Ec.tfDeprecatedName,Ec.defaultValue));break;case "dtype":Dc=w(Ta.attr,Ec.tfName,Ec.defaultValue);void 0===Dc&&Ec.tfDeprecatedName&&(Dc=w(Ta.attr,Ec.tfDeprecatedName,Ec.defaultValue));break;case "dtype[]":Dc=y(Ta.attr,Ec.tfName,Ec.defaultValue);void 0===Dc&&Ec.tfDeprecatedName&&(Dc=y(Ta.attr,Ec.tfDeprecatedName,Ec.defaultValue));break;case "func":Dc=q(Ta.attr,Ec.tfName,Ec.defaultValue);
void 0===Dc&&Ec.tfDeprecatedName&&(Dc=q(Ta.attr,Ec.tfDeprecatedName,Ec.defaultValue));break;case "tensor":case "tensors":break;default:throw Error("Unsupported param type: "+Ec.type+" for op: "+Ta.op);}xc[Ec.name]={value:Dc,type:dd};return xc},{}));return Wb};ab.prototype.mapFunction=function(Ta){var jb=this,Wb=Ta.nodeDef,xc=[],Ec={};null!=Wb&&(Ec=Wb.reduce(function(ld,Nb){ld[Nb.name]=jb.mapNode(Nb);"Const"===Nb.op&&xc.push(ld[Nb.name]);return ld},{}));var dd=[],Dc=[];Ta.signature.inputArg.forEach(function(ld){var Nb=
u(e(ld.name),1)[0],Sb={name:Nb,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:p(ld.type),type:"dtype"}},children:[]};Sb.signatureKey=ld.name;dd.push(Sb);Ec[Nb]=Sb});Object.keys(Ec).forEach(function(ld){var Nb=Ec[ld];Nb.inputNames.forEach(function(Sb){Sb=u(e(Sb),1)[0];Nb.inputs.push(Ec[Sb]);Ec[Sb].children.push(Nb)})});var kd=Ta.ret;Ta.signature.outputArg.forEach(function(ld){var Nb=u(e(kd[ld.name]),2);ld=Nb[1];Nb=Ec[Nb[0]];null!=Nb&&(Nb.defaultOutput=
ld,Dc.push(Nb))});Ta=this.mapArgsToSignature(Ta);return{nodes:Ec,inputs:dd,outputs:Dc,weights:xc,placeholders:[],signature:Ta}};ab.prototype.mapArgsToSignature=function(Ta){var jb=this;return{methodName:Ta.signature.name,inputs:Ta.signature.inputArg.reduce(function(Wb,xc){Wb[xc.name]=jb.mapArgToTensorInfo(xc);return Wb},{}),outputs:Ta.signature.outputArg.reduce(function(Wb,xc){Wb[xc.name]=jb.mapArgToTensorInfo(xc,Ta.ret);return Wb},{})}};ab.prototype.mapArgToTensorInfo=function(Ta,jb){var Wb=Ta.name;
null!=jb&&(Wb=jb[Wb]);return{name:Wb,dtype:Ta.type}};return ab}(),ya=function(){function ab(Ta,jb,Wb){var xc=this;this.node=Ta;this.tensorMap=jb;this.context=Wb;this.inputs=[];this.attrs={};this.inputs=Ta.inputNames.map(function(Ec){return xc.getInput(Ec)});null!=Ta.rawAttrs&&(this.attrs=Object.keys(Ta.rawAttrs).reduce(function(Ec,dd){Ec[dd]=xc.getAttr(dd);return Ec},{}))}ab.prototype.getInput=function(Ta){return b(Ta,this.tensorMap,this.context)};ab.prototype.getAttr=function(Ta,jb){var Wb=this.node.rawAttrs[Ta];
if(null!=Wb.tensor)return b(Ta,this.tensorMap,this.context);if(null!=Wb.i||null!=Wb.f)return k(this.node.rawAttrs,Ta,jb);if(null!=Wb.s)return m(this.node.rawAttrs,Ta,jb);if(null!=Wb.b)return n(this.node.rawAttrs,Ta,jb);if(null!=Wb.shape)return z(this.node.rawAttrs,Ta,jb);if(null!=Wb.type)return w(this.node.rawAttrs,Ta,jb);if(null!=Wb.list){if(null!=Wb.list.i||null!=Wb.list.f)return K(this.node.rawAttrs,Ta,jb);if(null!=Wb.list.s)return J(this.node.rawAttrs,Ta,jb);if(null!=Wb.list.shape)return B(this.node.rawAttrs,
Ta,jb);if(null!=Wb.list.b)return O(this.node.rawAttrs,Ta,jb);if(null!=Wb.list.type)return y(this.node.rawAttrs,Ta,jb)}return jb};return ab}(),Qa=function(ab,Ta,jb){switch(ab.op){case "BiasAdd":case "AddV2":case "Add":return[ba.add(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "AddN":return[ba.addN(a("tensors",ab,Ta,jb))];case "FloorMod":case "Mod":return[ba.mod(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "Mul":return[ba.mul(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "RealDiv":case "Div":return[ba.div(a("a",ab,Ta,
jb),a("b",ab,Ta,jb))];case "DivNoNan":return[ba.divNoNan(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "FloorDiv":return[ba.floorDiv(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "Sub":return[ba.sub(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "Minimum":return[ba.minimum(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "Maximum":return[ba.maximum(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "Pow":return[ba.pow(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "SquaredDifference":return[ba.squaredDifference(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];default:throw TypeError("Node type "+
ab.op+" is not implemented");}},$a=function(ab,Ta,jb){switch(ab.op){case "Abs":case "ComplexAbs":return[ba.abs(a("x",ab,Ta,jb))];case "Acos":return[ba.acos(a("x",ab,Ta,jb))];case "Acosh":return[ba.acosh(a("x",ab,Ta,jb))];case "Asin":return[ba.asin(a("x",ab,Ta,jb))];case "Asinh":return[ba.asinh(a("x",ab,Ta,jb))];case "Atan":return[ba.atan(a("x",ab,Ta,jb))];case "Atan2":return[ba.atan2(a("x",ab,Ta,jb),a("y",ab,Ta,jb))];case "Atanh":return[ba.atanh(a("x",ab,Ta,jb))];case "Ceil":return[ba.ceil(a("x",
ab,Ta,jb))];case "Complex":return[ba.complex(a("real",ab,Ta,jb),a("imag",ab,Ta,jb))];case "Cos":return[ba.cos(a("x",ab,Ta,jb))];case "Cosh":return[ba.cosh(a("x",ab,Ta,jb))];case "Elu":return[ba.elu(a("x",ab,Ta,jb))];case "Erf":return[ba.erf(a("x",ab,Ta,jb))];case "Exp":return[ba.exp(a("x",ab,Ta,jb))];case "Expm1":return[ba.expm1(a("x",ab,Ta,jb))];case "Floor":return[ba.floor(a("x",ab,Ta,jb))];case "Log":return[ba.log(a("x",ab,Ta,jb))];case "Log1p":return[ba.log1p(a("x",ab,Ta,jb))];case "Imag":return[ba.imag(a("x",
ab,Ta,jb))];case "Neg":return[ba.neg(a("x",ab,Ta,jb))];case "Reciprocal":return[ba.reciprocal(a("x",ab,Ta,jb))];case "Real":return[ba.real(a("x",ab,Ta,jb))];case "Relu":return[ba.relu(a("x",ab,Ta,jb))];case "Round":return[ba.round(a("x",ab,Ta,jb))];case "Selu":return[ba.selu(a("x",ab,Ta,jb))];case "Sigmoid":return[ba.sigmoid(a("x",ab,Ta,jb))];case "Sin":return[ba.sin(a("x",ab,Ta,jb))];case "Sign":return[ba.sign(a("x",ab,Ta,jb))];case "Sinh":return[ba.sinh(a("x",ab,Ta,jb))];case "Softplus":return[ba.softplus(a("x",
ab,Ta,jb))];case "Sqrt":return[ba.sqrt(a("x",ab,Ta,jb))];case "Square":return[ba.square(a("x",ab,Ta,jb))];case "Tanh":return[ba.tanh(a("x",ab,Ta,jb))];case "Tan":return[ba.tan(a("x",ab,Ta,jb))];case "Relu6":case "ClipByValue":return[ba.clipByValue(a("x",ab,Ta,jb),a("clipValueMin",ab,Ta,jb),a("clipValueMax",ab,Ta,jb))];case "Rsqrt":return[ba.rsqrt(b(ab.inputNames[0],Ta,jb))];case "Prod":return[ba.prod(a("x",ab,Ta,jb),a("axes",ab,Ta,jb))];case "LeakyRelu":return[ba.leakyRelu(a("x",ab,Ta,jb),a("alpha",
ab,Ta,jb))];case "Prelu":return[ba.prelu(a("x",ab,Ta,jb),a("alpha",ab,Ta,jb))];default:throw TypeError("Node type "+ab.op+" is not implemented");}},cb=function(){function ab(Ta,jb,Wb,xc,Ec,dd,Dc){this.name=Ta;this.dtype=jb;this.maxSize=Wb;this.elementShape=xc;this.identicalElementShapes=Ec;this.dynamicSize=dd;this.clearAfterRead=Dc;this.tensors=[];this.closed_=!1;this.idTensor=ba.scalar(0);ba.keep(this.idTensor)}Object.defineProperty(ab.prototype,"id",{get:function(){return this.idTensor.id},enumerable:!0,
configurable:!0});Object.defineProperty(ab.prototype,"closed",{get:function(){return this.closed_},enumerable:!0,configurable:!0});ab.prototype.clearAndClose=function(Ta){this.tensors.forEach(function(jb){null!=Ta&&Ta.has(jb.tensor.id)||jb.tensor.dispose()});this.tensors=[];this.closed_=!0;this.idTensor.dispose()};ab.prototype.size=function(){return this.tensors.length};ab.prototype.read=function(Ta){if(this.closed_)throw Error("TensorArray "+this.name+" has already been closed.");if(0>Ta||Ta>=this.size())throw Error("Tried to read from index "+
Ta+", but array size is: "+this.size());var jb=this.tensors[Ta];if(jb.cleared)throw Error("TensorArray "+this.name+": Could not read index "+Ta+" twice because it was cleared after a previous read (perhaps try setting clear_after_read \x3d false?).");this.clearAfterRead&&(jb.cleared=!0);jb.read=!0;return jb.tensor};ab.prototype.readMany=function(Ta){var jb=this;return Ta.map(function(Wb){return jb.read(Wb)})};ab.prototype.write=function(Ta,jb){if(this.closed_)throw Error("TensorArray "+this.name+
" has already been closed.");if(0>Ta||!this.dynamicSize&&Ta>=this.maxSize)throw Error("Tried to write to index "+Ta+", but array is not resizeable and size is: "+this.maxSize);var Wb=this.tensors[Ta]||{};if(jb.dtype!==this.dtype)throw Error("TensorArray "+this.name+": Could not write to TensorArray index "+Ta+",\n          because the value dtype is "+jb.dtype+", but TensorArray dtype is "+this.dtype+".");0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=jb.shape);
Q(this.elementShape,jb.shape,"TensorArray "+this.name+": Could not write to TensorArray index "+Ta+".");if(Wb.read)throw Error("TensorArray "+this.name+": Could not write to TensorArray index "+Ta+", because it has already been read.");if(Wb.written)throw Error("TensorArray "+this.name+": Could not write to TensorArray index "+Ta+", because it has already been written.");Wb.tensor=jb;ba.keep(jb);Wb.written=!0;this.tensors[Ta]=Wb};ab.prototype.writeMany=function(Ta,jb){var Wb=this;if(Ta.length!==jb.length)throw Error("TensorArray "+
this.name+": could not write multiple tensors,because the index size: "+(Ta.length+" is not the same as tensors size: "+jb.length+"."));Ta.forEach(function(xc,Ec){return Wb.write(xc,jb[Ec])})};ab.prototype.gather=function(Ta,jb){if(jb&&jb!==this.dtype)throw Error("TensorArray dtype is "+this.dtype+" but gather requested dtype "+jb);if(Ta)Ta=Ta.slice(0,this.size());else for(Ta=[],jb=0;jb<this.size();jb++)Ta.push(jb);if(0===Ta.length)return ba.tensor([],[0].concat(this.elementShape));Ta=this.readMany(Ta);
Q(this.elementShape,Ta[0].shape,"TensorArray shape mismatch: ");return ba.stack(Ta,0)};ab.prototype.concat=function(Ta){if(Ta&&Ta!==this.dtype)throw Error("TensorArray dtype is "+this.dtype+" but concat requested dtype "+Ta);if(0===this.size())return ba.tensor([],[0].concat(this.elementShape));Ta=[];for(var jb=0;jb<this.size();jb++)Ta.push(jb);Ta=this.readMany(Ta);Q(this.elementShape,Ta[0].shape,"TensorArray shape mismatch: tensor array shape ("+this.elementShape+") vs first tensor shape ("+Ta[0].shape+
")");return ba.concat(Ta,0)};ab.prototype.scatter=function(Ta,jb){if(jb.dtype!==this.dtype)throw Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+jb.dtype);if(Ta.length!==jb.shape[0])throw Error("Expected len(indices) \x3d\x3d tensor.shape[0], but saw: "+Ta.length+" vs. "+jb.shape[0]);var Wb=Math.max.apply(Math,f(Ta));if(!this.dynamicSize&&Wb>=this.maxSize)throw Error("Max index must be \x3c array size ("+Wb+"  vs. "+this.maxSize+")");this.writeMany(Ta,ba.unstack(jb,0))};ab.prototype.split=
function(Ta,jb){var Wb=this;if(jb.dtype!==this.dtype)throw Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+jb.dtype);var xc=0,Ec=Ta.map(function(Nb){return xc+=Nb});if(xc!==jb.shape[0])throw Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        "+xc+", and tensor's shape is: "+jb.shape);if(!this.dynamicSize&&Ta.length!==this.maxSize)throw Error("TensorArray's size is not equal to the size of lengths ("+this.maxSize+" vs. "+Ta.length+
"), and the TensorArray is not marked as dynamically resizeable");var dd=0===xc?0:jb.size/xc,Dc=[];ba.tidy(function(){jb=ba.reshape(jb,[1,xc,dd]);for(var Nb=0;Nb<Ta.length;++Nb)Dc[Nb]=ba.reshape(ba.slice(jb,[0,0===Nb?0:Ec[Nb-1],0],[1,Ta[Nb],dd]),Wb.elementShape);return Dc});for(var kd=[],ld=0;ld<Ta.length;ld++)kd[ld]=ld;this.writeMany(kd,Dc)};return ab}(),wa=function(){function ab(Ta,jb,Wb,xc){void 0===xc&&(xc=-1);this.tensors=Ta;this.elementShape=jb;this.elementDtype=Wb;null!=Ta&&Ta.forEach(function(Ec){if(Wb!==
Ec.dtype)throw Error("Invalid data types; op elements "+Wb+", but list elements "+Ec.dtype);Q(jb,Ec.shape,"TensorList shape mismatch: ");ba.keep(Ec)});this.idTensor=ba.scalar(0);this.maxNumElements=xc;ba.keep(this.idTensor)}Object.defineProperty(ab.prototype,"id",{get:function(){return this.idTensor.id},enumerable:!0,configurable:!0});ab.prototype.copy=function(){return new ab(f(this.tensors),this.elementShape,this.elementDtype)};ab.prototype.clearAndClose=function(Ta){this.tensors.forEach(function(jb){null!=
Ta&&Ta.has(jb.id)||jb.dispose()});this.tensors.length=0;this.idTensor.dispose()};ab.prototype.size=function(){return this.tensors.length};ab.prototype.stack=function(Ta,jb,Wb){var xc=this;void 0===Wb&&(Wb=-1);if(jb!==this.elementDtype)throw Error("Invalid data types; op elements "+jb+", but list elements "+this.elementDtype);if(-1!==Wb&&this.tensors.length!==Wb)throw Error("Operation expected a list with "+Wb+" elements but got a list with "+this.tensors.length+" elements.");Q(Ta,this.elementShape,
"TensorList shape mismatch: ");return ba.tidy(function(){var Ec=xc.tensors.map(function(dd){return ba.reshape(dd,Ta)});return ba.stack(Ec,0)})};ab.prototype.popBack=function(Ta,jb){if(jb!==this.elementDtype)throw Error("Invalid data types; op elements "+jb+", but list elements "+this.elementDtype);if(0===this.size())throw Error("Trying to pop from an empty list.");jb=this.tensors.pop();Q(jb.shape,Ta,"TensorList shape mismatch: ");return ba.reshape(jb,Ta)};ab.prototype.pushBack=function(Ta){if(Ta.dtype!==
this.elementDtype)throw Error("Invalid data types; op elements "+Ta.dtype+", but list elements "+this.elementDtype);Q(Ta.shape,this.elementShape,"TensorList shape mismatch: ");if(this.maxNumElements===this.size())throw Error("Trying to push element into a full list.");ba.keep(Ta);this.tensors.push(Ta)};ab.prototype.resize=function(Ta){if(0>Ta)throw Error("TensorListResize expects size to be non-negative. Got: "+Ta);if(-1!==this.maxNumElements&&Ta>this.maxNumElements)throw Error("TensorListResize input size "+
Ta+" is greater maxNumElement "+this.maxNumElements+".");this.tensors.length=Ta};ab.prototype.getItem=function(Ta,jb,Wb){if(Wb!==this.elementDtype)throw Error("Invalid data types; op elements "+Wb+", but list elements "+this.elementDtype);if(0>Ta||Ta>this.tensors.length)throw Error("Trying to access element "+Ta+" in a list with "+this.tensors.length+" elements.");if(null==this.tensors[Ta])throw Error("element at index "+Ta+" is null.");Q(this.tensors[Ta].shape,jb,"TensorList shape mismatch: ");return this.tensors[Ta]};
ab.prototype.setItem=function(Ta,jb){if(jb.dtype!==this.elementDtype)throw Error("Invalid data types; op elements "+jb.dtype+", but list elements "+this.elementDtype);if(0>Ta||-1!==this.maxNumElements&&Ta>=this.maxNumElements)throw Error("Trying to set element "+Ta+" in a list with max "+this.maxNumElements+" elements.");Q(this.elementShape,jb.shape,"TensorList shape mismatch: ");ba.keep(jb);this.tensors[Ta]=jb};ab.prototype.gather=function(Ta,jb,Wb){var xc=this;if(jb!==this.elementDtype)throw Error("Invalid data types; op elements "+
jb+", but list elements "+this.elementDtype);Q(this.elementShape,Wb,"TensorList shape mismatch: ");Ta=Ta.slice(0,this.size());return 0===Ta.length?ba.tensor([],[0].concat(this.elementShape)):ba.tidy(function(){var Ec=Ta.map(function(dd){return ba.reshape(xc.tensors[dd],Wb)});return ba.stack(Ec,0)})};ab.prototype.concat=function(Ta,jb){var Wb=this;if(Ta&&Ta!==this.elementDtype)throw Error("TensorList dtype is "+this.elementDtype+" but concat requested dtype "+Ta);Q(this.elementShape,jb,"TensorList shape mismatch: ");
return 0===this.size()?ba.tensor([],[0].concat(this.elementShape)):ba.tidy(function(){var xc=Wb.tensors.map(function(Ec){return ba.reshape(Ec,jb)});return ba.concat(xc,0)})};return ab}(),Aa=function(ab,Ta,jb){return t(void 0,void 0,void 0,function(){var Wb,xc,Ec,dd,Dc,kd,ld,Nb,Sb,Tb,Ac,Kc,Vc,Pc,gd,Dd,Jd,we,Ne,Je,Qe,Ce,Oe,od,Ud,Rd,pc,Ue,lc,pe,rc,qc,Ib,Ga,hb,Rb,mc,Ub,ic,jc,Ob,fc,yc,fd,Ad,Gd,Ge,Re,mf,Ze,Jb,wb,Lb,oc,Lc,ed;return r(this,function(ge){switch(ge.label){case 0:Wb=ab.op;switch(Wb){case "If":return[3,
1];case "StatelessIf":return[3,1];case "While":return[3,3];case "StatelessWhile":return[3,3];case "LoopCond":return[3,9];case "Switch":return[3,10];case "Merge":return[3,12];case "Enter":return[3,13];case "Exit":return[3,14];case "NextIteration":return[3,15];case "TensorArrayV3":return[3,16];case "TensorArrayWriteV3":return[3,17];case "TensorArrayReadV3":return[3,18];case "TensorArrayGatherV3":return[3,19];case "TensorArrayScatterV3":return[3,20];case "TensorArrayConcatV3":return[3,21];case "TensorArraySplitV3":return[3,
22];case "TensorArraySizeV3":return[3,23];case "TensorArrayCloseV3":return[3,24];case "TensorListSetItem":return[3,25];case "TensorListGetItem":return[3,26];case "TensorListScatterV2":return[3,27];case "TensorListScatter":return[3,27];case "TensorListReserve":return[3,28];case "TensorListGather":return[3,29];case "TensorListStack":return[3,30];case "TensorListFromTensor":return[3,31];case "TensorListConcat":return[3,32];case "TensorListPushBack":return[3,33];case "TensorListPopBack":return[3,34];
case "TensorListSplit":return[3,35]}return[3,36];case 1:return xc=a("thenBranch",ab,Ta,jb),Ec=a("elseBranch",ab,Ta,jb),dd=a("cond",ab,Ta,jb),Dc=a("args",ab,Ta,jb),[4,dd.data()];case 2:return kd=ge.sent(),kd[0]?[2,jb.functionMap[xc].executeFunctionAsync(Dc,jb.tensorArrayMap,jb.tensorListMap)]:[2,jb.functionMap[Ec].executeFunctionAsync(Dc,jb.tensorArrayMap,jb.tensorListMap)];case 3:return ld=a("body",ab,Ta,jb),Nb=a("cond",ab,Ta,jb),Dc=a("args",ab,Ta,jb),[4,jb.functionMap[Nb].executeFunctionAsync(Dc,
jb.tensorArrayMap,jb.tensorListMap)];case 4:return Sb=ge.sent(),Tb=Dc.map(function(he){return he.id}),[4,Sb[0].data()];case 5:kd=ge.sent(),Sb.forEach(function(he){he.kept||-1!==Tb.indexOf(he.id)||he.dispose()}),Ac=Dc,Kc=function(){var he,bf,cf;return r(this,function(qe){switch(qe.label){case 0:return he=Ac,[4,jb.functionMap[ld].executeFunctionAsync(Ac,jb.tensorArrayMap,jb.tensorListMap)];case 1:return Ac=qe.sent(),bf=Ac.map(function(ie){return ie.id}),he.forEach(function(ie){ie.kept||-1!==Tb.indexOf(ie.id)||
-1!==bf.indexOf(ie.id)||ie.dispose()}),[4,jb.functionMap[Nb].executeFunctionAsync(Ac,jb.tensorArrayMap,jb.tensorListMap)];case 2:return cf=qe.sent(),[4,cf[0].data()];case 3:return kd=qe.sent(),cf.forEach(function(ie){ie.kept||-1!==Tb.indexOf(ie.id)||-1!==bf.indexOf(ie.id)||ie.dispose()}),[2]}})},ge.label=6;case 6:return kd[0]?[5,Kc()]:[3,8];case 7:return ge.sent(),[3,6];case 8:return[2,Ac];case 9:return Vc=a("pred",ab,Ta,jb),[2,[c(Vc)]];case 10:return Vc=a("pred",ab,Ta,jb),Pc=a("data",ab,Ta,jb),Pc.kept||
(Pc=c(Pc)),[4,Vc.data()];case 11:return[2,ge.sent()[0]?[void 0,Pc]:[Pc,void 0]];case 12:return(gd=ab.inputNames.find(function(he){return void 0!==b(he,Ta,jb)}))?(Pc=b(gd,Ta,jb),[2,[c(Pc)]]):[2,void 0];case 13:return Dd=a("frameName",ab,Ta,jb),Pc=a("tensor",ab,Ta,jb),jb.enterFrame(Dd),[2,[c(Pc)]];case 14:return Pc=a("tensor",ab,Ta,jb),jb.exitFrame(),[2,[c(Pc)]];case 15:return Pc=a("tensor",ab,Ta,jb),jb.nextIteration(),[2,[c(Pc)]];case 16:return Jd=a("size",ab,Ta,jb),we=a("dtype",ab,Ta,jb),Ne=a("elementShape",
ab,Ta,jb),Je=a("dynamicSize",ab,Ta,jb),Qe=a("clearAfterRead",ab,Ta,jb),Ce=a("identicalElementShapes",ab,Ta,jb),Oe=a("name",ab,Ta,jb),od=new cb(Oe,we,Jd,Ne,Ce,Je,Qe),jb.addTensorArray(od),[2,[od.idTensor,ba.scalar(1)]];case 17:return Ud=a("tensorArrayId",ab,Ta,jb),Rd=a("index",ab,Ta,jb),pc=a("tensor",ab,Ta,jb),Ue=jb.getTensorArray(Ud.id),Ue.write(Rd,pc),[2,[Ue.idTensor]];case 18:return lc=a("tensorArrayId",ab,Ta,jb),pe=a("index",ab,Ta,jb),rc=jb.getTensorArray(lc.id),[2,[rc.read(pe)]];case 19:return qc=
a("tensorArrayId",ab,Ta,jb),Ib=a("indices",ab,Ta,jb),Ga=a("dtype",ab,Ta,jb),hb=jb.getTensorArray(qc.id),[2,[hb.gather(Ib,Ga)]];case 20:return Rb=a("tensorArrayId",ab,Ta,jb),mc=a("indices",ab,Ta,jb),Ub=a("tensor",ab,Ta,jb),ic=jb.getTensorArray(Rb.id),ic.scatter(mc,Ub),[2,[ic.idTensor]];case 21:return jc=a("tensorArrayId",ab,Ta,jb),Ob=jb.getTensorArray(jc.id),fc=a("dtype",ab,Ta,jb),[2,[Ob.concat(fc)]];case 22:return yc=a("tensorArrayId",ab,Ta,jb),fd=a("tensor",ab,Ta,jb),Ad=a("lengths",ab,Ta,jb),Gd=
jb.getTensorArray(yc.id),Gd.split(Ad,fd),[2,[Gd.idTensor]];case 23:return Ge=a("tensorArrayId",ab,Ta,jb),Re=jb.getTensorArray(Ge.id),[2,[ba.scalar(Re.size(),"int32")]];case 24:return mf=a("tensorArrayId",ab,Ta,jb),Ze=jb.getTensorArray(mf.id),Ze.clearAndClose(),[2,[Ze.idTensor]];case 25:return Jb=a("tensorListId",ab,Ta,jb),Rd=a("index",ab,Ta,jb),pc=a("tensor",ab,Ta,jb),wb=jb.getTensorList(Jb.id),wb.setItem(Rd,pc),[2,[wb.idTensor]];case 26:return Jb=a("tensorListId",ab,Ta,jb),pe=a("index",ab,Ta,jb),
Ne=a("elementShape",ab,Ta,jb),Lb=a("elementDType",ab,Ta,jb),wb=jb.getTensorList(Jb.id),[2,[wb.getItem(pe,Ne,Lb)]];case 27:return mc=a("indices",ab,Ta,jb),Ub=a("tensor",ab,Ta,jb),Ne=a("elementShape",ab,Ta,jb),oc=a("numElements",ab,Ta,jb),wb=F(Ub,mc,Ne,oc),jb.addTensorList(wb),[2,[wb.idTensor]];case 28:return Ne=a("elementShape",ab,Ta,jb),Lc=a("elementDType",ab,Ta,jb),oc=a("numElements",ab,Ta,jb),wb=new wa([],Ne,Lc,oc),jb.addTensorList(wb),[2,[wb.idTensor]];case 29:return qc=a("tensorListId",ab,Ta,
jb),Ib=a("indices",ab,Ta,jb),Ne=a("elementShape",ab,Ta,jb),Lc=a("elementDType",ab,Ta,jb),wb=jb.getTensorList(qc.id),[2,[wb.gather(Ib,Lc,Ne)]];case 30:return Jb=a("tensorListId",ab,Ta,jb),Ne=a("elementShape",ab,Ta,jb),Lc=a("elementDType",ab,Ta,jb),oc=a("numElements",ab,Ta,jb),wb=jb.getTensorList(Jb.id),[2,[wb.stack(Ne,Lc,oc)]];case 31:return ed=a("tensor",ab,Ta,jb),Ne=a("elementShape",ab,Ta,jb),Lc=a("elementDType",ab,Ta,jb),wb=M(ed,Ne,Lc),jb.addTensorList(wb),[2,[wb.idTensor]];case 32:return jc=a("tensorListId",
ab,Ta,jb),wb=jb.getTensorList(jc.id),fc=a("dtype",ab,Ta,jb),Ne=a("elementShape",ab,Ta,jb),[2,[wb.concat(fc,Ne)]];case 33:return Jb=a("tensorListId",ab,Ta,jb),pc=a("tensor",ab,Ta,jb),wb=jb.getTensorList(Jb.id),wb.pushBack(pc),[2,[wb.idTensor]];case 34:return Jb=a("tensorListId",ab,Ta,jb),Ne=a("elementShape",ab,Ta,jb),Lb=a("elementDType",ab,Ta,jb),wb=jb.getTensorList(Jb.id),[2,[wb.popBack(Ne,Lb)]];case 35:return fd=a("tensor",ab,Ta,jb),Ne=a("elementShape",ab,Ta,jb),Ad=a("lengths",ab,Ta,jb),wb=D(fd,
Ad,Ne),jb.addTensorList(wb),[2,[wb.idTensor]];case 36:throw TypeError("Node type "+ab.op+" is not implemented");}})})},lb=function(ab,Ta,jb){switch(ab.op){case "Conv1D":var Wb=a("stride",ab,Ta,jb),xc=a("pad",ab,Ta,jb),Ec=a("dataFormat",ab,Ta,jb).toUpperCase(),dd=a("dilation",ab,Ta,jb);return[ba.conv1d(a("x",ab,Ta,jb),a("filter",ab,Ta,jb),Wb,xc,Ec,dd)];case "Conv2D":return Wb=a("strides",ab,Ta,jb),xc=h(ab,Ta,jb),Ec=a("dataFormat",ab,Ta,jb).toUpperCase(),dd=a("dilations",ab,Ta,jb),[ba.conv2d(a("x",
ab,Ta,jb),a("filter",ab,Ta,jb),[Wb[1],Wb[2]],xc,Ec,[dd[1],dd[2]])];case "_FusedConv2D":var Dc=H(ab,Ta,jb);Wb=Dc.stride;xc=Dc.pad;Ec=Dc.dataFormat;dd=Dc.dilations;var kd=Dc.biasArg,ld=Dc.preluArg;Dc=Dc.activationFunc;return[ba.fused.conv2d({x:a("x",ab,Ta,jb),filter:a("filter",ab,Ta,jb),strides:[Wb[1],Wb[2]],pad:xc,dataFormat:Ec,dilations:[dd[1],dd[2]],bias:kd,activation:Dc,preluActivationWeights:ld})];case "FusedDepthwiseConv2dNative":return Dc=H(ab,Ta,jb),Wb=Dc.stride,xc=Dc.pad,Ec=Dc.dataFormat,dd=
Dc.dilations,kd=Dc.biasArg,ld=Dc.preluArg,Dc=Dc.activationFunc,[ba.fused.depthwiseConv2d({x:a("x",ab,Ta,jb),filter:a("filter",ab,Ta,jb),strides:[Wb[1],Wb[2]],pad:xc,dataFormat:Ec,dilations:[dd[1],dd[2]],bias:kd,activation:Dc,preluActivationWeights:ld})];case "Conv2DBackpropInput":case "Conv2dTranspose":return dd=a("outputShape",ab,Ta,jb),Wb=a("strides",ab,Ta,jb),xc=h(ab,Ta,jb),[ba.conv2dTranspose(a("x",ab,Ta,jb),a("filter",ab,Ta,jb),dd,[Wb[1],Wb[2]],xc)];case "DepthwiseConv2dNative":case "DepthwiseConv2d":return Wb=
a("strides",ab,Ta,jb),xc=h(ab,Ta,jb),dd=a("dilations",ab,Ta,jb),Ec=a("dataFormat",ab,Ta,jb).toUpperCase(),[ba.depthwiseConv2d(a("input",ab,Ta,jb),a("filter",ab,Ta,jb),[Wb[1],Wb[2]],xc,Ec,[dd[1],dd[2]])];case "Conv3D":return Wb=a("strides",ab,Ta,jb),xc=a("pad",ab,Ta,jb),Ec=a("dataFormat",ab,Ta,jb).toUpperCase(),dd=a("dilations",ab,Ta,jb),[ba.conv3d(a("x",ab,Ta,jb),a("filter",ab,Ta,jb),[Wb[1],Wb[2],Wb[3]],xc,Ec,[dd[1],dd[2],dd[3]])];case "AvgPool":return Wb=a("strides",ab,Ta,jb),xc=a("pad",ab,Ta,jb),
dd=a("kernelSize",ab,Ta,jb),[ba.avgPool(a("x",ab,Ta,jb),[dd[1],dd[2]],[Wb[1],Wb[2]],xc)];case "MaxPool":return Wb=a("strides",ab,Ta,jb),xc=a("pad",ab,Ta,jb),dd=a("kernelSize",ab,Ta,jb),[ba.maxPool(a("x",ab,Ta,jb),[dd[1],dd[2]],[Wb[1],Wb[2]],xc)];case "MaxPoolWithArgmax":return Wb=a("strides",ab,Ta,jb),xc=a("pad",ab,Ta,jb),dd=a("kernelSize",ab,Ta,jb),Ec=a("includeBatchInIndex",ab,Ta,jb),ab=ba.maxPoolWithArgmax(a("x",ab,Ta,jb),[dd[1],dd[2]],[Wb[1],Wb[2]],xc,Ec),[ab.result,ab.indexes];case "AvgPool3D":return Wb=
a("strides",ab,Ta,jb),xc=a("pad",ab,Ta,jb),dd=a("kernelSize",ab,Ta,jb),[ba.avgPool3d(a("x",ab,Ta,jb),[dd[1],dd[2],dd[3]],[Wb[1],Wb[2],Wb[3]],xc)];case "MaxPool3D":return Wb=a("strides",ab,Ta,jb),xc=a("pad",ab,Ta,jb),dd=a("kernelSize",ab,Ta,jb),[ba.maxPool3d(a("x",ab,Ta,jb),[dd[1],dd[2],dd[3]],[Wb[1],Wb[2],Wb[3]],xc)];case "Dilation2D":return Ec=a("strides",ab,Ta,jb),xc=a("pad",ab,Ta,jb),dd=a("dilations",ab,Ta,jb),Wb=Ec[1],Ec=Ec[2],kd=dd[1],dd=dd[2],[ba.dilation2d(a("x",ab,Ta,jb),a("filter",ab,Ta,
jb),[Wb,Ec],xc,[kd,dd],"NHWC")];default:throw TypeError("Node type "+ab.op+" is not implemented");}},Ya=function(ab,Ta,jb){switch(ab.op){case "Fill":var Wb=a("shape",ab,Ta,jb),xc=a("dtype",ab,Ta,jb);ab=a("value",ab,Ta,jb);return[ba.fill(Wb,ab,xc)];case "LinSpace":return Wb=a("start",ab,Ta,jb),xc=a("stop",ab,Ta,jb),ab=a("num",ab,Ta,jb),[ba.linspace(Wb,xc,ab)];case "Multinomial":Wb=a("logits",ab,Ta,jb);var Ec=a("numSamples",ab,Ta,jb);xc=a("seed",ab,Ta,jb);return[ba.multinomial(Wb,Ec,xc)];case "OneHot":return Wb=
a("indices",ab,Ta,jb),xc=a("depth",ab,Ta,jb),Ec=a("onValue",ab,Ta,jb),ab=a("offValue",ab,Ta,jb),[ba.oneHot(Wb,xc,Ec,ab)];case "Ones":return[ba.ones(a("shape",ab,Ta,jb),a("dtype",ab,Ta,jb))];case "OnesLike":return[ba.onesLike(a("x",ab,Ta,jb))];case "RandomUniform":return[ba.randomUniform(a("shape",ab,Ta,jb),a("minval",ab,Ta,jb),a("maxval",ab,Ta,jb),a("dtype",ab,Ta,jb))];case "Range":return Wb=a("start",ab,Ta,jb),xc=a("stop",ab,Ta,jb),Ec=a("step",ab,Ta,jb),[ba.range(Wb,xc,Ec,a("dtype",ab,Ta,jb))];case "TruncatedNormal":Wb=
a("shape",ab,Ta,jb);Ec=a("mean",ab,Ta,jb);var dd=a("stdDev",ab,Ta,jb);xc=a("seed",ab,Ta,jb);return[ba.truncatedNormal(Wb,Ec,dd,a("dtype",ab,Ta,jb),xc)];case "Zeros":return[ba.zeros(a("shape",ab,Ta,jb),a("dtype",ab,Ta,jb))];case "ZerosLike":return[ba.zerosLike(a("x",ab,Ta,jb))];default:throw TypeError("Node type "+ab.op+" is not implemented");}},Pb=function(ab,Ta,jb){return t(void 0,void 0,void 0,function(){var Wb,xc,Ec,dd,Dc,kd,ld,Nb,Sb,Tb,Ac,Kc,Vc;return r(this,function(Pc){switch(Pc.label){case 0:Wb=
ab.op;switch(Wb){case "NonMaxSuppressionV5":return[3,1];case "NonMaxSuppressionV4":return[3,3];case "NonMaxSuppressionV3":return[3,5];case "NonMaxSuppressionV2":return[3,5];case "Where":return[3,7];case "ListDiff":return[3,9]}return[3,10];case 1:return xc=U(ab,Ta,jb),Ec=xc.boxes,dd=xc.scores,Dc=xc.maxOutputSize,kd=xc.iouThreshold,ld=xc.scoreThreshold,Nb=xc.softNmsSigma,[4,ba.image.nonMaxSuppressionWithScoreAsync(Ec,dd,Dc,kd,ld,Nb)];case 2:return Sb=Pc.sent(),[2,[Sb.selectedIndices,Sb.selectedScores]];
case 3:return Tb=U(ab,Ta,jb),Ec=Tb.boxes,dd=Tb.scores,Dc=Tb.maxOutputSize,kd=Tb.iouThreshold,ld=Tb.scoreThreshold,Ac=a("padToMaxOutputSize",ab,Ta,jb),[4,ba.image.nonMaxSuppressionPaddedAsync(Ec,dd,Dc,kd,ld,Ac)];case 4:return Sb=Pc.sent(),[2,[Sb.selectedIndices,Sb.validOutputs]];case 5:return Kc=U(ab,Ta,jb),Ec=Kc.boxes,dd=Kc.scores,Dc=Kc.maxOutputSize,kd=Kc.iouThreshold,ld=Kc.scoreThreshold,[4,ba.image.nonMaxSuppressionAsync(Ec,dd,Dc,kd,ld)];case 6:return[2,[Pc.sent()]];case 7:return Vc=ba.cast(a("condition",
ab,Ta,jb),"bool"),[4,ba.whereAsync(Vc)];case 8:return Sb=[Pc.sent()],Vc.dispose(),[2,Sb];case 9:return[2,ba.setdiff1dAsync(a("x",ab,Ta,jb),a("y",ab,Ta,jb))];case 10:throw TypeError("Node type "+ab.op+" is not implemented");}})})},tb=function(ab,Ta,jb){switch(ab.op){case "Const":return Ta[ab.name];case "PlaceholderWithDefault":var Wb=a("default",ab,Ta,jb);return[b(ab.name,Ta,jb)||Wb];case "Placeholder":return[b(ab.name,Ta,jb)];case "Identity":case "StopGradient":case "FakeQuantWithMinMaxVars":return Wb=
a("x",ab,Ta,jb),[c(Wb)];case "IdentityN":return a("x",ab,Ta,jb).map(function(dd){return c(dd)});case "Snapshot":return Wb=a("x",ab,Ta,jb),[c(Wb)];case "Shape":return[ba.tensor1d(a("x",ab,Ta,jb).shape,"int32")];case "ShapeN":return a("x",ab,Ta,jb).map(function(dd){return ba.tensor1d(dd.shape)});case "Size":return[ba.scalar(a("x",ab,Ta,jb).size,"int32")];case "Rank":return[ba.scalar(a("x",ab,Ta,jb).rank,"int32")];case "NoOp":return[ba.scalar(1)];case "Print":Wb=a("x",ab,Ta,jb);var xc=a("data",ab,Ta,
jb),Ec=a("message",ab,Ta,jb);ab=a("summarize",ab,Ta,jb);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance.");console.log(Ec);for(Ta=0;Ta<xc.length;Ta++)console.log(Array.prototype.slice.call(xc[Ta].dataSync()).slice(0,ab));return[Wb];default:throw TypeError("Node type "+ab.op+" is not implemented");}},bb=function(){function ab(Ta,jb){this.keyDType=Ta;this.valueDType=jb;this.handle=ba.scalar(0);this.tensorMap=new Map;ba.keep(this.handle)}Object.defineProperty(ab.prototype,
"id",{get:function(){return this.handle.id},enumerable:!0,configurable:!0});ab.prototype.clearAndClose=function(){this.tensorMap.forEach(function(Ta){return Ta.dispose()});this.tensorMap.clear();this.handle.dispose()};ab.prototype.size=function(){return this.tensorMap.size};ab.prototype.import=function(Ta,jb){return t(this,void 0,void 0,function(){var Wb,xc=this;return r(this,function(Ec){switch(Ec.label){case 0:return this.checkKeyAndValueTensor(Ta,jb),[4,Ta.data()];case 1:return Wb=Ec.sent(),this.tensorMap.forEach(function(dd){return dd.dispose()}),
this.tensorMap.clear(),[2,ba.tidy(function(){var dd=ba.unstack(jb),Dc=Wb.length,kd=dd.length;ba.util.assert(Dc===kd,function(){return"The number of elements doesn't match, keys has "+(Dc+" elements, the values has "+kd+" elements.")});for(var ld=0;ld<Dc;ld++){var Nb=Wb[ld],Sb=dd[ld];ba.keep(Sb);xc.tensorMap.set(Nb,Sb)}return xc.handle})]}})})};ab.prototype.find=function(Ta,jb){return t(this,void 0,void 0,function(){var Wb,xc=this;return r(this,function(Ec){switch(Ec.label){case 0:return this.checkKeyAndValueTensor(Ta,
jb),[4,Ta.data()];case 1:return Wb=Ec.sent(),[2,ba.tidy(function(){for(var dd=[],Dc=0;Dc<Wb.length;Dc++){var kd=xc.findWithDefault(Wb[Dc],jb);dd.push(kd)}return ba.stack(dd)})]}})})};ab.prototype.findWithDefault=function(Ta,jb){Ta=this.tensorMap.get(Ta);return null!=Ta?Ta:jb};ab.prototype.checkKeyAndValueTensor=function(Ta,jb){if(Ta.dtype!==this.keyDType)throw Error("Expect key dtype "+this.keyDType+", but got "+Ta.dtype);if(jb.dtype!==this.valueDType)throw Error("Expect value dtype "+this.valueDType+
", but got "+jb.dtype);};return ab}(),La=function(ab,Ta,jb,Wb){return t(void 0,void 0,void 0,function(){var xc,Ec,dd,Dc,kd,ld,Nb,Sb;return r(this,function(Tb){switch(Tb.label){case 0:xc=ab.op;switch(xc){case "HashTable":return[3,1];case "HashTableV2":return[3,1];case "LookupTableImport":return[3,2];case "LookupTableImportV2":return[3,2];case "LookupTableFind":return[3,4];case "LookupTableFindV2":return[3,4]}return[3,6];case 1:return Ec=a("keyDType",ab,Ta,jb),dd=a("valueDType",ab,Ta,jb),Dc=new bb(Ec,
dd),Wb.addHashTable(ab.name,Dc),[2,[Dc.handle]];case 2:return kd=a("tableHandle",ab,Ta,jb,Wb),ld=a("keys",ab,Ta,jb),Nb=a("values",ab,Ta,jb),Dc=Wb.getHashTableById(kd.id),[4,Dc.import(ld,Nb)];case 3:return[2,[Tb.sent()]];case 4:return kd=a("tableHandle",ab,Ta,jb,Wb),ld=a("keys",ab,Ta,jb),Sb=a("defaultValue",ab,Ta,jb),Dc=Wb.getHashTableById(kd.id),[4,Dc.find(ld,Sb)];case 5:return[2,[Tb.sent()]];case 6:throw TypeError("Node type "+ab.op+" is not implemented");}})})},Fb=function(ab,Ta,jb){switch(ab.op){case "Equal":return[ba.equal(a("a",
ab,Ta,jb),a("b",ab,Ta,jb))];case "NotEqual":return[ba.notEqual(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "Greater":return[ba.greater(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "GreaterEqual":return[ba.greaterEqual(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "Less":return[ba.less(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "LessEqual":return[ba.lessEqual(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "LogicalAnd":return[ba.logicalAnd(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "LogicalNot":return[ba.logicalNot(a("a",ab,Ta,jb))];
case "LogicalOr":return[ba.logicalOr(a("a",ab,Ta,jb),a("b",ab,Ta,jb))];case "Select":case "SelectV2":return[ba.where(a("condition",ab,Ta,jb),a("a",ab,Ta,jb),a("b",ab,Ta,jb))];default:throw TypeError("Node type "+ab.op+" is not implemented");}},vb=function(ab,Ta,jb){switch(ab.op){case "FusedBatchNorm":case "FusedBatchNormV2":return[ba.batchNorm(a("x",ab,Ta,jb),a("mean",ab,Ta,jb),a("variance",ab,Ta,jb),a("offset",ab,Ta,jb),a("scale",ab,Ta,jb),a("epsilon",ab,Ta,jb))];case "FusedBatchNormV3":return[ba.batchNorm(a("x",
ab,Ta,jb),a("mean",ab,Ta,jb),a("variance",ab,Ta,jb),a("offset",ab,Ta,jb),a("scale",ab,Ta,jb),a("epsilon",ab,Ta,jb))];case "LRN":return[ba.localResponseNormalization(a("x",ab,Ta,jb),a("radius",ab,Ta,jb),a("bias",ab,Ta,jb),a("alpha",ab,Ta,jb),a("beta",ab,Ta,jb))];case "Softmax":return[ba.softmax(a("x",ab,Ta,jb))];case "LogSoftmax":return[ba.logSoftmax(a("x",ab,Ta,jb))];case "SparseToDense":return[ba.sparseToDense(a("sparseIndices",ab,Ta,jb),a("outputShape",ab,Ta,jb),a("sparseValues",ab,Ta,jb),a("defaultValue",
ab,Ta,jb))];default:throw TypeError("Node type "+ab.op+" is not implemented");}},Xb=function(ab,Ta,jb){switch(ab.op){case "Max":var Wb=a("axis",ab,Ta,jb),xc=a("keepDims",ab,Ta,jb);return[ba.max(a("x",ab,Ta,jb),Wb,xc)];case "Mean":return Wb=a("axis",ab,Ta,jb),xc=a("keepDims",ab,Ta,jb),[ba.mean(a("x",ab,Ta,jb),Wb,xc)];case "Min":return Wb=a("axis",ab,Ta,jb),xc=a("keepDims",ab,Ta,jb),[ba.min(a("x",ab,Ta,jb),Wb,xc)];case "Sum":return Wb=a("axis",ab,Ta,jb),xc=a("keepDims",ab,Ta,jb),[ba.sum(a("x",ab,Ta,
jb),Wb,xc)];case "All":return Wb=a("axis",ab,Ta,jb),xc=a("keepDims",ab,Ta,jb),[ba.all(a("x",ab,Ta,jb),Wb,xc)];case "Any":return Wb=a("axis",ab,Ta,jb),xc=a("keepDims",ab,Ta,jb),[ba.any(a("x",ab,Ta,jb),Wb,xc)];case "ArgMax":return Wb=a("axis",ab,Ta,jb),[ba.argMax(a("x",ab,Ta,jb),Wb)];case "ArgMin":return Wb=a("axis",ab,Ta,jb),[ba.argMin(a("x",ab,Ta,jb),Wb)];case "Prod":return Wb=a("axis",ab,Ta,jb),xc=a("keepDims",ab,Ta,jb),[ba.prod(a("x",ab,Ta,jb),Wb,xc)];case "Cumsum":Wb=a("axis",ab,Ta,jb);xc=a("exclusive",
ab,Ta,jb);var Ec=a("reverse",ab,Ta,jb);return[ba.cumsum(a("x",ab,Ta,jb),Wb,xc,Ec)];default:throw TypeError("Node type "+ab.op+" is not implemented");}},Mc=function(ab,Ta,jb){switch(ab.op){case "ConcatV2":case "Concat":var Wb=a("n",ab,Ta,jb),xc=a("axis",ab,Ta,jb),Ec=a("tensors",ab,Ta,jb);Ec=Ec.slice(0,Wb);return[ba.concat(Ec,xc)];case "GatherV2":case "Gather":return xc=a("axis",ab,Ta,jb),Ec=a("x",ab,Ta,jb),Wb=a("indices",ab,Ta,jb),[ba.gather(Ec,ba.cast(Wb,"int32"),xc)];case "ReverseV2":case "Reverse":return xc=
a("axis",ab,Ta,jb),Ec=a("x",ab,Ta,jb),[ba.reverse(Ec,xc)];case "Slice":return xc=a("begin",ab,Ta,jb),Wb=a("size",ab,Ta,jb),[ba.slice(a("x",ab,Ta,jb),xc,Wb)];case "StridedSlice":xc=a("begin",ab,Ta,jb);Ec=a("end",ab,Ta,jb);var dd=a("strides",ab,Ta,jb),Dc=a("beginMask",ab,Ta,jb),kd=a("endMask",ab,Ta,jb),ld=a("ellipsisMask",ab,Ta,jb),Nb=a("newAxisMask",ab,Ta,jb),Sb=a("shrinkAxisMask",ab,Ta,jb);Wb=a("x",ab,Ta,jb);return[ba.stridedSlice(Wb,xc,Ec,dd,Dc,kd,ld,Nb,Sb)];case "Pack":return ba.tidy(function(){var Tb=
a("axis",ab,Ta,jb),Ac=a("tensors",ab,Ta,jb),Kc=Ac[0].shape,Vc=ba.squeeze(Ac[0]).shape;Ac=Ac.map(function(Pc){var gd=ba.util.arraysEqual(Pc.shape,Kc);if(!gd&&!ba.util.arraysEqual(ba.squeeze(Pc).shape,Vc))throw Error("the input tensors shape does not match");return gd?Pc:ba.reshape(Pc,Kc)});return[ba.stack(Ac,Tb)]});case "Unpack":return xc=a("axis",ab,Ta,jb),Wb=a("tensor",ab,Ta,jb),ba.unstack(Wb,xc);case "Tile":return Wb=a("reps",ab,Ta,jb),[ba.tile(a("x",ab,Ta,jb),Wb)];case "Split":case "SplitV":return xc=
a("axis",ab,Ta,jb),Ec=a("numOrSizeSplits",ab,Ta,jb),Wb=a("x",ab,Ta,jb),ba.split(Wb,Ec,xc);case "ScatterNd":return Wb=a("indices",ab,Ta,jb),Ec=a("values",ab,Ta,jb),xc=a("shape",ab,Ta,jb),[ba.scatterND(Wb,Ec,xc)];case "GatherNd":return xc=a("x",ab,Ta,jb),Wb=a("indices",ab,Ta,jb),[ba.gatherND(xc,Wb)];case "SparseToDense":return Wb=a("sparseIndices",ab,Ta,jb),xc=a("outputShape",ab,Ta,jb),Ec=a("sparseValues",ab,Ta,jb),dd=a("defaultValue",ab,Ta,jb),[ba.sparseToDense(Wb,Ec,xc,Ec.dtype===dd.dtype?dd:ba.cast(dd,
Ec.dtype))];default:throw TypeError("Node type "+ab.op+" is not implemented");}},Yc=function(ab,Ta,jb){switch(ab.op){case "Cast":return[ba.cast(a("x",ab,Ta,jb),a("dtype",ab,Ta,jb))];case "ExpandDims":var Wb=a("axis",ab,Ta,jb);return[ba.expandDims(a("x",ab,Ta,jb),Wb)];case "Squeeze":return Wb=a("axis",ab,Ta,jb),[ba.squeeze(a("x",ab,Ta,jb),Wb)];case "Reshape":return[ba.reshape(a("x",ab,Ta,jb),a("shape",ab,Ta,jb))];case "MirrorPad":return[ba.mirrorPad(a("x",ab,Ta,jb),a("padding",ab,Ta,jb),a("mode",ab,
Ta,jb))];case "PadV2":case "Pad":return[ba.pad(a("x",ab,Ta,jb),a("padding",ab,Ta,jb),a("constantValue",ab,Ta,jb))];case "SpaceToBatchND":Wb=a("blockShape",ab,Ta,jb);var xc=a("paddings",ab,Ta,jb);return[ba.spaceToBatchND(a("x",ab,Ta,jb),Wb,xc)];case "BatchToSpaceND":return Wb=a("blockShape",ab,Ta,jb),xc=a("crops",ab,Ta,jb),[ba.batchToSpaceND(a("x",ab,Ta,jb),Wb,xc)];case "DepthToSpace":return Wb=a("blockSize",ab,Ta,jb),xc=a("dataFormat",ab,Ta,jb).toUpperCase(),[ba.depthToSpace(a("x",ab,Ta,jb),Wb,xc)];
case "BroadcastTo":return[ba.broadcastTo(a("x",ab,Ta,jb),a("shape",ab,Ta,jb))];default:throw TypeError("Node type "+ab.op+" is not implemented");}},yd=function(){function ab(Ta,jb,Wb,xc){void 0===Ta&&(Ta={});void 0===jb&&(jb={});void 0===Wb&&(Wb={});void 0===xc&&(xc={});this.weightMap=Ta;this.tensorArrayMap=jb;this.tensorListMap=Wb;this.functionMap=xc;this.rootContext={id:0,frameName:"",iterationId:0};this.contexts=[this.rootContext];this.lastId=0;this.generateCurrentContextIds()}ab.prototype.newFrame=
function(Ta,jb){return{id:Ta,frameName:jb,iterationId:0}};Object.defineProperty(ab.prototype,"currentContext",{get:function(){return this.contexts},set:function(Ta){this.contexts!==Ta&&(this.contexts=Ta,this.generateCurrentContextIds())},enumerable:!0,configurable:!0});Object.defineProperty(ab.prototype,"currentContextId",{get:function(){return this._currentContextIds[0]},enumerable:!0,configurable:!0});Object.defineProperty(ab.prototype,"currentContextIds",{get:function(){return this._currentContextIds},
enumerable:!0,configurable:!0});ab.prototype.generateCurrentContextIds=function(){for(var Ta=[],jb=0;jb<this.contexts.length-1;jb++){var Wb=this.contexts.slice(0,this.contexts.length-jb);Ta.push(this.contextIdforContexts(Wb))}Ta.push("");this._currentContextIds=Ta};ab.prototype.contextIdforContexts=function(Ta){return Ta?Ta.map(function(jb){return 0===jb.id&&0===jb.iterationId?"":jb.frameName+"-"+jb.iterationId}).join("/"):""};ab.prototype.enterFrame=function(Ta){this.contexts&&(this.lastId++,this.contexts=
this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,Ta)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))};ab.prototype.exitFrame=function(){if(this.contexts&&1<this.contexts.length)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw Error("Cannot exit frame, the context is empty");};ab.prototype.nextIteration=function(){if(this.contexts&&0<this.contexts.length){this.contexts=this.contexts.slice();this.lastId++;
var Ta=Object.assign({},this.contexts[this.contexts.length-1]);Ta.iterationId+=1;Ta.id=this.lastId;this.contexts.splice(-1,1,Ta);this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw Error("Cannot increase frame iteration, the context is empty");};ab.prototype.getWeight=function(Ta){return this.weightMap[Ta]};ab.prototype.addTensorArray=function(Ta){this.tensorArrayMap[Ta.id]=Ta};ab.prototype.getTensorArray=function(Ta){return this.tensorArrayMap[Ta]};ab.prototype.addTensorList=
function(Ta){this.tensorListMap[Ta.id]=Ta};ab.prototype.getTensorList=function(Ta){return this.tensorListMap[Ta]};ab.prototype.dispose=function(Ta){for(var jb in this.tensorArrayMap)this.tensorArrayMap[jb].clearAndClose(Ta);for(jb in this.tensorListMap)this.tensorListMap[jb].clearAndClose(Ta)};return ab}(),pd="Switch Merge Enter Exit NextIteration StatelessIf StatelessWhile if While".split(" "),sc=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],tc="HashTable HashTableV2 LookupTableImport LookupTableImportV2 LookupTableFind LookupTableFindV2".split(" "),
vc=function(){function ab(Ta,jb){var Wb=this;this.graph=Ta;this.parent=jb;this.compiledMap=new Map;this._weightMap={};this.SEPERATOR=",";this._functions={};this._functionExecutorMap={};this._outputs=Ta.outputs;this._inputs=Ta.inputs;this._initNodes=Ta.initNodes;this._signature=Ta.signature;this._functions=Ta.functions;null!=Ta.functions&&Object.keys(Ta.functions).forEach(function(xc){Wb._functionExecutorMap[xc]=new ab(Ta.functions[xc],Wb)})}Object.defineProperty(ab.prototype,"weightIds",{get:function(){return this.parent?
this.parent.weightIds:this._weightIds},enumerable:!0,configurable:!0});Object.defineProperty(ab.prototype,"functionExecutorMap",{get:function(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap},enumerable:!0,configurable:!0});Object.defineProperty(ab.prototype,"weightMap",{get:function(){return this.parent?this.parent.weightMap:this._weightMap},set:function(Ta){var jb=Object.keys(Ta).map(function(Wb){return Ta[Wb].map(function(xc){return xc.id})});this._weightIds=[].concat.apply([],
f(jb));this._weightMap=Ta},enumerable:!0,configurable:!0});Object.defineProperty(ab.prototype,"resourceManager",{set:function(Ta){this._resourceManager=Ta},enumerable:!0,configurable:!0});Object.defineProperty(ab.prototype,"inputs",{get:function(){return this._inputs.map(function(Ta){return{name:Ta.name,shape:Ta.attrParams.shape?Ta.attrParams.shape.value:void 0,dtype:Ta.attrParams.dtype?Ta.attrParams.dtype.value:void 0}})},enumerable:!0,configurable:!0});Object.defineProperty(ab.prototype,"outputs",
{get:function(){return this._outputs.map(function(Ta){return{name:Ta.name,shape:Ta.attrParams.shape?Ta.attrParams.shape.value:void 0,dtype:Ta.attrParams.dtype?Ta.attrParams.dtype.value:void 0}})},enumerable:!0,configurable:!0});Object.defineProperty(ab.prototype,"inputNodes",{get:function(){return this._inputs.map(function(Ta){return Ta.signatureKey||Ta.name})},enumerable:!0,configurable:!0});Object.defineProperty(ab.prototype,"outputNodes",{get:function(){return this._outputs.map(function(Ta){var jb=
Ta.signatureKey||Ta.name;return Ta.defaultOutput?jb+":"+Ta.defaultOutput:jb})},enumerable:!0,configurable:!0});Object.defineProperty(ab.prototype,"functions",{get:function(){var Ta=this;return Object.keys(this._functions).reduce(function(jb,Wb){jb[Wb]=Ta._functions[Wb].signature;return jb},{})},enumerable:!0,configurable:!0});ab.prototype.getCompilationKey=function(Ta,jb){Ta=Ta.map(function(Wb){return Wb.name}).sort();jb=jb.map(function(Wb){return Wb.name}).sort();return Ta.join(this.SEPERATOR)+"--"+
jb.join(this.SEPERATOR)};ab.prototype.compile=function(Ta,jb){var Wb=I(Ta,jb,this.weightMap,this._initNodes),xc=Wb.missingInputs,Ec=Wb.dynamicNode,dd=Wb.syncInputs;if(null!=Ec)throw Error("This execution contains the node '"+Ec.name+"', which has the dynamic op '"+(Ec.op+"'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [")+(dd+"]"));if(0<xc.length)throw jb=jb.map(function(Dc){return Dc.name}),Ta=Object.keys(Ta),Error("Cannot compute the outputs ["+
jb+"] from the provided inputs ["+(Ta+"]. Missing the following inputs: ["+xc+"]"));return T(this.graph,this.weightMap,Wb)};ab.prototype.execute=function(Ta,jb){var Wb=this;Ta=this.mapInputs(Ta);var xc=Object.keys(Ta).sort();this.checkInputs(Ta);this.checkInputShapeAndType(Ta);jb=this.mapOutputs(jb);this.checkOutputs(jb);var Ec=xc.map(function(Nb){return Wb.graph.nodes[d(Nb)[0]]}),dd=jb.map(function(Nb){return d(Nb)[0]});xc=dd.map(function(Nb){return Wb.graph.nodes[Nb]});0===xc.length&&(xc=this._outputs);
Ec=this.getCompilationKey(Ec,xc);var Dc=this.compiledMap.get(Ec);null==Dc&&(Dc=this.compile(Ta,xc),this.compiledMap.set(Ec,Dc));var kd={},ld={};return ba.tidy(function(){var Nb=new yd(Wb.weightMap,kd,ld,Wb.functionExecutorMap),Sb=Z({},Wb.weightMap);Object.keys(Ta).forEach(function(gd){var Dd=u(d(gd),2),Jd=Dd[0],we=[];we[Dd[1]]=Ta[gd];Sb[Jd]=we});for(var Tb=Wb.getFrozenTensorIds(Sb),Ac={},Kc=0;Kc<Dc.length;Kc++){var Vc=Dc[Kc];if(!Sb[Vc.name]){var Pc=L(Vc,Sb,Nb,Wb._resourceManager);if(ba.util.isPromise(Pc))throw Error("The execution of the op '"+
Vc.op+"' returned a promise. Please use model.executeAsync() instead.");Sb[Vc.name]=Pc;Wb.checkTensorForDisposal(Vc.name,Vc,Sb,Nb,Tb,dd,Ac)}}null==Wb.parent&&Nb.dispose(Tb);return jb.map(function(gd){return b(gd,Sb,Nb)})})};ab.prototype.getFrozenTensorIds=function(Ta){var jb=[].concat.apply([],Object.keys(Ta).map(function(Wb){return Ta[Wb]}).map(function(Wb){return Wb.map(function(xc){return xc.id})}));return new Set(jb)};ab.prototype.checkTensorForDisposal=function(Ta,jb,Wb,xc,Ec,dd,Dc){"control"!==
jb.category&&-1===dd.indexOf(Ta)&&(Wb[Ta].forEach(function(kd){null!=kd&&(Dc[kd.id]=(Dc[kd.id]||0)+jb.children.length)}),jb.inputs.forEach(function(kd){"control"!==kd.category&&(kd=Wb[g(kd.name,xc.currentContextId)],null!=kd&&kd.forEach(function(ld){if(ld&&!Ec.has(ld.id)){var Nb=Dc[ld.id];1===Nb?(ld.dispose(),delete Dc[ld.id]):null!=Nb&&Dc[ld.id]--}}))}))};ab.prototype.executeAsync=function(Ta,jb){return t(this,void 0,void 0,function(){return r(this,function(Wb){return[2,this._executeAsync(Ta,jb)]})})};
ab.prototype._executeAsync=function(Ta,jb,Wb,xc,Ec){void 0===Wb&&(Wb=!1);void 0===xc&&(xc={});void 0===Ec&&(Ec={});return t(this,void 0,void 0,function(){var dd,Dc,kd,ld,Nb,Sb;return r(this,function(Tb){switch(Tb.label){case 0:return Wb||(Ta=this.mapInputs(Ta),this.checkInputs(Ta),this.checkInputShapeAndType(Ta),jb=this.mapOutputs(jb),this.checkOutputs(jb)),dd=new yd(this.weightMap,xc,Ec,this.functionExecutorMap),[4,this.executeWithControlFlow(Ta,dd,jb,Wb)];case 1:return Dc=Tb.sent(),kd=jb.map(function(Ac){return b(Ac,
Dc,dd)}),ld=kd.map(function(Ac){return Ac.id}),Nb=Object.keys(Ta).map(function(Ac){return Ta[Ac].id}),Sb=new Set(f(ld,Nb,this.weightIds)),Object.keys(Dc).forEach(function(Ac){Dc[Ac].forEach(function(Kc){!Kc||Kc.isDisposed||Sb.has(Kc.id)||Kc.dispose()})}),null==this.parent&&dd.dispose(Sb),[2,kd]}})})};ab.prototype.executeFunctionAsync=function(Ta,jb,Wb){return t(this,void 0,void 0,function(){var xc,Ec=this;return r(this,function(dd){xc=Ta.reduce(function(Dc,kd,ld){Dc[Ec.inputs[ld].name]=kd;return Dc},
{});return[2,this._executeAsync(xc,this.outputNodes,!0,jb,Wb)]})})};ab.prototype.executeWithControlFlow=function(Ta,jb,Wb,xc){return t(this,void 0,void 0,function(){var Ec,dd,Dc,kd,ld,Nb,Sb,Tb,Ac,Kc,Vc,Pc,gd,Dd,Jd,we,Ne,Je=this;return r(this,function(Qe){switch(Qe.label){case 0:Ec=Object.keys(Ta),dd=Ec.map(function(Ce){return Je.graph.nodes[d(Ce)[0]]}),Dc=Wb.map(function(Ce){return d(Ce)[0]}),kd=Dc.map(function(Ce){return Je.graph.nodes[Ce]}),0===kd.length&&(kd=this._outputs),ld=I(Ta,kd,this.weightMap,
this._initNodes),Nb=ld.usedNodes,Sb=ld.missingInputs,Tb=ld.dynamicNode,Ac=ld.syncInputs,Kc=f(dd,this.graph.weights,this._initNodes||[]).map(function(Ce){return{node:Ce,contexts:jb.currentContext}}),Vc=Z({},this.weightMap),Object.keys(Ta).forEach(function(Ce){var Oe=u(d(Ce),2),od=Oe[0],Ud=[];Ud[Oe[1]]=Ta[Ce];Vc[od]=Ud}),Pc={},gd=this.getFrozenTensorIds(Vc),Dd={},Qe.label=1;case 1:if(!(0<Kc.length))return[3,3];Jd=this.processStack(dd,Kc,jb,Vc,Dd,gd,Dc,Pc,Nb);return[4,Promise.all(Jd)];case 2:return Qe.sent(),
[3,1];case 3:null!=Tb||xc||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");we=kd.filter(function(Ce){return!(0<=pd.indexOf(Ce.op))&&!b(Ce.name,Vc,jb)}).map(function(Ce){return Ce.name});if(0<we.length)throw Ne="",null!=Tb&&(Ne="Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs ["+(Ac+"]")),Error("Cannot compute the outputs ["+we+"] from the provided inputs ["+(Ec+"]. Consider providing the following inputs: [")+
(Sb+"]. "+Ne));return[2,Vc]}})})};ab.prototype.processStack=function(Ta,jb,Wb,xc,Ec,dd,Dc,kd,ld){var Nb=this,Sb=[];Ta=function(){var Ac=jb.pop();Wb.currentContext=Ac.contexts;var Kc="";if("Enter"===Ac.node.op&&a("isConstant",Ac.node,xc,Wb)){var Vc=u(e(Ac.node.name,Wb),1);Kc=Vc[0]}if(null==xc[Ac.node.name]){var Pc=L(Ac.node,xc,Wb,Tb._resourceManager);Kc||(Vc=u(e(Ac.node.name,Wb),1),Kc=Vc[0]);var gd=Wb.currentContext;ba.util.isPromise(Pc)?Sb.push(Pc.then(function(Dd){xc[Kc]=Dd;Wb.currentContext=gd;
Nb.checkTensorForDisposal(Kc,Ac.node,xc,Wb,dd,Dc,kd);Nb.processChildNodes(Ac.node,jb,Wb,xc,Ec,ld);return Dd})):(xc[Kc]=Pc,Tb.checkTensorForDisposal(Kc,Ac.node,xc,Wb,dd,Dc,kd),Tb.processChildNodes(Ac.node,jb,Wb,xc,Ec,ld))}else Tb.processChildNodes(Ac.node,jb,Wb,xc,Ec,ld)};for(var Tb=this;0<jb.length;)Ta();return Sb};ab.prototype.processChildNodes=function(Ta,jb,Wb,xc,Ec,dd){Ta.children.forEach(function(Dc){var kd=u(e(Dc.name,Wb),1)[0];!Ec[kd]&&dd.has(Dc.name)&&("Merge"===Dc.op?Dc.inputNames.some(function(ld){return!!b(ld,
xc,Wb)})&&(Ec[kd]=!0,jb.push({contexts:Wb.currentContext,node:Dc})):Dc.inputNames.every(function(ld){return!!b(ld,xc,Wb)})&&(Ec[kd]=!0,jb.push({contexts:Wb.currentContext,node:Dc})))})};ab.prototype.dispose=function(){var Ta=this;Object.keys(this.weightMap).forEach(function(jb){return Ta.weightMap[jb].forEach(function(Wb){return Wb.dispose()})})};ab.prototype.checkInputShapeAndType=function(Ta){var jb=this;Object.keys(Ta).forEach(function(Wb){var xc=Ta[Wb];Wb=u(d(Wb),1)[0];var Ec=jb.graph.nodes[Wb];
if(Ec.attrParams.shape&&Ec.attrParams.shape.value){var dd=Ec.attrParams.shape.value;Wb=dd.length===xc.shape.length&&xc.shape.every(function(Dc,kd){return-1===dd[kd]||dd[kd]===Dc});ba.util.assert(Wb,function(){return"The shape of dict['"+Ec.name+"'] provided in model.execute(dict) must be ["+(dd+"], but was [")+(xc.shape+"]")})}Ec.attrParams.dtype&&Ec.attrParams.dtype.value&&ba.util.assert(xc.dtype===Ec.attrParams.dtype.value,function(){return"The dtype of dict['"+Ec.name+"'] provided in model.execute(dict) must be "+
(Ec.attrParams.dtype.value+", but was "+xc.dtype)})})};ab.prototype.mapInputs=function(Ta){var jb={},Wb;for(Wb in Ta)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[Wb]?jb[this._signature.inputs[Wb].name]=Ta[Wb]:jb[Wb]=Ta[Wb];return jb};ab.prototype.checkInputs=function(Ta){var jb=this;Ta=Object.keys(Ta).filter(function(Wb){Wb=u(d(Wb),1)[0];return null==jb.graph.nodes[Wb]});if(0<Ta.length)throw Error("The dict provided in model.execute(dict) has keys: ["+(Ta+"] that are not part of graph"));
};ab.prototype.mapOutputs=function(Ta){var jb=this;return Ta.map(function(Wb){return null!=jb._signature&&null!=jb._signature.outputs&&null!=jb._signature.outputs[Wb]?jb._signature.outputs[Wb].name:Wb},{})};ab.prototype.checkOutputs=function(Ta){var jb=this;Ta.forEach(function(Wb){var xc=u(d(Wb),1)[0];if(!jb.graph.nodes[xc])throw Error("The output '"+Wb+"' is not found in the graph");})};return ab}(),$c=function(){function ab(Ta,jb){void 0===Ta&&(Ta={});void 0===jb&&(jb={});this.hashTableNameToHandle=
Ta;this.hashTableMap=jb}ab.prototype.addHashTable=function(Ta,jb){this.hashTableNameToHandle[Ta]=jb.handle;this.hashTableMap[jb.id]=jb};ab.prototype.getHashTableHandleByName=function(Ta){return this.hashTableNameToHandle[Ta]};ab.prototype.getHashTableById=function(Ta){return this.hashTableMap[Ta]};ab.prototype.dispose=function(){for(var Ta in this.hashTableMap)this.hashTableMap[Ta].clearAndClose(),delete this.hashTableMap[Ta];for(var jb in this.hashTableNameToHandle)this.hashTableNameToHandle[jb].dispose(),
delete this.hashTableNameToHandle[jb]};return ab}(),xd=function(){function ab(Ta,jb){void 0===jb&&(jb={});this.modelUrl=Ta;this.loadOptions=jb;this.version="n/a";null==jb&&(this.loadOptions={});this.resourceManager=new $c}Object.defineProperty(ab.prototype,"modelVersion",{get:function(){return this.version},enumerable:!0,configurable:!0});Object.defineProperty(ab.prototype,"inputNodes",{get:function(){return this.executor.inputNodes},enumerable:!0,configurable:!0});Object.defineProperty(ab.prototype,
"outputNodes",{get:function(){return this.executor.outputNodes},enumerable:!0,configurable:!0});Object.defineProperty(ab.prototype,"inputs",{get:function(){return this.executor.inputs},enumerable:!0,configurable:!0});Object.defineProperty(ab.prototype,"outputs",{get:function(){return this.executor.outputs},enumerable:!0,configurable:!0});Object.defineProperty(ab.prototype,"weights",{get:function(){return this.executor.weightMap},enumerable:!0,configurable:!0});ab.prototype.findIOHandler=function(){var Ta=
this.modelUrl;if(null!=Ta.load)this.handler=Ta;else if(null!=this.loadOptions.requestInit)this.handler=ba.io.browserHTTPRequest(Ta,this.loadOptions);else{var jb=ba.io.getLoadHandlers(Ta,this.loadOptions);if(0===jb.length)jb.push(ba.io.browserHTTPRequest(Ta,this.loadOptions));else if(1<jb.length)throw Error("Found more than one ("+jb.length+") load handlers for URL '"+([Ta]+"'"));this.handler=jb[0]}};ab.prototype.load=function(){return t(this,void 0,void 0,function(){var Ta;return r(this,function(jb){switch(jb.label){case 0:this.findIOHandler();
if(null==this.handler.load)throw Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");return[4,this.handler.load()];case 1:return Ta=jb.sent(),[2,this.loadSync(Ta)]}})})};ab.prototype.loadSync=function(Ta){this.artifacts=Ta;var jb=this.artifacts.modelTopology,Wb={};null!=this.artifacts.userDefinedMetadata&&(Wb=this.artifacts.userDefinedMetadata.signature);this.version=jb.versions.producer+"."+jb.versions.minConsumer;var xc=ba.io.decodeWeights(this.artifacts.weightData,
this.artifacts.weightSpecs);this.executor=new vc(ha.Instance.transformGraph(jb,Wb));this.executor.weightMap=this.convertTensorMapToTensorsMap(xc);this.executor.resourceManager=this.resourceManager;null!=Ta.modelInitializer&&(Ta=ha.Instance.transformGraph(Ta.modelInitializer),this.initializer=new vc(Ta),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[]));return!0};ab.prototype.save=function(Ta,jb){return t(this,
void 0,void 0,function(){var Wb;return r(this,function(xc){if("string"===typeof Ta){Wb=ba.io.getSaveHandlers(Ta);if(0===Wb.length)throw Error("Cannot find any save handlers for URL '"+Ta+"'");if(1<Wb.length)throw Error("Found more than one ("+Wb.length+") save handlers for URL '"+(Ta+"'"));Ta=Wb[0]}if(null==Ta.save)throw Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return[2,Ta.save(this.artifacts)]})})};ab.prototype.predict=function(Ta,
jb){return this.execute(Ta,this.outputNodes)};ab.prototype.normalizeInputs=function(Ta){if(!(Ta instanceof ba.Tensor||Array.isArray(Ta)))return Ta;Ta=Array.isArray(Ta)?Ta:[Ta];if(Ta.length!==this.inputNodes.length)throw Error("Input tensor count mismatch,the graph model has "+(this.inputNodes.length+" placeholders, while there are ")+(Ta.length+" input tensors."));return this.inputNodes.reduce(function(jb,Wb,xc){jb[Wb]=Ta[xc];return jb},{})};ab.prototype.normalizeOutputs=function(Ta){Ta=Ta||this.outputNodes;
return Array.isArray(Ta)?Ta:[Ta]};ab.prototype.execute=function(Ta,jb){Ta=this.normalizeInputs(Ta);jb=this.normalizeOutputs(jb);Ta=this.executor.execute(Ta,jb);return 1<Ta.length?Ta:Ta[0]};ab.prototype.executeAsync=function(Ta,jb){return t(this,void 0,void 0,function(){var Wb;return r(this,function(xc){switch(xc.label){case 0:return Ta=this.normalizeInputs(Ta),jb=this.normalizeOutputs(jb),[4,this.executor.executeAsync(Ta,jb)];case 1:return Wb=xc.sent(),[2,1<Wb.length?Wb:Wb[0]]}})})};ab.prototype.convertTensorMapToTensorsMap=
function(Ta){return Object.keys(Ta).reduce(function(jb,Wb){jb[Wb]=[Ta[Wb]];return jb},{})};ab.prototype.dispose=function(){this.executor.dispose();this.initializer&&this.initializer.dispose();this.resourceManager.dispose()};return ab}();v.GraphModel=xd;v.deregisterOp=function(ab){delete fa[ab]};v.loadGraphModel=function(ab,Ta){void 0===Ta&&(Ta={});return t(this,void 0,void 0,function(){var jb;return r(this,function(Wb){switch(Wb.label){case 0:if(null==ab)throw Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
null==Ta&&(Ta={});Ta.fromTFHub&&null==ab.load&&(ab.endsWith("/")||(ab+="/"),ab=""+ab+"model.json?tfjs-format\x3dfile");jb=new xd(ab,Ta);return[4,jb.load()];case 1:return Wb.sent(),[2,jb]}})})};v.registerOp=function(ab,Ta){fa[ab]={tfOpName:ab,category:"custom",inputs:[],attrs:[],customExecutor:Ta}};v.version_converter="2.7.0"};
shadow$provide[951]=function(W,A,la,v){function t(cb,wa){function Aa(){this.constructor=cb}y(cb,wa);cb.prototype=null===wa?Object.create(wa):(Aa.prototype=wa.prototype,new Aa)}function r(cb,wa,Aa,lb){return new (Aa||(Aa=Promise))(function(Ya,Pb){function tb(Fb){try{La(lb.next(Fb))}catch(vb){Pb(vb)}}function bb(Fb){try{La(lb["throw"](Fb))}catch(vb){Pb(vb)}}function La(Fb){Fb.done?Ya(Fb.value):(new Aa(function(vb){vb(Fb.value)})).then(tb,bb)}La((lb=lb.apply(cb,wa||[])).next())})}function u(cb,wa){function Aa(Fb){return function(vb){return lb([Fb,
vb])}}function lb(Fb){if(Pb)throw new TypeError("Generator is already executing.");for(;Ya;)try{if(Pb=1,tb&&(bb=Fb[0]&2?tb["return"]:Fb[0]?tb["throw"]||((bb=tb["return"])&&bb.call(tb),0):tb.next)&&!(bb=bb.call(tb,Fb[1])).done)return bb;if(tb=0,bb)Fb=[Fb[0]&2,bb.value];switch(Fb[0]){case 0:case 1:bb=Fb;break;case 4:return Ya.label++,{value:Fb[1],done:!1};case 5:Ya.label++;tb=Fb[1];Fb=[0];continue;case 7:Fb=Ya.ops.pop();Ya.trys.pop();continue;default:if(!(bb=Ya.trys,bb=0<bb.length&&bb[bb.length-1])&&
(6===Fb[0]||2===Fb[0])){Ya=0;continue}if(3===Fb[0]&&(!bb||Fb[1]>bb[0]&&Fb[1]<bb[3]))Ya.label=Fb[1];else if(6===Fb[0]&&Ya.label<bb[1])Ya.label=bb[1],bb=Fb;else if(bb&&Ya.label<bb[2])Ya.label=bb[2],Ya.ops.push(Fb);else{bb[2]&&Ya.ops.pop();Ya.trys.pop();continue}}Fb=wa.call(cb,Ya)}catch(vb){Fb=[6,vb],tb=0}finally{Pb=bb=0}if(Fb[0]&5)throw Fb[1];return{value:Fb[0]?Fb[1]:void 0,done:!0}}var Ya={label:0,sent:function(){if(bb[0]&1)throw bb[1];return bb[1]},trys:[],ops:[]},Pb,tb,bb,La;return La={next:Aa(0),
"throw":Aa(1),"return":Aa(2)},"function"===typeof Symbol&&(La[Symbol.iterator]=function(){return this}),La}function f(cb,wa){return wa={exports:{}},cb(wa,wa.exports),wa.exports}function a(cb,wa,Aa,lb){void 0===Aa&&(Aa=new Map);void 0===lb&&(lb=new Set);if(null==cb)return null;if(lb.has(cb))throw Error("Circular references are not supported.");if(Aa.has(cb))return Aa.get(cb);var Ya=wa(cb);if(Ya.recurse&&null!==Ya.value)throw Error("A deep map function may not return both a value and recurse\x3dtrue.");
if(Ya.recurse){if(d(cb)){Ya=Array.isArray(cb)?[]:{};lb.add(cb);for(var Pb in cb){var tb=a(cb[Pb],wa,Aa,lb);Ya[Pb]=tb}lb.delete(cb);return Ya}throw Error("Can't recurse into non-iterable type: "+cb);}Aa.set(cb,Ya.value);return Ya.value}function b(cb,wa,Aa){void 0===Aa&&(Aa=new Set);var lb=cb[0];if(Aa.has(lb))throw Error("Circular references are not supported.");var Ya=wa(cb);if(Ya.recurse&&null!==Ya.value)throw Error("A deep zip function may not return both a value and recurse\x3dtrue.");if(Ya.recurse){if(d(lb)){var Pb=
Array.isArray(lb)?[]:{};Aa.add(lb);Ya=function(bb){var La=cb.map(function(Fb){return Fb[bb]});La=b(La,wa,Aa);Pb[bb]=La};for(var tb in lb)Ya(tb);Aa.delete(lb);return Pb}throw Error("Can't recurse into non-iterable type: "+lb);}return Ya.value}function e(cb){return null===cb?null:d(cb[0])?{value:null,recurse:!0}:{value:cb,recurse:!1}}function g(cb,wa){return r(this,void 0,void 0,function(){var Aa,lb,Ya,Pb,tb,bb,La;return u(this,function(Fb){switch(Fb.label){case 0:Aa=new Map,a(cb,wa,Aa),lb=0,Ya=Array.from(Aa.keys()),
Fb.label=1;case 1:if(!(lb<Ya.length))return[3,4];Pb=Ya[lb];tb=Aa.get(Pb);return w.util.isPromise(tb)?[4,tb]:[3,3];case 2:bb=Fb.sent(),Aa.set(Pb,bb),Fb.label=3;case 3:return lb++,[3,1];case 4:return La=a(cb,wa,Aa),[2,La]}})})}function d(cb){return null!=cb&&!ArrayBuffer.isView(cb)&&(Array.isArray(cb)||"object"===typeof cb&&!(cb instanceof w.Tensor))}function h(cb){return cb instanceof w.Tensor?{value:cb.clone(),recurse:!1}:d(cb)?{value:null,recurse:!0}:{value:cb,recurse:!1}}function c(cb,wa){return new fa(cb,
wa)}function l(cb,wa){void 0===wa&&(wa=ta.FAIL);return new ma(cb,wa)}function m(cb,wa){void 0===wa&&(wa=null);return new (function(Aa){function lb(){var Ya=null!==Aa&&Aa.apply(this,arguments)||this;Ya.size=wa;return Ya}t(lb,Aa);lb.prototype.iterator=function(){return r(this,void 0,void 0,function(){return u(this,function(Ya){return[2,cb()]})})};return lb}(Fa))}function n(cb){if(null===cb)return null;var wa=cb[0];if(null==wa||null===wa||"object"!==typeof wa&&"function"!==typeof wa||Array.isArray(wa)||
"object"===typeof wa&&wa instanceof w.Tensor||w.util.isTypedArray(wa)){if(0===cb.length)throw Error("Can't make a batch of zero elements.");cb=cb[0]instanceof w.Tensor?w.stack(cb):w.tensor(cb);return{value:cb,recurse:!1}}return{value:null,recurse:!0}}function k(cb,wa){void 0===wa&&(wa={});return r(this,void 0,void 0,function(){var Aa,lb,Ya,Pb,tb;return u(this,function(bb){switch(bb.label){case 0:return"string"===typeof cb?Aa=cb:(Aa=cb.url,lb={method:cb.method,headers:cb.headers,body:cb.body,mode:cb.mode,
credentials:cb.credentials,cache:cb.cache,redirect:cb.redirect,referrer:cb.referrer,integrity:cb.integrity}),[4,w.util.fetch(Aa,lb)];case 1:Ya=bb.sent();if(!Ya.ok)return[3,3];tb=Uint8Array.bind;return[4,Ya.arrayBuffer()];case 2:return Pb=new (tb.apply(Uint8Array,[void 0,bb.sent()])),[2,new ya(Pb,wa)];case 3:throw Error(Ya.statusText);}})})}function p(cb){return"string"===typeof cb&&"file://"===cb.substr(0,7)}var q=A(5).Buffer;"use strict";Object.defineProperty(v,"__esModule",{value:!0});var w=A(948),
y=function(cb,wa){y=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(Aa,lb){Aa.__proto__=lb}||function(Aa,lb){for(var Ya in lb)lb.hasOwnProperty(Ya)&&(Aa[Ya]=lb[Ya])};return y(cb,wa)},C="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof W?W:"undefined"!==typeof self?self:{};W=f(function(cb){(function(wa,Aa,lb){function Ya(La){var Fb=this,vb=bb();Fb.next=function(){var Xb=2091639*Fb.s0+2.3283064365386963E-10*Fb.c;Fb.s0=Fb.s1;Fb.s1=Fb.s2;
return Fb.s2=Xb-(Fb.c=Xb|0)};Fb.c=1;Fb.s0=vb(" ");Fb.s1=vb(" ");Fb.s2=vb(" ");Fb.s0-=vb(La);0>Fb.s0&&(Fb.s0+=1);Fb.s1-=vb(La);0>Fb.s1&&(Fb.s1+=1);Fb.s2-=vb(La);0>Fb.s2&&(Fb.s2+=1);vb=null}function Pb(La,Fb){Fb.c=La.c;Fb.s0=La.s0;Fb.s1=La.s1;Fb.s2=La.s2;return Fb}function tb(La,Fb){var vb=new Ya(La);La=Fb&&Fb.state;var Xb=vb.next;Xb.int32=function(){return 4294967296*vb.next()|0};Xb.double=function(){return Xb()+1.1102230246251565E-16*(2097152*Xb()|0)};Xb.quick=Xb;La&&("object"==typeof La&&Pb(La,vb),
Xb.state=function(){return Pb(vb,{})});return Xb}function bb(){var La=4022871197;return function(Fb){Fb=Fb.toString();for(var vb=0;vb<Fb.length;vb++){La+=Fb.charCodeAt(vb);var Xb=.02519603282416938*La;La=Xb>>>0;Xb-=La;Xb*=La;La=Xb>>>0;Xb-=La;La+=4294967296*Xb}return 2.3283064365386963E-10*(La>>>0)}}Aa&&Aa.exports?Aa.exports=tb:lb&&lb.amd?lb(function(){return tb}):this.alea=tb})(C,cb,!1)});la=f(function(cb){(function(wa,Aa,lb){function Ya(bb){var La=this,Fb="";La.x=0;La.y=0;La.z=0;La.w=0;La.next=function(){var vb=
La.x^La.x<<11;La.x=La.y;La.y=La.z;La.z=La.w;return La.w=La.w^La.w>>>19^vb^vb>>>8};bb===(bb|0)?La.x=bb:Fb+=bb;for(bb=0;bb<Fb.length+64;bb++)La.x^=Fb.charCodeAt(bb)|0,La.next()}function Pb(bb,La){La.x=bb.x;La.y=bb.y;La.z=bb.z;La.w=bb.w;return La}function tb(bb,La){var Fb=new Ya(bb);bb=La&&La.state;La=function(){return(Fb.next()>>>0)/4294967296};La.double=function(){do{var vb=Fb.next()>>>11,Xb=(Fb.next()>>>0)/4294967296;vb=(vb+Xb)/2097152}while(0===vb);return vb};La.int32=Fb.next;La.quick=La;bb&&("object"==
typeof bb&&Pb(bb,Fb),La.state=function(){return Pb(Fb,{})});return La}Aa&&Aa.exports?Aa.exports=tb:lb&&lb.amd?lb(function(){return tb}):this.xor128=tb})(C,cb,!1)});var z=f(function(cb){(function(wa,Aa,lb){function Ya(bb){var La=this,Fb="";La.next=function(){var vb=La.x^La.x>>>2;La.x=La.y;La.y=La.z;La.z=La.w;La.w=La.v;return(La.d=La.d+362437|0)+(La.v=La.v^La.v<<4^vb^vb<<1)|0};La.x=0;La.y=0;La.z=0;La.w=0;La.v=0;bb===(bb|0)?La.x=bb:Fb+=bb;for(bb=0;bb<Fb.length+64;bb++)La.x^=Fb.charCodeAt(bb)|0,bb==Fb.length&&
(La.d=La.x<<10^La.x>>>4),La.next()}function Pb(bb,La){La.x=bb.x;La.y=bb.y;La.z=bb.z;La.w=bb.w;La.v=bb.v;La.d=bb.d;return La}function tb(bb,La){var Fb=new Ya(bb);bb=La&&La.state;La=function(){return(Fb.next()>>>0)/4294967296};La.double=function(){do{var vb=Fb.next()>>>11,Xb=(Fb.next()>>>0)/4294967296;vb=(vb+Xb)/2097152}while(0===vb);return vb};La.int32=Fb.next;La.quick=La;bb&&("object"==typeof bb&&Pb(bb,Fb),La.state=function(){return Pb(Fb,{})});return La}Aa&&Aa.exports?Aa.exports=tb:lb&&lb.amd?lb(function(){return tb}):
this.xorwow=tb})(C,cb,!1)}),K=f(function(cb){(function(wa,Aa,lb){function Ya(bb){var La=this;La.next=function(){var Fb=La.x,vb=La.i;var Xb=Fb[vb];Xb^=Xb>>>7;var Mc=Xb^Xb<<24;Xb=Fb[vb+1&7];Mc^=Xb^Xb>>>10;Xb=Fb[vb+3&7];Mc^=Xb^Xb>>>3;Xb=Fb[vb+4&7];Mc^=Xb^Xb<<7;Xb=Fb[vb+7&7];Xb^=Xb<<13;Mc^=Xb^Xb<<9;Fb[vb]=Mc;La.i=vb+1&7;return Mc};(function(Fb,vb){var Xb,Mc=[];if(vb===(vb|0))Mc[0]=vb;else for(vb=""+vb,Xb=0;Xb<vb.length;++Xb)Mc[Xb&7]=Mc[Xb&7]<<15^vb.charCodeAt(Xb)+Mc[Xb+1&7]<<13;for(;8>Mc.length;)Mc.push(0);
for(Xb=0;8>Xb&&0===Mc[Xb];++Xb);8==Xb&&(Mc[7]=-1);Fb.x=Mc;Fb.i=0;for(Xb=256;0<Xb;--Xb)Fb.next()})(La,bb)}function Pb(bb,La){La.x=bb.x.slice();La.i=bb.i;return La}function tb(bb,La){null==bb&&(bb=+new Date);var Fb=new Ya(bb);bb=La&&La.state;La=function(){return(Fb.next()>>>0)/4294967296};La.double=function(){do{var vb=Fb.next()>>>11,Xb=(Fb.next()>>>0)/4294967296;vb=(vb+Xb)/2097152}while(0===vb);return vb};La.int32=Fb.next;La.quick=La;bb&&(bb.x&&Pb(bb,Fb),La.state=function(){return Pb(Fb,{})});return La}
Aa&&Aa.exports?Aa.exports=tb:lb&&lb.amd?lb(function(){return tb}):this.xorshift7=tb})(C,cb,!1)}),J=f(function(cb){(function(wa,Aa,lb){function Ya(bb){var La=this;La.next=function(){var Fb=La.w,vb=La.X,Xb=La.i;La.w=Fb=Fb+1640531527|0;var Mc=vb[Xb+34&127];var Yc=vb[Xb=Xb+1&127];Mc^=Mc<<13;Yc^=Yc<<17;Mc=vb[Xb]=Mc^Mc>>>15^Yc^Yc>>>12;La.i=Xb;return Mc+(Fb^Fb>>>16)|0};(function(Fb,vb){var Xb,Mc,Yc=[],yd=128;if(vb===(vb|0)){var pd=vb;vb=null}else vb+="\x00",pd=0,yd=Math.max(yd,vb.length);var sc=0;for(Xb=
-32;Xb<yd;++Xb)if(vb&&(pd^=vb.charCodeAt((Xb+32)%vb.length)),0===Xb&&(Mc=pd),pd^=pd<<10,pd^=pd>>>15,pd^=pd<<4,pd^=pd>>>13,0<=Xb){Mc=Mc+1640531527|0;var tc=Yc[Xb&127]^=pd+Mc;sc=0==tc?sc+1:0}128<=sc&&(Yc[(vb&&vb.length||0)&127]=-1);sc=127;for(Xb=512;0<Xb;--Xb)pd=Yc[sc+34&127],tc=Yc[sc=sc+1&127],pd^=pd<<13,tc^=tc<<17,pd^=pd>>>15,tc^=tc>>>12,Yc[sc]=pd^tc;Fb.w=Mc;Fb.X=Yc;Fb.i=sc})(La,bb)}function Pb(bb,La){La.i=bb.i;La.w=bb.w;La.X=bb.X.slice();return La}function tb(bb,La){null==bb&&(bb=+new Date);var Fb=
new Ya(bb);bb=La&&La.state;La=function(){return(Fb.next()>>>0)/4294967296};La.double=function(){do{var vb=Fb.next()>>>11,Xb=(Fb.next()>>>0)/4294967296;vb=(vb+Xb)/2097152}while(0===vb);return vb};La.int32=Fb.next;La.quick=La;bb&&(bb.X&&Pb(bb,Fb),La.state=function(){return Pb(Fb,{})});return La}Aa&&Aa.exports?Aa.exports=tb:lb&&lb.amd?lb(function(){return tb}):this.xor4096=tb})(C,cb,!1)}),B=f(function(cb){(function(wa,Aa,lb){function Ya(bb){var La=this,Fb="";La.next=function(){var vb=La.b,Xb=La.c,Mc=
La.d,Yc=La.a;vb=vb<<25^vb>>>7^Xb;Xb=Xb-Mc|0;Mc=Mc<<24^Mc>>>8^Yc;Yc=Yc-vb|0;La.b=vb=vb<<20^vb>>>12^Xb;La.c=Xb=Xb-Mc|0;La.d=Mc<<16^Xb>>>16^Yc;return La.a=Yc-vb|0};La.a=0;La.b=0;La.c=-1640531527;La.d=1367130551;bb===Math.floor(bb)?(La.a=bb/4294967296|0,La.b=bb|0):Fb+=bb;for(bb=0;bb<Fb.length+20;bb++)La.b^=Fb.charCodeAt(bb)|0,La.next()}function Pb(bb,La){La.a=bb.a;La.b=bb.b;La.c=bb.c;La.d=bb.d;return La}function tb(bb,La){var Fb=new Ya(bb);bb=La&&La.state;La=function(){return(Fb.next()>>>0)/4294967296};
La.double=function(){do{var vb=Fb.next()>>>11,Xb=(Fb.next()>>>0)/4294967296;vb=(vb+Xb)/2097152}while(0===vb);return vb};La.int32=Fb.next;La.quick=La;bb&&("object"==typeof bb&&Pb(bb,Fb),La.state=function(){return Pb(Fb,{})});return La}Aa&&Aa.exports?Aa.exports=tb:lb&&lb.amd?lb(function(){return tb}):this.tychei=tb})(C,cb,!1)}),O=f(function(cb){(function(wa,Aa){function lb(pd,sc,tc){var vc=[];sc=1==sc?{entropy:!0}:sc||{};pd=bb(tb(sc.entropy?[pd,Fb(wa)]:null==pd?La():pd,3),vc);var $c=new Ya(vc);vc=function(){for(var xd=
$c.g(6),ab=Xb,Ta=0;xd<Mc;)xd=256*(xd+Ta),ab*=256,Ta=$c.g(1);for(;xd>=Yc;)xd/=2,ab/=2,Ta>>>=1;return(xd+Ta)/ab};vc.int32=function(){return $c.g(4)|0};vc.quick=function(){return $c.g(4)/4294967296};vc.double=vc;bb(Fb($c.S),wa);return(sc.pass||tc||function(xd,ab,Ta,jb){jb&&(jb.S&&Pb(jb,$c),xd.state=function(){return Pb($c,{})});return Ta?(Aa.random=xd,ab):xd})(vc,pd,"global"in sc?sc.global:this==Aa,sc.state)}function Ya(pd){var sc,tc=pd.length,vc=this,$c=0,xd=vc.i=vc.j=0,ab=vc.S=[];for(tc||(pd=[tc++]);256>
$c;)ab[$c]=$c++;for($c=0;256>$c;$c++)ab[$c]=ab[xd=255&xd+pd[$c%tc]+(sc=ab[$c])],ab[xd]=sc;(vc.g=function(Ta){for(var jb,Wb=0,xc=vc.i,Ec=vc.j,dd=vc.S;Ta--;)jb=dd[xc=255&xc+1],Wb=256*Wb+dd[255&(dd[xc]=dd[Ec=255&Ec+jb])+(dd[Ec]=jb)];vc.i=xc;vc.j=Ec;return Wb})(256)}function Pb(pd,sc){sc.i=pd.i;sc.j=pd.j;sc.S=pd.S.slice();return sc}function tb(pd,sc){var tc=[],vc=typeof pd,$c;if(sc&&"object"==vc)for($c in pd)try{tc.push(tb(pd[$c],sc-1))}catch(xd){}return tc.length?tc:"string"==vc?pd:pd+"\x00"}function bb(pd,
sc){pd+="";for(var tc,vc=0;vc<pd.length;)sc[255&vc]=255&(tc^=19*sc[255&vc])+pd.charCodeAt(vc++);return Fb(sc)}function La(){try{var pd;yd&&(pd=yd.randomBytes)?pd=pd(256):(pd=new Uint8Array(256),(vb.crypto||vb.msCrypto).getRandomValues(pd));return Fb(pd)}catch(sc){return pd=vb.navigator,[+new Date,vb,pd&&pd.plugins,vb.screen,Fb(wa)]}}function Fb(pd){return String.fromCharCode.apply(0,pd)}var vb=this,Xb=Aa.pow(256,6),Mc=Aa.pow(2,52),Yc=2*Mc;Aa.seedrandom=lb;bb(Aa.random(),wa);if(cb.exports){cb.exports=
lb;try{var yd=A(35)}catch(pd){}}})([],Math)});O.alea=W;O.xor128=la;O.xorwow=z;O.xorshift7=K;O.xor4096=J;O.tychei=B;var Q=O.alea,V=function(){function cb(wa){this.capacity=wa;this.end=this.begin=0;if(null==wa)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(1>wa)throw new RangeError("Can't create ring buffer of capacity \x3c 1.");this.data=Array(wa);this.doubledCapacity=2*wa}cb.prototype.wrap=function(wa){for(;0>wa;)wa+=this.doubledCapacity;return wa%this.doubledCapacity};
cb.prototype.get=function(wa){if(0>wa)throw new RangeError("Can't get item at a negative index.");return this.data[wa%this.capacity]};cb.prototype.set=function(wa,Aa){if(0>wa)throw new RangeError("Can't set item at a negative index.");this.data[wa%this.capacity]=Aa};cb.prototype.length=function(){var wa=this.end-this.begin;0>wa&&(wa=this.doubledCapacity+wa);return wa};cb.prototype.isFull=function(){return this.length()===this.capacity};cb.prototype.isEmpty=function(){return 0===this.length()};cb.prototype.push=
function(wa){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,wa);this.end=this.wrap(this.end+1)};cb.prototype.pushAll=function(wa){for(var Aa=0;Aa<wa.length;Aa++)this.push(wa[Aa])};cb.prototype.pop=function(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);var wa=this.get(this.end);this.set(this.end,void 0);return wa};cb.prototype.unshift=function(wa){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=
this.wrap(this.begin-1);this.set(this.begin,wa)};cb.prototype.shift=function(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");var wa=this.get(this.begin);this.set(this.begin,void 0);this.begin=this.wrap(this.begin+1);return wa};cb.prototype.shuffleExcise=function(wa){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");wa=this.wrap(this.begin+wa);var Aa=this.get(wa);this.set(wa,this.pop());return Aa};return cb}(),M=function(cb){function wa(){return cb.call(this,wa.INITIAL_CAPACITY)||
this}t(wa,cb);wa.prototype.isFull=function(){return!1};wa.prototype.push=function(Aa){cb.prototype.isFull.call(this)&&this.expand();cb.prototype.push.call(this,Aa)};wa.prototype.unshift=function(Aa){cb.prototype.isFull.call(this)&&this.expand();cb.prototype.unshift.call(this,Aa)};wa.prototype.expand=function(){for(var Aa=2*this.capacity,lb=Array(Aa),Ya=this.length(),Pb=0;Pb<Ya;Pb++)lb[Pb]=this.get(this.wrap(this.begin+Pb));this.data=lb;this.capacity=Aa;this.doubledCapacity=2*this.capacity;this.begin=
0;this.end=Ya};wa.INITIAL_CAPACITY=32;return wa}(V),F=function(){function cb(){}cb.prototype.toArray=function(){return r(this,void 0,void 0,function(){var wa,Aa;return u(this,function(lb){switch(lb.label){case 0:return wa=[],[4,this.next()];case 1:Aa=lb.sent(),lb.label=2;case 2:if(Aa.done)return[3,4];wa.push(Aa.value);return[4,this.next()];case 3:return Aa=lb.sent(),[3,2];case 4:return[2,wa]}})})};cb.prototype.toArrayForTest=function(){return r(this,void 0,void 0,function(){var wa,Aa,lb;return u(this,
function(Ya){switch(Ya.label){case 0:return wa=this.prefetch(100),Aa=[],[4,wa.next()];case 1:lb=Ya.sent(),Ya.label=2;case 2:if(lb.done)return[3,4];Aa.push(lb.value);return[4,wa.next()];case 3:return lb=Ya.sent(),[3,2];case 4:return[2,Aa]}})})};cb.prototype.resolveFully=function(){return r(this,void 0,void 0,function(){var wa;return u(this,function(Aa){switch(Aa.label){case 0:return[4,this.next()];case 1:wa=Aa.sent(),Aa.label=2;case 2:return wa.done?[3,4]:[4,this.next()];case 3:return wa=Aa.sent(),
[3,2];case 4:return[2]}})})};cb.prototype.resolveWhile=function(wa){return r(this,void 0,void 0,function(){var Aa,lb;return u(this,function(Ya){switch(Ya.label){case 0:return[4,this.next()];case 1:Aa=Ya.sent(),lb=wa(Aa.value),Ya.label=2;case 2:return Aa.done||!lb?[3,4]:[4,this.next()];case 3:return Aa=Ya.sent(),lb=wa(Aa.value),[3,2];case 4:return[2]}})})};cb.prototype.handleErrors=function(wa){return new Z(this,wa)};cb.prototype.filter=function(wa){return new aa(this,wa)};cb.prototype.map=function(wa){return new ba(this,
wa)};cb.prototype.mapAsync=function(wa){return new da(this,wa)};cb.prototype.serialMapAsync=function(wa){return(new da(this,wa)).serial()};cb.prototype.flatmap=function(wa){return new pa(this,wa)};cb.prototype.forEachAsync=function(wa){return r(this,void 0,void 0,function(){return u(this,function(Aa){return[2,this.map(wa).resolveFully()]})})};cb.prototype.serialForEach=function(wa){return r(this,void 0,void 0,function(){return u(this,function(Aa){return[2,this.serialMapAsync(wa).resolveWhile(function(lb){return!0===
lb})]})})};cb.prototype.rowMajorBatch=function(wa,Aa){void 0===Aa&&(Aa=!0);return new T(this,wa,Aa)};cb.prototype.columnMajorBatch=function(wa,Aa,lb){void 0===Aa&&(Aa=!0);void 0===lb&&(lb=e);return this.rowMajorBatch(wa,Aa).map(function(Ya){var Pb=lb;void 0===Pb&&(Pb=e);return b(Ya,Pb)})};cb.prototype.concatenate=function(wa,Aa){return new fa(new D([this,wa]),Aa)};cb.prototype.take=function(wa){return 0>wa||null==wa?this:new I(this,wa)};cb.prototype.skip=function(wa){return 0>wa||null==wa?this:new L(this,
wa)};cb.prototype.prefetch=function(wa){return new ja(this,wa)};cb.prototype.shuffle=function(wa,Aa){return new qa(this,wa,Aa)};cb.prototype.serial=function(){return new U(this)};return cb}(),D=function(cb){function wa(Aa){var lb=cb.call(this)||this;lb.items=Aa;lb.trav=0;return lb}t(wa,cb);wa.prototype.summary=function(){return"Array of "+this.items.length+" items"};wa.prototype.next=function(){return r(this,void 0,void 0,function(){var Aa;return u(this,function(lb){if(this.trav>=this.items.length)return[2,
{value:null,done:!0}];Aa=this.items[this.trav];this.trav++;return[2,{value:a(Aa,h),done:!1}]})})};return wa}(F),H=function(cb){function wa(Aa){var lb=cb.call(this)||this;lb.nextFn=Aa;return lb}t(wa,cb);wa.prototype.summary=function(){return"Function call"};wa.prototype.next=function(){return r(this,void 0,void 0,function(){return u(this,function(Aa){try{return[2,this.nextFn()]}catch(lb){throw lb.message="Error thrown while iterating through a dataset: "+lb.message,lb;}})})};return wa}(F),U=function(cb){function wa(Aa){var lb=
cb.call(this)||this;lb.upstream=Aa;lb.lastRead=Promise.resolve({value:null,done:!1});return lb}t(wa,cb);wa.prototype.summary=function(){return this.upstream.summary()+" -\x3e Serial"};wa.prototype.next=function(){return r(this,void 0,void 0,function(){var Aa=this;return u(this,function(lb){this.lastRead=this.lastRead.then(function(){return Aa.serialNext()});return[2,this.lastRead]})})};wa.prototype.serialNext=function(){return r(this,void 0,void 0,function(){return u(this,function(Aa){return[2,this.upstream.next()]})})};
return wa}(F),L=function(cb){function wa(Aa,lb){var Ya=cb.call(this)||this;Ya.upstream=Aa;Ya.maxCount=lb;Ya.count=0;Ya.lastRead=Promise.resolve({value:null,done:!1});return Ya}t(wa,cb);wa.prototype.summary=function(){return this.upstream.summary()+" -\x3e Skip"};wa.prototype.next=function(){return r(this,void 0,void 0,function(){var Aa=this;return u(this,function(lb){this.lastRead=this.lastRead.then(function(){return Aa.serialNext()});return[2,this.lastRead]})})};wa.prototype.serialNext=function(){return r(this,
void 0,void 0,function(){var Aa;return u(this,function(lb){switch(lb.label){case 0:return this.count++<this.maxCount?[4,this.upstream.next()]:[3,2];case 1:Aa=lb.sent();if(Aa.done)return[2,Aa];w.dispose(Aa.value);return[3,0];case 2:return[2,this.upstream.next()]}})})};return wa}(F),I=function(cb){function wa(Aa,lb){var Ya=cb.call(this)||this;Ya.upstream=Aa;Ya.maxCount=lb;Ya.count=0;return Ya}t(wa,cb);wa.prototype.summary=function(){return this.upstream.summary()+" -\x3e Take"};wa.prototype.next=function(){return r(this,
void 0,void 0,function(){return u(this,function(Aa){return this.count++>=this.maxCount?[2,{value:null,done:!0}]:[2,this.upstream.next()]})})};return wa}(F),T=function(cb){function wa(Aa,lb,Ya){void 0===Ya&&(Ya=!0);var Pb=cb.call(this)||this;Pb.upstream=Aa;Pb.batchSize=lb;Pb.enableSmallLastBatch=Ya;Pb.lastRead=Promise.resolve({value:null,done:!1});return Pb}t(wa,cb);wa.prototype.summary=function(){return this.upstream.summary()+" -\x3e RowMajorBatch"};wa.prototype.next=function(){return r(this,void 0,
void 0,function(){var Aa=this;return u(this,function(lb){this.lastRead=this.lastRead.then(function(){return Aa.serialNext()});return[2,this.lastRead]})})};wa.prototype.serialNext=function(){return r(this,void 0,void 0,function(){var Aa,lb;return u(this,function(Ya){switch(Ya.label){case 0:Aa=[],Ya.label=1;case 1:return Aa.length<this.batchSize?[4,this.upstream.next()]:[3,3];case 2:lb=Ya.sent();if(lb.done)return this.enableSmallLastBatch&&0<Aa.length?[2,{value:Aa,done:!1}]:[2,{value:null,done:!0}];
Aa.push(lb.value);return[3,1];case 3:return[2,{value:Aa,done:!1}]}})})};return wa}(F),aa=function(cb){function wa(Aa,lb){var Ya=cb.call(this)||this;Ya.upstream=Aa;Ya.predicate=lb;Ya.lastRead=Promise.resolve({value:null,done:!1});return Ya}t(wa,cb);wa.prototype.summary=function(){return this.upstream.summary()+" -\x3e Filter"};wa.prototype.next=function(){return r(this,void 0,void 0,function(){var Aa=this;return u(this,function(lb){this.lastRead=this.lastRead.then(function(){return Aa.serialNext()});
return[2,this.lastRead]})})};wa.prototype.serialNext=function(){return r(this,void 0,void 0,function(){var Aa;return u(this,function(lb){switch(lb.label){case 0:return[4,this.upstream.next()];case 1:Aa=lb.sent();if(Aa.done||this.predicate(Aa.value))return[2,Aa];w.dispose(Aa.value);return[3,0];case 2:return[2]}})})};return wa}(F),ba=function(cb){function wa(Aa,lb){var Ya=cb.call(this)||this;Ya.upstream=Aa;Ya.transform=lb;return Ya}t(wa,cb);wa.prototype.summary=function(){return this.upstream.summary()+
" -\x3e Map"};wa.prototype.next=function(){return r(this,void 0,void 0,function(){var Aa,lb,Ya,Pb,tb,bb,La;return u(this,function(Fb){switch(Fb.label){case 0:return[4,this.upstream.next()];case 1:Aa=Fb.sent();if(Aa.done)return[2,{value:null,done:!0}];lb=w.tensor_util.getTensorsInContainer(Aa.value);Ya=this.transform(Aa.value);Pb=w.tensor_util.getTensorsInContainer(Ya);tb=0;for(bb=lb;tb<bb.length;tb++)La=bb[tb],w.tensor_util.isTensorInList(La,Pb)||La.dispose();return[2,{value:Ya,done:!1}]}})})};return wa}(F),
Z=function(cb){function wa(Aa,lb){var Ya=cb.call(this)||this;Ya.upstream=Aa;Ya.handler=lb;Ya.count=0;Ya.lastRead=Promise.resolve({value:null,done:!1});return Ya}t(wa,cb);wa.prototype.summary=function(){return this.upstream.summary()+" -\x3e handleErrors"};wa.prototype.next=function(){return r(this,void 0,void 0,function(){var Aa=this;return u(this,function(lb){this.lastRead=this.lastRead.then(function(){return Aa.serialNext()});return[2,this.lastRead]})})};wa.prototype.serialNext=function(){return r(this,
void 0,void 0,function(){var Aa;return u(this,function(lb){switch(lb.label){case 0:lb.label=1;case 1:return lb.trys.push([1,3,,4]),[4,this.upstream.next()];case 2:return[2,lb.sent()];case 3:return Aa=lb.sent(),this.handler(Aa)?[3,4]:[2,{value:null,done:!0}];case 4:return[3,0];case 5:return[2]}})})};return wa}(F),da=function(cb){function wa(Aa,lb){var Ya=cb.call(this)||this;Ya.upstream=Aa;Ya.transform=lb;return Ya}t(wa,cb);wa.prototype.summary=function(){return this.upstream.summary()+" -\x3e AsyncMap"};
wa.prototype.next=function(){return r(this,void 0,void 0,function(){var Aa,lb,Ya,Pb,tb,bb,La;return u(this,function(Fb){switch(Fb.label){case 0:return[4,this.upstream.next()];case 1:Aa=Fb.sent();if(Aa.done)return[2,{value:null,done:!0}];lb=w.tensor_util.getTensorsInContainer(Aa.value);return[4,this.transform(Aa.value)];case 2:Ya=Fb.sent();Pb=w.tensor_util.getTensorsInContainer(Ya);tb=0;for(bb=lb;tb<bb.length;tb++)La=bb[tb],w.tensor_util.isTensorInList(La,Pb)||La.dispose();return[2,{value:Ya,done:!1}]}})})};
return wa}(F);W=function(cb){function wa(){var Aa=cb.call(this)||this;Aa.outputQueue=new M;Aa.lastRead=Promise.resolve({value:null,done:!1});return Aa}t(wa,cb);wa.prototype.next=function(){return r(this,void 0,void 0,function(){var Aa=this;return u(this,function(lb){this.lastRead=this.lastRead.then(function(){return Aa.serialNext()});return[2,this.lastRead]})})};wa.prototype.serialNext=function(){return r(this,void 0,void 0,function(){return u(this,function(Aa){switch(Aa.label){case 0:return 0!==
this.outputQueue.length()?[3,2]:[4,this.pump()];case 1:return Aa.sent()?[3,0]:[2,{value:null,done:!0}];case 2:return[2,{value:this.outputQueue.shift(),done:!1}]}})})};return wa}(F);var pa=function(cb){function wa(Aa,lb){var Ya=cb.call(this)||this;Ya.upstream=Aa;Ya.transform=lb;return Ya}t(wa,cb);wa.prototype.summary=function(){return this.upstream.summary()+" -\x3e Flatmap"};wa.prototype.pump=function(){return r(this,void 0,void 0,function(){var Aa,lb,Ya,Pb,tb,bb,La;return u(this,function(Fb){switch(Fb.label){case 0:return[4,
this.upstream.next()];case 1:Aa=Fb.sent();if(Aa.done)return[2,!1];lb=w.tensor_util.getTensorsInContainer(Aa.value);Ya=this.transform(Aa.value);Pb=w.tensor_util.getTensorsInContainer(Ya);this.outputQueue.pushAll(Ya);tb=0;for(bb=lb;tb<bb.length;tb++)La=bb[tb],w.tensor_util.isTensorInList(La,Pb)||La.dispose();return[2,!0]}})})};return wa}(W),fa=function(cb){function wa(Aa,lb){var Ya=cb.call(this)||this;Ya.baseErrorHandler=lb;Ya.lastRead=null;Ya.iterator=null;Ya.moreIterators=Aa;return Ya}t(wa,cb);wa.prototype.summary=
function(){return"TODO: fill in upstream of chained summaries -\x3e Chained"};wa.prototype.next=function(){return r(this,void 0,void 0,function(){return u(this,function(Aa){this.lastRead=this.readFromChain(this.lastRead);return[2,this.lastRead]})})};wa.prototype.readFromChain=function(Aa){return r(this,void 0,void 0,function(){var lb,Ya;return u(this,function(Pb){switch(Pb.label){case 0:return[4,Aa];case 1:return Pb.sent(),null!=this.iterator?[3,3]:[4,this.moreIterators.next()];case 2:lb=Pb.sent();
if(lb.done)return[2,{value:null,done:!0}];this.iterator=lb.value;null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler));Pb.label=3;case 3:return[4,this.iterator.next()];case 4:return Ya=Pb.sent(),Ya.done?(this.iterator=null,[2,this.readFromChain(Aa)]):[2,Ya]}})})};return wa}(F),ta;(function(cb){cb[cb.FAIL=0]="FAIL";cb[cb.SHORTEST=1]="SHORTEST";cb[cb.LONGEST=2]="LONGEST"})(ta||(ta={}));var ma=function(cb){function wa(Aa,lb){void 0===lb&&(lb=ta.FAIL);var Ya=cb.call(this)||
this;Ya.iterators=Aa;Ya.mismatchMode=lb;Ya.count=0;Ya.currentPromise=null;return Ya}t(wa,cb);wa.prototype.summary=function(){return"{TODO: fill in upstream of zip summaries} -\x3e Zip"};wa.prototype.nextState=function(Aa){return r(this,void 0,void 0,function(){function lb(bb){return bb instanceof F?{value:bb.next().then(function(La){Ya++;La.done&&Pb++;return La.value}),recurse:!1}:{value:null,recurse:!0}}var Ya,Pb,tb;return u(this,function(bb){switch(bb.label){case 0:return[4,Aa];case 1:return bb.sent(),
Pb=Ya=0,[4,g(this.iterators,lb)];case 2:tb=bb.sent();if(Ya===Pb)return[2,{value:null,done:!0}];if(0<Pb)switch(this.mismatchMode){case ta.FAIL:throw Error("Zipped streams should have the same length. Mismatched at element "+(this.count+"."));case ta.SHORTEST:return[2,{value:null,done:!0}]}this.count++;return[2,{value:tb,done:!1}]}})})};wa.prototype.next=function(){return r(this,void 0,void 0,function(){return u(this,function(Aa){this.currentPromise=this.nextState(this.currentPromise);return[2,this.currentPromise]})})};
return wa}(F),ja=function(cb){function wa(Aa,lb){var Ya=cb.call(this)||this;Ya.upstream=Aa;Ya.bufferSize=lb;Ya.buffer=new V(lb);return Ya}t(wa,cb);wa.prototype.summary=function(){return this.upstream.summary()+" -\x3e Prefetch"};wa.prototype.refill=function(){for(;!this.buffer.isFull();){var Aa=this.upstream.next();this.buffer.push(Aa)}};wa.prototype.next=function(){this.refill();return this.buffer.shift()};return wa}(F),qa=function(cb){function wa(Aa,lb,Ya){var Pb=cb.call(this,Aa,lb)||this;Pb.upstream=
Aa;Pb.windowSize=lb;Pb.upstreamExhausted=!1;Pb.random=Q(Ya||w.util.now().toString());Pb.lastRead=Promise.resolve({value:null,done:!1});return Pb}t(wa,cb);wa.prototype.next=function(){return r(this,void 0,void 0,function(){var Aa=this;return u(this,function(lb){this.lastRead=this.lastRead.then(function(){return Aa.serialNext()});return[2,this.lastRead]})})};wa.prototype.randomInt=function(Aa){return Math.floor(this.random()*Aa)};wa.prototype.chooseIndex=function(){return this.randomInt(this.buffer.length())};
wa.prototype.serialNext=function(){return r(this,void 0,void 0,function(){var Aa,lb;return u(this,function(Ya){switch(Ya.label){case 0:this.upstreamExhausted||this.refill(),Ya.label=1;case 1:if(this.buffer.isEmpty())return[3,3];Aa=this.chooseIndex();return[4,this.buffer.shuffleExcise(Aa)];case 2:lb=Ya.sent();if(lb.done)this.upstreamExhausted=!0;else return this.refill(),[2,lb];return[3,1];case 3:return[2,{value:null,done:!0}]}})})};return wa}(ja),Fa=function(){function cb(){this.size=null}cb.prototype.batch=
function(wa,Aa){var lb=this;void 0===Aa&&(Aa=!0);var Ya=this;w.util.assert(0<wa,function(){return"batchSize needs to be positive, but it is\n      "+wa});return m(function(){return r(lb,void 0,void 0,function(){return u(this,function(Pb){switch(Pb.label){case 0:return[4,Ya.iterator()];case 1:return[2,Pb.sent().columnMajorBatch(wa,Aa,n)]}})})},Infinity===this.size||null==this.size?this.size:Aa?Math.ceil(this.size/wa):Math.floor(this.size/wa))};cb.prototype.concatenate=function(wa){var Aa=this,lb=this;
return m(function(){return r(Aa,void 0,void 0,function(){var Ya,Pb;return u(this,function(tb){switch(tb.label){case 0:return[4,lb.iterator()];case 1:return Pb=(Ya=tb.sent()).concatenate,[4,wa.iterator()];case 2:return[2,Pb.apply(Ya,[tb.sent()])]}})})},Infinity===this.size||Infinity===wa.size?Infinity:null!=this.size&&null!=wa.size?this.size+wa.size:null)};cb.prototype.filter=function(wa){var Aa=this,lb=this;return m(function(){return r(Aa,void 0,void 0,function(){return u(this,function(Ya){switch(Ya.label){case 0:return[4,
lb.iterator()];case 1:return[2,Ya.sent().filter(function(Pb){return w.tidy(function(){return wa(Pb)})})]}})})},Infinity===this.size?Infinity:null)};cb.prototype.forEachAsync=function(wa){return r(this,void 0,void 0,function(){return u(this,function(Aa){switch(Aa.label){case 0:return[4,this.iterator()];case 1:return[2,Aa.sent().forEachAsync(wa)]}})})};cb.prototype.map=function(wa){var Aa=this,lb=this;return m(function(){return r(Aa,void 0,void 0,function(){return u(this,function(Ya){switch(Ya.label){case 0:return[4,
lb.iterator()];case 1:return[2,Ya.sent().map(function(Pb){return w.tidy(function(){return wa(Pb)})})]}})})},this.size)};cb.prototype.mapAsync=function(wa){var Aa=this,lb=this;return m(function(){return r(Aa,void 0,void 0,function(){return u(this,function(Ya){switch(Ya.label){case 0:return[4,lb.iterator()];case 1:return[2,Ya.sent().mapAsync(wa)]}})})},this.size)};cb.prototype.prefetch=function(wa){var Aa=this;if(null==wa)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
var lb=this;return m(function(){return r(Aa,void 0,void 0,function(){return u(this,function(Ya){switch(Ya.label){case 0:return[4,lb.iterator()];case 1:return[2,Ya.sent().prefetch(wa)]}})})},this.size)};cb.prototype.repeat=function(wa){var Aa=this,lb=this;return m(function(){return r(Aa,void 0,void 0,function(){var Ya,Pb=this;return u(this,function(tb){Ya=new H(function(){return r(Pb,void 0,void 0,function(){var bb;return u(this,function(La){switch(La.label){case 0:return bb={},[4,lb.iterator()];case 1:return[2,
(bb.value=La.sent(),bb.done=!1,bb)]}})})});return[2,c(Ya.take(wa))]})})},null!=this.size&&0<wa?this.size*wa:0===wa?0:null!=this.size&&(void 0===wa||0>wa)?Infinity:null)};cb.prototype.skip=function(wa){var Aa=this,lb=this;return m(function(){return r(Aa,void 0,void 0,function(){return u(this,function(Ya){switch(Ya.label){case 0:return[4,lb.iterator()];case 1:return[2,Ya.sent().skip(wa)]}})})},null!=this.size&&0<=wa&&this.size>=wa?this.size-wa:null!=this.size&&(this.size<wa||void 0===wa||0>wa)?0:null)};
cb.prototype.shuffle=function(wa,Aa,lb){var Ya=this;void 0===lb&&(lb=!0);if(null==wa||0>wa){if(null==this.size)throw new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.");throw new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting bufferSize to the dataset size ("+(this.size+" elements)"));}var Pb=this,tb=Q(Aa||w.util.now().toString());return m(function(){return r(Ya,
void 0,void 0,function(){var bb;return u(this,function(La){switch(La.label){case 0:return bb=tb.int32(),lb&&(bb+=tb.int32()),[4,Pb.iterator()];case 1:return[2,La.sent().shuffle(wa,bb.toString())]}})})},this.size)};cb.prototype.take=function(wa){var Aa=this,lb=this;return m(function(){return r(Aa,void 0,void 0,function(){return u(this,function(Ya){switch(Ya.label){case 0:return[4,lb.iterator()];case 1:return[2,Ya.sent().take(wa)]}})})},null!=this.size&&this.size>wa?wa:null!=this.size&&this.size<=wa?
this.size:null)};cb.prototype.toArray=function(){return r(this,void 0,void 0,function(){return u(this,function(wa){switch(wa.label){case 0:if(Infinity===this.size)throw Error("Can not convert infinite data stream to array.");return[4,this.iterator()];case 1:return[2,wa.sent().toArray()]}})})};cb.prototype.toArrayForTest=function(){return r(this,void 0,void 0,function(){return u(this,function(wa){switch(wa.label){case 0:if(Infinity===this.size)throw Error("Can not convert infinite data stream to array.");
return[4,this.iterator()];case 1:return[2,wa.sent().toArrayForTest()]}})})};cb.MAX_BUFFER_SIZE=1E4;return cb}(),ua=function(cb){function wa(Aa){var lb=cb.call(this)||this;lb.input=Aa;return lb}t(wa,cb);wa.prototype.iterator=function(){return r(this,void 0,void 0,function(){var Aa,lb,Ya;return u(this,function(Pb){switch(Pb.label){case 0:return[4,this.input.iterator()];case 1:return Aa=Pb.sent(),lb=Aa.decodeUTF8(),Ya=lb.split("\n").map(function(tb){tb.endsWith("\r")&&(tb=tb.slice(0,-1));return tb}),
[2,Ya]}})})};return wa}(Fa),Ra=Symbol("out"),Ia=Symbol("field"),oa=Symbol("quote"),Ba=Symbol("quoteafterquote"),gb=Symbol("quoteinquote"),Va=function(cb){function wa(Aa,lb){var Ya=cb.call(this)||this;Ya.input=Aa;Ya.hasHeader=!0;Ya.fullColumnNames=null;Ya.columnNamesValidated=!1;Ya.columnConfigs=null;Ya.configuredColumnsOnly=!1;Ya.delimiter=",";Ya.delimWhitespace=!1;Ya.base=new ua(Aa);lb||(lb={});Ya.hasHeader=!1===lb.hasHeader?!1:!0;Ya.fullColumnNames=lb.columnNames;Ya.columnConfigs=lb.columnConfigs;
Ya.configuredColumnsOnly=lb.configuredColumnsOnly;lb.delimWhitespace?(w.util.assert(null==lb.delimiter,function(){return"Delimiter should not be provided when delimWhitespace is true."}),Ya.delimWhitespace=!0,Ya.delimiter=" "):Ya.delimiter=lb.delimiter?lb.delimiter:",";return Ya}t(wa,cb);wa.prototype.columnNames=function(){return r(this,void 0,void 0,function(){return u(this,function(Aa){switch(Aa.label){case 0:return this.columnNamesValidated?[3,2]:[4,this.setColumnNames()];case 1:Aa.sent(),Aa.label=
2;case 2:return[2,this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames]}})})};wa.prototype.setColumnNames=function(){return r(this,void 0,void 0,function(){var Aa,lb,Ya,Pb,tb,bb,La,Fb=this;return u(this,function(vb){switch(vb.label){case 0:return[4,this.maybeReadHeaderLine()];case 1:Aa=vb.sent();if(this.fullColumnNames||Aa)this.fullColumnNames&&Aa&&w.util.assert(Aa.length===this.fullColumnNames.length,function(){return"The length of provided columnNames ("+Fb.fullColumnNames.length.toString()+
") does not match the length of the header line read from file ("+Aa.length.toString()+")."});else throw Error("Column names must be provided if there is no header line.");this.fullColumnNames||(this.fullColumnNames=Aa);lb=this.fullColumnNames.reduce(function(Xb,Mc){Xb[Mc]=Xb[Mc]+1||1;return Xb},{});Ya=Object.keys(lb).filter(function(Xb){return 1<lb[Xb]});w.util.assert(0===Ya.length,function(){return"Duplicate column names found: "+Ya.toString()});if(this.columnConfigs)for(Pb=0,tb=Object.keys(this.columnConfigs);Pb<
tb.length;Pb++)if(bb=tb[Pb],La=this.fullColumnNames.indexOf(bb),-1===La)throw Error('The key "'+bb+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0;return[2]}})})};wa.prototype.maybeReadHeaderLine=function(){return r(this,void 0,void 0,function(){var Aa,lb,Ya,Pb;return u(this,function(tb){switch(tb.label){case 0:return this.hasHeader?[4,this.base.iterator()]:[3,3];case 1:return Aa=tb.sent(),[4,Aa.next()];case 2:lb=
tb.sent();if(lb.done)throw Error("No data was found for CSV parsing.");Ya=lb.value;Pb=this.parseRow(Ya,!1);return[2,Pb];case 3:return[2,null]}})})};wa.prototype.iterator=function(){return r(this,void 0,void 0,function(){var Aa,lb=this;return u(this,function(Ya){switch(Ya.label){case 0:return this.columnNamesValidated?[3,2]:[4,this.setColumnNames()];case 1:Ya.sent(),Ya.label=2;case 2:return[4,this.base.iterator()];case 3:return Aa=Ya.sent(),this.hasHeader&&(Aa=Aa.skip(1)),[2,Aa.map(function(Pb){return lb.makeDataElement(Pb)})]}})})};
wa.prototype.makeDataElement=function(Aa){for(var lb=this.parseRow(Aa),Ya={},Pb={},tb=0;tb<this.fullColumnNames.length;tb++){var bb=this.fullColumnNames[tb],La=this.columnConfigs?this.columnConfigs[bb]:null;if(!this.configuredColumnsOnly||La){var Fb=lb[tb];if(""===Fb)if(La&&void 0!==La.default)Fb=La.default;else{if(La&&(La.required||La.isLabel))throw Error("Required column "+bb+" is empty in this line: "+Aa);Fb=void 0}else{var vb=Number(Fb);if(isNaN(vb))Fb=La&&"bool"===La.dtype?this.getBoolean(Fb):
Fb;else if(La&&La.dtype)switch(La.dtype){case "float32":Fb=vb;break;case "int32":Fb=Math.floor(vb);break;case "bool":Fb=this.getBoolean(Fb);break;default:Fb=vb}else Fb=vb}La&&La.isLabel?Pb[bb]=Fb:Ya[bb]=Fb}}return 0===Object.keys(Pb).length?Ya:{xs:Ya,ys:Pb}};wa.prototype.getBoolean=function(Aa){return"1"===Aa||"true"===Aa.toLowerCase()?1:0};wa.prototype.parseRow=function(Aa,lb){void 0===lb&&(lb=!0);for(var Ya=[],Pb=0,tb=Aa.length,bb=Ra,La=0;La<tb;La++)switch(bb){case Ra:switch(Aa.charAt(La)){case '"':Pb=
La+1;bb=oa;break;case this.delimiter:Pb=La+1;if(" "===this.delimiter&&this.delimWhitespace)break;Ya.push("");bb=Ra;break;default:bb=Ia,Pb=La}break;case Ia:switch(Aa.charAt(La)){case this.delimiter:Ya.push(Aa.substring(Pb,La)),bb=Ra,Pb=La+1}break;case oa:switch(Aa.charAt(La)){case '"':bb=Ba}break;case Ba:switch(Aa.charAt(La)){case this.delimiter:Ya.push(Aa.substring(Pb,La-1));bb=Ra;Pb=La+1;break;case '"':bb=oa;break;default:bb=gb}break;case gb:switch(Aa.charAt(La)){case '"':bb=oa}}bb===Ba?Ya.push(Aa.substring(Pb,
tb-1)):Ya.push(Aa.substring(Pb));if(lb&&Ya.length!==this.fullColumnNames.length)throw Error("Invalid row in csv file. Should have "+this.fullColumnNames.length+" elements in a row, but got "+Ya);return Ya};return wa}(Fa),Ma=function(cb){function wa(Aa){var lb=cb.call(this)||this;lb.microphoneConfig=Aa;lb.isClosed=!1;lb.fftSize=Aa.fftSize||1024;var Ya=Math.log2(lb.fftSize);if(0>lb.fftSize||4>Ya||14<Ya||!Number.isInteger(Ya))throw Error("Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got "+
lb.fftSize);lb.numFrames=Aa.numFramesPerSpectrogram||43;lb.sampleRateHz=Aa.sampleRateHz;lb.columnTruncateLength=Aa.columnTruncateLength||lb.fftSize;lb.audioTrackConstraints=Aa.audioTrackConstraints;lb.smoothingTimeConstant=Aa.smoothingTimeConstant||0;lb.includeSpectrogram=!1===Aa.includeSpectrogram?!1:!0;lb.includeWaveform=!0===Aa.includeWaveform?!0:!1;if(!lb.includeSpectrogram&&!lb.includeWaveform)throw Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.");
return lb}t(wa,cb);wa.prototype.summary=function(){return"microphone"};wa.create=function(Aa){void 0===Aa&&(Aa={});return r(this,void 0,void 0,function(){var lb;return u(this,function(Ya){switch(Ya.label){case 0:if(w.env().get("IS_NODE"))throw Error("microphone API is only supported in browser environment.");lb=new wa(Aa);return[4,lb.start()];case 1:return Ya.sent(),[2,lb]}})})};wa.prototype.start=function(){return r(this,void 0,void 0,function(){var Aa,lb,Ya,Pb;return u(this,function(tb){switch(tb.label){case 0:return tb.trys.push([0,
2,,3]),Aa=this,[4,navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints?!0:this.audioTrackConstraints,video:!1})];case 1:return Aa.stream=tb.sent(),[3,3];case 2:throw lb=tb.sent(),Error("Error thrown while initializing video stream: "+lb.message);case 3:if(!this.stream)throw Error("Could not obtain audio from microphone.");Ya=window.AudioContext||window.webkitAudioContext;this.audioContext=new Ya;if(!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==
this.sampleRateHz)throw Error("Mismatch in sampling rate: Expected: "+(this.sampleRateHz+"; Actual: ")+this.audioContext.sampleRate);Pb=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser();this.analyser.fftSize=2*this.fftSize;this.analyser.smoothingTimeConstant=this.smoothingTimeConstant;Pb.connect(this.analyser);this.freqData=new Float32Array(this.fftSize);this.timeData=new Float32Array(this.fftSize);return[2]}})})};wa.prototype.next=function(){return r(this,
void 0,void 0,function(){var Aa,lb,Ya,Pb,tb;return u(this,function(bb){switch(bb.label){case 0:return this.isClosed?[2,{value:null,done:!0}]:[4,this.getAudioData()];case 1:return Ya=bb.sent(),this.includeSpectrogram&&(Pb=this.flattenQueue(Ya.freqDataQueue),Aa=this.getTensorFromAudioDataArray(Pb,[this.numFrames,this.columnTruncateLength,1])),this.includeWaveform&&(tb=this.flattenQueue(Ya.timeDataQueue),lb=this.getTensorFromAudioDataArray(tb,[this.numFrames*this.fftSize,1])),[2,{value:{spectrogram:Aa,
waveform:lb},done:!1}]}})})};wa.prototype.capture=function(){return r(this,void 0,void 0,function(){return u(this,function(Aa){switch(Aa.label){case 0:return[4,this.next()];case 1:return[2,Aa.sent().value]}})})};wa.prototype.getAudioData=function(){return r(this,void 0,void 0,function(){var Aa,lb,Ya,Pb=this;return u(this,function(tb){Aa=[];lb=[];Ya=0;return[2,new Promise(function(bb){var La=setInterval(function(){Pb.includeSpectrogram&&(Pb.analyser.getFloatFrequencyData(Pb.freqData),-Infinity===Pb.freqData[0]&&
bb({freqDataQueue:Aa,timeDataQueue:lb}),Aa.push(Pb.freqData.slice(0,Pb.columnTruncateLength)));Pb.includeWaveform&&(Pb.analyser.getFloatTimeDomainData(Pb.timeData),lb.push(Pb.timeData.slice()));++Ya===Pb.numFrames&&(clearInterval(La),bb({freqDataQueue:Aa,timeDataQueue:lb}))},Pb.fftSize/Pb.sampleRateHz*1E3)})]})})};wa.prototype.stop=function(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&0<this.stream.getTracks().length&&this.stream.getTracks()[0].stop())};
wa.prototype.toArray=function(){throw Error("Can not convert infinite audio stream to array.");};wa.prototype.getSampleRate=function(){return this.sampleRateHz};wa.prototype.flattenQueue=function(Aa){var lb=Aa[0].length,Ya=new Float32Array(Aa.length*lb);Aa.forEach(function(Pb,tb){return Ya.set(Pb,tb*lb)});return Ya};wa.prototype.getTensorFromAudioDataArray=function(Aa,lb){var Ya=new Float32Array(w.util.sizeFromShape(lb));Ya.set(Aa,Ya.length-Aa.length);return w.tensor(Ya,lb)};return wa}(F),ib=function(cb){function wa(Aa,
lb){var Ya=cb.call(this)||this;Ya.webcamVideoElement=Aa;Ya.webcamConfig=lb;Ya.isClosed=!0;Ya.resize=!1;if(Ya.needToResize())if(Ya.resize=!0,Ya.cropSize=[Ya.webcamConfig.resizeHeight,Ya.webcamConfig.resizeWidth],Ya.cropBoxInd=w.tensor1d([0],"int32"),Ya.webcamConfig.centerCrop){Aa=1*Ya.webcamConfig.resizeWidth/Ya.webcamVideoElement.width;lb=1*Ya.webcamConfig.resizeHeight/Ya.webcamVideoElement.height;var Pb=(1-Aa)/2,tb=(1-lb)/2;Ya.cropBox=w.tensor2d([tb,Pb,lb+tb,Pb+Aa],[1,4])}else Ya.cropBox=w.tensor2d([0,
0,1,1],[1,4]);return Ya}t(wa,cb);wa.prototype.summary=function(){return"webcam"};wa.create=function(Aa,lb){void 0===lb&&(lb={});return r(this,void 0,void 0,function(){var Ya;return u(this,function(Pb){switch(Pb.label){case 0:if(w.env().get("IS_NODE"))throw Error("tf.data.webcam is only supported in browser environment.");if(!Aa){Aa=document.createElement("video");if(!lb.resizeWidth||!lb.resizeHeight)throw Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");
Aa.width=lb.resizeWidth;Aa.height=lb.resizeHeight}Ya=new wa(Aa,lb);return[4,Ya.start()];case 1:return Pb.sent(),[2,Ya]}})})};wa.prototype.start=function(){return r(this,void 0,void 0,function(){var Aa,lb,Ya=this;return u(this,function(Pb){switch(Pb.label){case 0:this.webcamConfig.facingMode&&w.util.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,function(){return"Invalid webcam facing mode: "+Ya.webcamConfig.facingMode+". Please provide 'user' or 'environment'"}),
Pb.label=1;case 1:return Pb.trys.push([1,3,,4]),Aa=this,[4,navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})];case 2:return Aa.stream=Pb.sent(),[3,4];case 3:throw lb=Pb.sent(),lb.message="Error thrown while initializing video stream: "+lb.message,lb;case 4:if(!this.stream)throw Error("Could not obtain video from webcam.");
try{this.webcamVideoElement.srcObject=this.stream}catch(tb){console.log(tb),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}this.webcamVideoElement.play();this.isClosed=!1;return[2,new Promise(function(tb){Ya.webcamVideoElement.onloadedmetadata=function(){tb()}})]}})})};wa.prototype.next=function(){return r(this,void 0,void 0,function(){var Aa;return u(this,function(lb){if(this.isClosed)return[2,{value:null,done:!0}];try{Aa=w.browser.fromPixels(this.webcamVideoElement)}catch(Ya){throw Error("Error thrown converting video to pixels: "+
JSON.stringify(Ya));}if(this.resize)try{return[2,{value:this.cropAndResizeFrame(Aa),done:!1}]}catch(Ya){throw Error("Error thrown cropping the video: "+Ya.message);}finally{Aa.dispose()}else return[2,{value:Aa,done:!1}];return[2]})})};wa.prototype.needToResize=function(){return this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight)?!0:!1};wa.prototype.cropAndResizeFrame=
function(Aa){var lb=this;return w.tidy(function(){var Ya=Aa.toFloat().expandDims(0);Ya=w.image.cropAndResize(Ya,lb.cropBox,lb.cropBoxInd,lb.cropSize,"bilinear");return Ya.reshape(Ya.shape.slice(1))})};wa.prototype.capture=function(){return r(this,void 0,void 0,function(){return u(this,function(Aa){switch(Aa.label){case 0:return[4,this.next()];case 1:return[2,Aa.sent().value]}})})};wa.prototype.stop=function(){this.stream.getTracks().forEach(function(Aa){return Aa.stop()});try{this.webcamVideoElement.srcObject=
null}catch(Aa){console.log(Aa),this.webcamVideoElement.src=null}this.isClosed=!0};wa.prototype.toArray=function(){throw Error("Can not convert infinite video stream to array.");};return wa}(F);la=function(){return function(){}}();z=function(cb){function wa(){return null!==cb&&cb.apply(this,arguments)||this}t(wa,cb);wa.prototype.split=function(Aa){return new Ja(this,Aa)};return wa}(F);var Ja=function(cb){function wa(Aa,lb){var Ya=cb.call(this)||this;Ya.upstream=Aa;Ya.impl=new Sa(Aa,lb);return Ya}t(wa,
cb);wa.prototype.summary=function(){return this.impl.summary()};wa.prototype.next=function(){return r(this,void 0,void 0,function(){return u(this,function(Aa){return[2,this.impl.next()]})})};return wa}(z),Sa=function(cb){function wa(Aa,lb){var Ya=cb.call(this)||this;Ya.upstream=Aa;Ya.separator=lb;Ya.carryover="";return Ya}t(wa,cb);wa.prototype.summary=function(){return this.upstream.summary()+" -\x3e Split('"+this.separator+"')"};wa.prototype.pump=function(){return r(this,void 0,void 0,function(){var Aa,
lb,Ya,Pb,tb;return u(this,function(bb){switch(bb.label){case 0:return[4,this.upstream.next()];case 1:Aa=bb.sent();if(Aa.done){if(""===this.carryover)return[2,!1];this.outputQueue.push(this.carryover);this.carryover="";return[2,!0]}lb=Aa.value.split(this.separator);lb[0]=this.carryover+lb[0];Ya=0;for(Pb=lb.slice(0,-1);Ya<Pb.length;Ya++)tb=Pb[Ya],this.outputQueue.push(tb);this.carryover=lb[lb.length-1];return[2,!0]}})})};return wa}(W);K=function(cb){function wa(){return null!==cb&&cb.apply(this,arguments)||
this}t(wa,cb);wa.prototype.decodeUTF8=function(){return new S(this)};return wa}(F);var S=function(cb){function wa(Aa){var lb=cb.call(this)||this;lb.upstream=Aa;lb.impl=new ha(Aa);return lb}t(wa,cb);wa.prototype.summary=function(){return this.impl.summary()};wa.prototype.next=function(){return r(this,void 0,void 0,function(){return u(this,function(Aa){return[2,this.impl.next()]})})};return wa}(z),ha=function(cb){function wa(Aa){var lb=cb.call(this)||this;lb.upstream=Aa;w.env().get("IS_BROWSER")?lb.decoder=
new TextDecoder("utf-8"):(Aa=A(35).StringDecoder,lb.decoder=new Aa("utf8"));return lb}t(wa,cb);wa.prototype.summary=function(){return this.upstream.summary()+" -\x3e Utf8"};wa.prototype.pump=function(){return r(this,void 0,void 0,function(){var Aa,lb,Ya;return u(this,function(Pb){switch(Pb.label){case 0:return[4,this.upstream.next()];case 1:Aa=Pb.sent();if(Aa.done)return[2,!1];lb=Aa.value;Ya=w.env().get("IS_BROWSER")?this.decoder.decode(lb,{stream:!0}):this.decoder.write(q.from(lb.buffer));this.outputQueue.push(Ya);
return[2,!0]}})})};return wa}(W),ya=function(cb){function wa(Aa,lb){void 0===lb&&(lb={});var Ya=cb.call(this)||this;Ya.file=Aa;Ya.options=lb;w.util.assert(Aa instanceof Uint8Array||(w.env().get("IS_BROWSER")?Aa instanceof File||Aa instanceof Blob:!1),function(){return"FileChunkIterator only supports File, Blob and Uint8Array right now."});Ya.offset=lb.offset||0;Ya.chunkSize=lb.chunkSize||1048576;return Ya}t(wa,cb);wa.prototype.summary=function(){return"FileChunks "+this.file};wa.prototype.next=function(){return r(this,
void 0,void 0,function(){var Aa,lb,Ya=this;return u(this,function(Pb){switch(Pb.label){case 0:if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return[2,{value:null,done:!0}];Aa=new Promise(function(tb,bb){var La=Ya.offset+Ya.chunkSize;if(Ya.file instanceof Uint8Array)tb(new Uint8Array(Ya.file.slice(Ya.offset,La)));else{var Fb=new FileReader;Fb.onload=function(Xb){Xb=Fb.result;Xb instanceof ArrayBuffer&&(Xb=new Uint8Array(Xb));if(!(Xb instanceof Uint8Array))return bb(new TypeError("FileReader returned unknown type."));
tb(Xb)};Fb.onabort=function(Xb){return bb(Error("Aborted"))};Fb.onerror=function(Xb){return bb(Error(Xb.type))};var vb=Ya.file.slice(Ya.offset,La);Fb.readAsArrayBuffer(vb)}Ya.offset=La});lb={};return[4,Aa];case 1:return[2,(lb.value=Pb.sent(),lb.done=!1,lb)]}})})};return wa}(K),Qa=function(cb){function wa(Aa,lb){void 0===lb&&(lb={});var Ya=cb.call(this)||this;Ya.input=Aa;Ya.options=lb;return Ya}t(wa,cb);wa.prototype.iterator=function(){return r(this,void 0,void 0,function(){var Aa;return u(this,function(lb){p(this.input)&&
w.env().get("IS_NODE")&&(Aa=A(35),this.input=Aa.readFileSync(this.input.substr(7)));return[2,new ya(this.input,this.options)]})})};return wa}(la),$a=function(cb){function wa(Aa,lb){void 0===lb&&(lb={});var Ya=cb.call(this)||this;Ya.url=Aa;Ya.fileOptions=lb;return Ya}t(wa,cb);wa.prototype.iterator=function(){return r(this,void 0,void 0,function(){return u(this,function(Aa){return p(this.url)?[2,(new Qa(this.url,this.fileOptions)).iterator()]:[2,k(this.url,this.fileOptions)]})})};return wa}(la);v.CSVDataset=
Va;v.Dataset=Fa;v.FileDataSource=Qa;v.TextLineDataset=ua;v.URLDataSource=$a;v.array=function(cb){var wa=this;return m(function(){return r(wa,void 0,void 0,function(){return u(this,function(Aa){return[2,new D(cb)]})})},cb.length)};v.csv=function(cb,wa){void 0===wa&&(wa={});return new Va(new $a(cb),wa)};v.func=function(cb){var wa=this,Aa=new H(cb);return m(function(){return r(wa,void 0,void 0,function(){return u(this,function(lb){return[2,Aa]})})})};v.generator=function(cb){var wa=this;return m(function(){return r(wa,
void 0,void 0,function(){var Aa;return u(this,function(lb){switch(lb.label){case 0:return[4,cb()];case 1:return Aa=lb.sent(),[2,new H(function(){return Aa.next()})]}})})})};v.microphone=function(cb){return r(this,void 0,void 0,function(){return u(this,function(wa){return[2,Ma.create(cb)]})})};v.version_data="2.7.0";v.webcam=function(cb,wa){return r(this,void 0,void 0,function(){return u(this,function(Aa){return[2,ib.create(cb,wa)]})})};v.zip=function(cb){var wa=this;if(!d(cb))throw Error("The argument to zip() must be an object or array.");
if(Array.isArray(cb))for(var Aa=0;Aa<cb.length;Aa++)var lb=null==lb?cb[Aa].size:Math.min(lb,cb[Aa].size);else if(cb instanceof Object)for(Aa in cb)lb=null==lb?cb[Aa].size:Math.min(lb,cb[Aa].size);return m(function(){return r(wa,void 0,void 0,function(){var Ya;return u(this,function(Pb){switch(Pb.label){case 0:return[4,g(cb,function(tb){if(tb instanceof Fa)return{value:tb.iterator(),recurse:!1};if(d(tb))return{value:null,recurse:!0};throw Error("Leaves of the structure passed to zip() must be Datasets, not primitives.");
})];case 1:return Ya=Pb.sent(),[2,l(Ya,ta.SHORTEST)]}})})},lb)}};
shadow$provide[952]=function(W,A,la,v){(function(t,r,u){function f(g){var d=this,h=e();d.next=function(){var c=2091639*d.s0+2.3283064365386963E-10*d.c;d.s0=d.s1;d.s1=d.s2;return d.s2=c-(d.c=c|0)};d.c=1;d.s0=h(" ");d.s1=h(" ");d.s2=h(" ");d.s0-=h(g);0>d.s0&&(d.s0+=1);d.s1-=h(g);0>d.s1&&(d.s1+=1);d.s2-=h(g);0>d.s2&&(d.s2+=1);h=null}function a(g,d){d.c=g.c;d.s0=g.s0;d.s1=g.s1;d.s2=g.s2;return d}function b(g,d){var h=new f(g);g=d&&d.state;var c=h.next;c.int32=function(){return 4294967296*h.next()|0};
c.double=function(){return c()+1.1102230246251565E-16*(2097152*c()|0)};c.quick=c;g&&("object"==typeof g&&a(g,h),c.state=function(){return a(h,{})});return c}function e(){var g=4022871197;return function(d){d=d.toString();for(var h=0;h<d.length;h++){g+=d.charCodeAt(h);var c=.02519603282416938*g;g=c>>>0;c-=g;c*=g;g=c>>>0;c-=g;g+=4294967296*c}return 2.3283064365386963E-10*(g>>>0)}}r&&r.exports?r.exports=b:u&&u.amd?u(function(){return b}):this.alea=b})(this,"object"==typeof la&&la,"function"==typeof define&&
define)};
shadow$provide[953]=function(W,A,la,v){(function(t,r,u){function f(e){var g=this,d="";g.x=0;g.y=0;g.z=0;g.w=0;g.next=function(){var h=g.x^g.x<<11;g.x=g.y;g.y=g.z;g.z=g.w;return g.w=g.w^g.w>>>19^h^h>>>8};e===(e|0)?g.x=e:d+=e;for(e=0;e<d.length+64;e++)g.x^=d.charCodeAt(e)|0,g.next()}function a(e,g){g.x=e.x;g.y=e.y;g.z=e.z;g.w=e.w;return g}function b(e,g){var d=new f(e);e=g&&g.state;g=function(){return(d.next()>>>0)/4294967296};g.double=function(){do{var h=d.next()>>>11,c=(d.next()>>>0)/4294967296;h=
(h+c)/2097152}while(0===h);return h};g.int32=d.next;g.quick=g;e&&("object"==typeof e&&a(e,d),g.state=function(){return a(d,{})});return g}r&&r.exports?r.exports=b:u&&u.amd?u(function(){return b}):this.xor128=b})(this,"object"==typeof la&&la,"function"==typeof define&&define)};
shadow$provide[954]=function(W,A,la,v){(function(t,r,u){function f(e){var g=this,d="";g.next=function(){var h=g.x^g.x>>>2;g.x=g.y;g.y=g.z;g.z=g.w;g.w=g.v;return(g.d=g.d+362437|0)+(g.v=g.v^g.v<<4^h^h<<1)|0};g.x=0;g.y=0;g.z=0;g.w=0;g.v=0;e===(e|0)?g.x=e:d+=e;for(e=0;e<d.length+64;e++)g.x^=d.charCodeAt(e)|0,e==d.length&&(g.d=g.x<<10^g.x>>>4),g.next()}function a(e,g){g.x=e.x;g.y=e.y;g.z=e.z;g.w=e.w;g.v=e.v;g.d=e.d;return g}function b(e,g){var d=new f(e);e=g&&g.state;g=function(){return(d.next()>>>0)/
4294967296};g.double=function(){do{var h=d.next()>>>11,c=(d.next()>>>0)/4294967296;h=(h+c)/2097152}while(0===h);return h};g.int32=d.next;g.quick=g;e&&("object"==typeof e&&a(e,d),g.state=function(){return a(d,{})});return g}r&&r.exports?r.exports=b:u&&u.amd?u(function(){return b}):this.xorwow=b})(this,"object"==typeof la&&la,"function"==typeof define&&define)};
shadow$provide[955]=function(W,A,la,v){(function(t,r,u){function f(e){var g=this;g.next=function(){var d=g.x,h=g.i;var c=d[h];c^=c>>>7;var l=c^c<<24;c=d[h+1&7];l^=c^c>>>10;c=d[h+3&7];l^=c^c>>>3;c=d[h+4&7];l^=c^c<<7;c=d[h+7&7];c^=c<<13;l^=c^c<<9;d[h]=l;g.i=h+1&7;return l};(function(d,h){var c,l=[];if(h===(h|0))l[0]=h;else for(h=""+h,c=0;c<h.length;++c)l[c&7]=l[c&7]<<15^h.charCodeAt(c)+l[c+1&7]<<13;for(;8>l.length;)l.push(0);for(c=0;8>c&&0===l[c];++c);8==c&&(l[7]=-1);d.x=l;d.i=0;for(c=256;0<c;--c)d.next()})(g,
e)}function a(e,g){g.x=e.x.slice();g.i=e.i;return g}function b(e,g){null==e&&(e=+new Date);var d=new f(e);e=g&&g.state;g=function(){return(d.next()>>>0)/4294967296};g.double=function(){do{var h=d.next()>>>11,c=(d.next()>>>0)/4294967296;h=(h+c)/2097152}while(0===h);return h};g.int32=d.next;g.quick=g;e&&(e.x&&a(e,d),g.state=function(){return a(d,{})});return g}r&&r.exports?r.exports=b:u&&u.amd?u(function(){return b}):this.xorshift7=b})(this,"object"==typeof la&&la,"function"==typeof define&&define)};
shadow$provide[956]=function(W,A,la,v){(function(t,r,u){function f(e){var g=this;g.next=function(){var d=g.w,h=g.X,c=g.i;g.w=d=d+1640531527|0;var l=h[c+34&127];var m=h[c=c+1&127];l^=l<<13;m^=m<<17;l=h[c]=l^l>>>15^m^m>>>12;g.i=c;return l+(d^d>>>16)|0};(function(d,h){var c,l,m=[],n=128;if(h===(h|0)){var k=h;h=null}else h+="\x00",k=0,n=Math.max(n,h.length);var p=0;for(c=-32;c<n;++c)if(h&&(k^=h.charCodeAt((c+32)%h.length)),0===c&&(l=k),k^=k<<10,k^=k>>>15,k^=k<<4,k^=k>>>13,0<=c){l=l+1640531527|0;var q=
m[c&127]^=k+l;p=0==q?p+1:0}128<=p&&(m[(h&&h.length||0)&127]=-1);p=127;for(c=512;0<c;--c)k=m[p+34&127],q=m[p=p+1&127],k^=k<<13,q^=q<<17,k^=k>>>15,q^=q>>>12,m[p]=k^q;d.w=l;d.X=m;d.i=p})(g,e)}function a(e,g){g.i=e.i;g.w=e.w;g.X=e.X.slice();return g}function b(e,g){null==e&&(e=+new Date);var d=new f(e);e=g&&g.state;g=function(){return(d.next()>>>0)/4294967296};g.double=function(){do{var h=d.next()>>>11,c=(d.next()>>>0)/4294967296;h=(h+c)/2097152}while(0===h);return h};g.int32=d.next;g.quick=g;e&&(e.X&&
a(e,d),g.state=function(){return a(d,{})});return g}r&&r.exports?r.exports=b:u&&u.amd?u(function(){return b}):this.xor4096=b})(this,"object"==typeof la&&la,"function"==typeof define&&define)};
shadow$provide[957]=function(W,A,la,v){(function(t,r,u){function f(e){var g=this,d="";g.next=function(){var h=g.b,c=g.c,l=g.d,m=g.a;h=h<<25^h>>>7^c;c=c-l|0;l=l<<24^l>>>8^m;m=m-h|0;g.b=h=h<<20^h>>>12^c;g.c=c=c-l|0;g.d=l<<16^c>>>16^m;return g.a=m-h|0};g.a=0;g.b=0;g.c=-1640531527;g.d=1367130551;e===Math.floor(e)?(g.a=e/4294967296|0,g.b=e|0):d+=e;for(e=0;e<d.length+20;e++)g.b^=d.charCodeAt(e)|0,g.next()}function a(e,g){g.a=e.a;g.b=e.b;g.c=e.c;g.d=e.d;return g}function b(e,g){var d=new f(e);e=g&&g.state;
g=function(){return(d.next()>>>0)/4294967296};g.double=function(){do{var h=d.next()>>>11,c=(d.next()>>>0)/4294967296;h=(h+c)/2097152}while(0===h);return h};g.int32=d.next;g.quick=g;e&&("object"==typeof e&&a(e,d),g.state=function(){return a(d,{})});return g}r&&r.exports?r.exports=b:u&&u.amd?u(function(){return b}):this.tychei=b})(this,"object"==typeof la&&la,"function"==typeof define&&define)};
shadow$provide[958]=function(W,A,la,v){(function(t,r){function u(k,p,q){var w=[];p=1==p?{entropy:!0}:p||{};k=e(b(p.entropy?[k,d(t)]:null==k?g():k,3),w);var y=new f(w);w=function(){for(var C=y.g(6),z=c,K=0;C<l;)C=256*(C+K),z*=256,K=y.g(1);for(;C>=m;)C/=2,z/=2,K>>>=1;return(C+K)/z};w.int32=function(){return y.g(4)|0};w.quick=function(){return y.g(4)/4294967296};w.double=w;e(d(y.S),t);return(p.pass||q||function(C,z,K,J){J&&(J.S&&a(J,y),C.state=function(){return a(y,{})});return K?(r.random=C,z):C})(w,
k,"global"in p?p.global:this==r,p.state)}function f(k){var p,q=k.length,w=this,y=0,C=w.i=w.j=0,z=w.S=[];for(q||(k=[q++]);256>y;)z[y]=y++;for(y=0;256>y;y++)z[y]=z[C=255&C+k[y%q]+(p=z[y])],z[C]=p;(w.g=function(K){for(var J,B=0,O=w.i,Q=w.j,V=w.S;K--;)J=V[O=255&O+1],B=256*B+V[255&(V[O]=V[Q=255&Q+J])+(V[Q]=J)];w.i=O;w.j=Q;return B})(256)}function a(k,p){p.i=k.i;p.j=k.j;p.S=k.S.slice();return p}function b(k,p){var q=[],w=typeof k,y;if(p&&"object"==w)for(y in k)try{q.push(b(k[y],p-1))}catch(C){}return q.length?
q:"string"==w?k:k+"\x00"}function e(k,p){k+="";for(var q,w=0;w<k.length;)p[255&w]=255&(q^=19*p[255&w])+k.charCodeAt(w++);return d(p)}function g(){try{var k;n&&(k=n.randomBytes)?k=k(256):(k=new Uint8Array(256),(h.crypto||h.msCrypto).getRandomValues(k));return d(k)}catch(p){return k=h.navigator,[+new Date,h,k&&k.plugins,h.screen,d(t)]}}function d(k){return String.fromCharCode.apply(0,k)}var h=this,c=r.pow(256,6),l=r.pow(2,52),m=2*l;r.seedrandom=u;e(r.random(),t);if("object"==typeof la&&la.exports){la.exports=
u;try{var n=A(35)}catch(k){}}else"function"==typeof define&&define.amd&&define(function(){return u})})([],Math)};
shadow$provide[959]=function(W,A,la,v){W=A(952);v=A(953);var t=A(954),r=A(955),u=A(956),f=A(957);A=A(958);A.alea=W;A.xor128=v;A.xorwow=t;A.xorshift7=r;A.xor4096=u;A.tychei=f;la.exports=A};
shadow$provide[960]=function(W,A,la,v){function t(xa,Wa){function Da(){this.constructor=xa}aa(xa,Wa);xa.prototype=null===Wa?Object.create(Wa):(Da.prototype=Wa.prototype,new Da)}function r(xa,Wa,Da,mb){function Bb($b){return $b instanceof Da?$b:new Da(function(wc){wc($b)})}return new (Da||(Da=Promise))(function($b,wc){function Rc(bd){try{Xc(mb.next(bd))}catch(id){wc(id)}}function Zc(bd){try{Xc(mb["throw"](bd))}catch(id){wc(id)}}function Xc(bd){bd.done?$b(bd.value):Bb(bd.value).then(Rc,Zc)}Xc((mb=mb.apply(xa,
Wa||[])).next())})}function u(xa,Wa){function Da(Xc){return function(bd){return mb([Xc,bd])}}function mb(Xc){if($b)throw new TypeError("Generator is already executing.");for(;Bb;)try{if($b=1,wc&&(Rc=Xc[0]&2?wc["return"]:Xc[0]?wc["throw"]||((Rc=wc["return"])&&Rc.call(wc),0):wc.next)&&!(Rc=Rc.call(wc,Xc[1])).done)return Rc;if(wc=0,Rc)Xc=[Xc[0]&2,Rc.value];switch(Xc[0]){case 0:case 1:Rc=Xc;break;case 4:return Bb.label++,{value:Xc[1],done:!1};case 5:Bb.label++;wc=Xc[1];Xc=[0];continue;case 7:Xc=Bb.ops.pop();
Bb.trys.pop();continue;default:if(!(Rc=Bb.trys,Rc=0<Rc.length&&Rc[Rc.length-1])&&(6===Xc[0]||2===Xc[0])){Bb=0;continue}if(3===Xc[0]&&(!Rc||Xc[1]>Rc[0]&&Xc[1]<Rc[3]))Bb.label=Xc[1];else if(6===Xc[0]&&Bb.label<Rc[1])Bb.label=Rc[1],Rc=Xc;else if(Rc&&Bb.label<Rc[2])Bb.label=Rc[2],Bb.ops.push(Xc);else{Rc[2]&&Bb.ops.pop();Bb.trys.pop();continue}}Xc=Wa.call(xa,Bb)}catch(bd){Xc=[6,bd],wc=0}finally{$b=Rc=0}if(Xc[0]&5)throw Xc[1];return{value:Xc[0]?Xc[1]:void 0,done:!0}}var Bb={label:0,sent:function(){if(Rc[0]&
1)throw Rc[1];return Rc[1]},trys:[],ops:[]},$b,wc,Rc,Zc;return Zc={next:Da(0),"throw":Da(1),"return":Da(2)},"function"===typeof Symbol&&(Zc[Symbol.iterator]=function(){return this}),Zc}function f(xa,Wa){Array.isArray(xa)||(xa=[xa]);xa.forEach(function(Da){null!=Da&&I.util.assert("complex64"!==Da.dtype,function(){return Wa+" does not support complex64 tensors in the CPU backend."})})}function a(xa){for(var Wa=new Float32Array(xa.length),Da=0;Da<xa.length;++Da)Wa[Da]=Math.abs(xa[Da]);return Wa}function b(xa){return function(Wa,
Da,mb,Bb,$b){var wc=I.backend_util.assertAndGetBroadcastShape(Wa,Da),Rc=wc.length,Zc=I.util.computeStrides(wc),Xc=I.util.sizeFromShape(wc),bd=I.util.getTypedArrayFromDType($b,Xc),id=Wa.length,Ic=Da.length,Kd=I.util.computeStrides(Wa),Bd=I.util.computeStrides(Da),vd=I.backend_util.getBroadcastDims(Wa,wc),Nd=I.backend_util.getBroadcastDims(Da,wc);if(0===vd.length+Nd.length)for(Wa=0;Wa<bd.length;++Wa)bd[Wa]=xa(mb[Wa%mb.length],Bb[Wa%Bb.length]);else for(Da=function(de){var ne=I.util.indexToLoc(de,Rc,
Zc),xe=ne.slice(-id);vd.forEach(function(ue){return xe[ue]=0});var Vd=I.util.locToIndex(xe,id,Kd),le=ne.slice(-Ic);Nd.forEach(function(ue){return le[ue]=0});ne=I.util.locToIndex(le,Ic,Bd);bd[de]=xa(mb[Vd],Bb[ne])},Wa=0;Wa<bd.length;++Wa)Da(Wa);return[bd,wc]}}function e(xa){var Wa=xa.inputs;xa=xa.backend;var Da=Wa.real;Wa=Wa.imag;var mb=xa.data.get(Da.dataId).values,Bb=xa.data.get(Wa.dataId).values,$b=xa.makeTensorInfo(Da.shape,"complex64");xa.data.get($b.dataId).complexTensorInfos={real:xa.makeTensorInfo(Da.shape,
"float32",mb),imag:xa.makeTensorInfo(Wa.shape,"float32",Bb)};return $b}function g(xa){var Wa=xa.inputs.x;xa.backend.incRef(Wa.dataId);return{dataId:Wa.dataId,shape:Wa.shape,dtype:Wa.dtype}}function d(xa){var Wa=xa.backend;xa=Wa.data.get(xa.inputs.input.dataId).complexTensorInfos.real;var Da=Wa.data.get(xa.dataId).values;return Wa.makeTensorInfo(xa.shape,xa.dtype,Da)}function h(xa){var Wa=xa.backend,Da=xa.inputs.x;xa=xa.attrs.dtype;if("complex64"===xa){if("complex64"===Da.dtype)return g({inputs:{x:Da},
backend:Wa});xa=I.zeros(Da.shape);var mb=h({inputs:{x:Da},backend:Wa,attrs:{dtype:"float32"}});Da=e({inputs:{real:mb,imag:xa},backend:Wa});xa.dispose();Wa.disposeIntermediateTensorInfo(mb);return Da}if("complex64"===Da.dtype)return mb=d({inputs:{input:Da},backend:Wa}),Da=h({inputs:{x:mb},backend:Wa,attrs:{dtype:xa}}),Wa.disposeIntermediateTensorInfo(mb),Da;if(!I.util.hasEncodingLoss(Da.dtype,xa))return Da=g({inputs:{x:Da},backend:Wa}),{dataId:Da.dataId,shape:Da.shape,dtype:xa};if("int32"===xa)return xa=
Wa.data.get(Da.dataId).values,xa=Int32Array.from(xa),Wa.makeTensorInfo(Da.shape,"int32",xa);if("bool"===xa)return xa=Wa.data.get(Da.dataId).values,mb=I.util.toTypedArray([0],Da.dtype),Da=b(function(Bb,$b){return Bb!==$b?1:0})(Da.shape,[],xa,mb,"bool"),Wa.makeTensorInfo(Da[1],"bool",Da[0]);throw Error("Error in Cast: failed to cast "+Da.dtype+" to "+xa);}function c(xa,Wa,Da,mb){return null==Da?function(Bb){var $b=Bb.inputs,wc=$b.a;$b=$b.b;Bb=Bb.backend;f([wc,$b],xa);var Rc=Bb.data.get(wc.dataId).values,
Zc=Bb.data.get($b.dataId).values,Xc=mb||wc.dtype;wc=Wa(wc.shape,$b.shape,Rc,Zc,Xc);return Bb.makeTensorInfo(wc[1],Xc,wc[0])}:function(Bb){var $b=Bb.inputs,wc=$b.a,Rc=$b.b;Bb=Bb.backend;if("complex64"===wc.dtype||"complex64"===Rc.dtype){$b=h({inputs:{x:wc},backend:Bb,attrs:{dtype:"complex64"}});var Zc=Bb.data.get($b.dataId),Xc=Zc.complexTensorInfos.imag;Zc=Bb.data.get(Zc.complexTensorInfos.real.dataId).values;var bd=Bb.data.get(Xc.dataId).values;Xc=h({inputs:{x:Rc},backend:Bb,attrs:{dtype:"complex64"}});
var id=Bb.data.get(Xc.dataId),Ic=id.complexTensorInfos.imag;id=Bb.data.get(id.complexTensorInfos.real.dataId).values;Ic=Bb.data.get(Ic.dataId).values;Rc=Da(wc.shape,Rc.shape,Zc,bd,id,Ic);Zc=Rc[1];wc=Rc[2];Rc=Bb.makeTensorInfo(wc,"float32",Rc[0]);wc=Bb.makeTensorInfo(wc,"float32",Zc);Zc=e({inputs:{real:Rc,imag:wc},backend:Bb});Bb.disposeIntermediateTensorInfo($b);Bb.disposeIntermediateTensorInfo(Xc);Bb.disposeIntermediateTensorInfo(Rc);Bb.disposeIntermediateTensorInfo(wc);return Zc}Xc=Bb.data.get(wc.dataId).values;
Zc=Bb.data.get(Rc.dataId).values;$b=mb||wc.dtype;wc=Wa(wc.shape,Rc.shape,Xc,Zc,$b);Rc=wc[0];wc=wc[1];return Bb.makeTensorInfo(wc,$b,Rc)}}function l(xa){return function(Wa,Da,mb,Bb,$b,wc){var Rc=I.backend_util.assertAndGetBroadcastShape(Wa,Da),Zc=I.util.sizeFromShape(Rc),Xc=Rc.length,bd=I.util.computeStrides(Rc),id=I.util.getTypedArrayFromDType("float32",Zc),Ic=I.util.getTypedArrayFromDType("float32",Zc),Kd=I.backend_util.getBroadcastDims(Wa,Rc),Bd=I.backend_util.getBroadcastDims(Da,Rc),vd=I.backend_util.mergeRealAndImagArrays(mb,
Bb),Nd=I.backend_util.mergeRealAndImagArrays($b,wc),de=Wa.length,ne=I.util.computeStrides(Wa),xe=Da.length,Vd=I.util.computeStrides(Da);if(0===Kd.length+Bd.length)for(Wa=0;Wa<id.length;Wa++)Da=Wa%vd.length,mb=Wa%Nd.length,Da=xa(vd[2*Da],vd[2*Da+1],Nd[2*mb],Nd[2*mb+1]),id[Wa]=Da.real,Ic[Wa]=Da.imag;else for(Da=function(le){var ue=I.util.indexToLoc(le,Xc,bd),Ae=ue.slice(-de);Kd.forEach(function(Hb){return Ae[Hb]=0});var kb=I.util.locToIndex(Ae,de,ne),yb=ue.slice(-xe);Bd.forEach(function(Hb){return yb[Hb]=
0});ue=I.util.locToIndex(yb,xe,Vd);kb=xa(vd[2*kb],vd[2*kb+1],Nd[2*ue],Nd[2*ue+1]);id[le]=kb.real;Ic[le]=kb.imag},Wa=0;Wa<id.length;Wa++)Da(Wa);return[id,Ic,Rc]}}function m(xa){return function(Wa,Da,mb){Da=I.util.getTypedArrayFromDType(Da,Wa.length);for(var Bb=0;Bb<Wa.length;++Bb)Da[Bb]=xa(Wa[Bb],mb);return Da}}function n(xa,Wa,Da){return function(mb){var Bb=mb.attrs,$b=mb.backend;mb=mb.inputs.x;f(mb,xa);if("string"===mb.dtype||"string"===Da)throw Error("unaryKernelFunc does not support string input/output");
for(var wc=$b.data.get(mb.dataId).values,Rc=I.util.sizeFromShape(mb.shape),Zc=Da||mb.dtype,Xc=I.util.getArrayFromDType(Zc,Rc),bd=0;bd<Rc;++bd)Xc[bd]=Wa(wc[bd],Bb);return $b.makeTensorInfo(mb.shape,Zc,Xc)}}function k(xa,Wa,Da){return function(mb){var Bb=mb.attrs,$b=mb.backend;mb=mb.inputs.x;f(mb,xa);if("string"===mb.dtype||"string"===Da)throw Error("unaryKernelFunc does not support string input/output");var wc=$b.data.get(mb.dataId).values,Rc=Da||mb.dtype;Bb=Wa(wc,Rc,Bb);return $b.makeTensorInfo(mb.shape,
Rc,Bb)}}function p(xa,Wa,Da,mb){Da=I.util.getTypedArrayFromDType(mb,I.util.sizeFromShape(Da));for(mb=0;mb<Da.length;++mb){for(var Bb=mb*Wa,$b=xa[Bb],wc=0;wc<Wa;++wc){var Rc=xa[Bb+wc];Rc>$b&&($b=Rc)}Da[mb]=$b}return Da}function q(xa,Wa,Da,mb,Bb){var $b=I.slice_util.isSliceContinous(mb,Wa,Da),wc=I.util.sizeFromShape(Da),Rc=I.util.computeStrides(mb);if($b)return Da=I.slice_util.computeFlatOffset(Wa,Rc),xa.subarray(Da,Da+wc);Bb=I.util.getTypedArrayFromDType(Bb,wc);for($b=0;$b<wc;++$b){var Zc=Da.length,
Xc=I.util.computeStrides(Da);Zc=I.util.indexToLoc($b,Zc,Xc).map(function(bd,id){return bd+Wa[id]});Zc=I.util.locToIndex(Zc,mb.length,Rc);Bb[$b]=xa[Zc]}return Bb}function w(xa){var Wa=xa.backend,Da=xa.attrs;xa=xa.inputs.x;var mb=Da.begin;Da=Da.size;f(xa,"slice");mb=I.slice_util.parseSliceParams(xa,mb,Da);Da=mb[0];mb=mb[1];I.slice_util.assertParamsValid(xa,Da,mb);var Bb=Wa.data.get(xa.dataId).values;Da=q(Bb,Da,mb,xa.shape,xa.dtype);return Wa.makeTensorInfo(mb,xa.dtype,Da)}function y(xa,Wa,Da,mb,Bb){var $b=
Wa.length,wc=I.util.sizeFromShape(Wa);Wa=I.util.computeStrides(Wa);var Rc=I.util.computeStrides(Bb);Da=I.util.getTypedArrayFromDType(Da,I.util.sizeFromShape(Bb));for(Bb=0;Bb<wc;++Bb){for(var Zc=I.util.indexToLoc(Bb,$b,Wa),Xc=Array(Zc.length),bd=0;bd<Xc.length;bd++)Xc[bd]=Zc[mb[bd]];Zc=I.util.locToIndex(Xc,$b,Rc);Da[Zc]=xa[Bb]}return Da}function C(xa,Wa,Da,mb){Wa=I.util.parseAxisParam(Wa,Da)[0];for(var Bb=[1,Da[0],1],$b=0;$b<Wa;$b++)Bb[0]*=Da[$b];Bb[1]=Da[Wa];for($b=Wa+1;$b<Da.length;$b++)Bb[2]*=Da[$b];
var wc={},Rc=new Int32Array(Da[Wa]),Zc=new I.TensorBuffer(Bb,mb,xa),Xc=[],bd=1===Bb[0]&&1===Bb[2];for($b=0;$b<Da[Wa];$b++){var id=void 0;if(bd)id=xa[$b].toString();else{id=[];for(var Ic=0;Ic<Bb[0];Ic++)for(var Kd=0;Kd<Bb[2];Kd++)id.push(Zc.get(Ic,$b,Kd));id=id.join(",")}void 0!==wc[id]?Rc[$b]=wc[id]:(Ic=Object.keys(wc).length,wc[id]=Ic,Rc[$b]=Ic,Xc.push($b))}xa=Bb.slice();xa[1]=Object.keys(wc).length;var Bd=new I.TensorBuffer(xa,mb);Xc.forEach(function(vd,Nd){for(var de=0;de<Bb[0];de++)for(var ne=
0;ne<Bb[2];ne++)Bd.set(Zc.get(de,vd,ne),de,Nd,ne)});Da=Da.slice();Da[Wa]=xa[1];return{outputValues:Bd.values,outputShape:Da,indices:Rc}}function z(xa){var Wa=xa.inputs;xa=xa.backend;var Da=Wa.x;Wa=Wa.alpha;f([Da,Wa],"prelu");var mb=xa.data.get(Da.dataId).values,Bb=xa.data.get(Wa.dataId).values;Wa=xc(Da.shape,Wa.shape,mb,Bb,Da.dtype);return xa.makeTensorInfo(Wa[1],Da.dtype,Wa[0])}function K(xa,Wa,Da,mb){if("linear"===Da)return g({inputs:{x:Wa},backend:xa});if("relu"===Da)return dd({inputs:{x:Wa},backend:xa});
if("elu"===Da)return jb({inputs:{x:Wa},backend:xa});if("relu6"===Da)return kd({inputs:{x:Wa},backend:xa});if("prelu"===Da)return z({inputs:{x:Wa,alpha:mb},backend:xa});throw Error("Activation "+Da+" has not been implemented for the CPU backend.");}function J(xa){var Wa=xa.backend,Da=xa.inputs.x;xa=xa.attrs.shape;var mb=I.util.sizeFromShape(Da.shape),Bb=I.util.inferFromImplicitShape(xa,mb),$b=I.util.sizeFromShape(Bb);I.util.assert(mb===$b,function(){return"The new shape ("+Bb+") has "+$b+" elements and the old shape ("+
(Da.shape+") has "+mb+" elements. The new shape and old shape must have the same number of elements.")});Wa.incRef(Da.dataId);Wa=Wa.data.get(Da.dataId);null!=Wa.complexTensorInfos&&(xa=Wa.complexTensorInfos.imag,Wa.complexTensorInfos.real.shape=Bb,xa.shape=Bb);return{dataId:Da.dataId,shape:Bb,dtype:Da.dtype}}function B(xa){var Wa=xa.inputs,Da=xa.backend;xa=xa.attrs;var mb=Wa.a,Bb=Wa.b,$b=xa.transposeA,wc=xa.transposeB;f([mb,Bb],"matMul");var Rc=mb.shape.length,Zc=Bb.shape.length,Xc=$b?mb.shape[Rc-
2]:mb.shape[Rc-1],bd=wc?Bb.shape[Zc-1]:Bb.shape[Zc-2],id=$b?mb.shape[Rc-1]:mb.shape[Rc-2],Ic=wc?Bb.shape[Zc-2]:Bb.shape[Zc-1],Kd=mb.shape.slice(0,-2),Bd=Bb.shape.slice(0,-2);Wa=I.util.sizeFromShape(Kd);xa=I.util.sizeFromShape(Bd);I.util.assert(2<=Rc&&2<=Zc&&(Wa===xa||1===Wa||1===xa),function(){return"Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of ("+(Kd+") and ("+Bd+").")});Rc=(Wa>xa?mb.shape.slice(0,
-2):Bb.shape.slice(0,-2)).concat([id,Ic]);I.util.assert(Xc===bd,function(){return"Error in matMul: inner shapes ("+Xc+") and ("+(bd+") of Tensors with shapes "+mb.shape+" and ")+(Bb.shape+" and transposeA\x3d"+$b)+(" and transposeB\x3d"+wc+" must match.")});Ic=wc?[xa,Ic,bd]:[xa,bd,Ic];id=J({inputs:{x:mb},backend:Da,attrs:{shape:$b?[Wa,Xc,id]:[Wa,id,Xc]}});Ic=J({inputs:{x:Bb},backend:Da,attrs:{shape:Ic}});Zc=$b?id.shape[1]:id.shape[2];var vd=$b?id.shape[2]:id.shape[1],Nd=wc?Ic.shape[1]:Ic.shape[2],
de=Math.max(Wa,xa),ne=Da.data.get(id.dataId).values,xe=Da.data.get(Ic.dataId).values,Vd=I.util.computeStrides(id.shape),le=I.util.computeStrides(Ic.shape),ue=$b?[Vd[0],1,Vd[1]]:[Vd[0],Vd[1],1];Vd=ue[0];var Ae=ue[1];ue=ue[2];var kb=wc?[1,le[1],le[0]]:[le[1],1,le[0]];le=kb[0];var yb=kb[1];kb=kb[2];for(var Hb=vd*Nd,ec=I.buffer([de,vd,Nd],id.dtype),Bc=ec.values,Sc=Da.blockSize,Uc=0;Uc<de;Uc++)for(var Ed=0;Ed<vd;Ed+=Sc)for(var Sd=0;Sd<Nd;Sd+=Sc)for(var Xe=0;Xe<Zc;Xe+=Sc)for(var pf=Math.min(Ed+Sc,vd),wf=
Math.min(Sd+Sc,Nd),Yf=Math.min(Xe+Sc,Zc),of=Ed;of<pf;of++)for(var fg=Sd;fg<wf;fg++){for(var zd=0,uf=Xe;uf<Yf;uf++)zd+=ne[Math.min(Uc,Wa-1)*Vd+of*Ae+uf*ue]*xe[uf*le+fg*yb+Math.min(Uc,xa-1)*kb];Bc[Uc*Hb+(of*Nd+fg)]+=zd}Da.disposeIntermediateTensorInfo(id);Da.disposeIntermediateTensorInfo(Ic);return Da.makeTensorInfo(Rc,ec.dtype,ec.values)}function O(xa,Wa,Da,mb,Bb,$b){Wa=Bb.strideHeight;var wc=Bb.strideWidth,Rc=Bb.dilationHeight,Zc=Bb.dilationWidth,Xc=Bb.effectiveFilterHeight,bd=Bb.effectiveFilterWidth,
id=Bb.padInfo.top,Ic=Bb.padInfo.left,Kd="max"===$b?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY;Da=I.buffer(Bb.outShape,Da);for(var Bd=Da.values,vd=Bb.outShape[1]*Bb.outShape[2]*Bb.outShape[3],Nd=Bb.outShape[2]*Bb.outShape[3],de=Bb.outShape[3],ne=0;ne<Bb.batchSize;++ne)for(var xe=ne*vd,Vd=ne*mb[0],le=0;le<Bb.inChannels;++le)for(var ue=0;ue<Bb.outHeight;++ue){var Ae=ue*Wa-id,kb=Math.max(0,Ae);Ae=Math.min(Bb.inHeight,Xc+Ae);for(var yb=xe+ue*Nd,Hb=0;Hb<Bb.outWidth;++Hb){var ec=Hb*wc-Ic,Bc=Math.max(0,
ec);ec=Math.min(Bb.inWidth,bd+ec);for(var Sc=Kd,Uc=0,Ed=0,Sd=kb;Sd<Ae;Sd+=Rc){for(var Xe=Vd+Sd*mb[1],pf=Bc;pf<ec;pf+=Zc){var wf=xa[Xe+pf*mb[2]+le];"max"===$b&&wf>Sc?Sc=wf:"avg"===$b&&(Uc+=wf,Ed++)}if(isNaN(Sc))break}Bd[yb+Hb*de+le]="avg"===$b?Uc/Ed:Sc}}return Da}function Q(xa,Wa,Da,mb,Bb,$b){void 0===Bb&&(Bb=!1);void 0===$b&&($b=!1);var wc=I.buffer(mb.outShape,"int32"),Rc=mb.strideHeight,Zc=mb.strideWidth,Xc=mb.dilationHeight,bd=mb.dilationWidth,id=mb.effectiveFilterHeight,Ic=mb.effectiveFilterWidth,
Kd=mb.padInfo.top,Bd=mb.padInfo.left;xa=I.buffer(Wa,Da,xa);for(Wa=0;Wa<mb.batchSize;++Wa)for(Da=0;Da<mb.inChannels;++Da)for(var vd=0;vd<mb.outHeight;++vd){for(var Nd=vd*Rc-Kd,de=Nd;0>de;)de+=Xc;for(var ne=Math.min(mb.inHeight,id+Nd),xe=0;xe<mb.outWidth;++xe){for(var Vd=xe*Zc-Bd,le=Vd;0>le;)le+=bd;for(var ue=Math.min(mb.inWidth,Ic+Vd),Ae=Number.NEGATIVE_INFINITY,kb=-1,yb=de;yb<ne;yb+=Xc)for(var Hb=yb-Nd,ec=le;ec<ue;ec+=bd){var Bc=ec-Vd,Sc=xa.get(Wa,yb,ec,Da);Sc>Ae&&(Ae=Sc,kb=Bb?$b?((Wa*mb.inHeight+
yb)*mb.inWidth+ec)*mb.inChannels+Da:(yb*mb.inWidth+ec)*mb.inChannels+Da:Hb*Ic+Bc)}wc.set(kb,Wa,vd,xe,Da)}}return wc}function V(xa){var Wa=xa.backend;xa=Wa.data.get(xa.inputs.input.dataId).complexTensorInfos.imag;var Da=Wa.data.get(xa.dataId).values;return Wa.makeTensorInfo(xa.shape,xa.dtype,Da)}function M(xa){var Wa=xa.inputs,Da=xa.backend,mb=I.util.parseAxisParam(xa.attrs.axis,Wa[0].shape)[0],Bb=I.backend_util.computeOutShape(Wa.map(function(id){return id.shape}),mb);if(0===I.util.sizeFromShape(Bb))return Da.makeTensorInfo(Bb,
Wa[0].dtype,[]);xa=Wa.filter(function(id){return 0<I.util.sizeFromShape(id.shape)});if(1===xa.length)return xa[0];var $b=xa.map(function(id){return id.shape});I.backend_util.assertParamsConsistent($b,mb);if("complex64"===xa[0].dtype){Wa=xa.map(function(id){return d({inputs:{input:id},backend:Da})});xa=xa.map(function(id){return V({inputs:{input:id},backend:Da})});$b=M({inputs:Wa,backend:Da,attrs:{axis:mb}});var wc=M({inputs:xa,backend:Da,attrs:{axis:mb}}),Rc=e({inputs:{real:$b,imag:wc},backend:Da});
Wa.forEach(function(id){return Da.disposeIntermediateTensorInfo(id)});xa.forEach(function(id){return Da.disposeIntermediateTensorInfo(id)});Da.disposeIntermediateTensorInfo($b);Da.disposeIntermediateTensorInfo(wc);return Rc}$b=xa.map(function(id){var Ic=[-1,I.util.sizeFromShape(id.shape.slice(mb))];return J({inputs:{x:id},backend:Da,attrs:{shape:Ic}})});Bb=I.backend_util.computeOutShape($b.map(function(id){return id.shape}),1);var Zc=I.util.getTypedArrayFromDType(xa[0].dtype,I.util.sizeFromShape(Bb));
if(1===$b[0].shape[0]){var Xc=0;$b.forEach(function(id){var Ic=Da.data.get(id.dataId).values;id=I.util.sizeFromShape(id.shape);Zc.set(Ic,Xc);Xc+=id})}else{var bd=0;$b.forEach(function(id){for(var Ic=Da.data.get(id.dataId).values,Kd=0,Bd=0;Bd<id.shape[0];++Bd)for(var vd=Bd*Bb[1]+bd,Nd=0;Nd<id.shape[1];++Nd)Zc[vd+Nd]=Ic[Kd++];bd+=id.shape[1]})}xa=I.backend_util.computeOutShape(xa.map(function(id){return id.shape}),mb);Wa=Da.makeTensorInfo(xa,Wa[0].dtype,Zc);$b.forEach(function(id){return Da.disposeIntermediateTensorInfo(id)});
return Wa}function F(xa){var Wa=xa.inputs,Da=xa.backend,mb=xa.attrs,Bb=Wa.x,$b=Wa.filter;Wa=mb.strides;xa=mb.pad;var wc=mb.dataFormat,Rc=mb.dilations;mb=mb.dimRoundingMode;f([Bb,$b],"conv2d");wc=I.backend_util.convertConv2DDataFormat(wc);Wa=I.backend_util.computeConv2DInfo(Bb.shape,$b.shape,Wa,Rc,xa,mb,!1,wc);xa=Wa.filterHeight;Rc=Wa.filterWidth;mb=Wa.dilationHeight;wc=Wa.dilationWidth;var Zc=Wa.padInfo.left,Xc=Wa.padInfo.top,bd="channelsLast"===Wa.dataFormat,id=new I.TensorBuffer(Wa.outShape,Bb.dtype),
Ic=I.util.computeStrides(Bb.shape),Kd=I.util.computeStrides($b.shape),Bd=Ic[0],vd=bd?Ic[1]:Ic[2],Nd=bd?Ic[2]:1;Ic=bd?1:Ic[1];var de=id.strides[0],ne=bd?id.strides[1]:id.strides[2],xe=bd?id.strides[2]:1;bd=bd?1:id.strides[1];Bb=Da.data.get(Bb.dataId).values;$b=Da.data.get($b.dataId).values;for(var Vd=id.values,le=0;le<Wa.batchSize;++le)for(var ue=le*Bd,Ae=le*de,kb=0;kb<Wa.outHeight;++kb)for(var yb=Ae+kb*ne,Hb=kb*Wa.strideHeight-Xc,ec=0;ec<xa;++ec){var Bc=Hb+ec*mb;if(!(0>Bc||Bc>=Wa.inHeight)){var Sc=
ec*Kd[0];Bc=ue+Bc*vd;for(var Uc=0;Uc<Wa.outWidth;++Uc)for(var Ed=yb+Uc*xe,Sd=Uc*Wa.strideWidth-Zc,Xe=0;Xe<Rc;++Xe){var pf=Sd+Xe*wc;if(!(0>pf||pf>=Wa.inWidth)){pf=Bc+pf*Nd;for(var wf=Sc+Xe*Kd[1],Yf=0;Yf<Wa.inChannels;++Yf){for(var of=Bb[pf+Yf*Ic],fg=0;fg<Wa.outChannels;++fg)Vd[Ed+fg*bd]+=of*$b[wf+fg];wf+=Wa.outChannels}}}}}return Da.makeTensorInfo(id.shape,id.dtype,Vd)}function D(xa){var Wa=xa.inputs,Da=xa.backend;xa=xa.attrs;var mb=Wa.x,Bb=Wa.filter,$b=xa.strides,wc=xa.pad,Rc=xa.dilations,Zc=xa.dimRoundingMode;
f([mb,Bb],"depthwiseConv2DNative");xa=I.util.computeStrides(mb.shape);Wa=I.util.computeStrides(Bb.shape);var Xc=Rc;null==Xc&&(Xc=[1,1]);I.util.assert(I.backend_util.eitherStridesOrDilationsAreOne($b,Xc),function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+($b+" and dilations '"+Xc+"'")});wc=I.backend_util.computeConv2DInfo(mb.shape,Bb.shape,$b,Xc,wc,Zc,!0);Rc=wc.filterHeight;Zc=wc.filterWidth;var bd=wc.dilationHeight,id=wc.dilationWidth,Ic=wc.padInfo,Kd=
Ic.left;Ic=Ic.top;var Bd=wc.outChannels/wc.inChannels,vd=new I.TensorBuffer(wc.outShape,mb.dtype);mb=Da.data.get(mb.dataId).values;Bb=Da.data.get(Bb.dataId).values;for(var Nd=vd.values,de=0;de<wc.batchSize;++de)for(var ne=de*xa[0],xe=de*vd.strides[0],Vd=0;Vd<wc.outHeight;++Vd)for(var le=xe+Vd*vd.strides[1],ue=Vd*wc.strideHeight-Kd,Ae=0;Ae<Rc;++Ae){var kb=ue+Ae*bd;if(!(0>kb||kb>=wc.inHeight)){var yb=Ae*Wa[0];kb=ne+kb*xa[1];for(var Hb=0;Hb<wc.outWidth;++Hb)for(var ec=le+Hb*vd.strides[2],Bc=Hb*wc.strideWidth-
Ic,Sc=0;Sc<Zc;++Sc){var Uc=Bc+Sc*id;if(!(0>Uc||Uc>=wc.inWidth)){Uc=kb+Uc*wc.inChannels;for(var Ed=ec,Sd=yb+Sc*Wa[1],Xe=0;Xe<wc.inChannels;++Xe){for(var pf=mb[Uc+Xe],wf=0;wf<Bd;++wf)Nd[Ed+wf]+=pf*Bb[Sd+wf];Ed+=Bd;Sd+=Bd}}}}}return Da.makeTensorInfo(vd.shape,vd.dtype,vd.values)}function H(xa,Wa,Da){var mb=xa.shape,Bb=mb[0];mb=mb[1];var $b=Da.data.get(xa.dataId);xa=$b.complexTensorInfos.real;var wc=$b.complexTensorInfos.imag;$b=[Bb,mb];var Rc=I.util.sizeFromShape($b),Zc=I.util.getTypedArrayFromDType("float32",
Rc);Rc=I.util.getTypedArrayFromDType("float32",Rc);for(var Xc=0;Xc<Bb;Xc++){var bd=w({inputs:{x:xa},backend:Da,attrs:{begin:[Xc,0],size:[1,mb]}}),id=w({inputs:{x:wc},backend:Da,attrs:{begin:[Xc,0],size:[1,mb]}}),Ic=e({inputs:{real:bd,imag:id},backend:Da});var Kd=Ic,Bd=Wa;var vd=Da;var Nd=I.util.sizeFromShape(Kd.shape),de=vd.data.get(Kd.dataId),ne=vd.data.get(de.complexTensorInfos.real.dataId).values;de=vd.data.get(de.complexTensorInfos.imag.dataId).values;if(0===(Nd&Nd-1))if(ne=U(ne,de,Nd,Bd,vd),
Kd=[Kd.shape[0],Kd.shape[1]],Bd){Bd=vd.makeTensorInfo(Kd,"float32",ne.real);Kd=vd.makeTensorInfo(Kd,"float32",ne.imag);Nd=vd.makeTensorInfo([],"float32",I.util.createScalarValue(Nd,"float32"));ne=g({inputs:{x:Nd},backend:vd});de=Re.kernelFunc({inputs:{a:Bd,b:Nd},backend:vd});var xe=Re.kernelFunc({inputs:{a:Kd,b:ne},backend:vd}),Vd=vd.data.get(de.dataId).values,le=vd.data.get(xe.dataId).values;vd.disposeIntermediateTensorInfo(Bd);vd.disposeIntermediateTensorInfo(Kd);vd.disposeIntermediateTensorInfo(Nd);
vd.disposeIntermediateTensorInfo(ne);vd.disposeIntermediateTensorInfo(de);vd.disposeIntermediateTensorInfo(xe);vd={real:Vd,imag:le}}else vd=ne;else{vd=I.backend_util.mergeRealAndImagArrays(ne,de);Kd=new Float32Array(2*Nd);for(ne=0;ne<Nd;ne++){for(Vd=xe=de=0;Vd<Nd;Vd++){le=I.backend_util.exponent(ne*Vd,Nd,Bd);var ue=I.backend_util.getComplexWithIndex(vd,Vd);de+=ue.real*le.real-ue.imag*le.imag;xe+=ue.real*le.imag+ue.imag*le.real}Bd&&(de/=Nd,xe/=Nd);I.backend_util.assignToTypedArray(Kd,de,xe,ne)}vd=
I.backend_util.splitRealAndImagArrays(Kd)}vd=I.backend_util.mergeRealAndImagArrays(vd.real,vd.imag);for(Nd=0;Nd<mb;Nd++)Bd=I.backend_util.getComplexWithIndex(vd,Nd),Zc[Xc*mb+Nd]=Bd.real,Rc[Xc*mb+Nd]=Bd.imag;Da.disposeIntermediateTensorInfo(bd);Da.disposeIntermediateTensorInfo(id);Da.disposeIntermediateTensorInfo(Ic)}Wa=Da.makeTensorInfo($b,"float32",Zc);Bb=Da.makeTensorInfo($b,"float32",Rc);mb=e({inputs:{real:Wa,imag:Bb},backend:Da});Da.disposeIntermediateTensorInfo(Wa);Da.disposeIntermediateTensorInfo(Bb);
return mb}function U(xa,Wa,Da,mb,Bb){if(1===Da)return{real:xa,imag:Wa};var $b=I.backend_util.mergeRealAndImagArrays(xa,Wa),wc=Da/2;xa=I.backend_util.complexWithEvenIndex($b);var Rc=xa.real,Zc=xa.imag;Wa=[Rc.length];xa=Bb.makeTensorInfo(Wa,"float32",Rc);Wa=Bb.makeTensorInfo(Wa,"float32",Zc);var Xc=e({inputs:{real:xa,imag:Wa},backend:Bb});$b=I.backend_util.complexWithOddIndex($b);var bd=$b.real,id=$b.imag,Ic=[bd.length];$b=Bb.makeTensorInfo(Ic,"float32",bd);Ic=Bb.makeTensorInfo(Ic,"float32",id);var Kd=
e({inputs:{real:$b,imag:Ic},backend:Bb});Zc=U(Rc,Zc,wc,mb,Bb);Rc=Zc.real;Zc=Zc.imag;var Bd=[Rc.length];Rc=Bb.makeTensorInfo(Bd,"float32",Rc);Zc=Bb.makeTensorInfo(Bd,"float32",Zc);Bd=e({inputs:{real:Rc,imag:Zc},backend:Bb});bd=U(bd,id,wc,mb,Bb);wc=bd.real;bd=bd.imag;id=[wc.length];wc=Bb.makeTensorInfo(id,"float32",wc);bd=Bb.makeTensorInfo(id,"float32",bd);id=e({inputs:{real:wc,imag:bd},backend:Bb});mb=I.backend_util.exponents(Da,mb);var vd=[mb.real.length];Da=Bb.makeTensorInfo(vd,"float32",mb.real);
mb=Bb.makeTensorInfo(vd,"float32",mb.imag);vd=e({inputs:{real:Da,imag:mb},backend:Bb});var Nd=tb({inputs:{a:vd,b:id},backend:Bb}),de=oa({inputs:{a:Bd,b:Nd},backend:Bb}),ne=xd({inputs:{a:Bd,b:Nd},backend:Bb}),xe=d({inputs:{input:de},backend:Bb}),Vd=d({inputs:{input:ne},backend:Bb}),le=V({inputs:{input:de},backend:Bb}),ue=V({inputs:{input:ne},backend:Bb}),Ae=M({inputs:[xe,Vd],backend:Bb,attrs:{axis:0}}),kb=M({inputs:[le,ue],backend:Bb,attrs:{axis:0}}),yb=Bb.data.get(Ae.dataId).values,Hb=Bb.data.get(kb.dataId).values;
Bb.disposeIntermediateTensorInfo(xa);Bb.disposeIntermediateTensorInfo(Wa);Bb.disposeIntermediateTensorInfo(Xc);Bb.disposeIntermediateTensorInfo($b);Bb.disposeIntermediateTensorInfo(Ic);Bb.disposeIntermediateTensorInfo(Kd);Bb.disposeIntermediateTensorInfo(Rc);Bb.disposeIntermediateTensorInfo(Zc);Bb.disposeIntermediateTensorInfo(Bd);Bb.disposeIntermediateTensorInfo(wc);Bb.disposeIntermediateTensorInfo(bd);Bb.disposeIntermediateTensorInfo(id);Bb.disposeIntermediateTensorInfo(Da);Bb.disposeIntermediateTensorInfo(mb);
Bb.disposeIntermediateTensorInfo(vd);Bb.disposeIntermediateTensorInfo(Nd);Bb.disposeIntermediateTensorInfo(de);Bb.disposeIntermediateTensorInfo(ne);Bb.disposeIntermediateTensorInfo(xe);Bb.disposeIntermediateTensorInfo(le);Bb.disposeIntermediateTensorInfo(Vd);Bb.disposeIntermediateTensorInfo(ue);Bb.disposeIntermediateTensorInfo(Ae);Bb.disposeIntermediateTensorInfo(kb);return{real:yb,imag:Hb}}function L(xa){var Wa=xa.backend,Da=xa.inputs.x,mb=xa.attrs.perm;f(Da,"transpose");xa=Array(Da.shape.length);
for(var Bb=0;Bb<xa.length;Bb++)xa[Bb]=Da.shape[mb[Bb]];Bb=Wa.data.get(Da.dataId).values;mb=y(Bb,Da.shape,Da.dtype,mb,xa);return{dataId:Wa.write(mb,xa,Da.dtype),shape:xa,dtype:Da.dtype}}Object.defineProperty(v,"__esModule",{value:!0});var I=A(948),T=A(959),aa=function(xa,Wa){aa=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(Da,mb){Da.__proto__=mb}||function(Da,mb){for(var Bb in mb)mb.hasOwnProperty(Bb)&&(Da[Bb]=mb[Bb])};return aa(xa,Wa)},ba=I.kernel_impls.nonMaxSuppressionV3Impl,Z=
I.kernel_impls.split,da=I.kernel_impls.tile,pa=I.kernel_impls.topkImpl,fa=I.kernel_impls.whereImpl,ta=function(xa){function Wa(){var Da=xa.call(this)||this;Da.blockSize=48;Da.firstUse=!0;Da.data=new I.DataStorage(Da,I.engine());return Da}t(Wa,xa);Wa.prototype.write=function(Da,mb,Bb){this.firstUse&&(this.firstUse=!1,I.env().get("IS_NODE")&&I.backend_util.warn("\n\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\nHi there \ud83d\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d"));
mb={};this.data.set(mb,{values:Da,dtype:Bb,refCount:1});return mb};Wa.prototype.makeTensorInfo=function(Da,mb,Bb){"string"===mb&&null!=Bb&&0<Bb.length&&I.util.isString(Bb[0])?(Bb=Bb.map(function($b){return I.util.encodeString($b)}),Bb=this.write(Bb,Da,mb)):Bb=this.write(Bb,Da,mb);return{dataId:Bb,shape:Da,dtype:mb}};Wa.prototype.incRef=function(Da){this.data.get(Da).refCount++};Wa.prototype.decRef=function(Da){this.data.has(Da)&&this.data.get(Da).refCount--};Wa.prototype.move=function(Da,mb,Bb,$b){this.data.set(Da,
{values:mb,dtype:$b,refCount:1})};Wa.prototype.numDataIds=function(){return this.data.numDataIds()};Wa.prototype.read=function(Da){return r(this,void 0,void 0,function(){return u(this,function(mb){return[2,this.readSync(Da)]})})};Wa.prototype.readSync=function(Da){var mb=this.data.get(Da),Bb=mb.complexTensorInfos;return"complex64"===mb.dtype?(Da=this.readSync(Bb.real.dataId),Bb=this.readSync(Bb.imag.dataId),I.backend_util.mergeRealAndImagArrays(Da,Bb)):this.data.get(Da).values};Wa.prototype.bufferSync=
function(Da){var mb=this.readSync(Da.dataId),Bb=mb;if("string"===Da.dtype)try{Bb=mb.map(function($b){return I.util.decodeString($b)})}catch($b){throw Error("Failed to decode encoded string bytes into utf-8");}return I.buffer(Da.shape,Da.dtype,Bb)};Wa.prototype.makeOutput=function(Da,mb,Bb){Da=this.write(Da,mb,Bb);return I.engine().makeTensorFromDataId(Da,mb,Bb,this)};Wa.prototype.disposeData=function(Da){if(this.data.has(Da)){var mb=this.data.get(Da).complexTensorInfos;null!=mb&&(this.disposeData(mb.real.dataId),
this.disposeData(mb.imag.dataId));this.data.delete(Da)}};Wa.prototype.disposeIntermediateTensorInfo=function(Da){Da=Da.dataId;if(this.data.has(Da)){var mb=this.data.get(Da);mb.refCount--;1>mb.refCount&&this.disposeData(Da)}};Wa.prototype.time=function(Da){return r(this,void 0,void 0,function(){var mb,Bb;return u(this,function($b){mb=I.util.now();Da();Bb=I.util.now()-mb;return[2,{kernelMs:Bb}]})})};Wa.prototype.memory=function(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}};
Wa.prototype.stridedSlice=function(Da,mb,Bb,$b){f(Da,"stridedSlice");Bb=I.slice_util.computeOutShape(mb,Bb,$b);if(Bb.some(function(bd){return 0===bd}))return I.tensor([],Bb);Bb=I.buffer(Bb,Da.dtype);Da=this.bufferSync(Da);for(var wc=0;wc<Bb.size;wc++){for(var Rc=Bb.indexToLoc(wc),Zc=Array(Rc.length),Xc=0;Xc<Zc.length;Xc++)Zc[Xc]=Rc[Xc]*$b[Xc]+mb[Xc];Bb.set.apply(Bb,[Da.get.apply(Da,Zc)].concat(Rc))}return Bb.toTensor()};Wa.prototype.diag=function(Da){for(var mb=this.readSync(Da.dataId),Bb=I.buffer([Da.size,
Da.size],Da.dtype),$b=Bb.values,wc=0;wc<mb.length;wc++)$b[wc*Da.size+wc]=mb[wc];return Bb.toTensor()};Wa.prototype.unstack=function(Da,mb){for(var Bb=Da.shape[mb],$b=Array(Da.rank-1),wc=0,Rc=0;Rc<Da.rank;Rc++)Rc!==mb&&($b[wc++]=Da.shape[Rc]);wc=Array(Da.rank).fill(0);var Zc=Da.shape.slice();Zc[mb]=1;Bb=Array(Bb);for(Rc=0;Rc<Bb.length;Rc++)wc[mb]=Rc,Bb[Rc]=I.slice(Da,wc,Zc).reshape($b);return Bb};Wa.prototype.reverse=function(Da,mb){f(Da,"reverse");for(var Bb=I.buffer(Da.shape,Da.dtype),$b=this.bufferSync(Da),
wc=function(Zc){Zc=Bb.indexToLoc(Zc);var Xc=Zc.slice();mb.forEach(function(bd){return Xc[bd]=Da.shape[bd]-1-Xc[bd]});Bb.set.apply(Bb,[$b.get.apply($b,Xc)].concat(Zc))},Rc=0;Rc<Bb.size;Rc++)wc(Rc);return Bb.toTensor()};Wa.prototype.neg=function(Da){f(Da,"neg");return I.mul(I.scalar(-1),Da)};Wa.prototype.addN=function(Da){var mb=this;f(Da,"addN");for(var Bb=Da.map(function(bd){return mb.readSync(bd.dataId)}),$b=I.buffer(Da[0].shape,Da[0].dtype),wc=$b.values,Rc=0;Rc<Da.length;Rc++)for(var Zc=Bb[Rc],
Xc=0;Xc<wc.length;Xc++)wc[Xc]+=Zc[Xc];return $b.toTensor()};Wa.prototype.softmax=function(Da,mb){mb=I.util.parseAxisParam([mb],Da.shape);var Bb=I.max(Da,mb),$b=I.backend_util.expandShapeToKeepDim(Bb.shape,mb);Da=I.sub(Da,Bb.reshape($b));Da=I.exp(Da);mb=this.sum(Da,mb).reshape($b);return I.div(Da,mb)};Wa.prototype.pow=function(Da,mb){f([Da,mb],"pow");return this.broadcastedBinaryOp(Da,mb,Da.dtype,function(Bb,$b){return Math.pow(Bb,$b)})};Wa.prototype.floorDiv=function(Da,mb){f([Da,mb],"floorDiv");
return this.broadcastedBinaryOp(Da,mb,"int32",function(Bb,$b){return Math.floor(Bb/$b)})};Wa.prototype.sum=function(Da,mb){f(Da,"sum");I.backend_util.assertAxesAreInnerMostDims("sum",mb,Da.rank);var Bb=I.backend_util.computeOutAndReduceShapes(Da.shape,mb);mb=Bb[0];Bb=Bb[1];var $b=I.upcastType(Da.dtype,"int32");mb=I.zeros(mb,$b);Bb=I.util.sizeFromShape(Bb);$b=this.readSync(mb.dataId);Da=this.readSync(Da.dataId);for(var wc=0;wc<$b.length;++wc){for(var Rc=wc*Bb,Zc=0,Xc=0;Xc<Bb;++Xc)Zc+=Da[Rc+Xc];$b[wc]=
Zc}return mb};Wa.prototype.prod=function(Da,mb){f(Da,"sum");var Bb=I.backend_util.computeOutAndReduceShapes(Da.shape,mb);mb=Bb[0];Bb=Bb[1];var $b=I.upcastType(Da.dtype,"int32");mb=I.zeros(mb,$b);Bb=I.util.sizeFromShape(Bb);$b=this.readSync(mb.dataId);Da=this.readSync(Da.dataId);for(var wc=0;wc<$b.length;++wc){for(var Rc=wc*Bb,Zc=1,Xc=0;Xc<Bb;++Xc)Zc*=Da[Rc+Xc];$b[wc]=Zc}return mb};Wa.prototype.unsortedSegmentSum=function(Da,mb,Bb){f(Da,"unsortedSegmentSum");for(var $b=[],wc=Da.rank-mb.rank,Rc=0;Rc<
wc;++Rc)mb=mb.expandDims(Rc+1);for(Rc=0;Rc<Bb;++Rc)wc=I.scalar(Rc,"int32"),wc=I.equal(wc,mb).asType("float32").mul(Da).sum(0),$b.push(wc);return I.stack($b)};Wa.prototype.argMin=function(Da,mb){f(Da,"argMin");mb=[mb];I.backend_util.assertAxesAreInnerMostDims("argMin",mb,Da.rank);mb=I.backend_util.computeOutAndReduceShapes(Da.shape,mb);var Bb=mb[1];mb=I.zeros(mb[0],"int32");Bb=I.util.sizeFromShape(Bb);var $b=this.readSync(mb.dataId);Da=this.readSync(Da.dataId);for(var wc=0;wc<$b.length;++wc){for(var Rc=
wc*Bb,Zc=Da[Rc],Xc=0,bd=0;bd<Bb;++bd){var id=Da[Rc+bd];id<Zc&&(Zc=id,Xc=bd)}$b[wc]=Xc}return mb};Wa.prototype.argMax=function(Da,mb){f(Da,"argMax");mb=[mb];I.backend_util.assertAxesAreInnerMostDims("argMax",mb,Da.rank);mb=I.backend_util.computeOutAndReduceShapes(Da.shape,mb);var Bb=mb[1];mb=I.zeros(mb[0],"int32");Bb=I.util.sizeFromShape(Bb);var $b=this.readSync(mb.dataId);Da=this.readSync(Da.dataId);for(var wc=0;wc<$b.length;++wc){for(var Rc=wc*Bb,Zc=Da[Rc],Xc=0,bd=0;bd<Bb;++bd){var id=Da[Rc+bd];
id>Zc&&(Zc=id,Xc=bd)}$b[wc]=Xc}return mb};Wa.prototype.cumsum=function(Da,mb,Bb,$b){f(Da,"cumsum");if(mb!==Da.rank-1)throw Error("backend.cumsum in CPU expects an inner-most axis\x3d"+(Da.rank-1)+" but got axis\x3d"+mb);mb=I.upcastType(Da.dtype,"int32");mb=I.zeros(Da.shape,mb);var wc=this.readSync(mb.dataId),Rc=this.readSync(Da.dataId),Zc=Da.shape[Da.rank-1];Da=$b?function(Ic,Kd){return Ic+Zc-Kd-1}:function(Ic,Kd){return Ic+Kd};for($b=0;$b<Rc.length;$b+=Zc)for(var Xc=0;Xc<Zc;Xc++){var bd=Da($b,Xc);
if(0===Xc)wc[bd]=Bb?0:Rc[bd];else{var id=Da($b,Xc-1);wc[bd]=Bb?Rc[id]+wc[id]:Rc[bd]+wc[id]}}return mb};Wa.prototype.equal=function(Da,mb){f([Da,mb],"equal");return this.broadcastedBinaryOp(Da,mb,"bool",function(Bb,$b){return Bb===$b?1:0})};Wa.prototype.notEqual=function(Da,mb){f([Da,mb],"notEqual");return this.broadcastedBinaryOp(Da,mb,"bool",function(Bb,$b){return Bb!==$b?1:0})};Wa.prototype.less=function(Da,mb){f([Da,mb],"less");return this.broadcastedBinaryOp(Da,mb,"bool",function(Bb,$b){return Bb<
$b?1:0})};Wa.prototype.lessEqual=function(Da,mb){f([Da,mb],"lessEqual");return this.broadcastedBinaryOp(Da,mb,"bool",function(Bb,$b){return Bb<=$b?1:0})};Wa.prototype.greater=function(Da,mb){f([Da,mb],"greater");return this.broadcastedBinaryOp(Da,mb,"bool",function(Bb,$b){return Bb>$b?1:0})};Wa.prototype.greaterEqual=function(Da,mb){f([Da,mb],"greaterEqual");return this.broadcastedBinaryOp(Da,mb,"bool",function(Bb,$b){return Bb>=$b?1:0})};Wa.prototype.logicalAnd=function(Da,mb){f([Da,mb],"logicalAnd");
return this.broadcastedBinaryOp(Da,mb,"bool",function(Bb,$b){return Bb&&$b})};Wa.prototype.logicalOr=function(Da,mb){f([Da,mb],"logicalOr");return this.broadcastedBinaryOp(Da,mb,"bool",function(Bb,$b){return Bb||$b})};Wa.prototype.select=function(Da,mb,Bb){f([Da,mb,Bb],"select");var $b=this.readSync(Da.dataId),wc=this.readSync(mb.dataId),Rc=this.readSync(Bb.dataId);Bb=I.zeros(mb.shape,I.upcastType(mb.dtype,Bb.dtype));var Zc=this.readSync(Bb.dataId),Xc=0;Da=0===Da.rank||1<Da.rank||1===mb.rank?1:I.util.sizeFromShape(mb.shape.slice(1));
for(mb=0;mb<$b.length;mb++)for(var bd=0;bd<Da;bd++)1===$b[mb]?Zc[Xc++]=wc[mb]:Zc[Xc++]=Rc[mb];return Bb};Wa.prototype.where=function(Da){f([Da],"where");var mb=this.readSync(Da.dataId);return fa(Da.shape,mb)};Wa.prototype.topk=function(Da,mb,Bb){f(Da,"topk");var $b=this.readSync(Da.dataId);return pa($b,Da.shape,Da.dtype,mb,Bb)};Wa.prototype.min=function(Da,mb){f(Da,"min");I.backend_util.assertAxesAreInnerMostDims("min",mb,Da.rank);mb=I.backend_util.computeOutAndReduceShapes(Da.shape,mb);var Bb=mb[1];
mb=I.zeros(mb[0],Da.dtype);Bb=I.util.sizeFromShape(Bb);var $b=this.readSync(mb.dataId);Da=this.readSync(Da.dataId);for(var wc=0;wc<$b.length;++wc){for(var Rc=wc*Bb,Zc=Da[Rc],Xc=0;Xc<Bb;++Xc){var bd=Da[Rc+Xc];bd<Zc&&(Zc=bd)}$b[wc]=Zc}return mb};Wa.prototype.minimum=function(Da,mb){f([Da,mb],"minimum");return this.broadcastedBinaryOp(Da,mb,Da.dtype,function(Bb,$b){return Math.min(Bb,$b)})};Wa.prototype.mod=function(Da,mb){f([Da,mb],"mod");return this.broadcastedBinaryOp(Da,mb,Da.dtype,function(Bb,$b){var wc=
Bb%$b;return 0>Bb&&0>$b||0<=Bb&&0<=$b?wc:(wc+$b)%$b})};Wa.prototype.maximum=function(Da,mb){f([Da,mb],"maximum");return this.broadcastedBinaryOp(Da,mb,Da.dtype,function(Bb,$b){return Math.max(Bb,$b)})};Wa.prototype.all=function(Da,mb){f(Da,"all");I.backend_util.assertAxesAreInnerMostDims("all",mb,Da.rank);mb=I.backend_util.computeOutAndReduceShapes(Da.shape,mb);var Bb=mb[1];mb=I.zeros(mb[0],Da.dtype);Bb=I.util.sizeFromShape(Bb);var $b=this.readSync(mb.dataId);Da=this.readSync(Da.dataId);for(var wc=
0;wc<$b.length;++wc){for(var Rc=wc*Bb,Zc=Da[Rc],Xc=0;Xc<Bb;++Xc){var bd=Da[Rc+Xc];Zc=Zc&&bd}$b[wc]=Zc}return mb};Wa.prototype.any=function(Da,mb){f(Da,"any");I.backend_util.assertAxesAreInnerMostDims("any",mb,Da.rank);mb=I.backend_util.computeOutAndReduceShapes(Da.shape,mb);var Bb=mb[1];mb=I.zeros(mb[0],Da.dtype);Bb=I.util.sizeFromShape(Bb);var $b=this.readSync(mb.dataId);Da=this.readSync(Da.dataId);for(var wc=0;wc<$b.length;++wc){for(var Rc=wc*Bb,Zc=Da[Rc],Xc=0;Xc<Bb;++Xc){var bd=Da[Rc+Xc];Zc=Zc||
bd}$b[wc]=Zc}return mb};Wa.prototype.squaredDifference=function(Da,mb){f([Da,mb],"squaredDifference");return this.broadcastedBinaryOp(Da,mb,Da.dtype,function(Bb,$b){Bb-=$b;return Bb*Bb})};Wa.prototype.eluDer=function(Da,mb){f([Da,mb],"eluDer");var Bb=new Float32Array(mb.size),$b=this.readSync(mb.dataId);Da=this.readSync(Da.dataId);for(var wc=0;wc<$b.length;++wc){var Rc=$b[wc];Bb[wc]=1<=Rc?Da[wc]:Da[wc]*(Rc+1)}return this.makeOutput(Bb,mb.shape,"float32")};Wa.prototype.atan2=function(Da,mb){f([Da,
mb],"atan2");return this.broadcastedBinaryOp(Da,mb,Da.dtype,function(Bb,$b){return Math.atan2(Bb,$b)})};Wa.prototype.tile=function(Da,mb){f(Da,"tile");return da(this.bufferSync(Da),mb)};Wa.prototype.gather=function(Da,mb,Bb){f([Da,mb],"gather");var $b=Da.shape.slice();mb=this.readSync(mb.dataId);$b[Bb]=mb.length;$b=I.buffer($b,Da.dtype);Da=this.bufferSync(Da);for(var wc=0;wc<$b.size;++wc){var Rc=$b.indexToLoc(wc),Zc=Rc.slice();Zc[Bb]=mb[Rc[Bb]];Rc=Da.locToIndex(Zc);$b.values[wc]=Da.values[Rc]}return $b.toTensor()};
Wa.prototype.batchToSpaceND=function(Da,mb,Bb){f([Da],"batchToSpaceND");var $b=mb.reduce(function(Xc,bd){return Xc*bd}),wc=I.backend_util.getReshaped(Da.shape,mb,$b),Rc=I.backend_util.getPermuted(wc.length,mb.length);$b=I.backend_util.getReshapedPermuted(Da.shape,mb,$b);var Zc=I.backend_util.getSliceBeginCoords(Bb,mb.length);mb=I.backend_util.getSliceSize($b,Bb,mb.length);return I.transpose(Da.reshape(wc),Rc).reshape($b).slice(Zc,mb)};Wa.prototype.pool3d=function(Da,mb,Bb){f(Da,"pool3d");for(var $b=
mb.strideDepth,wc=mb.strideHeight,Rc=mb.strideWidth,Zc=mb.dilationDepth,Xc=mb.dilationHeight,bd=mb.dilationWidth,id=mb.effectiveFilterDepth,Ic=mb.effectiveFilterHeight,Kd=mb.effectiveFilterWidth,Bd=mb.padInfo.front,vd=mb.padInfo.top,Nd=mb.padInfo.left,de="max"===Bb?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,ne=this.readSync(Da.dataId),xe=I.buffer(mb.outShape,Da.dtype),Vd=xe.values,le=mb.outShape[1]*mb.outShape[2]*mb.outShape[3]*mb.outShape[4],ue=mb.outShape[2]*mb.outShape[3]*mb.outShape[4],
Ae=mb.outShape[3]*mb.outShape[4],kb=mb.outShape[4],yb=0;yb<mb.batchSize;++yb)for(var Hb=yb*le,ec=yb*Da.strides[0],Bc=0;Bc<mb.inChannels;++Bc)for(var Sc=0;Sc<mb.outDepth;++Sc){for(var Uc=Sc*$b-Bd,Ed=Uc;0>Ed;)Ed+=Zc;Uc=Math.min(mb.inDepth,id+Uc);for(var Sd=Hb+Sc*ue,Xe=0;Xe<mb.outHeight;++Xe){for(var pf=Xe*wc-vd,wf=pf;0>wf;)wf+=Xc;pf=Math.min(mb.inHeight,Ic+pf);for(var Yf=Sd+Xe*Ae,of=0;of<mb.outWidth;++of){for(var fg=of*Rc-Nd,zd=fg;0>zd;)zd+=bd;fg=Math.min(mb.inWidth,Kd+fg);for(var uf=Yf+of*kb,ng=de,
hg=0,Ng=0,Ig=Ed;Ig<Uc;Ig+=Zc){for(var Og=ec+Ig*Da.strides[1],Dg=wf;Dg<pf;Dg+=Xc){for(var fh=Og+Dg*Da.strides[2],Kg=zd;Kg<fg;Kg+=bd){var Pg=ne[fh+Kg*Da.strides[3]+Bc];"max"===Bb&&Pg>ng?ng=Pg:"avg"===Bb&&(hg+=Pg,Ng++);if(isNaN(ng))break}if(isNaN(ng))break}if(isNaN(ng))break}Vd[uf+Bc]="avg"===Bb?hg/Ng:ng}}}return xe.toTensor()};Wa.prototype.avgPool3d=function(Da,mb){f(Da,"avgPool3d");return this.pool3d(Da,mb,"avg").toFloat()};Wa.prototype.avgPool3dBackprop=function(Da,mb,Bb){f([Da,mb],"avgPool3dBackprop");
var $b=Bb.strideDepth,wc=Bb.strideHeight,Rc=Bb.strideWidth,Zc=Bb.filterDepth,Xc=Bb.filterHeight,bd=Bb.filterWidth,id=Bb.dilationDepth,Ic=Bb.dilationHeight,Kd=Bb.dilationWidth,Bd=Bb.effectiveFilterDepth,vd=Bb.effectiveFilterHeight,Nd=Bb.effectiveFilterWidth,de=Bd-1-Bb.padInfo.front,ne=Nd-1-Bb.padInfo.left,xe=vd-1-Bb.padInfo.top;mb=I.buffer(mb.shape,"float32");Zc=1/(Zc*Xc*bd);Da=this.bufferSync(Da);for(Xc=0;Xc<Bb.batchSize;++Xc)for(bd=0;bd<Bb.inChannels;++bd)for(var Vd=0;Vd<Bb.inDepth;++Vd)for(var le=
0;le<Bb.inHeight;++le)for(var ue=0;ue<Bb.inWidth;++ue){for(var Ae=Vd-de,kb=le-xe,yb=ue-ne,Hb=0,ec=0;ec<Bd;ec+=id){var Bc=(Ae+ec)/$b;if(!(0>Bc||Bc>=Bb.outDepth||Math.floor(Bc)!==Bc))for(var Sc=0;Sc<vd;Sc+=Ic){var Uc=(kb+Sc)/wc;if(!(0>Uc||Uc>=Bb.outHeight||Math.floor(Uc)!==Uc))for(var Ed=0;Ed<Nd;Ed+=Kd){var Sd=(yb+Ed)/Rc;0>Sd||Sd>=Bb.outWidth||Math.floor(Sd)!==Sd||(Sd=Da.get(Xc,Bc,Uc,Sd,bd),Hb+=Sd)}}}mb.set(Hb*Zc,Xc,Vd,le,ue,bd)}return mb.toTensor()};Wa.prototype.maxPool3d=function(Da,mb){f(Da,"maxPool3d");
return this.pool3d(Da,mb,"max").toFloat()};Wa.prototype.maxPool3dPositions=function(Da,mb){var Bb=I.buffer(mb.outShape,"int32"),$b=mb.strideDepth,wc=mb.strideHeight,Rc=mb.strideWidth,Zc=mb.dilationDepth,Xc=mb.dilationHeight,bd=mb.dilationWidth,id=mb.effectiveFilterDepth,Ic=mb.effectiveFilterHeight,Kd=mb.effectiveFilterWidth,Bd=mb.padInfo.front,vd=mb.padInfo.top,Nd=mb.padInfo.left;Da=this.bufferSync(Da);for(var de=0;de<mb.batchSize;++de)for(var ne=0;ne<mb.inChannels;++ne)for(var xe=0;xe<mb.outDepth;++xe){for(var Vd=
xe*$b-Bd,le=Vd;0>le;)le+=Zc;for(var ue=Math.min(mb.inDepth,id+Vd),Ae=0;Ae<mb.outHeight;++Ae){for(var kb=Ae*wc-vd,yb=kb;0>yb;)yb+=Xc;for(var Hb=Math.min(mb.inHeight,Ic+kb),ec=0;ec<mb.outWidth;++ec){for(var Bc=ec*Rc-Nd,Sc=Bc;0>Sc;)Sc+=bd;for(var Uc=Math.min(mb.inWidth,Kd+Bc),Ed=Number.NEGATIVE_INFINITY,Sd=-1,Xe=le;Xe<ue;Xe+=Zc)for(var pf=Xe-Vd,wf=yb;wf<Hb;wf+=Xc)for(var Yf=wf-kb,of=Sc;of<Uc;of+=bd){var fg=of-Bc,zd=Da.get(de,Xe,wf,of,ne);zd>=Ed&&(Ed=zd,Sd=pf*Ic*Kd+Yf*Ic+fg)}Bb.set(Sd,de,xe,Ae,ec,ne)}}}return Bb.toTensor()};
Wa.prototype.maxPool3dBackprop=function(Da,mb,Bb,$b){f([mb,Bb],"maxPool3dBackprop");var wc=this.maxPool3dPositions(mb,$b);Bb=$b.strideDepth;var Rc=$b.strideHeight,Zc=$b.strideWidth,Xc=$b.dilationDepth,bd=$b.dilationHeight,id=$b.dilationWidth,Ic=$b.effectiveFilterDepth,Kd=$b.effectiveFilterHeight,Bd=$b.effectiveFilterWidth,vd=Ic-1-$b.padInfo.front,Nd=Bd-1-$b.padInfo.left,de=Kd-1-$b.padInfo.top;mb=I.buffer(mb.shape,"float32");wc=this.bufferSync(wc);Da=this.bufferSync(Da);for(var ne=0;ne<$b.batchSize;++ne)for(var xe=
0;xe<$b.inChannels;++xe)for(var Vd=0;Vd<$b.inDepth;++Vd)for(var le=0;le<$b.inHeight;++le)for(var ue=0;ue<$b.inWidth;++ue){for(var Ae=Vd-vd,kb=le-de,yb=ue-Nd,Hb=0,ec=0;ec<Ic;ec+=Xc){var Bc=(Ae+ec)/Bb;if(!(0>Bc||Bc>=$b.outDepth||Math.floor(Bc)!==Bc))for(var Sc=0;Sc<Kd;Sc+=bd){var Uc=(kb+Sc)/Rc;if(!(0>Uc||Uc>=$b.outHeight||Math.floor(Uc)!==Uc))for(var Ed=0;Ed<Bd;Ed+=id){var Sd=(yb+Ed)/Zc;if(!(0>Sd||Sd>=$b.outWidth||Math.floor(Sd)!==Sd)){var Xe=Ic*Kd*Bd-1-wc.get(ne,Bc,Uc,Sd,xe)===ec*Kd*Bd+Sc*Bd+Ed?1:
0;0!==Xe&&(Sd=Da.get(ne,Bc,Uc,Sd,xe),Hb+=Sd*Xe)}}}}mb.set(Hb,ne,Vd,le,ue,xe)}return mb.toTensor()};Wa.prototype.resizeBilinear=function(Da,mb,Bb,$b){f(Da,"resizeBilinear");var wc=Da.shape,Rc=wc[0],Zc=wc[1],Xc=wc[2];wc=wc[3];var bd=this.readSync(Da.dataId),id=new Float32Array(I.util.sizeFromShape([Rc,mb,Bb,wc])),Ic=[$b&&1<mb?Zc-1:Zc,$b&&1<Bb?Xc-1:Xc],Kd=[$b&&1<mb?mb-1:mb,$b&&1<Bb?Bb-1:Bb];$b=0;var Bd=Ic[0]/Kd[0];Ic=Ic[1]/Kd[1];for(Kd=0;Kd<Rc;Kd++)for(var vd=0;vd<mb;vd++){var Nd=Bd*vd,de=Math.floor(Nd),
ne=Nd-de;de=Kd*Da.strides[0]+de*Da.strides[1];Nd=Kd*Da.strides[0]+Math.min(Zc-1,Math.ceil(Nd))*Da.strides[1];for(var xe=0;xe<Bb;xe++){var Vd=Ic*xe,le=Math.floor(Vd),ue=Vd-le,Ae=Math.min(Xc-1,Math.ceil(Vd));Vd=de+le*Da.strides[2];le=Nd+le*Da.strides[2];var kb=de+Ae*Da.strides[2];Ae=Nd+Ae*Da.strides[2];for(var yb=0;yb<wc;yb++){var Hb=bd[Vd+yb],ec=bd[le+yb];Hb+=(bd[kb+yb]-Hb)*ue;ec=Hb+(ec+(bd[Ae+yb]-ec)*ue-Hb)*ne;id[$b++]=ec}}}return I.tensor(id,[Rc,mb,Bb,wc])};Wa.prototype.resizeBilinearBackprop=function(Da,
mb,Bb){f([Da,mb],"resizeBilinearBackprop");var $b=mb.shape,wc=$b[0],Rc=$b[1],Zc=$b[2];$b=$b[3];var Xc=Da.shape,bd=Xc[1];Xc=Xc[2];var id=new Float32Array(wc*Rc*Zc*$b),Ic=[Bb&&1<bd?Rc-1:Rc,Bb&&1<Xc?Zc-1:Zc],Kd=[Bb&&1<bd?bd-1:bd,Bb&&1<Xc?Xc-1:Xc];Bb=Ic[0]/Kd[0];Ic=Ic[1]/Kd[1];Da=this.readSync(Da.dataId);for(var Bd=Kd=0;Bd<wc;Bd++)for(var vd=Bd*mb.strides[0],Nd=0;Nd<bd;Nd++){var de=Nd*Bb,ne=Math.floor(de),xe=vd+ne*mb.strides[1],Vd=vd+Math.min(Math.ceil(de),Rc-1)*mb.strides[1];de-=ne;ne=1-de;for(var le=
0;le<Xc;le++){var ue=le*Ic,Ae=Math.floor(ue),kb=Math.min(Math.ceil(ue),Zc-1),yb=ue-Ae,Hb=1-yb;ue=xe+Ae*mb.strides[2];var ec=xe+kb*mb.strides[2];Ae=Vd+Ae*mb.strides[2];kb=Vd+kb*mb.strides[2];var Bc=ne*Hb,Sc=ne*yb;Hb*=de;yb*=de;for(var Uc=0;Uc<$b;Uc++){var Ed=Da[Kd++];id[ue+Uc]+=Ed*Bc;id[ec+Uc]+=Ed*Sc;id[Ae+Uc]+=Ed*Hb;id[kb+Uc]+=Ed*yb}}}return I.tensor4d(id,[wc,Zc,Rc,$b],mb.dtype)};Wa.prototype.resizeNearestNeighbor=function(Da,mb,Bb,$b){f(Da,"resizeNearestNeighbor");var wc=Da.shape,Rc=wc[0],Zc=wc[1],
Xc=wc[2];wc=wc[3];var bd=this.readSync(Da.dataId),id=new Float32Array(Rc*mb*Bb*wc),Ic=[$b&&1<mb?Zc-1:Zc,$b&&1<Bb?Xc-1:Xc],Kd=[$b&&1<mb?mb-1:mb,$b&&1<Bb?Bb-1:Bb],Bd=Ic[0]/Kd[0];Ic=Ic[1]/Kd[1];for(var vd=Kd=0;vd<Rc;vd++)for(var Nd=vd*Da.strides[0],de=0;de<mb;de++){var ne=Bd*de;ne=Nd+Math.min(Zc-1,$b?Math.round(ne):Math.floor(ne))*Da.strides[1];for(var xe=0;xe<Bb;xe++){var Vd=Ic*xe;Vd=ne+Math.min(Xc-1,$b?Math.round(Vd):Math.floor(Vd))*Da.strides[2];for(var le=0;le<wc;le++){var ue=bd[Vd+le];id[Kd++]=
ue}}}return I.tensor(id,[Rc,mb,Bb,wc],Da.dtype)};Wa.prototype.resizeNearestNeighborBackprop=function(Da,mb,Bb){f([Da,mb],"resizeNearestNeighborBackprop");var $b=mb.shape,wc=$b[0],Rc=$b[1],Zc=$b[2];$b=$b[3];var Xc=Da.shape,bd=Xc[1];Xc=Xc[2];var id=new Float32Array(wc*Rc*Zc*$b),Ic=this.readSync(Da.dataId),Kd=[Bb&&1<bd?Rc-1:Rc,Bb&&1<Xc?Zc-1:Zc],Bd=[Bb&&1<bd?bd-1:bd,Bb&&1<Xc?Xc-1:Xc],vd=Kd[0]/Bd[0];Kd=Kd[1]/Bd[1];Bd=1/vd;for(var Nd=1/Kd,de=2*Math.ceil(Bd)+2,ne=2*Math.ceil(Nd)+2,xe=0;xe<wc;xe++)for(var Vd=
xe*mb.strides[0],le=0;le<Rc;le++)for(var ue=Vd+le*mb.strides[1],Ae=Math.floor(Math.floor(le*Bd)-de/2),kb=0;kb<Zc;kb++)for(var yb=ue+kb*mb.strides[2],Hb=Math.floor(Math.floor(kb*Nd)-ne/2),ec=0;ec<$b;ec++){for(var Bc=0,Sc=0;Sc<de;Sc++){var Uc=Sc+Ae;if(!(0>Uc||Uc>=bd)){var Ed=Vd+Uc*Da.strides[1];Uc*=vd;if(le===Math.min(Rc-1,Bb?Math.round(Uc):Math.floor(Uc)))for(Uc=0;Uc<ne;Uc++){var Sd=Uc+Hb;if(!(0>Sd||Sd>=Xc)){var Xe=Ed+Sd*Da.strides[2];Sd*=Kd;kb===Math.min(Zc-1,Bb?Math.round(Sd):Math.floor(Sd))&&(Bc+=
Ic[Xe+ec])}}}}id[yb+ec]=Bc}return I.tensor4d(id,mb.shape,mb.dtype)};Wa.prototype.localResponseNormalization4D=function(Da,mb,Bb,$b,wc){f(Da,"localResponseNormalization4D");for(var Rc=Da.shape[3],Zc=Rc-1,Xc=this.readSync(Da.dataId),bd=Da.size,id=new Float32Array(bd),Ic=0;Ic<bd;Ic++){var Kd=Ic%Rc,Bd=Ic-Kd+Math.max(0,Kd-mb);Kd=Ic-Kd+Math.min(Kd+mb,Zc);for(var vd=0;Bd<=Kd;Bd++){var Nd=Xc[Bd];vd+=Nd*Nd}id[Ic]=Xc[Ic]*Math.pow(Bb+$b*vd,-wc)}return I.tensor4d(id,Da.shape)};Wa.prototype.LRNGrad=function(Da,
mb,Bb,$b,wc,Rc,Zc){f(Da,"LRNGrad");var Xc=Da.shape[3],bd=this.readSync(Da.dataId);mb=this.readSync(mb.dataId);Bb=this.readSync(Bb.dataId);for(var id=new Float32Array(Da.size),Ic=Da.size,Kd=0;Kd<Ic;Kd++){var Bd=Kd%Xc,vd=Kd-Bd+Math.max(0,Bd-$b);Bd=Kd-Bd+Math.min(Xc,Bd+$b+1);for(var Nd=0,de=vd;de<Bd;de++)Nd+=Math.pow(mb[de],2);Nd=Rc*Nd+wc;for(de=vd;de<Bd;de++)vd=-2*Rc*Zc*mb[de]*Bb[Kd]/Nd,Kd===de&&(vd+=Math.pow(Nd,-Zc)),vd*=bd[Kd],id[de]+=vd}return I.tensor4d(id,Da.shape)};Wa.prototype.multinomial=function(Da,
mb,Bb,$b){f(Da,"multinomial");var wc=mb?Da:I.softmax(Da);Da=wc.shape[0];mb=wc.shape[1];var Rc=I.zeros([Da,Bb],"int32"),Zc=this.readSync(Rc.dataId);wc=this.readSync(wc.dataId);for(var Xc=0;Xc<Da;++Xc){var bd=Xc*mb,id=new Float32Array(mb-1);id[0]=wc[bd];for(var Ic=1;Ic<id.length;++Ic)id[Ic]=id[Ic-1]+wc[bd+Ic];bd=T.alea($b.toString());Ic=Xc*Bb;for(var Kd=0;Kd<Bb;++Kd){var Bd=bd();Zc[Ic+Kd]=id.length;for(var vd=0;vd<id.length;vd++)if(Bd<id[vd]){Zc[Ic+Kd]=vd;break}}}return Rc};Wa.prototype.oneHot=function(Da,
mb,Bb,$b){f(Da,"oneHot");var wc=new Float32Array(Da.size*mb);wc.fill($b);$b=this.readSync(Da.dataId);for(var Rc=0;Rc<Da.size;++Rc)0<=$b[Rc]&&$b[Rc]<mb&&(wc[Rc*mb+$b[Rc]]=Bb);return I.tensor2d(wc,[Da.size,mb],"int32")};Wa.prototype.nonMaxSuppression=function(Da,mb,Bb,$b,wc){f(Da,"nonMaxSuppression");Da=this.readSync(Da.dataId);mb=this.readSync(mb.dataId);return ba(Da,mb,Bb,$b,wc)};Wa.prototype.depthToSpace=function(Da,mb,Bb){I.util.assert("NHWC"===Bb,function(){return"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+
Bb});I.util.assert(1<mb,function(){return"blockSize should be \x3e 1 for depthToSpace, but was: "+mb});var $b=Da.shape[0],wc=Da.shape[1],Rc=Da.shape[2],Zc=Da.shape[3],Xc=wc*mb,bd=Rc*mb,id=Zc/(mb*mb);Da=this.readSync(Da.dataId);for(var Ic=new Float32Array($b*Xc*bd*id),Kd=0,Bd=0;Bd<$b;++Bd)for(var vd=0;vd<Xc;++vd)for(var Nd=Math.floor(vd/mb),de=vd%mb,ne=0;ne<bd;++ne)for(var xe=Math.floor(ne/mb),Vd=(de*mb+ne%mb)*id,le=0;le<id;++le){var ue=le+Vd+Zc*(xe+Rc*(Nd+wc*Bd));Ic[Kd++]=Da[ue]}return I.tensor4d(Ic,
[$b,Xc,bd,id])};Wa.prototype.broadcastedBinaryOp=function(Da,mb,Bb,$b){var wc=I.backend_util.assertAndGetBroadcastShape(Da.shape,mb.shape),Rc=I.buffer(wc,Bb),Zc=this.readSync(Da.dataId),Xc=this.readSync(mb.dataId),bd=I.backend_util.getBroadcastDims(Da.shape,wc),id=I.backend_util.getBroadcastDims(mb.shape,wc),Ic=Rc.values;if(0===bd.length+id.length)for(Bb=0;Bb<Ic.length;++Bb)Ic[Bb]=$b(Zc[Bb%Zc.length],Xc[Bb%Xc.length]);else{var Kd=this.bufferSync(Da),Bd=this.bufferSync(mb);wc=function(vd){var Nd=Rc.indexToLoc(vd),
de=Nd.slice(-Da.rank);bd.forEach(function(Vd){return de[Vd]=0});var ne=Kd.locToIndex(de),xe=Nd.slice(-mb.rank);id.forEach(function(Vd){return xe[Vd]=0});Nd=Bd.locToIndex(xe);Ic[vd]=$b(Zc[ne],Xc[Nd])};for(Bb=0;Bb<Ic.length;++Bb)wc(Bb)}return Rc.toTensor()};Wa.prototype.split=function(Da,mb,Bb){return Z(Da,mb,Bb)};Wa.prototype.dispose=function(){};Wa.prototype.floatPrecision=function(){return 32};Wa.prototype.epsilon=function(){return xa.prototype.epsilon.call(this)};Wa.prototype.cropAndResize=function(Da,
mb,Bb,$b,wc,Rc){var Zc=Da.shape,Xc=Zc[0],bd=Zc[1],id=Zc[2];Zc=Zc[3];var Ic=mb.shape[0],Kd=$b[0];$b=$b[1];var Bd=I.buffer([Ic,Kd,$b,Zc],"float32");mb=this.readSync(mb.dataId);Bb=this.readSync(Bb.dataId);var vd=this.readSync(Da.dataId);Da=Da.strides;for(var Nd=Bd.strides,de=0;de<Ic;de++){var ne=4*de,xe=mb[ne],Vd=mb[ne+1],le=mb[ne+2];ne=mb[ne+3];var ue=Bb[de];if(!(ue>=Xc))for(var Ae=1<Kd?(le-xe)*(bd-1)/(Kd-1):0,kb=1<$b?(ne-Vd)*(id-1)/($b-1):0,yb=0;yb<Kd;yb++){var Hb=1<Kd?xe*(bd-1)+yb*Ae:.5*(xe+le)*(bd-
1);if(0>Hb||Hb>bd-1)for(var ec=0;ec<$b;ec++)for(var Bc=0;Bc<Zc;Bc++){var Sc=Bc+ec*Nd[2]+yb*Nd[1]+de*Nd[0];Bd.values[Sc]=Rc}else if("bilinear"===wc){var Uc=Math.floor(Hb),Ed=Math.ceil(Hb);Hb-=Uc;for(ec=0;ec<$b;ec++)if(Bc=1<$b?Vd*(id-1)+ec*kb:.5*(Vd+ne)*(id-1),0>Bc||Bc>id-1)for(Bc=0;Bc<Zc;Bc++)Sc=Bc+ec*Nd[2]+yb*Nd[1]+de*Nd[0],Bd.values[Sc]=Rc;else{var Sd=Math.floor(Bc),Xe=Math.ceil(Bc),pf=Bc-Sd;for(Bc=0;Bc<Zc;Bc++){Sc=Bc+Sd*Da[2]+Uc*Da[1]+ue*Da[0];var wf=vd[Sc];Sc=Bc+Xe*Da[2]+Uc*Da[1]+ue*Da[0];var Yf=
vd[Sc];Sc=Bc+Sd*Da[2]+Ed*Da[1]+ue*Da[0];var of=vd[Sc];Sc=Bc+Xe*Da[2]+Ed*Da[1]+ue*Da[0];wf+=(Yf-wf)*pf;of+=(vd[Sc]-of)*pf;Sc=Bc+ec*Nd[2]+yb*Nd[1]+de*Nd[0];Bd.values[Sc]=wf+(of-wf)*Hb}}}else for(ec=0;ec<$b;++ec)if(Bc=1<$b?Vd*(id-1)+ec*kb:.5*(Vd+ne)*(id-1),0>Bc||Bc>id-1)for(Bc=0;Bc<Zc;Bc++)Sc=Bc+ec*Nd[2]+yb*Nd[1]+de*Nd[0],Bd.values[Sc]=Rc;else for(Uc=Math.round(Bc),Ed=Math.round(Hb),Bc=0;Bc<Zc;Bc++)Bd.values[Bc+ec*Nd[2]+yb*Nd[1]+de*Nd[0]]=vd[Bc+Uc*Da[2]+Ed*Da[1]+ue*Da[0]]}}return Bd.toTensor()};Wa.prototype.sparseToDense=
function(Da,mb,Bb,$b){var wc=I.backend_util.calculateShapes(mb,Da,Bb);return this.scatter(Da,mb,Bb,wc.outputSize,wc.sliceSize,wc.numUpdates,wc.sliceRank,wc.strides,$b,!1)};Wa.prototype.gatherND=function(Da,mb){var Bb=mb.shape;Bb=Bb[Bb.length-1];var $b=I.backend_util.prepareAndValidate(Da,mb),wc=$b[0],Rc=$b[1],Zc=$b[2];$b=$b[3];if(0===Rc)return I.tensor([],wc,Da.dtype);var Xc=new I.TensorBuffer([Rc,Zc],Da.dtype);mb=this.readSync(mb.dataId);for(var bd=this.readSync(Da.dataId),id=0;id<Rc;id++){for(var Ic=
[],Kd=0,Bd=0;Bd<Bb;Bd++){var vd=mb[id*Bb+Bd];Kd+=vd*$b[Bd];Ic.push(vd)}if(0>Kd||Kd>=Da.size/Zc)throw Error("Invalid indices: "+Ic+" does not index into "+Da.shape);for(Ic=0;Ic<Zc;Ic++)Xc.values[id*Zc+Ic]=bd[Kd*Zc+Ic]}return Xc.toTensor().reshape(wc)};Wa.prototype.scatterND=function(Da,mb,Bb){var $b=I.backend_util.calculateShapes(mb,Da,Bb),wc=$b.sliceRank,Rc=$b.numUpdates,Zc=$b.sliceSize,Xc=$b.strides;$b=$b.outputSize;var bd=I.scalar(0);return this.scatter(Da,mb,Bb,$b,Zc,Rc,wc,Xc,bd,!0)};Wa.prototype.onesLike=
function(Da){if("string"===Da.dtype)throw Error("onesLike is not supported for string tensors");return I.fill(Da.shape,1,Da.dtype)};Wa.prototype.zerosLike=function(Da){var mb=I.util.getArrayFromDType(Da.dtype,I.util.sizeFromShape(Da.shape));return this.makeOutput(mb,Da.shape,Da.dtype)};Wa.prototype.linspace=function(Da,mb,Bb){return I.backend_util.linspaceImpl(Da,mb,Bb)};Wa.prototype.scatter=function(Da,mb,Bb,$b,wc,Rc,Zc,Xc,bd,id){var Ic=[$b/wc,wc];Da=this.readSync(Da.dataId);var Kd=this.readSync(mb.dataId);
if(0===$b)return I.tensor([],Bb,mb.dtype);Ic=new I.TensorBuffer(Ic,mb.dtype);Ic.values.fill(this.readSync(bd.dataId)[0]);for(bd=0;bd<Rc;bd++){for(var Bd=[],vd=0,Nd=0;Nd<Zc;Nd++){var de=Da[bd*Zc+Nd];Bd.push(de);vd+=de*Xc[Nd]}if(0>vd||vd>=$b/wc)throw Error("Invalid indices: "+Bd+" does not index into "+Bb);for(Bd=0;Bd<wc;Bd++)Ic.values[vd*wc+Bd]=id?Ic.values[vd*wc+Bd]+Kd[bd*wc+Bd]:0===mb.rank?Kd[0]:Kd[bd*wc+Bd]}return Ic.toTensor().reshape(Bb)};return Wa}(I.KernelBackend),ma={kernelName:I.Abs,backendName:"cpu",
kernelFunc:function(xa){var Wa=xa.inputs.x;xa=xa.backend;var Da=new Float32Array(I.util.sizeFromShape(Wa.shape));if("complex64"!==Wa.dtype)Da=xa.data.get(Wa.dataId).values,Da=a(Da);else{var mb=xa.data.get(Wa.dataId),Bb=mb.complexTensorInfos.imag;mb=xa.data.get(mb.complexTensorInfos.real.dataId).values;Bb=xa.data.get(Bb.dataId).values;for(var $b=0;$b<mb.length;$b++)Da[$b]=Math.hypot(mb[$b],Bb[$b])}return xa.makeOutput(Da,Wa.shape,"float32")}},ja={kernelName:I.Complex,backendName:"cpu",kernelFunc:e},
qa={kernelName:I.Identity,backendName:"cpu",kernelFunc:g},Fa={kernelName:I.Real,backendName:"cpu",kernelFunc:d},ua={kernelName:I.Cast,backendName:"cpu",kernelFunc:h},Ra=b(function(xa,Wa){return xa+Wa}),Ia=l(function(xa,Wa,Da,mb){return{real:xa+Da,imag:Wa+mb}}),oa=c(I.Add,Ra,Ia),Ba={kernelName:I.Add,backendName:"cpu",kernelFunc:oa},gb=m(function(xa){return Math.ceil(xa)}),Va=k(I.Ceil,gb),Ma={kernelName:I.Ceil,backendName:"cpu",kernelFunc:Va},ib=m(function(xa){return Math.exp(xa)}),Ja=k(I.Exp,ib),Sa=
{kernelName:I.Exp,backendName:"cpu",kernelFunc:Ja},S=m(function(xa){return Math.expm1(xa)}),ha=k(I.Expm1,S),ya={kernelName:I.Expm1,backendName:"cpu",kernelFunc:ha},Qa=m(function(xa){return Math.floor(xa)}),$a=k(I.Floor,Qa),cb={kernelName:I.Floor,backendName:"cpu",kernelFunc:$a},wa=m(function(xa){return Math.log(xa)}),Aa=k(I.Log,wa),lb={kernelName:I.Log,backendName:"cpu",kernelFunc:Aa},Ya=b(function(xa,Wa){return xa*Wa}),Pb=l(function(xa,Wa,Da,mb){return{real:xa*Da-Wa*mb,imag:xa*mb+Wa*Da}}),tb=c(I.Multiply,
Ya,Pb),bb={kernelName:I.Multiply,backendName:"cpu",kernelFunc:tb},La=b(function(xa,Wa){return xa!==Wa?1:0}),Fb=c(I.NotEqual,La,null,"bool"),vb={kernelName:I.NotEqual,backendName:"cpu",kernelFunc:Fb},Xb=m(function(xa){return 1/Math.sqrt(xa)}),Mc=k(I.Rsqrt,Xb),Yc={kernelName:I.Rsqrt,backendName:"cpu",kernelFunc:Mc},yd={kernelName:I.Slice,backendName:"cpu",kernelFunc:w},pd=b(function(xa,Wa){xa-=Wa;return xa*xa}),sc=c(I.SquaredDifference,pd),tc={kernelName:I.SquaredDifference,backendName:"cpu",kernelFunc:sc},
vc=b(function(xa,Wa){return xa-Wa}),$c=l(function(xa,Wa,Da,mb){return{real:xa-Da,imag:Wa-mb}}),xd=c(I.Sub,vc,$c),ab={kernelName:I.Sub,backendName:"cpu",kernelFunc:xd},Ta={__proto__:null,simpleAbsImpl:a,addImpl:Ra,ceilImpl:gb,expImpl:ib,expm1Impl:S,floorImpl:Qa,logImpl:wa,maxImpl:p,multiplyImpl:Ya,notEqualImpl:La,rsqrtImpl:Xb,sliceImpl:q,squaredDifferenceImpl:pd,subImpl:vc,transposeImpl:y,uniqueImpl:C};I.registerBackend("cpu",function(){return new ta},1);for(var jb=n(I.Elu,function(xa){return 0<=xa?
xa:Math.exp(xa)-1}),Wb={kernelName:I.Elu,backendName:"cpu",kernelFunc:jb},xc=b(function(xa,Wa){return 0>xa?Wa*xa:xa}),Ec={kernelName:I.Prelu,backendName:"cpu",kernelFunc:z},dd=n(I.Relu,function(xa){return Math.max(0,xa)}),Dc={kernelName:I.Relu,backendName:"cpu",kernelFunc:dd},kd=n(I.Relu6,function(xa){return Math.min(Math.max(0,xa),6)}),ld={kernelName:I.Relu6,backendName:"cpu",kernelFunc:kd},Nb={kernelName:I.Reshape,backendName:"cpu",kernelFunc:J},Sb={kernelName:I.BatchMatMul,backendName:"cpu",kernelFunc:B},
Tb={kernelName:I._FusedMatMul,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=xa.backend,mb=xa.attrs,Bb=Wa.bias,$b=Wa.preluActivationWeights,wc=mb.activation;xa=[];Wa=B({inputs:{a:Wa.a,b:Wa.b},attrs:{transposeA:mb.transposeA,transposeB:mb.transposeB},backend:Da});Bb&&(Bb=oa({inputs:{a:Wa,b:Bb},backend:Da}),xa.push(Wa),Wa=Bb);wc&&($b=K(Da,Wa,wc,$b),xa.push(Wa),Wa=$b);for($b=0;$b<xa.length;$b++)Da.disposeIntermediateTensorInfo(xa[$b]);return Wa}},Ac=n(I.Acos,function(xa){return Math.acos(xa)}),
Kc={kernelName:I.Acos,backendName:"cpu",kernelFunc:Ac},Vc=n(I.Acosh,function(xa){return Math.acosh(xa)}),Pc={kernelName:I.Acosh,backendName:"cpu",kernelFunc:Vc},gd=n(I.Asin,function(xa){return Math.asin(xa)}),Dd={kernelName:I.Asin,backendName:"cpu",kernelFunc:gd},Jd=n(I.Asinh,function(xa){return Math.asinh(xa)}),we={kernelName:I.Asinh,backendName:"cpu",kernelFunc:Jd},Ne=n(I.Atan,function(xa){return Math.atan(xa)}),Je={kernelName:I.Atan,backendName:"cpu",kernelFunc:Ne},Qe=n(I.Atanh,function(xa){return Math.atanh(xa)}),
Ce={kernelName:I.Atanh,backendName:"cpu",kernelFunc:Qe},Oe={kernelName:I.AvgPool,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.backend,Da=xa.attrs;xa=xa.inputs.x;f(xa,"avgPool");var mb=Da.filterSize,Bb=Da.strides,$b=Da.pad;Da=Da.dimRoundingMode;I.util.assert(I.backend_util.eitherStridesOrDilationsAreOne(Bb,1),function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+(Bb+" and dilations '1'")});Da=I.backend_util.computePool2DInfo(xa.shape,mb,Bb,1,$b,Da);1===Da.filterWidth&&
1===Da.filterHeight&&I.util.arraysEqual(Da.inShape,Da.outShape)?Wa=g({inputs:{x:xa},backend:Wa}):(mb=Wa.data.get(xa.dataId).values,$b=I.util.computeStrides(xa.shape),mb=O(mb,xa.shape,xa.dtype,$b,Da,"avg"),Wa=Wa.makeTensorInfo(Da.outShape,xa.dtype,mb.values));return Wa}},od={kernelName:I.AvgPoolBackprop,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=xa.backend;xa=xa.attrs;var mb=Wa.dy,Bb=Wa.input;f([mb,Bb],"avgPoolBackprop");Wa=I.backend_util.computePool2DInfo(Bb.shape,xa.filterSize,
xa.strides,1,xa.pad);xa=Wa.strideHeight;var $b=Wa.strideWidth,wc=Wa.filterHeight,Rc=Wa.filterWidth,Zc=Wa.dilationHeight,Xc=Wa.dilationWidth,bd=Wa.effectiveFilterHeight,id=Wa.effectiveFilterWidth,Ic=id-1-Wa.padInfo.left,Kd=bd-1-Wa.padInfo.top;Bb=I.buffer(Bb.shape,"float32");wc=1/(wc*Rc);Rc=Da.data.get(mb.dataId).values;mb=I.buffer(mb.shape,"float32",Rc);for(Rc=0;Rc<Wa.batchSize;++Rc)for(var Bd=0;Bd<Wa.inChannels;++Bd)for(var vd=0;vd<Wa.inHeight;++vd)for(var Nd=0;Nd<Wa.inWidth;++Nd){for(var de=vd-Kd,
ne=Nd-Ic,xe=0,Vd=0;Vd<bd;Vd+=Zc){var le=(de+Vd)/xa;if(!(0>le||le>=Wa.outHeight||Math.floor(le)!==le))for(var ue=0;ue<id;ue+=Xc){var Ae=(ne+ue)/$b;0>Ae||Ae>=Wa.outWidth||Math.floor(Ae)!==Ae||(Ae=mb.get(Rc,le,Ae,Bd),xe+=Ae)}}Bb.set(xe*wc,Rc,vd,Nd,Bd)}return Da.makeTensorInfo(Bb.shape,Bb.dtype,Bb.values)}},Ud={kernelName:I.FusedBatchNorm,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=xa.backend,mb=xa.attrs;xa=Wa.x;var Bb=Wa.scale,$b=Wa.offset,wc=Wa.mean,Rc=Wa.variance;I.util.assert(wc.shape.length===
Rc.shape.length,function(){return"Batch normalization gradient requires mean and variance to have equal ranks."});I.util.assert(null==$b||wc.shape.length===$b.shape.length,function(){return"Batch normalization gradient requires mean and offset to have equal ranks."});I.util.assert(null==Bb||wc.shape.length===Bb.shape.length,function(){return"Batch normalization gradient requires mean and scale to have equal ranks."});f([xa,wc,Rc,Bb,$b],"batchNorm");Wa=mb.varianceEpsilon;null==Wa&&(Wa=.001);mb=Da.data.get(xa.dataId).values;
wc=Da.data.get(wc.dataId).values;Rc=Da.data.get(Rc.dataId).values;Bb=Bb?Da.data.get(Bb.dataId).values:new Float32Array([1]);$b=$b?Da.data.get($b.dataId).values:new Float32Array([0]);for(var Zc=new Float32Array(mb.length),Xc=$b.length,bd=Bb.length,id=Rc.length,Ic=wc.length,Kd=0,Bd=0,vd=0,Nd=0,de=0;de<mb.length;++de)Zc[de]=$b[Kd++]+(mb[de]-wc[Bd++])*Bb[vd++]/Math.sqrt(Rc[Nd++]+Wa),Kd>=Xc&&(Kd=0),Bd>=Ic&&(Bd=0),vd>=bd&&(vd=0),Nd>=id&&(Nd=0);return Da.makeTensorInfo(xa.shape,xa.dtype,Zc)}},Rd=n(I.ClipByValue,
function(xa,Wa){return xa>Wa.clipValueMax?Wa.clipValueMax:xa<Wa.clipValueMin?Wa.clipValueMin:xa}),pc={kernelName:I.ClipByValue,backendName:"cpu",kernelFunc:Rd},Ue={kernelName:I.Imag,backendName:"cpu",kernelFunc:V},lc={kernelName:I.Concat,backendName:"cpu",kernelFunc:M},pe={kernelName:I.Conv2D,backendName:"cpu",kernelFunc:F},rc={kernelName:I.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=xa.backend,mb=xa.attrs,Bb=Wa.x,$b=Wa.dy;Wa=mb.strides;xa=mb.pad;var wc=mb.dataFormat,
Rc=mb.dimRoundingMode;mb=mb.filterShape;f([Bb,$b],"conv2dBackpropFilter");wc=I.backend_util.convertConv2DDataFormat(wc);Wa=I.backend_util.computeConv2DInfo(Bb.shape,mb,Wa,1,xa,Rc,!1,wc);xa=Wa.strideHeight;Rc=Wa.strideWidth;mb=Wa.filterHeight;wc=Wa.filterWidth;var Zc="channelsLast"===Wa.dataFormat,Xc=new I.TensorBuffer(Wa.filterShape,"float32"),bd=Wa.padInfo.left,id=Wa.padInfo.top,Ic=Da.data.get(Bb.dataId).values,Kd=Da.data.get($b.dataId).values;Bb=new I.TensorBuffer(Bb.shape,Bb.dtype,Ic);$b=new I.TensorBuffer($b.shape,
$b.dtype,Kd);for(Kd=0;Kd<mb;++Kd){Ic=Math.max(0,Math.ceil((id-Kd)/xa));for(var Bd=Math.min(Wa.outHeight,(Wa.inHeight+id-Kd)/xa),vd=0;vd<wc;++vd)for(var Nd=Math.max(0,Math.ceil((bd-vd)/Rc)),de=Math.min(Wa.outWidth,(Wa.inWidth+bd-vd)/Rc),ne=0;ne<Wa.inChannels;++ne)for(var xe=0;xe<Wa.outChannels;++xe){for(var Vd=0,le=0;le<Wa.batchSize;++le)for(var ue=Ic;ue<Bd;++ue)for(var Ae=Kd+ue*xa-id,kb=Nd;kb<de;++kb){var yb=vd+kb*Rc-bd;Vd=Zc?Vd+Bb.get(le,Ae,yb,ne)*$b.get(le,ue,kb,xe):Vd+Bb.get(le,ne,Ae,yb)*$b.get(le,
xe,ue,kb)}Xc.set(Vd,Kd,vd,ne,xe)}}return Da.makeTensorInfo(Xc.shape,Xc.dtype,Xc.values)}},qc={kernelName:I.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=xa.backend,mb=xa.attrs,Bb=Wa.dy,$b=Wa.filter;Wa=mb.inputShape;xa=mb.strides;var wc=mb.pad,Rc=mb.dataFormat,Zc=mb.dimRoundingMode;f([Bb,$b],"conv2dBackpropInput");mb=I.util.computeStrides($b.shape);var Xc=I.util.computeStrides(Bb.shape),bd=I.backend_util.convertConv2DDataFormat(Rc),id=I.backend_util.computeConv2DInfo(Wa,
$b.shape,xa,1,wc,Zc,!1,bd);Wa=new I.TensorBuffer(id.inShape,"float32");xa=Wa.values;Bb=Da.data.get(Bb.dataId).values;$b=Da.data.get($b.dataId).values;wc=mb[0];Rc=mb[1];mb=mb[2];Zc=id.batchSize;var Ic=id.filterHeight,Kd=id.filterWidth,Bd=id.inChannels,vd=id.inHeight,Nd=id.inWidth,de=id.outChannels,ne=id.outHeight,xe=id.outWidth,Vd=id.strideHeight,le=id.strideWidth;bd=id.dataFormat;var ue=Ic-1-id.padInfo.top;id=Kd-1-id.padInfo.left;var Ae="channelsLast"===bd;bd=Wa.strides[0];var kb=Ae?Wa.strides[1]:
Wa.strides[2],yb=Ae?Wa.strides[2]:1,Hb=Ae?1:Wa.strides[1],ec=Xc[0],Bc=Ae?Xc[1]:Xc[2],Sc=Ae?Xc[2]:1;Xc=Ae?1:Xc[1];for(Ae=0;Ae<Zc;++Ae)for(var Uc=0;Uc<Bd;++Uc)for(var Ed=0;Ed<vd;++Ed)for(var Sd=Ed-ue,Xe=Math.max(0,Math.ceil(Sd/Vd)),pf=Math.min(ne,(Ic+Sd)/Vd),wf=0;wf<Nd;++wf){for(var Yf=wf-id,of=Math.max(0,Math.ceil(Yf/le)),fg=Math.min(xe,(Kd+Yf)/le),zd=0,uf=Xe;uf<pf;++uf)for(var ng=uf*Vd-Sd,hg=of;hg<fg;++hg)for(var Ng=ec*Ae+Bc*uf+Sc*hg,Ig=wc*(Ic-1-ng)+Rc*(Kd-1-(hg*le-Yf))+mb*Uc,Og=0;Og<de;++Og)zd+=
Bb[Ng+Xc*Og]*$b[Ig+Og];xa[bd*Ae+kb*Ed+yb*wf+Hb*Uc]=zd}return Da.makeTensorInfo(Wa.shape,Wa.dtype,Wa.values)}},Ib={kernelName:I.Conv3D,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=xa.backend;xa=xa.attrs;var mb=Wa.x,Bb=Wa.filter;Wa=xa.strides;var $b=xa.pad;xa=xa.dilations;f([mb,Bb],"conv3d");xa=I.backend_util.computeConv3DInfo(mb.shape,Bb.shape,Wa,xa,$b);Wa=xa.filterDepth;$b=xa.filterHeight;var wc=xa.filterWidth,Rc=xa.dilationDepth,Zc=xa.dilationHeight,Xc=xa.dilationWidth,bd=xa.padInfo,
id=bd.front,Ic=bd.left;bd=bd.top;var Kd=new I.TensorBuffer(xa.outShape,mb.dtype),Bd=Da.data.get(mb.dataId).values,vd=Da.data.get(Bb.dataId).values,Nd=Kd.values;mb=I.util.computeStrides(mb.shape);Bb=I.util.computeStrides(Bb.shape);for(var de=0;de<xa.batchSize;++de)for(var ne=de*mb[0],xe=de*Kd.strides[0],Vd=0;Vd<xa.outDepth;++Vd)for(var le=xe+Vd*Kd.strides[1],ue=Vd*xa.strideDepth-id,Ae=0;Ae<Wa;++Ae){var kb=ue+Ae*Rc;if(!(0>kb||kb>=xa.inDepth)){var yb=Ae*Bb[0];kb=ne+kb*mb[1];for(var Hb=0;Hb<xa.outHeight;++Hb)for(var ec=
le+Hb*Kd.strides[2],Bc=Hb*xa.strideHeight-bd,Sc=0;Sc<$b;++Sc){var Uc=Bc+Sc*Zc;if(!(0>Uc||Uc>=xa.inHeight)){var Ed=yb+Sc*Bb[1];Uc=kb+Uc*mb[2];for(var Sd=0;Sd<xa.outWidth;++Sd)for(var Xe=ec+Sd*xa.outChannels,pf=Sd*xa.strideWidth-Ic,wf=0;wf<wc;++wf){var Yf=pf+wf*Xc;if(!(0>Yf||Yf>=xa.inWidth)){Yf=Uc+Yf*xa.inChannels;for(var of=Ed+wf*Bb[2],fg=0;fg<xa.inChannels;++fg){for(var zd=Bd[Yf+fg],uf=0;uf<xa.outChannels;++uf)Nd[Xe+uf]+=zd*vd[of+uf];of+=xa.outChannels}}}}}}}return Da.makeTensorInfo(Kd.shape,Kd.dtype,
Kd.values)}},Ga={kernelName:I.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=xa.backend,mb=xa.attrs,Bb=Wa.x,$b=Wa.dy;Wa=mb.strides;xa=mb.pad;mb=mb.filterShape;f([Bb,$b],"conv3dBackpropFilterV2");var wc=I.util.computeStrides(Bb.shape),Rc=I.util.computeStrides($b.shape);Wa=I.backend_util.computeConv3DInfo(Bb.shape,mb,Wa,1,xa);xa=Wa.strideDepth;mb=Wa.strideHeight;var Zc=Wa.strideWidth,Xc=Wa.filterDepth,bd=Wa.filterHeight,id=Wa.filterWidth,Ic=new I.TensorBuffer(Wa.filterShape,
"float32"),Kd=Ic.values,Bd=Ic.strides,vd=Bd[0],Nd=Bd[1],de=Bd[2];Bd=Bd[3];$b=Da.data.get($b.dataId).values;var ne=Rc[0],xe=Rc[1],Vd=Rc[2];Rc=Rc[3];Bb=Da.data.get(Bb.dataId).values;var le=wc[0],ue=wc[1],Ae=wc[2];wc=wc[3];for(var kb=Wa.padInfo.front,yb=Wa.padInfo.left,Hb=Wa.padInfo.top,ec=0;ec<Xc;++ec)for(var Bc=Math.max(0,Math.ceil((kb-ec)/xa)),Sc=Math.min(Wa.outDepth,(Wa.inDepth+kb-ec)/xa),Uc=ec*vd,Ed=0;Ed<bd;++Ed)for(var Sd=Math.max(0,Math.ceil((Hb-Ed)/mb)),Xe=Math.min(Wa.outHeight,(Wa.inHeight+
Hb-Ed)/mb),pf=Ed*Nd+Uc,wf=0;wf<id;++wf)for(var Yf=Math.max(0,Math.ceil((yb-wf)/Zc)),of=Math.min(Wa.outWidth,(Wa.inWidth+yb-wf)/Zc),fg=wf*de+pf,zd=0;zd<Wa.inChannels;++zd)for(var uf=zd*Bd+fg,ng=0;ng<Wa.outChannels;++ng){for(var hg=0,Ng=0;Ng<Wa.batchSize;++Ng)for(var Ig=Ng*le,Og=Ng*ne,Dg=Bc;Dg<Sc;++Dg)for(var fh=(ec+Dg*xa-kb)*ue+Ig,Kg=Dg*xe+Og,Pg=Sd;Pg<Xe;++Pg)for(var gh=(Ed+Pg*mb-Hb)*Ae+fh,bh=Pg*Vd+Kg,Cg=Yf;Cg<of;++Cg)hg+=Bb[(wf+Cg*Zc-yb)*wc+gh+zd]*$b[Cg*Rc+bh+ng];Kd[uf+ng]=hg}return Da.makeTensorInfo(Ic.shape,
Ic.dtype,Ic.values)}},hb={kernelName:I.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=xa.backend,mb=xa.attrs,Bb=Wa.dy,$b=Wa.filter;Wa=mb.pad;xa=mb.strides;mb=mb.inputShape;f([Bb],"conv3dBackpropInputV2");var wc=I.util.computeStrides(Bb.shape),Rc=I.util.computeStrides($b.shape),Zc=I.backend_util.computeConv3DInfo(mb,$b.shape,xa,1,Wa);Wa=new I.TensorBuffer(Zc.inShape,"float32");xa=Wa.values;var Xc=Wa.strides;mb=Xc[0];var bd=Xc[1],id=Xc[2];Xc=Xc[3];Bb=Da.data.get(Bb.dataId).values;
var Ic=wc[0],Kd=wc[1],Bd=wc[2];wc=wc[3];$b=Da.data.get($b.dataId).values;var vd=Rc[0],Nd=Rc[1],de=Rc[2];Rc=Rc[3];var ne=Zc.batchSize,xe=Zc.filterDepth,Vd=Zc.filterHeight,le=Zc.filterWidth,ue=Zc.inChannels,Ae=Zc.inDepth,kb=Zc.inHeight,yb=Zc.inWidth,Hb=Zc.outChannels,ec=Zc.outDepth,Bc=Zc.outHeight,Sc=Zc.outWidth,Uc=Zc.strideDepth,Ed=Zc.strideHeight,Sd=Zc.strideWidth,Xe=xe-1-Zc.padInfo.front,pf=Vd-1-Zc.padInfo.top;Zc=le-1-Zc.padInfo.left;for(var wf=0;wf<ne;++wf)for(var Yf=0;Yf<ue;++Yf)for(var of=0;of<
Ae;++of)for(var fg=of-Xe,zd=Math.max(0,Math.ceil(fg/Uc)),uf=Math.min(ec,(xe+fg)/Uc),ng=0;ng<kb;++ng)for(var hg=ng-pf,Ng=Math.max(0,Math.ceil(hg/Ed)),Ig=Math.min(Bc,(Vd+hg)/Ed),Og=0;Og<yb;++Og){for(var Dg=Og-Zc,fh=Math.max(0,Math.ceil(Dg/Sd)),Kg=Math.min(Sc,(le+Dg)/Sd),Pg=0,gh=zd;gh<uf;++gh)for(var bh=gh*Uc-fg,Cg=Ng;Cg<Ig;++Cg)for(var vf=Cg*Ed-hg,Qg=fh;Qg<Kg;++Qg)for(var xf=Ic*wf+Kd*gh+Bd*Cg+wc*Qg,se=vd*(xe-1-bh)+Nd*(Vd-1-vf)+de*(le-1-(Qg*Sd-Dg))+Rc*Yf,sg=0;sg<Hb;++sg)Pg+=Bb[xf+sg]*$b[se+sg];xa[mb*
wf+bd*of+id*ng+Xc*Og+Yf]=Pg}return Da.makeTensorInfo(Wa.shape,Wa.dtype,Wa.values)}},Rb=n(I.Cos,function(xa){return Math.cos(xa)}),mc={kernelName:I.Cos,backendName:"cpu",kernelFunc:Rb},Ub=n(I.Cosh,function(xa){return Math.cosh(xa)}),ic={kernelName:I.Cosh,backendName:"cpu",kernelFunc:Ub},jc={kernelName:I.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:D},Ob={kernelName:I.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=xa.backend;xa=xa.attrs;var mb=
Wa.x,Bb=Wa.dy;Wa=xa.strides;var $b=xa.dilations,wc=xa.pad,Rc=xa.dimRoundingMode;xa=xa.filterShape;f([mb,Bb],"depthwiseConv2dNativeBackpropFilter");xa=I.backend_util.computeConv2DInfo(mb.shape,xa,Wa,$b,wc,Rc,!0);Wa=xa.strideHeight;$b=xa.strideWidth;wc=xa.filterHeight;Rc=xa.filterWidth;var Zc=new I.TensorBuffer(xa.filterShape,"float32"),Xc=xa.padInfo.left,bd=xa.padInfo.top,id=xa.outChannels/xa.inChannels,Ic=Da.data.get(mb.dataId).values;mb=new I.TensorBuffer(mb.shape,mb.dtype,Ic);Ic=Da.data.get(Bb.dataId).values;
Bb=new I.TensorBuffer(Bb.shape,Bb.dtype,Ic);for(Ic=0;Ic<wc;++Ic)for(var Kd=Math.max(0,Math.ceil((bd-Ic)/Wa)),Bd=Math.min(xa.outHeight,(xa.inHeight+bd-Ic)/Wa),vd=0;vd<Rc;++vd)for(var Nd=Math.max(0,Math.ceil((Xc-vd)/$b)),de=Math.min(xa.outWidth,(xa.inWidth+Xc-vd)/$b),ne=0;ne<xa.outChannels;++ne){for(var xe=Math.trunc(ne/id),Vd=ne%id,le=0,ue=0;ue<xa.batchSize;++ue)for(var Ae=Kd;Ae<Bd;++Ae)for(var kb=Ic+Ae*Wa-bd,yb=Nd;yb<de;++yb)le+=mb.get(ue,kb,vd+yb*$b-Xc,xe)*Bb.get(ue,Ae,yb,ne);Zc.set(le,Ic,vd,xe,
Vd)}return Da.makeTensorInfo(Zc.shape,Zc.dtype,Zc.values)}},fc={kernelName:I.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=xa.backend,mb=xa.attrs,Bb=Wa.dy,$b=Wa.filter;Wa=mb.strides;xa=mb.dilations;var wc=mb.pad,Rc=mb.dimRoundingMode;mb=mb.inputShape;f([Bb,$b],"depthwiseConv2DNativeBackpropInput");var Zc=I.util.computeStrides(Bb.shape),Xc=I.util.computeStrides($b.shape),bd=I.backend_util.computeConv2DInfo(mb,$b.shape,Wa,xa,wc,Rc,!0);Wa=new I.TensorBuffer(bd.inShape,
"float32");xa=Wa.values;mb=Wa.strides;wc=mb[0];Rc=mb[1];mb=mb[2];Bb=Da.data.get(Bb.dataId).values;var id=Zc[0],Ic=Zc[1];Zc=Zc[2];$b=Da.data.get($b.dataId).values;var Kd=Xc[0],Bd=Xc[1];Xc=Xc[2];var vd=bd.batchSize,Nd=bd.filterHeight,de=bd.filterWidth,ne=bd.inChannels,xe=bd.inHeight,Vd=bd.inWidth,le=bd.outHeight,ue=bd.outWidth,Ae=bd.strideHeight,kb=bd.strideWidth,yb=Nd-1-bd.padInfo.top,Hb=de-1-bd.padInfo.left;bd=bd.outChannels/ne;for(var ec=0;ec<vd;++ec)for(var Bc=0;Bc<ne;++Bc)for(var Sc=0;Sc<xe;++Sc)for(var Uc=
Sc-yb,Ed=Math.max(0,Math.ceil(Uc/Ae)),Sd=Math.min(le,(Nd+Uc)/Ae),Xe=0;Xe<Vd;++Xe){for(var pf=Xe-Hb,wf=Math.max(0,Math.ceil(pf/kb)),Yf=Math.min(ue,(de+pf)/kb),of=0,fg=Ed;fg<Sd;++fg)for(var zd=fg*Ae-Uc,uf=wf;uf<Yf;++uf)for(var ng=id*ec+Ic*fg+Zc*uf,hg=Kd*(Nd-1-zd)+Bd*(de-1-(uf*kb-pf))+Xc*Bc,Ng=0;Ng<bd;++Ng)of+=Bb[ng+(Bc*bd+Ng)]*$b[hg+Ng];xa[wc*ec+Rc*Sc+mb*Xe+Bc]=of}return Da.makeTensorInfo(Wa.shape,Wa.dtype,Wa.values)}},yc={kernelName:I.Dilation2D,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,
Da=Wa.x;Wa=Wa.filter;var mb=xa.attrs,Bb=mb.strides,$b=mb.pad,wc=mb.dilations;xa=xa.backend;mb=xa.data.get(Da.dataId).values;var Rc=Da.shape.length,Zc=xa.data.get(Wa.dataId).values,Xc=Wa.shape.length,bd=I.backend_util.computeDilation2DInfo(Da.shape,Wa.shape,Bb,$b,"NHWC",wc);Bb=bd.batchSize;$b=bd.inHeight;wc=bd.inWidth;var id=bd.inChannels,Ic=bd.outHeight,Kd=bd.outWidth,Bd=bd.padInfo,vd=bd.strideHeight,Nd=bd.strideWidth,de=bd.filterHeight,ne=bd.filterWidth,xe=bd.dilationHeight,Vd=bd.dilationWidth;bd=
bd.outShape;var le=I.util.sizeFromShape(bd),ue=bd.length;le=I.util.getArrayFromDType(Da.dtype,le);for(var Ae=0;Ae<Bb;++Ae)for(var kb=0;kb<Ic;++kb)for(var yb=kb*vd-Bd.top,Hb=0;Hb<Kd;++Hb)for(var ec=Hb*Nd-Bd.left,Bc=0;Bc<id;++Bc){for(var Sc=Number.MIN_SAFE_INTEGER,Uc=0;Uc<de;++Uc){var Ed=yb+Uc*xe;if(0<=Ed&&Ed<$b)for(var Sd=0;Sd<ne;++Sd){var Xe=ec+Sd*Vd;if(0<=Xe&&Xe<wc){Xe=I.util.locToIndex([Ae,Ed,Xe,Bc],Rc,I.util.computeStrides(Da.shape));var pf=I.util.locToIndex([Uc,Sd,Bc],Xc,I.util.computeStrides(Wa.shape));
Xe=mb[Xe]+Zc[pf];Xe>Sc&&(Sc=Xe)}}}Uc=I.util.locToIndex([Ae,kb,Hb,Bc],ue,I.util.computeStrides(bd));le[Uc]=Sc}return{dataId:xa.write(I.util.toTypedArray(le,Da.dtype),bd,Da.dtype),shape:bd,dtype:Da.dtype}}},fd={kernelName:I.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=Wa.x,mb=Wa.filter,Bb=Wa.dy;Wa=xa.attrs;var $b=Wa.strides,wc=Wa.pad,Rc=Wa.dilations;xa=xa.backend;Wa=I.util.toNestedArray(Da.shape,xa.data.get(Da.dataId).values);var Zc=I.util.toNestedArray(mb.shape,
xa.data.get(mb.dataId).values),Xc=I.backend_util.computeDilation2DInfo(Da.shape,mb.shape,$b,wc,"NHWC",Rc);$b=Xc.batchSize;wc=Xc.inHeight;Rc=Xc.inWidth;var bd=Xc.inChannels,id=Xc.outHeight,Ic=Xc.outWidth,Kd=Xc.padInfo,Bd=Xc.strideHeight,vd=Xc.strideWidth,Nd=Xc.filterHeight,de=Xc.filterWidth,ne=Xc.dilationHeight,xe=Xc.dilationWidth,Vd=Xc.outShape;I.util.assert(Bb.rank===Vd.length,function(){return"Error in "+I.Dilation2DBackpropFilter+", dy must have the same rank as output "+(Vd.length+", but got ")+
Bb.rank});Xc=I.util.toNestedArray(Vd,xa.data.get(Bb.dataId).values);for(var le=I.util.makeZerosNestedTypedArray(mb.shape,mb.dtype),ue=0;ue<$b;++ue)for(var Ae=0;Ae<id;++Ae)for(var kb=Ae*Bd-Kd.top,yb=0;yb<Ic;++yb)for(var Hb=yb*vd-Kd.left,ec=0;ec<bd;++ec){for(var Bc=Number.MIN_SAFE_INTEGER,Sc=0,Uc=0,Ed=0;Ed<Nd;++Ed){var Sd=kb+Ed*ne;if(0<=Sd&&Sd<wc)for(var Xe=0;Xe<de;++Xe){var pf=Hb+Xe*xe;0<=pf&&pf<Rc&&(pf=Wa[ue][Sd][pf][ec]+Zc[Ed][Xe][ec],pf>Bc&&(Bc=pf,Sc=Ed,Uc=Xe))}}le[Sc][Uc][ec]+=Xc[ue][Ae][yb][ec]}return{dataId:xa.write(I.util.toTypedArray(le,
Da.dtype),mb.shape,mb.dtype),shape:mb.shape,dtype:mb.dtype}}},Ad={kernelName:I.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=Wa.x,mb=Wa.filter,Bb=Wa.dy;Wa=xa.attrs;var $b=Wa.strides,wc=Wa.pad,Rc=Wa.dilations;xa=xa.backend;Wa=I.util.toNestedArray(Da.shape,xa.data.get(Da.dataId).values);var Zc=I.util.toNestedArray(mb.shape,xa.data.get(mb.dataId).values),Xc=I.backend_util.computeDilation2DInfo(Da.shape,mb.shape,$b,wc,"NHWC",Rc);mb=Xc.batchSize;$b=Xc.inHeight;wc=
Xc.inWidth;Rc=Xc.inChannels;var bd=Xc.outHeight,id=Xc.outWidth,Ic=Xc.padInfo,Kd=Xc.strideHeight,Bd=Xc.strideWidth,vd=Xc.filterHeight,Nd=Xc.filterWidth,de=Xc.dilationHeight,ne=Xc.dilationWidth,xe=Xc.outShape;I.util.assert(Bb.rank===xe.length,function(){return"Error in "+I.Dilation2DBackpropInput+", dy must have the same rank as output "+(xe.length+", but got ")+Bb.rank});Xc=I.util.toNestedArray(xe,xa.data.get(Bb.dataId).values);for(var Vd=I.util.makeZerosNestedTypedArray(Da.shape,Da.dtype),le=0;le<
mb;++le)for(var ue=0;ue<bd;++ue)for(var Ae=ue*Kd-Ic.top,kb=0;kb<id;++kb)for(var yb=kb*Bd-Ic.left,Hb=0;Hb<Rc;++Hb){for(var ec=Number.MIN_SAFE_INTEGER,Bc=0>Ae?0:Ae,Sc=0>yb?0:yb,Uc=0;Uc<vd;++Uc){var Ed=Ae+Uc*de;if(0<=Ed&&Ed<$b)for(var Sd=0;Sd<Nd;++Sd){var Xe=yb+Sd*ne;if(0<=Xe&&Xe<wc){var pf=Wa[le][Ed][Xe][Hb]+Zc[Uc][Sd][Hb];pf>ec&&(ec=pf,Bc=Ed,Sc=Xe)}}}Vd[le][Bc][Sc][Hb]+=Xc[le][ue][kb][Hb]}return{dataId:xa.write(I.util.toTypedArray(Vd,Da.dtype),Da.shape,Da.dtype),shape:Da.shape,dtype:Da.dtype}}},Gd=
b(function(xa,Wa){return xa/Wa}),Ge=c(I.Div,Gd),Re={kernelName:I.Div,backendName:"cpu",kernelFunc:Ge},mf=I.backend_util.ERF_P,Ze=I.backend_util.ERF_A1,Jb=I.backend_util.ERF_A2,wb=I.backend_util.ERF_A3,Lb=I.backend_util.ERF_A4,oc=I.backend_util.ERF_A5,Lc=n(I.Erf,function(xa){var Wa=Math.abs(xa),Da=1/(1+mf*Wa);return Math.sign(xa)*(1-((((oc*Da+Lb)*Da+wb)*Da+Jb)*Da+Ze)*Da*Math.exp(-Wa*Wa))}),ed={kernelName:I.Erf,backendName:"cpu",kernelFunc:Lc},ge={kernelName:I.FFT,backendName:"cpu",kernelFunc:function(xa){var Wa=
xa.backend;xa=xa.inputs.input;var Da=I.util.sizeFromShape(xa.shape),mb=xa.shape[xa.shape.length-1];Da=J({inputs:{x:xa},backend:Wa,attrs:{shape:[Da/mb,mb]}});mb=H(Da,!1,Wa);xa=J({inputs:{x:mb},backend:Wa,attrs:{shape:xa.shape}});Wa.disposeIntermediateTensorInfo(Da);Wa.disposeIntermediateTensorInfo(mb);return xa}},he={kernelName:I.Fill,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.backend,Da=xa.attrs;xa=Da.shape;var mb=Da.value;Da=Da.dtype||I.util.inferDtype(mb);var Bb=I.util.getArrayFromDType(Da,
I.util.sizeFromShape(xa));Bb.fill(mb);return Wa.makeTensorInfo(xa,Da,Bb)}},bf={kernelName:I.FlipLeftRight,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs.image;xa=xa.backend;var Da=I.util.getTypedArrayFromDType(Wa.dtype,I.util.sizeFromShape(Wa.shape)),mb=Wa.shape,Bb=mb[0],$b=mb[1],wc=mb[2];mb=mb[3];for(var Rc=xa.data.get(Wa.dataId).values,Zc=0;Zc<Bb;Zc++)for(var Xc=Zc*wc*$b*mb,bd=0;bd<$b;bd++)for(var id=bd*wc*mb,Ic=0;Ic<wc;Ic++)for(var Kd=Ic*mb,Bd=0;Bd<mb;Bd++){var vd=Math.round(wc-Ic),
Nd=Xc+id+Kd+Bd,de=Rc[Nd];0<=vd&&vd<wc&&(de=Rc[Xc+id+vd*mb+Bd]);Da[Nd]=de}return{dataId:xa.write(Da,Wa.shape,Wa.dtype),shape:Wa.shape,dtype:Wa.dtype}}},cf={kernelName:I.FusedConv2D,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=xa.backend,mb=xa.attrs;xa=Wa.bias;var Bb=Wa.preluActivationWeights,$b=mb.activation;Wa=F({inputs:{x:Wa.x,filter:Wa.filter},backend:Da,attrs:{strides:mb.strides,pad:mb.pad,dataFormat:mb.dataFormat,dilations:mb.dilations,dimRoundingMode:mb.dimRoundingMode}});xa&&
(mb=Wa,Wa=oa({inputs:{a:Wa,b:xa},backend:Da}),Da.disposeIntermediateTensorInfo(mb));$b&&(mb=Wa,Wa=K(Da,Wa,$b,Bb),Da.disposeIntermediateTensorInfo(mb));return Wa}},qe={kernelName:I.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=xa.backend,mb=xa.attrs;xa=Wa.bias;var Bb=Wa.preluActivationWeights,$b=mb.activation;Wa=D({inputs:{x:Wa.x,filter:Wa.filter},backend:Da,attrs:{strides:mb.strides,pad:mb.pad,dataFormat:mb.dataFormat,dilations:mb.dilations,dimRoundingMode:mb.dimRoundingMode}});
xa&&(mb=Wa,Wa=oa({inputs:{a:Wa,b:xa},backend:Da}),Da.disposeIntermediateTensorInfo(mb));$b&&(mb=Wa,Wa=K(Da,Wa,$b,Bb),Da.disposeIntermediateTensorInfo(mb));return Wa}},ie={kernelName:I.IFFT,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.backend;xa=xa.inputs.input;var Da=I.util.sizeFromShape(xa.shape),mb=xa.shape[xa.shape.length-1];Da=J({inputs:{x:xa},backend:Wa,attrs:{shape:[Da/mb,mb]}});mb=H(Da,!0,Wa);xa=J({inputs:{x:mb},backend:Wa,attrs:{shape:xa.shape}});Wa.disposeIntermediateTensorInfo(Da);
Wa.disposeIntermediateTensorInfo(mb);return xa}},Za=n(I.IsFinite,function(xa){return Number.isFinite(xa)?1:0},"bool"),nb={kernelName:I.IsFinite,backendName:"cpu",kernelFunc:Za},Db=n(I.IsInf,function(xa){return Infinity===Math.abs(xa)?1:0},"bool"),dc={kernelName:I.IsInf,backendName:"cpu",kernelFunc:Db},uc=n(I.IsNan,function(xa){return Number.isNaN(xa)?1:0},"bool"),Qc={kernelName:I.IsNan,backendName:"cpu",kernelFunc:uc},ud=n(I.Log1p,function(xa){return Math.log1p(xa)}),Fd={kernelName:I.Log1p,backendName:"cpu",
kernelFunc:ud},je=n(I.LogicalNot,function(xa){return xa?0:1},"bool"),sd={kernelName:I.LogicalNot,backendName:"cpu",kernelFunc:je},wd={kernelName:I.Max,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs.x,Da=xa.attrs,mb=Da.keepDims;xa=xa.backend;var Bb=Wa.shape,$b=Bb.length,wc=Da=I.util.parseAxisParam(Da.reductionIndices,Bb),Rc=I.backend_util.getAxesPermutation(wc,$b),Zc=xa.data.get(Wa.dataId).values;if(null!=Rc){for(var Xc=Array($b),bd=0;bd<Xc.length;bd++)Xc[bd]=Bb[Rc[bd]];Zc=y(Zc,Bb,Wa.dtype,
Rc,Xc);wc=I.backend_util.getInnerMostAxes(wc.length,$b);Bb=Xc}f(Wa,"max");I.backend_util.assertAxesAreInnerMostDims("max",wc,$b);$b=I.backend_util.computeOutAndReduceShapes(Bb,wc);Bb=$b[0];$b=I.util.sizeFromShape($b[1]);Zc=p(Zc,$b,Bb,Wa.dtype);xa=xa.write(Zc,Bb,Wa.dtype);Zc=Bb;mb&&(Zc=Xc=I.backend_util.expandShapeToKeepDim(Bb,Da));return{dataId:xa,shape:Zc,dtype:Wa.dtype}}},Zd={kernelName:I.MaxPool,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.backend,Da=xa.attrs;xa=xa.inputs.x;f(xa,"maxPool");
var mb=Da.filterSize,Bb=Da.strides,$b=Da.pad;Da=Da.dimRoundingMode;I.util.assert(I.backend_util.eitherStridesOrDilationsAreOne(Bb,1),function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+(Bb+" and dilations '1'")});Da=I.backend_util.computePool2DInfo(xa.shape,mb,Bb,1,$b,Da);1===Da.filterWidth&&1===Da.filterHeight&&I.util.arraysEqual(Da.inShape,Da.outShape)?Wa=g({inputs:{x:xa},backend:Wa}):(mb=Wa.data.get(xa.dataId).values,$b=I.util.computeStrides(xa.shape),mb=O(mb,
xa.shape,xa.dtype,$b,Da,"max"),Wa=Wa.makeTensorInfo(Da.outShape,xa.dtype,mb.values));return Wa}},Te={kernelName:I.MaxPoolBackprop,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=xa.backend;xa=xa.attrs;var mb=Wa.dy,Bb=Wa.input;f([Bb,Wa.output],"maxPoolBackprop");Wa=I.backend_util.computePool2DInfo(Bb.shape,xa.filterSize,xa.strides,1,xa.pad,xa.dimRoundingMode);xa=Da.data.get(Bb.dataId).values;xa=I.buffer(Wa.outShape,Bb.dtype,Q(xa,Bb.shape,Bb.dtype,Wa).values);var $b=Wa.strideHeight,wc=
Wa.strideWidth,Rc=Wa.dilationHeight,Zc=Wa.dilationWidth,Xc=Wa.effectiveFilterHeight,bd=Wa.effectiveFilterWidth,id=bd-1-Wa.padInfo.left,Ic=Xc-1-Wa.padInfo.top;Bb=I.buffer(Bb.shape,"float32");var Kd=Da.data.get(mb.dataId).values;mb=I.buffer(mb.shape,"float32",Kd);for(Kd=0;Kd<Wa.batchSize;++Kd)for(var Bd=0;Bd<Wa.inChannels;++Bd)for(var vd=0;vd<Wa.inHeight;++vd)for(var Nd=0;Nd<Wa.inWidth;++Nd){for(var de=vd-Ic,ne=Nd-id,xe=0,Vd=0;Vd<Xc;Vd+=Rc){var le=(de+Vd)/$b;if(!(0>le||le>=Wa.outHeight||Math.floor(le)!==
le))for(var ue=0;ue<bd;ue+=Zc){var Ae=(ne+ue)/wc;if(!(0>Ae||Ae>=Wa.outWidth||Math.floor(Ae)!==Ae)){var kb=Xc*bd-1-xa.get(Kd,le,Ae,Bd)===Vd*bd+ue?1:0;0!==kb&&(Ae=mb.get(Kd,le,Ae,Bd),xe+=Ae*kb)}}}Bb.set(xe,Kd,vd,Nd,Bd)}return Da.makeTensorInfo(Bb.shape,Bb.dtype,Bb.values)}},re={kernelName:I.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs.x,Da=xa.attrs,mb=Da.filterSize,Bb=Da.strides,$b=Da.pad;Da=Da.includeBatchInIndex;xa=xa.backend;f(Wa,"MaxPoolWithArgmax");var wc=xa.data.get(Wa.dataId).values;
mb=I.backend_util.computePool2DInfo(Wa.shape,mb,Bb,[1,1],$b);Bb=Wa.shape;$b=Wa.dtype;var Rc=I.util.computeStrides(Bb);Rc=O(wc,Bb,$b,Rc,mb,"max");Da=Q(wc,Bb,$b,mb,!0,Da);wc=[Rc.values,Da.values];Da=wc[1];wc=xa.write(wc[0],mb.outShape,Wa.dtype);xa=xa.write(Da,mb.outShape,Wa.dtype);return[{dataId:wc,shape:mb.outShape,dtype:Wa.dtype},{dataId:xa,shape:mb.outShape,dtype:"int32"}]}},We={kernelName:I.MirrorPad,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.backend,Da=xa.attrs,mb=xa.inputs.x;xa=Da.paddings;
var Bb=Da.mode;f(mb,"mirrorPad");Da=xa.map(function(Nd,de){return Nd[0]+mb.shape[de]+Nd[1]});var $b=xa.map(function(Nd){return Nd[0]});xa=xa.map(function(Nd,de){return Nd[0]+mb.shape[de]});Bb="reflect"===Bb?0:1;for(var wc=Wa.data.get(mb.dataId).values,Rc=mb.shape.length,Zc=I.util.computeStrides(mb.shape),Xc=I.util.sizeFromShape(Da),bd=Da.length,id=I.util.computeStrides(Da),Ic=I.util.getTypedArrayFromDType(mb.dtype,Xc),Kd=0;Kd<Xc;Kd++){for(var Bd=I.util.indexToLoc(Kd,bd,id),vd=0;vd<bd;vd++)Bd[vd]<
$b[vd]?Bd[vd]=2*$b[vd]-Bd[vd]-Bb:Bd[vd]>=xa[vd]&&(Bd[vd]=2*(xa[vd]-1)-Bd[vd]+Bb);Bd=Bd.map(function(Nd,de){return Nd-$b[de]});Bd=I.util.locToIndex(Bd,Rc,Zc);Ic[Kd]=wc[Bd]}return{dataId:Wa.write(Ic,Da,mb.dtype),shape:Da,dtype:mb.dtype}}},nf=I.kernel_impls.nonMaxSuppressionV4Impl,bg={kernelName:I.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=Wa.boxes,mb=Wa.scores,Bb=xa.attrs;Wa=Bb.maxOutputSize;var $b=Bb.iouThreshold,wc=Bb.scoreThreshold;Bb=Bb.padToMaxOutputSize;
xa=xa.backend;f(Da,"NonMaxSuppressionPadded");Da=xa.data.get(Da.dataId).values;mb=xa.data.get(mb.dataId).values;Wa=nf(Da,mb,Wa,$b,wc,Bb);return[Wa.selectedIndices,Wa.validOutputs]}},Lf=I.kernel_impls.nonMaxSuppressionV5Impl,Wf={kernelName:I.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs,Da=Wa.boxes,mb=Wa.scores,Bb=xa.attrs;Wa=Bb.maxOutputSize;var $b=Bb.iouThreshold,wc=Bb.scoreThreshold;Bb=Bb.softNmsSigma;xa=xa.backend;f(Da,"NonMaxSuppressionWithScore");Da=xa.data.get(Da.dataId).values;
mb=xa.data.get(mb.dataId).values;Wa=Lf(Da,mb,Wa,$b,wc,Bb);return[Wa.selectedIndices,Wa.selectedScores]}},Pf={kernelName:I.PadV2,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.backend,Da=xa.attrs,mb=xa.inputs.x;xa=Da.paddings;var Bb=Da.constantValue;f(mb,"pad");Da=xa.map(function(Kd,Bd){return Kd[0]+mb.shape[Bd]+Kd[1]});var $b=xa.map(function(Kd){return Kd[0]});xa=Wa.data.get(mb.dataId).values;var wc=I.util.sizeFromShape(mb.shape),Rc=mb.shape.length,Zc=I.util.computeStrides(mb.shape),Xc=I.util.sizeFromShape(Da),
bd=Da.length,id=I.util.computeStrides(Da);Xc=I.util.getTypedArrayFromDType(mb.dtype,Xc);0!==Bb&&Xc.fill(Bb);for(Bb=0;Bb<wc;Bb++){var Ic=I.util.indexToLoc(Bb,Rc,Zc).map(function(Kd,Bd){return Kd+$b[Bd]});Ic=I.util.locToIndex(Ic,bd,id);Xc[Ic]=xa[Bb]}return{dataId:Wa.write(Xc,Da,mb.dtype),shape:Da,dtype:mb.dtype}}},Bg=n(I.Reciprocal,function(xa){return 1/xa}),Uf={kernelName:I.Reciprocal,backendName:"cpu",kernelFunc:Bg},Kb={kernelName:I.RotateWithOffset,backendName:"cpu",kernelFunc:function(xa){var Wa=
xa.inputs.image,Da=xa.attrs,mb=Da.radians,Bb=Da.fillValue,$b=Da.center;xa=xa.backend;Da=I.util.getTypedArrayFromDType(Wa.dtype,I.util.sizeFromShape(Wa.shape));var wc=Wa.shape,Rc=wc[0],Zc=wc[1],Xc=wc[2];wc=wc[3];var bd=I.backend_util.getImageCenter($b,Zc,Xc);$b=bd[0];bd=bd[1];var id=Math.sin(mb);mb=Math.cos(mb);for(var Ic=xa.data.get(Wa.dataId).values,Kd=0;Kd<Rc;Kd++)for(var Bd=Kd*Xc*Zc*wc,vd=0;vd<Zc;vd++)for(var Nd=vd*Xc*wc,de=0;de<Xc;de++)for(var ne=de*wc,xe=0;xe<wc;xe++){var Vd=[Rc,vd,de,xe],le=
Vd[2],ue=Vd[1];Vd=(le-$b)*mb-(ue-bd)*id;le=(le-$b)*id+(ue-bd)*mb;Vd=Math.round(Vd+$b);le=Math.round(le+bd);ue=Bb;"number"!==typeof Bb&&(ue=3===xe?255:Bb[xe]);0<=Vd&&Vd<Xc&&0<=le&&le<Zc&&(ue=Ic[Bd+le*Xc*wc+Vd*wc+xe]);Da[Bd+Nd+ne+xe]=ue}return{dataId:xa.write(Da,Wa.shape,Wa.dtype),shape:Wa.shape,dtype:Wa.dtype}}},ug=n(I.Round,function(xa){var Wa=Math.floor(xa);return.5>xa-Wa?Math.floor(xa):.5<xa-Wa?Math.ceil(xa):0===Wa%2?Wa:Wa+1}),sf={kernelName:I.Round,backendName:"cpu",kernelFunc:ug},Cf=I.backend_util.SELU_SCALEALPHA,
gf=I.backend_util.SELU_SCALE,Gf=n(I.Selu,function(xa){return 0<=xa?gf*xa:Cf*(Math.exp(xa)-1)}),ad={kernelName:I.Selu,backendName:"cpu",kernelFunc:Gf},$e=n(I.Sigmoid,function(xa){return 1/(1+Math.exp(-xa))}),va={kernelName:I.Sigmoid,backendName:"cpu",kernelFunc:$e},eb=n(I.Sign,function(xa){return 0>xa?-1:0<xa?1:0}),ub={kernelName:I.Sign,backendName:"cpu",kernelFunc:eb},pb=n(I.Sin,function(xa){return Math.sin(xa)}),Ea={kernelName:I.Sin,backendName:"cpu",kernelFunc:pb},db=n(I.Sinh,function(xa){return Math.sinh(xa)}),
fb={kernelName:I.Sinh,backendName:"cpu",kernelFunc:db},Gb=Math.log(1.1920928955078125E-7)+2,Vb=n(I.Softplus,function(xa){var Wa=xa>-Gb,Da=Math.exp(xa);return xa<Gb?Da:Wa?xa:Math.log(1+Da)}),Hc={kernelName:I.Softplus,backendName:"cpu",kernelFunc:Vb},md={kernelName:I.Transpose,backendName:"cpu",kernelFunc:L},Cd={kernelName:I.SpaceToBatchND,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.backend,Da=xa.attrs,mb=xa.inputs.x;xa=Da.blockShape;var Bb=Da.paddings;f([mb],"spaceToBatchND");Da=I.util.sizeFromShape(xa);
var $b=[[0,0]];$b.push.apply($b,Bb);for(Bb=1+xa.length;Bb<mb.shape.length;++Bb)$b.push([0,0]);mb=Pf.kernelFunc({inputs:{x:mb},backend:Wa,attrs:{paddings:$b,constantValue:0}});Bb=I.backend_util.getReshaped(mb.shape,xa,Da,!1);$b=I.backend_util.getPermuted(Bb.length,xa.length,!1);xa=I.backend_util.getReshapedPermuted(mb.shape,xa,Da,!1);Da=J({inputs:{x:mb},backend:Wa,attrs:{shape:Bb}});$b=L({inputs:{x:Da},backend:Wa,attrs:{perm:$b}});xa=J({inputs:{x:$b},backend:Wa,attrs:{shape:xa}});Wa.disposeIntermediateTensorInfo(mb);
Wa.disposeIntermediateTensorInfo(Da);Wa.disposeIntermediateTensorInfo($b);return xa}},ae=n(I.Sqrt,function(xa){return Math.sqrt(xa)}),ze={kernelName:I.Sqrt,backendName:"cpu",kernelFunc:ae},ef={kernelName:I.Square,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.inputs.x;xa=xa.backend;f(Wa,"square");for(var Da=xa.data.get(Wa.dataId).values,mb=new Float32Array(Da.length),Bb=0;Bb<Da.length;++Bb){var $b=Da[Bb];mb[Bb]=$b*$b}return{dataId:xa.write(mb,Wa.shape,Wa.dtype),shape:Wa.shape,dtype:Wa.dtype}}},
Qf=n(I.Step,function(xa,Wa){return isNaN(xa)?NaN:0<xa?1:Wa.alpha}),Zf={kernelName:I.Step,backendName:"cpu",kernelFunc:Qf},Df=n(I.Tan,function(xa){return Math.tan(xa)}),rg={kernelName:I.Tan,backendName:"cpu",kernelFunc:Df},If=n(I.Tanh,function(xa){return Math.tanh(xa)}),ag=0,Ua=[Tb,ma,Kc,Pc,Ba,Dd,we,Je,Ce,Oe,od,Sb,Ud,ua,Ma,pc,ja,lc,rc,qc,pe,Ga,hb,Ib,mc,ic,jc,Ob,fc,yc,Ad,fd,Re,Wb,ed,Sa,ya,ge,he,bf,cb,cf,qe,qa,ie,Ue,nb,dc,Qc,lb,Fd,sd,Zd,Te,re,wd,We,bb,bg,Wf,vb,Pf,Ec,Fa,Uf,Dc,ld,Nb,Kb,sf,Yc,ad,va,ub,
Ea,fb,yd,Hc,Cd,ze,ef,tc,Zf,ab,rg,{kernelName:I.Tanh,backendName:"cpu",kernelFunc:If},md,{kernelName:I.Unique,backendName:"cpu",kernelFunc:function(xa){var Wa=xa.backend,Da=xa.attrs.axis;xa=xa.inputs.x;f(xa,"unique");var mb=Wa.data.get(xa.dataId).values;Da=C(mb,Da,xa.shape,xa.dtype);mb=Da.indices;return[Wa.makeTensorInfo(Da.outputShape,xa.dtype,Da.outputValues),Wa.makeTensorInfo([mb.length],"int32",mb)]}}];ag<Ua.length;ag++)I.registerKernel(Ua[ag]);v.MathBackendCPU=ta;v.shared=Ta;v.version_cpu="2.7.0"};
shadow$provide[961]=function(W,A,la,v){function t(ea,sa){function ia(){this.constructor=ea}pe(ea,sa);ea.prototype=null===sa?Object.create(sa):(ia.prototype=sa.prototype,new ia)}function r(ea,sa,ia,za){function Xa(Cb){return Cb instanceof ia?Cb:new ia(function(gc){gc(Cb)})}return new (ia||(ia=Promise))(function(Cb,gc){function nc(Hd){try{hd(za.next(Hd))}catch($d){gc($d)}}function Tc(Hd){try{hd(za["throw"](Hd))}catch($d){gc($d)}}function hd(Hd){Hd.done?Cb(Hd.value):Xa(Hd.value).then(nc,Tc)}hd((za=za.apply(ea,
sa||[])).next())})}function u(ea,sa){function ia(hd){return function(Hd){return za([hd,Hd])}}function za(hd){if(Cb)throw new TypeError("Generator is already executing.");for(;Xa;)try{if(Cb=1,gc&&(nc=hd[0]&2?gc["return"]:hd[0]?gc["throw"]||((nc=gc["return"])&&nc.call(gc),0):gc.next)&&!(nc=nc.call(gc,hd[1])).done)return nc;if(gc=0,nc)hd=[hd[0]&2,nc.value];switch(hd[0]){case 0:case 1:nc=hd;break;case 4:return Xa.label++,{value:hd[1],done:!1};case 5:Xa.label++;gc=hd[1];hd=[0];continue;case 7:hd=Xa.ops.pop();
Xa.trys.pop();continue;default:if(!(nc=Xa.trys,nc=0<nc.length&&nc[nc.length-1])&&(6===hd[0]||2===hd[0])){Xa=0;continue}if(3===hd[0]&&(!nc||hd[1]>nc[0]&&hd[1]<nc[3]))Xa.label=hd[1];else if(6===hd[0]&&Xa.label<nc[1])Xa.label=nc[1],nc=hd;else if(nc&&Xa.label<nc[2])Xa.label=nc[2],Xa.ops.push(hd);else{nc[2]&&Xa.ops.pop();Xa.trys.pop();continue}}hd=sa.call(ea,Xa)}catch(Hd){hd=[6,Hd],gc=0}finally{Cb=nc=0}if(hd[0]&5)throw hd[1];return{value:hd[0]?hd[1]:void 0,done:!0}}var Xa={label:0,sent:function(){if(nc[0]&
1)throw nc[1];return nc[1]},trys:[],ops:[]},Cb,gc,nc,Tc;return Tc={next:ia(0),"throw":ia(1),"return":ia(2)},"function"===typeof Symbol&&(Tc[Symbol.iterator]=function(){return this}),Tc}function f(ea){if(!(ea in rc)){var sa=a(ea);if(null!==sa)rc[ea]=sa;else return console.log("Could not get context for WebGL version",ea),null}sa=rc[ea];if(sa.isContextLost())return delete rc[ea],f(ea);sa.disable(sa.DEPTH_TEST);sa.disable(sa.STENCIL_TEST);sa.disable(sa.BLEND);sa.disable(sa.DITHER);sa.disable(sa.POLYGON_OFFSET_FILL);
sa.disable(sa.SAMPLE_COVERAGE);sa.enable(sa.SCISSOR_TEST);sa.enable(sa.CULL_FACE);sa.cullFace(sa.BACK);return rc[ea]}function a(ea){if(1!==ea&&2!==ea)throw Error("Cannot get WebGL rendering context, WebGL is disabled.");if("undefined"!==typeof OffscreenCanvas&&2===ea)var sa=new OffscreenCanvas(300,150);else if("undefined"!==typeof document)sa=document.createElement("canvas");else throw Error("Cannot create a canvas in this context");sa.addEventListener("webglcontextlost",function(ia){ia.preventDefault();
delete rc[ea]},!1);return 1===ea?sa.getContext("webgl",qc)||sa.getContext("experimental-webgl",qc):sa.getContext("webgl2",qc)}function b(ea){ea=lc.util.sizeFromShape(ea);return lc.util.sizeToSquarishShape(Math.ceil(ea/4))}function e(ea,sa){return[Math.max(1,Math.ceil(sa/2)),Math.max(1,Math.ceil(ea/2))]}function g(ea,sa){if(2===lc.env().getNumber("WEBGL_VERSION")){var ia=ea.R32F;var za=ea.R16F;var Xa=ea.RGBA16F;var Cb=ea.RGBA32F;var gc=ea.RED;var nc=4;var Tc=1;sa=ea.HALF_FLOAT}else gc=Cb=Xa=za=ia=
ea.RGBA,Tc=nc=4,sa=null!=sa?sa.HALF_FLOAT_OES:null;return{internalFormatFloat:ia,internalFormatHalfFloat:za,internalFormatPackedHalfFloat:Xa,internalFormatPackedFloat:Cb,textureFormatFloat:gc,downloadTextureFormat:ea.RGBA,downloadUnpackNumChannels:nc,defaultNumChannels:Tc,textureTypeHalfFloat:sa,textureTypeFloat:ea.FLOAT}}function d(ea,sa){sa=sa();if(lc.env().getBool("DEBUG")){var ia=ea.getError();if(ia!==ea.NO_ERROR)throw Error("WebGL Error: "+c(ea,ia));}return sa}function h(ea){return lc.env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||
0===ea||5.96E-8<Math.abs(ea)&&65504>Math.abs(ea)?!0:!1}function c(ea,sa){switch(sa){case ea.NO_ERROR:return"NO_ERROR";case ea.INVALID_ENUM:return"INVALID_ENUM";case ea.INVALID_VALUE:return"INVALID_VALUE";case ea.INVALID_OPERATION:return"INVALID_OPERATION";case ea.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case ea.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case ea.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+sa}}function l(ea,sa){return U(ea,function(){return ea.getExtension(sa)},
'Extension "'+sa+'" not supported on this browser.')}function m(ea,sa){var ia=U(ea,function(){return ea.createShader(ea.VERTEX_SHADER)},"Unable to create vertex WebGLShader.");d(ea,function(){return ea.shaderSource(ia,sa)});d(ea,function(){return ea.compileShader(ia)});if(!1===ea.getShaderParameter(ia,ea.COMPILE_STATUS))throw console.log(ea.getShaderInfoLog(ia)),Error("Failed to compile vertex shader.");return ia}function n(ea,sa){var ia=U(ea,function(){return ea.createShader(ea.FRAGMENT_SHADER)},
"Unable to create fragment WebGLShader.");d(ea,function(){return ea.shaderSource(ia,sa)});d(ea,function(){return ea.compileShader(ia)});if(!1===ea.getShaderParameter(ia,ea.COMPILE_STATUS))throw k(sa,ea.getShaderInfoLog(ia)),Error("Failed to compile fragment shader.");return ia}function k(ea,sa){var ia=Rb.exec(sa);if(null==ia)console.log("Couldn't parse line number in error: "+sa),console.log(ea);else{ia=+ia[1];ea=ea.split("\n");for(var za=ea.length.toString().length+2,Xa=ea.map(function(nc,Tc){return lc.util.rightPad((Tc+
1).toString(),za)+nc}),Cb=ea=0;Cb<Xa.length;Cb++)ea=Math.max(Xa[Cb].length,ea);Cb=Xa.slice(0,ia-1);var gc=Xa.slice(ia-1,ia);ia=Xa.slice(ia);console.log(Cb.join("\n"));console.log(sa.split("\n")[0]);console.log("%c "+lc.util.rightPad(gc[0],ea),"border:1px solid red; background-color:#e3d2d2; color:#a61717");console.log(ia.join("\n"))}}function p(ea){return U(ea,function(){return ea.createProgram()},"Unable to create WebGLProgram.")}function q(ea,sa){d(ea,function(){return ea.linkProgram(sa)});if(!1===
ea.getProgramParameter(sa,ea.LINK_STATUS))throw console.log(ea.getProgramInfoLog(sa)),Error("Failed to link vertex and fragment shaders.");}function w(ea,sa){d(ea,function(){return ea.validateProgram(sa)});if(!1===ea.getProgramParameter(sa,ea.VALIDATE_STATUS))throw console.log(ea.getProgramInfoLog(sa)),Error("Shader program validation failed.");}function y(ea,sa){var ia=U(ea,function(){return ea.createBuffer()},"Unable to create WebGLBuffer");d(ea,function(){return ea.bindBuffer(ea.ARRAY_BUFFER,ia)});
d(ea,function(){return ea.bufferData(ea.ARRAY_BUFFER,sa,ea.STATIC_DRAW)});return ia}function C(ea,sa){var ia=U(ea,function(){return ea.createBuffer()},"Unable to create WebGLBuffer");d(ea,function(){return ea.bindBuffer(ea.ELEMENT_ARRAY_BUFFER,ia)});d(ea,function(){return ea.bufferData(ea.ELEMENT_ARRAY_BUFFER,sa,ea.STATIC_DRAW)});return ia}function z(ea){return U(ea,function(){return ea.createTexture()},"Unable to create WebGLTexture.")}function K(ea,sa){var ia=lc.env().getNumber("WEBGL_MAX_TEXTURE_SIZE");
if(0>=ea||0>=sa)throw Error("Requested texture size ["+(ea+"x"+sa+"] is invalid."));if(ea>ia||sa>ia)throw Error("Requested texture size ["+(ea+"x"+sa+"] greater than WebGL maximum on this browser / GPU [")+(ia+"x"+ia+"]."));}function J(ea){return U(ea,function(){return ea.createFramebuffer()},"Unable to create WebGLFramebuffer.")}function B(ea,sa,ia,za,Xa,Cb,gc){var nc=ea.getAttribLocation(sa,ia);if(-1===nc)return!1;d(ea,function(){return ea.bindBuffer(ea.ARRAY_BUFFER,za)});d(ea,function(){return ea.vertexAttribPointer(nc,
Xa,ea.FLOAT,!1,Cb,gc)});d(ea,function(){return ea.enableVertexAttribArray(nc)});return!0}function O(ea,sa,ia){L(ea,ia);d(ea,function(){return ea.activeTexture(ea.TEXTURE0+ia)});d(ea,function(){return ea.bindTexture(ea.TEXTURE_2D,sa)})}function Q(ea,sa,ia){return U(ea,function(){return ea.getUniformLocation(sa,ia)},'uniform "'+ia+'" not present in program.')}function V(ea,sa,ia,za){d(ea,function(){return O(ea,sa,za)});d(ea,function(){return ea.uniform1i(ia,za)})}function M(ea,sa,ia){d(ea,function(){return ea.bindFramebuffer(ea.FRAMEBUFFER,
ia)});d(ea,function(){return ea.framebufferTexture2D(ea.FRAMEBUFFER,ea.COLOR_ATTACHMENT0,ea.TEXTURE_2D,sa,0)})}function F(ea,sa){d(ea,function(){return ea.bindFramebuffer(ea.FRAMEBUFFER,sa)});d(ea,function(){return ea.framebufferTexture2D(ea.FRAMEBUFFER,ea.COLOR_ATTACHMENT0,ea.TEXTURE_2D,null,0)})}function D(ea){var sa=ea.checkFramebufferStatus(ea.FRAMEBUFFER);if(sa!==ea.FRAMEBUFFER_COMPLETE)throw Error("Error binding framebuffer: "+H(ea,sa));}function H(ea,sa){switch(sa){case ea.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
case ea.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case ea.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case ea.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+sa}}function U(ea,sa,ia){ea=d(ea,function(){return sa()});if(null==ea)throw Error(ia);return ea}function L(ea,sa){var ia=ea.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1;sa+=ea.TEXTURE0;if(sa<ea.TEXTURE0||sa>ia)throw Error("textureUnit must be in [gl.TEXTURE0, gl.TEXTURE"+
(ia+"]."));}function I(ea,sa){void 0===sa&&(sa=2);return lc.util.sizeFromShape(ea.slice(0,ea.length-sa))}function T(ea){if(0===ea.length)throw Error("Cannot get rows and columns of an empty shape array.");return[1<ea.length?ea[ea.length-2]:1,ea[ea.length-1]]}function aa(ea){var sa=[1,1,1];0===ea.length||1===ea.length&&1===ea[0]||(sa=[I(ea)].concat(T(ea)));return sa}function ba(ea,sa){void 0===sa&&(sa=!1);var ia=lc.env().getNumber("WEBGL_MAX_TEXTURE_SIZE");sa&&(ia*=2,ea=ea.map(function(Xa,Cb){return Cb>=
ea.length-2?lc.util.nearestLargerEven(ea[Cb]):ea[Cb]}),1===ea.length&&(ea=[2,ea[0]]));2!==ea.length&&(ea=lc.util.squeezeShape(ea).newShape);var za=lc.util.sizeFromShape(ea);return 1>=ea.length&&za<=ia?[1,za]:2===ea.length&&ea[0]<=ia&&ea[1]<=ia?ea:3===ea.length&&ea[0]*ea[1]<=ia&&ea[2]<=ia?[ea[0]*ea[1],ea[2]]:3===ea.length&&ea[0]<=ia&&ea[1]*ea[2]<=ia?[ea[0],ea[1]*ea[2]]:4===ea.length&&ea[0]*ea[1]*ea[2]<=ia&&ea[3]<=ia?[ea[0]*ea[1]*ea[2],ea[3]]:4===ea.length&&ea[0]<=ia&&ea[1]*ea[2]*ea[3]<=ia?[ea[0],ea[1]*
ea[2]*ea[3]]:sa?(sa=I(ea),za=ia=2,ea.length&&(za=T(ea),ia=za[0],za=za[1]),lc.util.sizeToSquarishShape(ia/2*sa*(za/2)).map(function(Xa){return 2*Xa})):lc.util.sizeToSquarishShape(za)}function Z(ea,sa){ea=ea.slice(-2);sa=sa.slice(-2);if(lc.util.arraysEqual(ea,sa)||!ea.length||!sa.length||0===ea[0]||0===ea[1]||0===sa[0]||0===sa[1])return!0;if(ea.length!==sa.length){var ia=ea.slice(-1)[0],za=sa.slice(-1)[0];if(ia===za||0===ia%2&&0===za%2&&(1===ea[0]||1===sa[0]))return!0}return ea[1]===sa[1]&&0===ea[0]%
2&&0===sa[0]%2}function da(ea){null==mc&&(ea=f(ea),mc=ea.getParameter(ea.MAX_TEXTURE_SIZE));return mc}function pa(ea){null==Ub&&(ea=f(ea),Ub=ea.getParameter(ea.MAX_TEXTURE_IMAGE_UNITS));return Math.min(16,Ub)}function fa(ea){if(0===ea)return 0;var sa=f(ea);return ta(sa,"EXT_disjoint_timer_query_webgl2")&&2===ea?2:ta(sa,"EXT_disjoint_timer_query")?1:0}function ta(ea,sa){return null!=ea.getExtension(sa)}function ma(ea){try{if(null!=f(ea))return!0}catch(sa){console.log("Error when getting WebGL context: ",
sa)}return!1}function ja(ea){if(0===ea)return!1;var sa=f(ea);if(1===ea){if(!ta(sa,"OES_texture_float"))return!1}else if(!ta(sa,"EXT_color_buffer_float"))return!1;return Fa(sa)}function qa(ea){if(0===ea)return!1;var sa=f(ea);if(1===ea){if(!ta(sa,"OES_texture_float")||!ta(sa,"WEBGL_color_buffer_float"))return!1}else{if(ta(sa,"EXT_color_buffer_float"))return Fa(sa);if(ta(sa,"EXT_color_buffer_half_float")){ea=sa.getExtension("EXT_color_buffer_half_float");var ia=g(sa,ea);ea=sa.createTexture();sa.bindTexture(sa.TEXTURE_2D,
ea);sa.texImage2D(sa.TEXTURE_2D,0,ia.internalFormatHalfFloat,1,1,0,ia.textureFormatFloat,ia.textureTypeHalfFloat,null);ia=sa.createFramebuffer();sa.bindFramebuffer(sa.FRAMEBUFFER,ia);sa.framebufferTexture2D(sa.FRAMEBUFFER,sa.COLOR_ATTACHMENT0,sa.TEXTURE_2D,ea,0);var za=sa.checkFramebufferStatus(sa.FRAMEBUFFER)===sa.FRAMEBUFFER_COMPLETE;sa.bindTexture(sa.TEXTURE_2D,null);sa.bindFramebuffer(sa.FRAMEBUFFER,null);sa.deleteTexture(ea);sa.deleteFramebuffer(ia);return za}return!1}return Fa(sa)}function Fa(ea){var sa=
g(ea),ia=ea.createTexture();ea.bindTexture(ea.TEXTURE_2D,ia);ea.texImage2D(ea.TEXTURE_2D,0,sa.internalFormatFloat,1,1,0,sa.textureFormatFloat,sa.textureTypeFloat,null);sa=ea.createFramebuffer();ea.bindFramebuffer(ea.FRAMEBUFFER,sa);ea.framebufferTexture2D(ea.FRAMEBUFFER,ea.COLOR_ATTACHMENT0,ea.TEXTURE_2D,ia,0);var za=ea.checkFramebufferStatus(ea.FRAMEBUFFER)===ea.FRAMEBUFFER_COMPLETE;ea.bindTexture(ea.TEXTURE_2D,null);ea.bindFramebuffer(ea.FRAMEBUFFER,null);ea.deleteTexture(ia);ea.deleteFramebuffer(sa);
return za}function ua(ea){return 2!==ea?!1:null!=f(ea).fenceSync}function Ra(ea,sa){Array.isArray(ea)||(ea=[ea]);ea.forEach(function(ia){null!=ia&&lc.util.assert("complex64"!==ia.dtype,function(){return sa+" does not support complex64 tensors in the WebGL backend."})})}function Ia(ea){return(sa,ia,za,Xa,Cb)=>{const gc=lc.backend_util.assertAndGetBroadcastShape(sa,ia);var nc=gc.length;const Tc=lc.util.computeStrides(gc);var hd=lc.util.sizeFromShape(gc);Cb=lc.util.getTypedArrayFromDType(Cb,hd);hd=sa.length;
const Hd=ia.length,$d=lc.util.computeStrides(sa),te=lc.util.computeStrides(ia);sa=lc.backend_util.getBroadcastDims(sa,gc);ia=lc.backend_util.getBroadcastDims(ia,gc);if(0===sa.length+ia.length)for(nc=0;nc<Cb.length;++nc)Cb[nc]=ea(za[nc%za.length],Xa[nc%Xa.length]);else for(let Xd=0;Xd<Cb.length;++Xd){var He=lc.util.indexToLoc(Xd,nc,Tc);const ye=He.slice(-hd);sa.forEach(Hg=>ye[Hg]=0);const cg=lc.util.locToIndex(ye,hd,$d),Ef=He.slice(-Hd);ia.forEach(Hg=>Ef[Hg]=0);He=lc.util.locToIndex(Ef,Hd,te);Cb[Xd]=
ea(za[cg],Xa[He])}return[Cb,gc]}}function oa(ea){return(sa,ia,za)=>{ia=lc.util.getTypedArrayFromDType(ia,sa.length);for(let Xa=0;Xa<sa.length;++Xa)ia[Xa]=ea(sa[Xa],za);return ia}}function Ba(ea,sa){return"xyzwuv".split("").slice(0,sa).map(function(ia){return ea+"."+ia})}function gb(ea,sa){return 1===sa?[ea]:Ba(ea,sa)}function Va(){if(2===lc.env().getNumber("WEBGL_VERSION")){var ea="#version 300 es";var sa="in";var ia="out";var za="in";var Xa="texture";var Cb="outputColor";var gc="out vec4 outputColor;";
var nc="\n      bool isnan_custom(float val) {\n        return (val \x3e 0.0 || val \x3c 0.0) ? false : val !\x3d 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ";var Tc="";var hd="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "}else ea=
"",sa="attribute",za=ia="varying",Xa="texture2D",Cb="gl_FragColor",gc="",nc="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val \x3e 0. || val \x3c 1. || val \x3d\x3d 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",Tc="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) \x3d\x3d INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",
hd="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ";return{version:ea,attribute:sa,varyingVs:ia,varyingFs:za,texture2D:Xa,output:Cb,defineOutput:gc,defineSpecialNaN:nc,defineSpecialInf:Tc,defineRound:hd}}function Ma(ea,sa,ia){void 0===ia&&(ia="index");var za=lc.util.computeStrides(sa);return za.map(function(Xa,Cb){return"int "+ea[Cb]+" \x3d "+ia+" / "+Xa+"; "+(Cb===
za.length-1?"int "+ea[Cb+1]+" \x3d "+ia+" - "+ea[Cb]+" * "+Xa:"index -\x3d "+ea[Cb]+" * "+Xa)+";"}).join("")}function ib(ea){ea=lc.util.computeStrides(ea).map(function(sa){return sa.toString()});return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * "+ea[0]+" + coords.y * "+ea[1]+" + coords.z;\n  }\n"}function Ja(ea,sa,ia,za){var Xa=[];ea.forEach(function(Hd){var $d=lc.util.sizeFromShape(Hd.shapeInfo.logicalShape);Hd.shapeInfo.isUniform?Xa.push("uniform float "+Hd.name+(1<$d?"["+$d+"]":
"")+";"):(Xa.push("uniform sampler2D "+Hd.name+";"),Xa.push("uniform int offset"+Hd.name+";"))});var Cb=Xa.join("\n");ea=ea.map(function(Hd){var $d=za;void 0===$d&&($d=!1);var te="";te=$d?te+S(Hd):te+Sa(Hd);Hd.shapeInfo.logicalShape.length<=sa.logicalShape.length&&(te=$d?te+wa(Hd,sa):te+Aa(Hd,sa));return te}).join("\n");var gc=sa.texShape,nc=Va(),Tc="\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return "+nc.texture2D+"(textureSampler, uv).r;\n    }\n  ",hd=nc.version+"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    "+
nc.varyingFs+" vec2 resultUV;\n    "+nc.defineOutput+"\n    const vec2 halfCR \x3d vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    "+nc.defineSpecialNaN+"\n    "+nc.defineSpecialInf+"\n    "+nc.defineRound+"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res \x3d a / b;\n      int mod \x3d imod(a, b);\n      if (sign \x3c 0. \x26\x26 mod !\x3d 0) {\n        res -\x3d 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p \x3d resultUV * seed;\n      vec3 p3  \x3d fract(vec3(p.xyx) * HASHSCALE1);\n      p3 +\x3d dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    "+
ge+"\n    "+he+"\n    "+bf+"\n  ";sa.isPacked?(gc=ha(sa.logicalShape,gc),nc="\n    void setOutput(vec4 val) {\n      "+nc.output+" \x3d val;\n    }\n  "):(gc=ya(sa.logicalShape,gc),nc="\n    void setOutput(float val) {\n      "+nc.output+" \x3d vec4(val, 0, 0, 0);\n    }\n  ");za&&(hd+=cf);return[hd,Tc,nc,Cb,gc,ea,ia].join("\n")}function Sa(ea){var sa=ea.shapeInfo.logicalShape;switch(sa.length){case 0:sa=ea.name;var ia="get"+sa.charAt(0).toUpperCase()+sa.slice(1);if(ea.shapeInfo.isUniform)ea="float "+
ia+"() {return "+sa+";}";else{var za=ea.shapeInfo.texShape,Xa=za[1];1===za[0]&&1===Xa?ea="\n      float "+ia+"() {\n        return sampleTexture("+sa+", halfCR);\n      }\n    ":(ea=ea.shapeInfo.texShape,ea="\n    float "+ia+"() {\n      vec2 uv \x3d uvFromFlat("+ea[0]+", "+ea[1]+", offset"+sa+");\n      return sampleTexture("+sa+", uv);\n    }\n  ")}return ea;case 1:return sa=ea.name,ia="get"+sa.charAt(0).toUpperCase()+sa.slice(1),ea.shapeInfo.isUniform?ea="\n      float "+ia+"(int index) {\n        "+
cb(ea)+"\n      }\n    ":(za=ea.shapeInfo.texShape,ea=za[0],za=za[1],1===za&&1===ea?ea="\n      float "+ia+"(int index) {\n        return sampleTexture("+sa+", halfCR);\n      }\n    ":(Xa="offset"+sa,ea=1===za?"\n      float "+ia+"(int index) {\n        vec2 uv \x3d vec2(0.5, (float(index + "+Xa+") + 0.5) / "+ea+".0);\n        return sampleTexture("+sa+", uv);\n      }\n    ":1===ea?"\n      float "+ia+"(int index) {\n        vec2 uv \x3d vec2((float(index + "+Xa+") + 0.5) / "+za+".0, 0.5);\n        return sampleTexture("+
sa+", uv);\n      }\n    ":"\n    float "+ia+"(int index) {\n      vec2 uv \x3d uvFromFlat("+ea+", "+za+", index + "+Xa+");\n      return sampleTexture("+sa+", uv);\n    }\n  ")),ea;case 2:return $a(ea);case 3:ia=ea.shapeInfo.logicalShape;za=ea.name;sa="get"+za.charAt(0).toUpperCase()+za.slice(1);Xa=ia[1]*ia[2];var Cb=ia[2],gc=lc.util.squeezeShape(ia),nc=gc.keptDims;gc=gc.newShape;gc.length<ia.length?(ea=Ya(ea,gc),ea="\n        "+Sa(ea)+"\n        float "+sa+"(int row, int col, int depth) {\n          return "+
sa+"("+Pb(["row","col","depth"],nc)+");\n        }\n      "):ea.shapeInfo.isUniform?ea="\n      float "+sa+"(int row, int col, int depth) {\n        int index \x3d round(dot(vec3(row, col, depth),\n                          vec3("+Xa+", "+Cb+", 1)));\n        "+cb(ea)+"\n      }\n    ":(gc=ea.shapeInfo.texShape,nc=gc[0],gc=gc[1],ea=ea.shapeInfo.flatOffset,ea=gc===Xa&&null==ea?"\n        float "+sa+"(int row, int col, int depth) {\n          float texR \x3d float(row);\n          float texC \x3d dot(vec2(col, depth), vec2("+
Cb+", 1));\n          vec2 uv \x3d (vec2(texC, texR) + halfCR) /\n                     vec2("+gc+".0, "+nc+".0);\n          return sampleTexture("+za+", uv);\n        }\n      ":gc===Cb&&null==ea?"\n    float "+sa+"(int row, int col, int depth) {\n      float texR \x3d dot(vec2(row, col), vec2("+ia[1]+", 1));\n      float texC \x3d float(depth);\n      vec2 uv \x3d (vec2(texC, texR) + halfCR) / vec2("+gc+".0, "+nc+".0);\n      return sampleTexture("+za+", uv);\n    }\n  ":"\n      float "+sa+"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index \x3d row * "+
Xa+" + col * "+Cb+" + depth + offset"+za+";\n        vec2 uv \x3d uvFromFlat("+nc+", "+gc+", index);\n        return sampleTexture("+za+", uv);\n      }\n  ");return ea;case 4:ia=ea.shapeInfo.logicalShape;za=ea.name;sa="get"+za.charAt(0).toUpperCase()+za.slice(1);Xa=ia[3];Cb=ia[2]*Xa;nc=ia[1]*Cb;var Tc=lc.util.squeezeShape(ia);gc=Tc.newShape;Tc=Tc.keptDims;gc.length<ia.length?(ea=Ya(ea,gc),ea="\n      "+Sa(ea)+"\n      float "+sa+"(int row, int col, int depth, int depth2) {\n        return "+sa+"("+
Pb(["row","col","depth","depth2"],Tc)+");\n      }\n    "):ea.shapeInfo.isUniform?ea="\n      float "+sa+"(int row, int col, int depth, int depth2) {\n        int index \x3d round(dot(vec4(row, col, depth, depth2),\n                          vec4("+nc+", "+Cb+", "+Xa+", 1)));\n        "+cb(ea)+"\n      }\n    ":(gc=ea.shapeInfo.flatOffset,Tc=ea.shapeInfo.texShape,ea=Tc[0],Tc=Tc[1],ea=Tc===nc&&null==gc?"\n      float "+sa+"(int row, int col, int depth, int depth2) {\n        float texR \x3d float(row);\n        float texC \x3d\n            dot(vec3(col, depth, depth2),\n                vec3("+
Cb+", "+Xa+", 1));\n        vec2 uv \x3d (vec2(texC, texR) + halfCR) /\n                   vec2("+Tc+".0, "+ea+".0);\n        return sampleTexture("+za+", uv);\n      }\n    ":Tc===Xa&&null==gc?"\n      float "+sa+"(int row, int col, int depth, int depth2) {\n        float texR \x3d dot(vec3(row, col, depth),\n                         vec3("+ia[1]*ia[2]+", "+ia[2]+", 1));\n        float texC \x3d float(depth2);\n        vec2 uv \x3d (vec2(texC, texR) + halfCR) /\n                  vec2("+Tc+".0, "+
ea+".0);\n        return sampleTexture("+za+", uv);\n      }\n    ":"\n    float "+sa+"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index \x3d row * "+nc+" + col * "+Cb+" +\n          depth * "+Xa+" + depth2;\n      vec2 uv \x3d uvFromFlat("+ea+", "+Tc+", index + offset"+za+");\n      return sampleTexture("+za+", uv);\n    }\n  ");return ea;case 5:ia=ea.shapeInfo.logicalShape;za=ea.name;sa="get"+za.charAt(0).toUpperCase()+
za.slice(1);Xa=ia[4];Cb=ia[3]*Xa;nc=ia[2]*Cb;gc=ia[1]*nc;var hd=lc.util.squeezeShape(ia);Tc=hd.newShape;hd=hd.keptDims;Tc.length<ia.length?(ea=Ya(ea,Tc),ea="\n      "+Sa(ea)+"\n      float "+sa+"(int row, int col, int depth, int depth2, int depth3) {\n        return "+sa+"("+Pb(["row","col","depth","depth2","depth3"],hd)+");\n      }\n    "):ea.shapeInfo.isUniform?ea="\n      float "+sa+"(int row, int col, int depth, int depth2, int depth3) {\n        float index \x3d dot(\n          vec4(row, col, depth, depth2),\n          vec4("+
gc+", "+nc+", "+Cb+", "+Xa+")) +\n          depth3;\n        "+cb(ea)+"\n      }\n    ":(Tc=ea.shapeInfo.flatOffset,hd=ea.shapeInfo.texShape,ea=hd[0],hd=hd[1],ea=hd===gc&&null==Tc?"\n      float "+sa+"(int row, int col, int depth, int depth2, int depth3) {\n        int texR \x3d row;\n        float texC \x3d dot(vec4(col, depth, depth2, depth3),\n                         vec4("+nc+", "+Cb+", "+Xa+", 1));\n        vec2 uv \x3d (vec2(texC, texR) + halfCR) /\n                   vec2("+hd+".0, "+ea+".0);\n        return sampleTexture("+
za+", uv);\n      }\n    ":hd===Xa&&null==Tc?"\n      float "+sa+"(int row, int col, int depth, int depth2, int depth3) {\n        float texR \x3d dot(\n          vec4(row, col, depth, depth2),\n          vec4("+ia[1]*ia[2]*ia[3]+",\n               "+ia[2]*ia[3]+", "+ia[3]+", 1));\n        int texC \x3d depth3;\n        vec2 uv \x3d (vec2(texC, texR) + halfCR) /\n                  vec2("+hd+".0, "+ea+".0);\n        return sampleTexture("+za+", uv);\n      }\n    ":"\n    float "+sa+"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index \x3d row * "+
gc+" + col * "+nc+" + depth * "+Cb+" +\n          depth2 * "+Xa+" + depth3 + offset"+za+";\n      vec2 uv \x3d uvFromFlat("+ea+", "+hd+", index);\n      return sampleTexture("+za+", uv);\n    }\n  ");return ea;case 6:ia=ea.shapeInfo.logicalShape;za=ea.name;sa="get"+za.charAt(0).toUpperCase()+za.slice(1);Cb=lc.util.squeezeShape(ia);Xa=Cb.newShape;Cb=Cb.keptDims;if(Xa.length<ia.length)ea=Ya(ea,Xa),ea="\n      "+Sa(ea)+"\n      float "+sa+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return "+
sa+"("+Pb("row col depth depth2 depth3 depth4".split(" "),Cb)+");\n      }\n    ";else if(Xa=ia[5],Cb=ia[4]*Xa,nc=ia[3]*Cb,gc=ia[2]*nc,Tc=ia[1]*gc,ea.shapeInfo.isUniform)ea="\n      float "+sa+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index \x3d round(dot(\n          vec4(row, col, depth, depth2),\n          vec4("+Tc+", "+gc+", "+nc+", "+Cb+")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2("+Xa+", 1)));\n        "+
cb(ea)+"\n      }\n    ";else{hd=ea.shapeInfo.flatOffset;var Hd=ea.shapeInfo.texShape;ea=Hd[0];Hd=Hd[1];ea=Hd===Tc&&null==hd?"\n      float "+sa+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR \x3d row;\n        float texC \x3d dot(vec4(col, depth, depth2, depth3),\n          vec4("+gc+", "+nc+", "+Cb+", "+Xa+")) +\n               float(depth4);\n        vec2 uv \x3d (vec2(texC, texR) + halfCR) /\n                   vec2("+Hd+".0, "+ea+".0);\n        return sampleTexture("+
za+", uv);\n      }\n    ":Hd===Xa&&null==hd?"\n      float "+sa+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR \x3d dot(vec4(row, col, depth, depth2),\n          vec4("+ia[1]*ia[2]*ia[3]*ia[4]+",\n               "+ia[2]*ia[3]*ia[4]+",\n               "+ia[3]*ia[4]+",\n               "+ia[4]+")) + float(depth3);\n        int texC \x3d depth4;\n        vec2 uv \x3d (vec2(texC, texR) + halfCR) /\n                  vec2("+Hd+".0, "+ea+".0);\n        return sampleTexture("+
za+", uv);\n      }\n    ":"\n    float "+sa+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index \x3d row * "+Tc+" + col * "+gc+" + depth * "+nc+" +\n          depth2 * "+Cb+" + depth3 * "+Xa+" + depth4 + offset"+za+";\n      vec2 uv \x3d uvFromFlat("+ea+", "+Hd+", index);\n      return sampleTexture("+za+", uv);\n    }\n  "}return ea;default:throw Error(sa.length+"-D input sampling is not yet supported");
}}function S(ea){switch(ea.shapeInfo.logicalShape.length){case 0:ea=ea.name;var sa="get"+ea.charAt(0).toUpperCase()+ea.slice(1),ia=Va();return"\n    vec4 "+sa+"() {\n      return "+ia.texture2D+"("+ea+", halfCR);\n    }\n  ";case 1:sa=ea.name;ia="get"+sa.charAt(0).toUpperCase()+sa.slice(1);ea=ea.shapeInfo.texShape;ea=[Math.ceil(ea[0]/2),Math.ceil(ea[1]/2)];var za=Va();return"\n    vec4 "+ia+"(int index) {\n      vec2 uv \x3d packedUVfrom1D(\n        "+ea[0]+", "+ea[1]+", index);\n      return "+za.texture2D+
"("+sa+", uv);\n    }\n  ";case 2:sa=ea.shapeInfo.logicalShape;ia=ea.name;za="get"+ia.charAt(0).toUpperCase()+ia.slice(1);var Xa=ea.shapeInfo.texShape,Cb=Xa[0],gc=Xa[1];ea=Va();null!=Xa&&lc.util.arraysEqual(sa,Xa)?ea="\n      vec4 "+za+"(int row, int col) {\n        vec2 uv \x3d (vec2(col, row) + halfCR) / vec2("+gc+".0, "+Cb+".0);\n\n        return "+ea.texture2D+"("+ia+", uv);\n      }\n    ":(Xa=[Math.ceil(Xa[0]/2),Math.ceil(Xa[1]/2)],ea="\n    vec4 "+za+"(int row, int col) {\n      vec2 uv \x3d packedUVfrom2D("+
Math.ceil(sa[1]/2)+", "+Xa[0]+", "+Xa[1]+", row, col);\n      return "+ea.texture2D+"("+ia+", uv);\n    }\n  ");return ea;case 3:return za=ea.shapeInfo.logicalShape,ia=ea.name,sa="get"+ia.charAt(0).toUpperCase()+ia.slice(1),Xa=ea.shapeInfo.texShape,Xa=[Math.ceil(Xa[0]/2),Math.ceil(Xa[1]/2)],1===za[0]?(ia=za.slice(1),ea=Ya(ea,ia),ea="\n        "+S(ea)+"\n        vec4 "+sa+"(int b, int row, int col) {\n          return "+sa+"("+Pb(["b","row","col"],[1,2])+");\n        }\n      "):(ea=Xa[0],Xa=Xa[1],
Cb=Math.ceil(za[2]/2),za=Cb*Math.ceil(za[1]/2),gc=Va(),ea="\n    vec4 "+sa+"(int b, int row, int col) {\n      vec2 uv \x3d packedUVfrom3D(\n        "+ea+", "+Xa+", "+za+", "+Cb+", b, row, col);\n      return "+gc.texture2D+"("+ia+", uv);\n    }\n  "),ea;default:za=ea.shapeInfo.logicalShape;Xa=za.length;sa=ea.name;ia="get"+sa.charAt(0).toUpperCase()+sa.slice(1);ea=ea.shapeInfo.texShape;Cb=[Math.ceil(ea[0]/2),Math.ceil(ea[1]/2)];ea=Cb[0];Cb=Cb[1];var nc=Math.ceil(za[Xa-1]/2),Tc=nc*Math.ceil(za[Xa-
2]/2);gc="int b, int row, int col";nc="b * "+Tc+" + (row / 2) * "+nc+" + (col / 2)";for(var hd=2;hd<Xa-1;hd++)gc="int b"+hd+", "+gc,Tc*=za[Xa-hd-1],nc="b"+hd+" * "+Tc+" + "+nc;za=Va();return"\n    vec4 "+ia+"("+gc+") {\n      int index \x3d "+nc+";\n      int texR \x3d index / "+Cb+";\n      int texC \x3d index - texR * "+Cb+";\n      vec2 uv \x3d (vec2(texC, texR) + halfCR) / vec2("+Cb+", "+ea+");\n      return "+za.texture2D+"("+sa+", uv);\n    }\n  "}}function ha(ea,sa){switch(ea.length){case 0:return Qa();
case 1:return ea=[Math.ceil(sa[0]/2),Math.ceil(sa[1]/2)],ea=1===ea[0]?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * "+ea[1]+".0);\n      }\n    ":1===ea[1]?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * "+ea[0]+".0);\n      }\n    ":"\n    int getOutputCoords() {\n      ivec2 resTexRC \x3d ivec2(resultUV.yx *\n                             vec2("+ea[0]+", "+ea[1]+"));\n      return 2 * (resTexRC.x * "+ea[1]+" + resTexRC.y);\n    }\n  ",ea;case 2:var ia=
[Math.ceil(sa[0]/2),Math.ceil(sa[1]/2)];lc.util.arraysEqual(ea,sa)?ea="\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2("+ia[0]+", "+ia[1]+"));\n      }\n    ":(ea=Math.ceil(ea[1]/2),ea="\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC \x3d ivec2(resultUV.yx *\n                             vec2("+ia[0]+", "+ia[1]+"));\n\n      int index \x3d resTexRC.x * "+ia[1]+" + resTexRC.y;\n      int r \x3d 2 * (index / "+ea+");\n      int c \x3d imod(index, "+ea+") * 2;\n\n      return ivec2(r, c);\n    }\n  ");
return ea;case 3:return ia=[Math.ceil(sa[0]/2),Math.ceil(sa[1]/2)],sa=Math.ceil(ea[2]/2),ea=sa*Math.ceil(ea[1]/2),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC \x3d ivec2(resultUV.yx *\n                             vec2("+ia[0]+", "+ia[1]+"));\n      int index \x3d resTexRC.x * "+ia[1]+" + resTexRC.y;\n\n      int b \x3d index / "+ea+";\n      index -\x3d b * "+ea+";\n\n      int r \x3d 2 * (index / "+sa+");\n      int c \x3d imod(index, "+sa+") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
default:ia=[Math.ceil(sa[0]/2),Math.ceil(sa[1]/2)];sa=Math.ceil(ea[ea.length-1]/2);for(var za=sa*Math.ceil(ea[ea.length-2]/2),Xa=za,Cb="",gc="b, r, c",nc=2;nc<ea.length-1;nc++)Xa*=ea[ea.length-nc-1],Cb="\n      int b"+nc+" \x3d index / "+Xa+";\n      index -\x3d b"+nc+" * "+Xa+";\n    "+Cb,gc="b"+nc+", "+gc;return"\n    ivec"+ea.length+" getOutputCoords() {\n      ivec2 resTexRC \x3d ivec2(resultUV.yx *\n                             vec2("+ia[0]+", "+ia[1]+"));\n      int index \x3d resTexRC.x * "+
ia[1]+" + resTexRC.y;\n\n      "+Cb+"\n\n      int b \x3d index / "+za+";\n      index -\x3d b * "+za+";\n\n      int r \x3d 2 * (index / "+sa+");\n      int c \x3d imod(index, "+sa+") * 2;\n\n      return ivec"+ea.length+"("+gc+");\n    }\n  "}}function ya(ea,sa){switch(ea.length){case 0:return Qa();case 1:return sa=1===sa[0]?"\n      int getOutputCoords() {\n        return int(resultUV.x * "+sa[1]+".0);\n      }\n    ":1===sa[1]?"\n      int getOutputCoords() {\n        return int(resultUV.y * "+
sa[0]+".0);\n      }\n    ":"\n    int getOutputCoords() {\n      ivec2 resTexRC \x3d ivec2(resultUV.yx *\n                             vec2("+sa[0]+", "+sa[1]+"));\n      return resTexRC.x * "+sa[1]+" + resTexRC.y;\n    }\n  ",sa;case 2:return lc.util.arraysEqual(ea,sa)?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+sa[0]+", "+sa[1]+"));\n      }\n    ":1===ea[1]?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC \x3d ivec2(resultUV.yx *\n                               vec2("+
sa[0]+", "+sa[1]+"));\n        int index \x3d resTexRC.x * "+sa[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":1===ea[0]?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC \x3d ivec2(resultUV.yx *\n                               vec2("+sa[0]+", "+sa[1]+"));\n        int index \x3d resTexRC.x * "+sa[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC \x3d ivec2(resultUV.yx *\n                             vec2("+
sa[0]+", "+sa[1]+"));\n      int index \x3d resTexRC.x * "+sa[1]+" + resTexRC.y;\n      int r \x3d index / "+ea[1]+";\n      int c \x3d index - r * "+ea[1]+";\n      return ivec2(r, c);\n    }\n  ";case 3:return ea=Ma(["r","c","d"],ea),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC \x3d ivec2(resultUV.yx *\n                             vec2("+sa[0]+", "+sa[1]+"));\n      int index \x3d resTexRC.x * "+sa[1]+" + resTexRC.y;\n      "+ea+"\n      return ivec3(r, c, d);\n    }\n  ";case 4:return ea=
Ma(["r","c","d","d2"],ea),"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC \x3d ivec2(resultUV.yx *\n        vec2("+sa[0]+", "+sa[1]+"));\n      int index \x3d resTexRC.x * "+sa[1]+" + resTexRC.y;\n      "+ea+"\n      return ivec4(r, c, d, d2);\n    }\n  ";case 5:return ea=Ma(["r","c","d","d2","d3"],ea),"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC \x3d ivec2(resultUV.yx * vec2("+sa[0]+",\n                             "+sa[1]+"));\n\n      int index \x3d resTexRC.x * "+sa[1]+" + resTexRC.y;\n\n      "+
ea+"\n\n      ivec5 outShape \x3d ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";case 6:return ea=Ma("r c d d2 d3 d4".split(" "),ea),"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC \x3d ivec2(resultUV.yx *\n        vec2("+sa[0]+", "+sa[1]+"));\n      int index \x3d resTexRC.x * "+sa[1]+" + resTexRC.y;\n\n      "+ea+"\n\n      ivec6 result \x3d ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ";default:throw Error(ea.length+"-D output sampling is not yet supported");
}}function Qa(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function $a(ea){var sa=ea.shapeInfo.logicalShape,ia=ea.name,za="get"+ia.charAt(0).toUpperCase()+ia.slice(1),Xa=ea.shapeInfo.texShape;if(null!=Xa&&lc.util.arraysEqual(sa,Xa))return"\n    float "+za+"(int row, int col) {\n      vec2 uv \x3d (vec2(col, row) + halfCR) / vec2("+Xa[1]+".0, "+Xa[0]+".0);\n      return sampleTexture("+ia+", uv);\n    }\n  ";var Cb=lc.util.squeezeShape(sa),gc=Cb.keptDims;Cb=Cb.newShape;if(Cb.length<
sa.length)return sa=Ya(ea,Cb),"\n      "+Sa(sa)+"\n      float "+za+"(int row, int col) {\n        return "+za+"("+Pb(["row","col"],gc)+");\n      }\n    ";if(ea.shapeInfo.isUniform)return"\n      float "+za+"(int row, int col) {\n        int index \x3d round(dot(vec2(row, col), vec2("+sa[1]+", 1)));\n        "+cb(ea)+"\n      }\n    ";gc=Xa[0];Xa=Xa[1];ea="offset"+ia;return 1===Xa?"\n    float "+za+"(int row, int col) {\n      float index \x3d dot(vec3(row, col, "+ea+"), vec3("+sa[1]+", 1, 1));\n      vec2 uv \x3d vec2(0.5, (index + 0.5) / "+
gc+".0);\n      return sampleTexture("+ia+", uv);\n    }\n  ":1===gc?"\n    float "+za+"(int row, int col) {\n      float index \x3d dot(vec3(row, col, "+ea+"), vec3("+sa[1]+", 1, 1));\n      vec2 uv \x3d vec2((index + 0.5) / "+Xa+".0, 0.5);\n      return sampleTexture("+ia+", uv);\n    }\n  ":"\n  float "+za+"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index \x3d row * "+sa[1]+" + col + "+ea+";\n    vec2 uv \x3d uvFromFlat("+gc+", "+Xa+", index);\n    return sampleTexture("+
ia+", uv);\n  }\n"}function cb(ea){var sa=ea.name;ea=lc.util.sizeFromShape(ea.shapeInfo.logicalShape);return 2>ea?"return "+sa+";":"\n    for (int i \x3d 0; i \x3c "+ea+"; i++) {\n      if (i \x3d\x3d index) {\n        return "+sa+"[i];\n      }\n    }\n  "}function wa(ea,sa){var ia=ea.name;ia=ia.charAt(0).toUpperCase()+ia.slice(1);var za="get"+ia+"AtOutCoords",Xa=ea.shapeInfo.logicalShape.length,Cb=sa.logicalShape.length,gc=ed(ea.shapeInfo.logicalShape,sa.logicalShape),nc=lb(Cb),Tc=Cb-Xa,hd="xyzwuv".split("");
var Hd=0===Xa?"":2>Cb&&1<=gc.length?"coords \x3d 0;":gc.map(function(He){return"coords."+hd[He+Tc]+" \x3d 0;"}).join("\n");var $d="";$d=2>Cb&&0<Xa?"coords":ea.shapeInfo.logicalShape.map(function(He,Xd){return"coords."+hd[Xd+Tc]}).join(", ");var te="return outputValue;";ea=1===lc.util.sizeFromShape(ea.shapeInfo.logicalShape);sa=1===lc.util.sizeFromShape(sa.logicalShape);1!==Xa||ea||sa?ea&&!sa?te=1===Cb?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ":
gc.length&&(sa=Xa-2,--Xa,-1<gc.indexOf(sa)&&-1<gc.indexOf(Xa)?te="return vec4(outputValue.x);":-1<gc.indexOf(sa)?te="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":-1<gc.indexOf(Xa)&&(te="return vec4(outputValue.xx, outputValue.zz);")):te="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 "+za+"() {\n      "+nc+" coords \x3d getOutputCoords();\n      "+Hd+"\n      vec4 outputValue \x3d get"+ia+"("+$d+");\n      "+te+"\n    }\n  "}function Aa(ea,
sa){var ia=ea.name,za=ia.charAt(0).toUpperCase()+ia.slice(1),Xa="get"+za+"AtOutCoords",Cb=sa.texShape,gc=ea.shapeInfo.texShape,nc=ea.shapeInfo.logicalShape.length,Tc=sa.logicalShape.length;if(!ea.shapeInfo.isUniform&&nc===Tc&&null==ea.shapeInfo.flatOffset&&lc.util.arraysEqual(gc,Cb))return"\n      float "+Xa+"() {\n        return sampleTexture("+ia+", resultUV);\n      }\n    ";ia=lb(Tc);sa=ed(ea.shapeInfo.logicalShape,sa.logicalShape);var hd=Tc-nc,Hd="xyzwuv".split("");sa=0===nc?"":2>Tc&&1<=sa.length?
"coords \x3d 0;":sa.map(function($d){return"coords."+Hd[$d+hd]+" \x3d 0;"}).join("\n");Cb="";Cb=2>Tc&&0<nc?"coords":ea.shapeInfo.logicalShape.map(function($d,te){return"coords."+Hd[te+hd]}).join(", ");return"\n    float "+Xa+"() {\n      "+ia+" coords \x3d getOutputCoords();\n      "+sa+"\n      return get"+za+"("+Cb+");\n    }\n  "}function lb(ea){if(1>=ea)return"int";if(2===ea)return"ivec2";if(3===ea)return"ivec3";if(4===ea)return"ivec4";if(5===ea)return"ivec5";if(6===ea)return"ivec6";throw Error("GPU for rank "+
ea+" is not yet supported");}function Ya(ea,sa){ea=JSON.parse(JSON.stringify(ea));ea.shapeInfo.logicalShape=sa;return ea}function Pb(ea,sa){return sa.map(function(ia){return ea[ia]}).join(", ")}function tb(ea,sa){if(1===ea)return""+sa;if(2===ea)return sa+".x, "+sa+".y";if(3===ea)return sa+".x, "+sa+".y, "+sa+".z";if(4===ea)return sa+".x, "+sa+".y, "+sa+".z, "+sa+".w";throw Error("Cumulative sum for rank "+ea+" is not yet supported");}function bb(ea,sa){if(1===ea)return""+sa;if(2===ea)return sa+".y";
if(3===ea)return sa+".z";if(4===ea)return sa+".w";throw Error("Cumulative sum for rank "+ea+" is not yet supported");}function La(ea){var sa=Va();return m(ea,sa.version+"\n    precision highp float;\n    "+sa.attribute+" vec3 clipSpacePos;\n    "+sa.attribute+" vec2 uv;\n    "+sa.varyingVs+" vec2 resultUV;\n\n    void main() {\n      gl_Position \x3d vec4(clipSpacePos, 1);\n      resultUV \x3d uv;\n    }")}function Fb(ea){var sa=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return y(ea,
sa)}function vb(ea){var sa=new Uint16Array([0,1,2,2,1,3]);return C(ea,sa)}function Xb(ea,sa,ia,za,Xa,Cb){K(sa,ia);var gc=z(ea),nc=ea.TEXTURE_2D;d(ea,function(){return ea.bindTexture(nc,gc)});d(ea,function(){return ea.texParameteri(nc,ea.TEXTURE_WRAP_S,ea.CLAMP_TO_EDGE)});d(ea,function(){return ea.texParameteri(nc,ea.TEXTURE_WRAP_T,ea.CLAMP_TO_EDGE)});d(ea,function(){return ea.texParameteri(nc,ea.TEXTURE_MIN_FILTER,ea.NEAREST)});d(ea,function(){return ea.texParameteri(nc,ea.TEXTURE_MAG_FILTER,ea.NEAREST)});
d(ea,function(){return ea.texImage2D(nc,0,za,sa,ia,0,Xa,Cb,null)});d(ea,function(){return ea.bindTexture(ea.TEXTURE_2D,null)});return gc}function Mc(ea,sa,ia,za){sa=[ia,sa];return Xb(ea,sa[0],sa[1],za.internalFormatFloat,za.textureFormatFloat,ea.FLOAT)}function Yc(ea,sa,ia,za){sa=[ia,sa];return Xb(ea,sa[0],sa[1],za.internalFormatHalfFloat,za.textureFormatFloat,za.textureTypeHalfFloat)}function yd(ea,sa,ia,za){sa=[ia,sa];return Xb(ea,sa[0],sa[1],za.downloadTextureFormat,ea.RGBA,ea.UNSIGNED_BYTE)}function pd(ea,
sa,ia,za){sa=e(sa,ia);return Xb(ea,sa[0],sa[1],za.internalFormatPackedFloat,ea.RGBA,ea.FLOAT)}function sc(ea,sa,ia,za){sa=e(sa,ia);return Xb(ea,sa[0],sa[1],za.internalFormatPackedHalfFloat,ea.RGBA,za.textureTypeHalfFloat)}function tc(ea,sa,ia){d(ea,function(){return ea.bindBuffer(ea.ARRAY_BUFFER,ia)});return B(ea,sa,"clipSpacePos",ia,3,20,0)&&B(ea,sa,"uv",ia,2,20,12)}function vc(ea,sa,ia,za,Xa,Cb){d(ea,function(){return ea.bindTexture(ea.TEXTURE_2D,sa)});if(Xa instanceof Uint8Array){var gc=new Uint8Array(ia*
za*4);var nc=ea.UNSIGNED_BYTE;var Tc=ea.RGBA}else gc=new Float32Array(ia*za*4),nc=ea.FLOAT,Tc=Cb.internalFormatPackedFloat;gc.set(Xa);d(ea,function(){return ea.texImage2D(ea.TEXTURE_2D,0,Tc,ia,za,0,ea.RGBA,nc,gc)});d(ea,function(){return ea.bindTexture(ea.TEXTURE_2D,null)})}function $c(ea,sa,ia){d(ea,function(){return ea.bindTexture(ea.TEXTURE_2D,sa)});ia.data instanceof Uint8Array?d(ea,function(){return ea.texImage2D(ea.TEXTURE_2D,0,ea.RGBA,ia.width,ia.height,0,ea.RGBA,ea.UNSIGNED_BYTE,ia.data)}):
d(ea,function(){return ea.texImage2D(ea.TEXTURE_2D,0,ea.RGBA,ea.RGBA,ea.UNSIGNED_BYTE,ia)});d(ea,function(){return ea.bindTexture(ea.TEXTURE_2D,null)})}function xd(ea,sa,ia,za){var Xa=ea.createBuffer();d(ea,function(){return ea.bindBuffer(ea.PIXEL_PACK_BUFFER,Xa)});var Cb=16*sa*ia;d(ea,function(){return ea.bufferData(ea.PIXEL_PACK_BUFFER,Cb,ea.STREAM_READ)});d(ea,function(){return ea.readPixels(0,0,ia,sa,ea.RGBA,ea.FLOAT,0)});d(ea,function(){return ea.bindBuffer(ea.PIXEL_PACK_BUFFER,null)});return Xa}
function ab(ea,sa,ia){ia=new Float32Array(ia);ea.bindBuffer(ea.PIXEL_PACK_BUFFER,sa);ea.getBufferSubData(ea.PIXEL_PACK_BUFFER,0,ia);ea.bindBuffer(ea.PIXEL_PACK_BUFFER,null);return ia}function Ta(ea,sa,ia,za){var Xa=[ia,sa],Cb=Xa[0],gc=Xa[1],nc=new Uint8Array(sa*ia*4);d(ea,function(){return ea.readPixels(0,0,Cb,gc,za.downloadTextureFormat,ea.UNSIGNED_BYTE,nc)});return new Float32Array(nc.buffer)}function jb(ea,sa,ia,za,Xa,Cb,gc,nc){ia=Float32Array;Cb=e(Cb,gc);Cb=new ia(Cb[0]*Cb[1]*4);ea.bindBuffer(ea.PIXEL_PACK_BUFFER,
sa);ea.getBufferSubData(ea.PIXEL_PACK_BUFFER,0,Cb);ea.bindBuffer(ea.PIXEL_PACK_BUFFER,null);return Cb}function Wb(ea,sa,ia){var za=new Float32Array(sa*ia*4);d(ea,function(){return ea.readPixels(0,0,ia,sa,ea.RGBA,ea.FLOAT,za)});return za}function xc(ea){for(var sa=0;sa<ea.length&&ea[sa]();++sa);return sa-1}function Ec(ea,sa,ia,za){var Xa=sa.userCode,Cb=ia.map(function($d,te){var He={logicalShape:$d.shape,texShape:$d.isUniform?null:$d.texData.texShape,isUniform:$d.isUniform,isPacked:$d.isUniform?!1:
$d.texData.isPacked,flatOffset:null};null!=$d.texData&&null!=$d.texData.slice&&0<$d.texData.slice.flatOffset&&(He.flatOffset=$d.texData.slice.flatOffset);return{name:sa.variableNames[te],shapeInfo:He}});ia=Cb.map(function($d){return $d.shapeInfo});za={logicalShape:za.shape,texShape:za.texData.texShape,isUniform:!1,isPacked:za.texData.isPacked,flatOffset:null};Xa=Ja(Cb,za,Xa,sa.packedInputs);Cb=ea.createProgram(Xa);var gc=null,nc=ea.getUniformLocation(Cb,"NAN",!1);1===lc.env().getNumber("WEBGL_VERSION")&&
(gc=ea.getUniformLocation(Cb,"INFINITY",!1));for(var Tc={},hd=0;hd<sa.variableNames.length;hd++){var Hd=sa.variableNames[hd];Tc[Hd]=ea.getUniformLocation(Cb,Hd,!1);Tc["offset"+Hd]=ea.getUniformLocation(Cb,"offset"+Hd,!1)}return{program:sa,source:Xa,webGLProgram:Cb,uniformLocations:Tc,inShapeInfos:ia,outShapeInfo:za,infLoc:gc,nanLoc:nc}}function dd(ea,sa){if(ea.length!==sa.length)throw Error("Binary was compiled with "+ea.length+" inputs, but was executed with "+(sa.length+" inputs"));ea.forEach(function(ia,
za){var Xa=ia.logicalShape;za=sa[za];var Cb=za.shape;if(!lc.util.arraysEqual(Xa,Cb))throw Error("Binary was compiled with different shapes than the current args. Shapes "+(Xa+" and "+Cb+" must match"));if(!ia.isUniform||!za.isUniform)if(ia=ia.texShape,Xa=za.isUniform?null:za.texData.texShape,!lc.util.arraysEqual(ia,Xa))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+(ia+" and "+Xa+" must match"));})}function Dc(ea,sa,ia,za,Xa){dd(sa.inShapeInfos,ia);dd([sa.outShapeInfo],
[za]);var Cb=za.texData.texture,gc=za.texData.texShape;za.texData.isPacked?ea.setOutputPackedMatrixTexture(Cb,gc[0],gc[1]):ea.setOutputMatrixTexture(Cb,gc[0],gc[1]);ea.setProgram(sa.webGLProgram);1===lc.env().getNumber("WEBGL_VERSION")&&null!==sa.infLoc&&ea.gl.uniform1f(sa.infLoc,Infinity);null!==sa.nanLoc&&ea.gl.uniform1f(sa.nanLoc,NaN);ia.forEach(function(nc,Tc){var hd=sa.program.variableNames[Tc],Hd=sa.uniformLocations[hd];hd=sa.uniformLocations["offset"+hd];null!=Hd&&(nc.isUniform?2>lc.util.sizeFromShape(nc.shape)?
ea.gl.uniform1f(Hd,nc.uniformValues[0]):(nc=nc.uniformValues,nc instanceof Float32Array||(nc=new Float32Array(nc)),ea.gl.uniform1fv(Hd,nc)):(null!=nc.texData.slice&&null!=hd&&ea.gl.uniform1i(hd,nc.texData.slice.flatOffset),ea.setInputMatrixTexture(nc.texData.texture,Hd,Tc)))});null!=Xa&&Xa(ea,sa.webGLProgram);ea.executeProgram()}function kd(ea,sa,ia){var za="";sa.concat(ia).forEach(function(Xa){za+=Xa.shape+"_"+(Xa.isUniform?"uniform":Xa.texData.texShape)+"_"+(null!=Xa.texData&&null!=Xa.texData.slice&&
0<Xa.texData.slice.flatOffset)});return ea.constructor.name+("_"+za+"_"+ea.userCode)}function ld(ea){if(1===ea)return"sourceLoc";if(6>=ea)return wc.slice(0,ea).map(function(sa){return"sourceLoc."+sa}).join(",");throw Error("Slicing for rank "+ea+" is not yet supported");}function Nb(ea,sa){if(sa===ea.R32F)return 4;if(sa===ea.R16F)return 2;if(sa===ea.RGBA32F||sa===ea.RGBA)return 16;if(sa===ea.RGBA16F)return 8;throw Error("Unknown internal format "+sa);}function Sb(ea,sa,ia,za,Xa){sa=Tb(sa,za);Xa?(ea=
e(ea[0],ea[1]),ea=ea[0]*ea[1]):(ea=[ea[1],ea[0]],ea=ea[0]*ea[1]);ia=Nb(ia,sa);return ea*ia}function Tb(ea,sa){switch(ea){case hb.PACKED_2X2_FLOAT32:return sa.internalFormatPackedFloat;case hb.PACKED_2X2_FLOAT16:return sa.internalFormatPackedHalfFloat;case hb.UNPACKED_FLOAT32:return sa.internalFormatFloat;case hb.UNPACKED_FLOAT16:return sa.internalFormatHalfFloat;case hb.PACKED_4X1_UNSIGNED_BYTE:return sa.downloadTextureFormat;default:throw Error("Unknown physical texture type "+ea);}}function Ac(ea,
sa){if(ea===Ga.UPLOAD)return hb.PACKED_2X2_FLOAT32;if(ea===Ga.RENDER||null==ea)return lc.env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?sa?hb.PACKED_2X2_FLOAT32:hb.UNPACKED_FLOAT32:sa?hb.PACKED_2X2_FLOAT16:hb.UNPACKED_FLOAT16;if(ea===Ga.DOWNLOAD||ea===Ga.PIXELS)return hb.PACKED_4X1_UNSIGNED_BYTE;throw Error("Unknown logical texture type "+ea);}function Kc(ea,sa){void 0===sa&&(sa=!1);if("linear"===ea)return"return x;";if("relu"===ea)return sa?"\n  vec4 result \x3d x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN \x3d isnan(x);\n\n  result.r \x3d isNaN.r ? x.r : result.r;\n  result.g \x3d isNaN.g ? x.g : result.g;\n  result.b \x3d isNaN.b ? x.b : result.b;\n  result.a \x3d isNaN.a ? x.a : result.a;\n\n  return result;\n":
"if (isnan(x)) return x;\n  return (x \x3c 0.0) ? 0.0 : x;\n";if("elu"===ea)return sa?"\n  vec4 result;\n\n  result.r \x3d (x.r \x3e\x3d 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g \x3d (x.g \x3e\x3d 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b \x3d (x.b \x3e\x3d 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a \x3d (x.a \x3e\x3d 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x \x3e\x3d 0.0) ? x : (exp(x) - 1.0);";if("relu6"===ea)return sa?"\n  vec4 result \x3d min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN \x3d isnan(x);\n\n  result.r \x3d isNaN.r ? x.r : result.r;\n  result.g \x3d isNaN.g ? x.g : result.g;\n  result.b \x3d isNaN.b ? x.b : result.b;\n  result.a \x3d isNaN.a ? x.a : result.a;\n\n  return result;\n":
"if (isnan(x)) return x;\n  return (x \x3c 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===ea)return sa?"\n  vec4 aLessThanZero \x3d vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n":"return (a \x3c 0.) ? b * a : a;";throw Error("Activation "+ea+" has not been implemented for the WebGL backend.");}function Vc(){lc.env().set("WEBGL_FORCE_F16_TEXTURES",!0)}function Pc(ea){var sa=ea.inputs.x;ea.backend.incRef(sa.dataId);return{dataId:sa.dataId,shape:sa.shape,
dtype:sa.dtype}}function gd(ea){var sa=ea.inputs;ea=ea.backend;var ia=sa.real,za=sa.imag;sa=ea.makeTensorInfo(ia.shape,"complex64");var Xa=ea.texData.get(sa.dataId);ia=Pc({inputs:{x:ia},backend:ea});ea.texData.get(ia.dataId).complexParentRefCount++;za=Pc({inputs:{x:za},backend:ea});ea.texData.get(za.dataId).complexParentRefCount++;Xa.complexTensorInfos={real:ia,imag:za};return sa}function Dd(ea){return function(sa){var ia=sa.inputs.x;sa=sa.backend;var za=new id(ia.shape,ea);return sa.runWebGLProgram(za,
[ia],ia.dtype)}}function Jd(ea){var sa=ea.opSnippet,ia=ea.packedOpSnippet,za=ea.checkOutOfBounds,Xa=void 0===za?!1:za;za=ea.supportsComplex;var Cb=void 0===za?!1:za,gc=ea.cpuKernelImpl,nc=ea.dtype;return function(Tc){var hd=Tc.inputs,Hd=hd.a,$d=hd.b,te=Tc.backend;if(Cb&&"complex64"===Hd.dtype){hd=te.texData.get(Hd.dataId);var He=te.texData.get($d.dataId);hd=[[hd.complexTensorInfos.real,He.complexTensorInfos.real],[hd.complexTensorInfos.imag,He.complexTensorInfos.imag]].map(function(Xd){var ye=Xd[0];
Xd=Xd[1];var cg={dataId:ye.dataId,dtype:ye.dtype,shape:Hd.shape},Ef={dataId:Xd.dataId,dtype:Xd.dtype,shape:$d.shape},Hg=new nb(sa,Hd.shape,$d.shape);return te.runWebGLProgram(Hg,[cg,Ef],lc.upcastType(ye.dtype,Xd.dtype))});Tc=hd[0];hd=hd[1];He=gd({inputs:{real:Tc,imag:hd},backend:te});te.disposeIntermediateTensorInfo(Tc);te.disposeIntermediateTensorInfo(hd);return He}Tc=nc||lc.upcastType(Hd.dtype,$d.dtype);if(te.shouldExecuteOnCPU([Hd,$d])&&null!=gc)return hd=te.texData.get(Hd.dataId),He=te.texData.get($d.dataId),
He=gc(Hd.shape,$d.shape,hd.values,He.values,Tc),hd=He[0],Tc=te.makeTensorInfo(He[1],Tc),te.texData.get(Tc.dataId).values=hd,Tc;hd=lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=ia?new Db(ia,Hd.shape,$d.shape,Xa):new nb(sa,Hd.shape,$d.shape);return te.runWebGLProgram(hd,[Hd,$d],Tc)}}function we(ea){var sa=ea.backend;ea=sa.texData.get(ea.inputs.input.dataId);return Pc({inputs:{x:ea.complexTensorInfos.real},backend:sa})}function Ne(ea){var sa=ea.backend,ia=ea.inputs.x;ea=ea.attrs.dtype;if("complex64"===
ea){if("complex64"===ia.dtype)return Pc({inputs:{x:ia},backend:sa});ea=lc.zeros(ia.shape);var za=Ne({inputs:{x:ia},backend:sa,attrs:{dtype:"float32"}});ia=gd({inputs:{real:za,imag:ea},backend:sa});ea.dispose();sa.disposeIntermediateTensorInfo(za);return ia}if("complex64"===ia.dtype)return za=we({inputs:{input:ia},backend:sa}),ia=Ne({inputs:{x:za},backend:sa,attrs:{dtype:ea}}),sa.disposeIntermediateTensorInfo(za),ia;if(!lc.util.hasEncodingLoss(ia.dtype,ea))return ia=Pc({inputs:{x:ia},backend:sa}),
{dataId:ia.dataId,shape:ia.shape,dtype:ea};if("int32"===ea)return ea=new id(ia.shape,"return float(int(x));"),sa=sa.runWebGLProgram(ea,[ia],"int32"),{dataId:sa.dataId,shape:sa.shape,dtype:sa.dtype};if("bool"===ea)return ea=sa.makeTensorInfo([],"bool",lc.util.getTypedArrayFromDType("bool",1)),ia=wf({inputs:{a:ia,b:ea},backend:sa}),sa.disposeIntermediateTensorInfo(ea),ia;throw Error("Error in Cast: failed to cast "+ia.dtype+" to "+ea);}function Je(ea,sa,ia){var za=ea.indexOf(sa);return ea.map(function(Xa,
Cb){return Cb===za?Xa+" - "+ia:Xa}).join()}function Qe(ea){var sa=ea.backend;ea=sa.texData.get(ea.inputs.input.dataId);return Pc({inputs:{x:ea.complexTensorInfos.imag},backend:sa})}function Ce(ea,sa,ia){var za=[I(ea.shape)].concat(T(ea.shape)),Xa={dtype:ea.dtype,shape:za,dataId:ea.dataId},Cb=[I(sa)].concat(T(sa));za=new Zf(Cb,za);ea=ia.runWebGLProgram(za,[Xa],ea.dtype,null,!0);return{dataId:ea.dataId,shape:sa,dtype:ea.dtype}}function Oe(ea){var sa=ea.inputs.x,ia=ea.attrs.shape;ea=ea.backend;var za=
lc.util.sizeFromShape(sa.shape),Xa=lc.util.inferFromImplicitShape(ia,za),Cb=lc.util.sizeFromShape(Xa);lc.util.assert(za===Cb,function(){return"The new shape ("+Xa+") has "+Cb+" elements and the old shape ("+(sa.shape+") has "+za+" elements. The new shape and old shape must have the same number of elements.")});ia=ea.texData.get(sa.dataId);if(ia.isPacked&&!Z(sa.shape,Xa)&&(null===ia.texture||!Z(ia.shape,Xa)))return Ce(sa,Xa,ea);ea.incRef(sa.dataId);return{dataId:sa.dataId,shape:Xa,dtype:sa.dtype}}
function od(ea,sa,ia){var za=ea[0].dtype;if("complex64"===za){za=ea.map(function(nc){return we({inputs:{input:nc},backend:ia})});ea=ea.map(function(nc){return Qe({inputs:{input:nc},backend:ia})});var Xa=od(za,sa,ia),Cb=od(ea,sa,ia),gc=gd({inputs:{real:Xa,imag:Cb},backend:ia});za.forEach(function(nc){return ia.disposeIntermediateTensorInfo(nc)});ea.forEach(function(nc){return ia.disposeIntermediateTensorInfo(nc)});ia.disposeIntermediateTensorInfo(Xa);ia.disposeIntermediateTensorInfo(Cb);return gc}if(ea.length>
lc.env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER"))return Xa=Math.floor(ea.length/2),za=od(ea.slice(0,Xa),sa,ia),ea=od(ea.slice(Xa),sa,ia),Xa=od([za,ea],sa,ia),ia.disposeIntermediateTensorInfo(za),ia.disposeIntermediateTensorInfo(ea),Xa;if(lc.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&1<ea[0].shape.length)return Xa=new uf(ea.map(function(nc){return nc.shape}),sa),ia.runWebGLProgram(Xa,ea,za);Xa=lc.backend_util.computeOutShape(ea.map(function(nc){return nc.shape}),sa);ea=ea.map(function(nc){return Oe({inputs:{x:nc},
attrs:{shape:[-1,lc.util.sizeFromShape(nc.shape.slice(sa))]},backend:ia})});Cb=new zd(ea.map(function(nc){return nc.shape}));za=ia.runWebGLProgram(Cb,ea,za);ea.forEach(function(nc){return ia.disposeIntermediateTensorInfo(nc)});ea=Oe({inputs:{x:za},attrs:{shape:Xa},backend:ia});ia.disposeIntermediateTensorInfo(za);return ea}function Ud(ea,sa,ia){var za=ia.texData.get(ea.dataId),Xa=lc.util.sizeFromShape(ea.shape),Cb=ea.shape[ea.shape.length-1];Cb=Oe({inputs:{x:ea},backend:ia,attrs:{shape:[Xa/Cb,Cb]}}).shape;
Xa=new Kg("real",Cb,sa);sa=new Kg("imag",Cb,sa);Cb=[{dataId:za.complexTensorInfos.real.dataId,dtype:za.complexTensorInfos.real.dtype,shape:Cb},{dataId:za.complexTensorInfos.imag.dataId,dtype:za.complexTensorInfos.imag.dtype,shape:Cb}];za=ia.runWebGLProgram(Xa,Cb,"float32");sa=ia.runWebGLProgram(sa,Cb,"float32");Xa=gd({inputs:{real:za,imag:sa},backend:ia});ia.disposeIntermediateTensorInfo(za);ia.disposeIntermediateTensorInfo(sa);ea=Oe({inputs:{x:Xa},backend:ia,attrs:{shape:ea.shape}});ia.disposeIntermediateTensorInfo(ea);
return ea}function Rd(ea,sa,ia,za){for(var Xa=ea.shape,Cb=[];0===Cb.length||1!==Cb[Cb.length-1].outSize;){var gc=Cb.length?Cb[Cb.length-1].outSize:Xa[1],nc=lc.backend_util.computeOptimalWindowSize(gc);Cb.push({inSize:gc,windowSize:nc,outSize:Math.ceil(gc/nc)})}Xa=ea;for(gc=0;gc<Cb.length;gc++){var Tc=Cb[gc];nc=Tc.inSize;var hd=Tc.windowSize;Tc=Tc.outSize;nc="mean"===ia?0===gc?new sg({windowSize:hd,inSize:nc,batchSize:ea.shape[0],outSize:Tc},nc):new sg({windowSize:hd,inSize:nc,batchSize:ea.shape[0],
outSize:Tc}):new Qf({windowSize:hd,inSize:nc,batchSize:ea.shape[0],outSize:Tc},ia);hd=Xa;Xa=za.runWebGLProgram(nc,[Xa],sa);hd.dataId!==ea.dataId&&za.disposeIntermediateTensorInfo(hd)}return Xa}function pc(ea,sa,ia){sa=lc.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ch(ea.shape,sa):new Sg(ea.shape,sa);return ia.runWebGLProgram(sa,[ea],ea.dtype)}function Ue(ea,sa,ia,za){var Xa=new ze(ia,"max",!1),Cb=za.runWebGLProgram(Xa,[ea],"float32");Xa=new ze(ia,"max",!0,!0,sa);ea=za.runWebGLProgram(Xa,[ea],
"float32");return[Cb,ea]}Object.defineProperty(v,"__esModule",{value:!0});var lc=A(948),pe=function(ea,sa){pe=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(ia,za){ia.__proto__=za}||function(ia,za){for(var Xa in za)za.hasOwnProperty(Xa)&&(ia[Xa]=za[Xa])};return pe(ea,sa)},rc={},qc={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0},Ib;(function(ea){ea[ea.DENSE=0]="DENSE";ea[ea.SHARED_BATCH=1]="SHARED_BATCH"})(Ib||
(Ib={}));var Ga;(function(ea){ea[ea.RENDER=0]="RENDER";ea[ea.UPLOAD=1]="UPLOAD";ea[ea.PIXELS=2]="PIXELS";ea[ea.DOWNLOAD=3]="DOWNLOAD"})(Ga||(Ga={}));var hb;(function(ea){ea[ea.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16";ea[ea.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32";ea[ea.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE";ea[ea.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32";ea[ea.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(hb||(hb={}));var Rb=/ERROR: [0-9]+:([0-9]+):/g,mc,Ub,ic={__proto__:null,callAndCheck:d,
canBeRepresented:h,getWebGLErrorMessage:c,getExtensionOrThrow:l,createVertexShader:m,createFragmentShader:n,createProgram:p,linkProgram:q,validateProgram:w,createStaticVertexBuffer:y,createStaticIndexBuffer:C,getNumChannels:function(){return 2===lc.env().getNumber("WEBGL_VERSION")?1:4},createTexture:z,validateTextureSize:K,createFramebuffer:J,bindVertexBufferToProgramAttribute:B,bindTextureUnit:O,unbindTextureUnit:function(ea,sa){L(ea,sa);d(ea,function(){return ea.activeTexture(ea.TEXTURE0+sa)});
d(ea,function(){return ea.bindTexture(ea.TEXTURE_2D,null)})},getProgramUniformLocationOrThrow:Q,getProgramUniformLocation:function(ea,sa,ia){return ea.getUniformLocation(sa,ia)},bindTextureToProgramUniformSampler:V,bindCanvasToFramebuffer:function(ea){d(ea,function(){return ea.bindFramebuffer(ea.FRAMEBUFFER,null)});d(ea,function(){return ea.viewport(0,0,ea.canvas.width,ea.canvas.height)});d(ea,function(){return ea.scissor(0,0,ea.canvas.width,ea.canvas.height)})},bindColorTextureToFramebuffer:M,unbindColorTextureFromFramebuffer:F,
validateFramebuffer:D,getFramebufferErrorMessage:H,getBatchDim:I,getRowsCols:T,getShapeAs3D:aa,getTextureShapeFromLogicalShape:ba,isReshapeFree:Z,getWebGLMaxTextureSize:da,resetMaxTextureSize:function(){mc=null},resetMaxTexturesInShader:function(){Ub=null},getMaxTexturesInShader:pa,getWebGLDisjointQueryTimerVersion:fa,hasExtension:ta,isWebGLVersionEnabled:ma,isCapableOfRenderingToFloatTexture:ja,isDownloadFloatTextureEnabled:qa,isWebGLFenceEnabled:ua,assertNotComplex:Ra},jc=lc.env();jc.registerFlag("HAS_WEBGL",
function(){return 0<jc.getNumber("WEBGL_VERSION")});jc.registerFlag("WEBGL_VERSION",function(){return ma(2)?2:ma(1)?1:0});jc.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",function(){return!1});jc.registerFlag("WEBGL_BUFFER_SUPPORTED",function(){return 2===jc.get("WEBGL_VERSION")});jc.registerFlag("WEBGL_CPU_FORWARD",function(){return!0});jc.registerFlag("WEBGL_FORCE_F16_TEXTURES",function(){return!1});jc.registerFlag("WEBGL_PACK",function(){return jc.getBool("HAS_WEBGL")});jc.registerFlag("WEBGL_PACK_NORMALIZATION",
function(){return jc.getBool("WEBGL_PACK")});jc.registerFlag("WEBGL_PACK_CLIP",function(){return jc.getBool("WEBGL_PACK")});jc.registerFlag("WEBGL_PACK_DEPTHWISECONV",function(){return!1});jc.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",function(){return jc.getBool("WEBGL_PACK")});jc.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",function(){return jc.getBool("WEBGL_PACK")});jc.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",function(){return jc.getBool("WEBGL_PACK")});jc.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",
function(){return jc.getBool("WEBGL_PACK")});jc.registerFlag("WEBGL_PACK_REDUCE",function(){return jc.getBool("WEBGL_PACK")});jc.registerFlag("WEBGL_LAZILY_UNPACK",function(){return jc.getBool("WEBGL_PACK")});jc.registerFlag("WEBGL_CONV_IM2COL",function(){return jc.getBool("WEBGL_PACK")});jc.registerFlag("WEBGL_MAX_TEXTURE_SIZE",function(){return da(jc.getNumber("WEBGL_VERSION"))});jc.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",function(){return pa(jc.getNumber("WEBGL_VERSION"))});jc.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",
function(){var ea=jc.getNumber("WEBGL_VERSION");return 0===ea?0:fa(ea)});jc.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",function(){return 0<jc.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")&&!lc.device_util.isMobile()});jc.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",function(){return ja(jc.getNumber("WEBGL_VERSION"))});jc.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",function(){return jc.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:jc.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")});
jc.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",function(){return qa(jc.getNumber("WEBGL_VERSION"))});jc.registerFlag("WEBGL_FENCE_API_ENABLED",function(){return ua(jc.getNumber("WEBGL_VERSION"))});jc.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",function(){return jc.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0});jc.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",function(){return-1},function(ea){if(0>ea&&-1!==ea)throw Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got "+
(ea+"."));});const Ob=Ia((ea,sa)=>ea+sa),fc=oa(ea=>Math.ceil(ea)),yc=oa(ea=>Math.exp(ea)),fd=oa(ea=>Math.expm1(ea)),Ad=oa(ea=>Math.floor(ea)),Gd=oa(ea=>Math.log(ea)),Ge=Ia((ea,sa)=>ea*sa),Re=oa(ea=>1/Math.sqrt(ea)),mf=Ia((ea,sa)=>ea-sa);var Ze=function(ea,sa,ia,za,Xa){var Cb=lc.slice_util.isSliceContinous(za,sa,ia);const gc=lc.util.sizeFromShape(ia),nc=lc.util.computeStrides(za);if(Cb)return ia=lc.slice_util.computeFlatOffset(sa,nc),ea.subarray(ia,ia+gc);Xa=lc.util.getTypedArrayFromDType(Xa,gc);for(Cb=
0;Cb<gc;++Cb){var Tc=ia.length;const hd=lc.util.computeStrides(ia);Tc=lc.util.indexToLoc(Cb,Tc,hd).map((Hd,$d)=>Hd+sa[$d]);Tc=lc.util.locToIndex(Tc,za.length,nc);Xa[Cb]=ea[Tc]}return Xa},Jb=function(ea,sa,ia,za,Xa){const Cb=sa.length,gc=lc.util.sizeFromShape(sa);sa=lc.util.computeStrides(sa);const nc=lc.util.computeStrides(Xa);ia=lc.util.getTypedArrayFromDType(ia,lc.util.sizeFromShape(Xa));for(Xa=0;Xa<gc;++Xa){var Tc=lc.util.indexToLoc(Xa,Cb,sa);const hd=Array(Tc.length);for(let Hd=0;Hd<hd.length;Hd++)hd[Hd]=
Tc[za[Hd]];Tc=lc.util.locToIndex(hd,Cb,nc);ia[Tc]=ea[Xa]}return ia},wb=function(ea,sa,ia,za){sa=lc.util.parseAxisParam(sa,ia)[0];const Xa=[1,ia[0],1];for(var Cb=0;Cb<sa;Cb++)Xa[0]*=ia[Cb];Xa[1]=ia[sa];for(Cb=sa+1;Cb<ia.length;Cb++)Xa[2]*=ia[Cb];const gc={};Cb=new Int32Array(ia[sa]);const nc=new lc.TensorBuffer(Xa,za,ea),Tc=[],hd=1===Xa[0]&&1===Xa[2];for(let He=0;He<ia[sa];He++){var Hd=void 0;if(hd)Hd=ea[He].toString();else{Hd=[];for(var $d=0;$d<Xa[0];$d++)for(let Xd=0;Xd<Xa[2];Xd++)Hd.push(nc.get($d,
He,Xd));Hd=Hd.join(",")}void 0!==gc[Hd]?Cb[He]=gc[Hd]:($d=Object.keys(gc).length,gc[Hd]=$d,Cb[He]=$d,Tc.push(He))}ea=Xa.slice();ea[1]=Object.keys(gc).length;const te=new lc.TensorBuffer(ea,za);Tc.forEach((He,Xd)=>{for(let ye=0;ye<Xa[0];ye++)for(let cg=0;cg<Xa[2];cg++)te.set(nc.get(ye,He,cg),ye,Xd,cg)});ia=ia.slice();ia[sa]=ea[1];return{outputValues:te.values,outputShape:ia,indices:Cb}},Lb=function(){return function(ea,sa){this.outputShape=[];this.outputShape=ea;this.variableNames=sa.map(function(za,
Xa){return"T"+Xa});var ia=[];this.variableNames.forEach(function(za){ia.push("float v"+za+" \x3d get"+za+"AtOutCoords();")});ea=this.variableNames.map(function(za){return"v"+za}).join(" + ");this.userCode="\n      void main() {\n        "+ia.join("\n        ")+"\n\n        float result \x3d "+ea+";\n        setOutput(result);\n      }\n    "}}(),oc=function(){return function(ea,sa){this.outputShape=[];this.packedOutput=this.packedInputs=!0;this.outputShape=ea;this.variableNames=sa.map(function(za,
Xa){return"T"+Xa});var ia=[];this.variableNames.forEach(function(za){ia.push("vec4 v"+za+" \x3d get"+za+"AtOutCoords();")});ea=this.variableNames.map(function(za){return"v"+za}).join(" + ");this.userCode="\n      void main() {\n        "+ia.join("\n        ")+"\n\n        vec4 result \x3d "+ea+";\n        setOutput(result);\n      }\n    "}}(),Lc=function(){return function(ea,sa,ia){this.variableNames=["A"];var za=ea.windowSize,Xa=ea.batchSize;ea=ea.outSize;ia||this.variableNames.push("bestIndicesA");
this.outputShape=[Xa,ea];this.userCode="\n      void main() {\n        ivec2 coords \x3d getOutputCoords();\n        int batch \x3d coords[0];\n        int outIdx \x3d coords[1];\n        int inOffset \x3d outIdx * "+za+";\n\n        int bestIndex \x3d inOffset;\n        float bestValue \x3d getA(batch, bestIndex);\n\n        for (int i \x3d 0; i \x3c "+za+"; i++) {\n          int inIdx \x3d "+(ia?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));")+";\n          float candidate \x3d getA(batch, inIdx);\n          if (candidate "+
("max"===sa?"\x3e":"\x3c")+" bestValue) {\n            bestValue \x3d candidate;\n            bestIndex \x3d inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "}}(),ed=lc.backend_util.getBroadcastDims,ge="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR \x3d index / texNumC;\n  int texC \x3d index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex \x3d index / 2;\n  int texR \x3d texelIndex / texNumC;\n  int texC \x3d texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
he="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex \x3d (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR \x3d texelIndex / texNumC;\n  int texC \x3d texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",bf="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index \x3d b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR \x3d index / texNumC;\n  int texC \x3d index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
cf="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord \x3d mod(innerDims, 2.);\n    return modCoord.x \x3d\x3d 0. ?\n      (modCoord.y \x3d\x3d 0. ? frag.r : frag.g) :\n      (modCoord.y \x3d\x3d 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord \x3d mod(float(dim), 2.);\n    return modCoord \x3d\x3d 0. ? frag.r : frag.g;\n  }\n",qe=function(){return function(ea,sa,ia,za){this.variableNames=["A"];this.packedOutput=this.packedInputs=!0;lc.util.assert(2<
ea.length,function(){return"Packed arg"+(ia.charAt(0).toUpperCase()+ia.slice(1))+" supports only inputs with rank above 2."});var Xa=Math.ceil(ea[ea.length-1]/sa);this.outputShape=ea.slice(0,-1);1<Xa&&this.outputShape.push(Xa);za||this.variableNames.push("bestIndicesA");ea=this.outputShape;var Cb=ea.length,gc=lb(Cb),nc=gb("coords",Cb);if(1===Xa){var Tc=Cb+1;Xa=lb(Tc);Xa="\n        "+Xa+" sourceLocR \x3d "+Xa+"("+nc.join()+", 0);\n        ++"+nc[Cb-1]+";\n        "+Xa+" sourceLocG \x3d "+Xa+"("+nc.join()+
", 0);\n        ++"+nc[Cb-2]+";\n        "+Xa+" sourceLocA \x3d "+Xa+"("+nc.join()+", 0);\n        --"+nc[Cb-1]+";\n        "+Xa+" sourceLocB \x3d "+Xa+"("+nc.join()+", 0);\n        --"+nc[Cb-2]+";"}else Tc=Cb,Xa="\n        "+gc+" sourceLocR \x3d coords;\n        ++"+nc[Cb-1]+";\n        "+gc+" sourceLocG \x3d coords;\n        ++"+nc[Cb-2]+";\n        "+gc+" sourceLocA \x3d coords;\n        --"+nc[Cb-1]+";\n        "+gc+" sourceLocB \x3d coords;\n        --"+nc[Cb-2]+";";var hd="xyzwuv".split("").slice(0,
Tc),Hd="."+hd[Tc-1],$d=hd.map(function(Ef){return"int "+Ef}),te=gb("sourceLocR",Tc-1).concat("inIdx.r"),He=gb("sourceLocG",Tc-1).concat("inIdx.g"),Xd=gb("sourceLocB",Tc-1).concat("inIdx.b"),ye=gb("sourceLocA",Tc-1).concat("inIdx.a");Tc="max"===ia?"greaterThan":"lessThan";var cg=za?"":"\n          inIdx \x3d round(vec4(getBestIndicesAChannel("+te.join()+"),\n                             getBestIndicesAChannel("+He.join()+"),\n                             getBestIndicesAChannel("+Xd.join()+"),\n                             getBestIndicesAChannel("+
ye.join()+")));";te="vec4(\n            getAChannel("+te.join()+"),\n            hasNextCol ? getAChannel("+He.join()+") : 0.,\n            hasNextRow ? getAChannel("+Xd.join()+") : 0.,\n            hasNextRow \x26\x26 hasNextCol ? getAChannel("+ye.join()+") : 0.)";za=za?"":"\n      float getBestIndicesAChannel("+$d.join()+") {\n        return getChannel(getBestIndicesA("+hd.join()+"),\n                                          vec2("+hd.slice(-2).join()+"));\n      }";this.userCode="\n      float getAChannel("+
$d.join()+") {\n        return getChannel(getA("+hd.join()+"),\n                               vec2("+hd.slice(-2).join()+"));\n      }\n      "+za+"\n      void main() {\n        "+gc+" coords \x3d getOutputCoords();\n        bool hasNextCol \x3d "+nc[Cb-1]+" \x3c "+(ea[Cb-1]-1)+";\n        bool hasNextRow \x3d "+nc[Cb-2]+" \x3c "+(ea[Cb-2]-1)+";\n        "+Xa+"\n        ivec4 srcIdx \x3d ivec4(sourceLocR"+Hd+", sourceLocG"+Hd+",\n          sourceLocB"+Hd+", sourceLocA"+Hd+") * "+sa+";\n        ivec4 inIdx \x3d srcIdx;\n        vec4 bestIndex \x3d vec4(inIdx);\n        vec4 bestValue \x3d "+
te+";\n\n        for (int i \x3d 0; i \x3c "+sa+"; i++) {\n          inIdx \x3d srcIdx;\n          "+cg+"\n          vec4 candidate \x3d "+te+";\n          bvec4 nan \x3d isnan(candidate);\n          bvec4 replace \x3d bvec4(\n            vec4("+Tc+"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue \x3d vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex \x3d mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    "}}(),
ie=function(){return function(ea){this.variableNames=["dy"];this.outputShape=ea.inShape;var sa=ea.effectiveFilterHeight,ia=ea.effectiveFilterWidth;this.userCode="\n      const ivec2 pads \x3d ivec2("+(sa-1-ea.padInfo.top)+", "+(ia-1-ea.padInfo.left)+");\n      const float avgMultiplier \x3d float("+1/(ea.filterHeight*ea.filterWidth)+");\n\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int b \x3d coords[0];\n        int d \x3d coords[3];\n\n        ivec2 dyRCCorner \x3d coords.yz - pads;\n        int dyRCorner \x3d dyRCCorner.x;\n        int dyCCorner \x3d dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? \x3d to be determined. : \x3d across all values in that axis.\n        float dotProd \x3d 0.0;\n        for (int wR \x3d 0; wR \x3c "+
sa+";\n            wR +\x3d "+ea.dilationHeight+") {\n          float dyR \x3d float(dyRCorner + wR) / "+ea.strideHeight+".0;\n\n          if (dyR \x3c 0.0 || dyR \x3e\x3d "+ea.outHeight+".0 || fract(dyR) \x3e 0.0) {\n            continue;\n          }\n          int idyR \x3d int(dyR);\n\n          for (int wC \x3d 0; wC \x3c "+ia+";\n            wC+\x3d "+ea.dilationWidth+") {\n            float dyC \x3d float(dyCCorner + wC) / "+ea.strideWidth+".0;\n\n            if (dyC \x3c 0.0 || dyC \x3e\x3d "+
ea.outWidth+".0 ||\n                fract(dyC) \x3e 0.0) {\n              continue;\n            }\n            int idyC \x3d int(dyC);\n\n            float dyValue \x3d getDy(b, idyR, idyC, d);\n\n            dotProd +\x3d dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Za=function(){return function(ea){this.variableNames=["dy"];this.outputShape=ea.inShape;var sa=ea.effectiveFilterDepth,ia=ea.effectiveFilterHeight,za=ea.effectiveFilterWidth;this.userCode=
"\n      const ivec3 pads \x3d ivec3("+(sa-1-ea.padInfo.front)+", "+(ia-1-ea.padInfo.top)+", "+(za-1-ea.padInfo.left)+");\n      const float avgMultiplier \x3d float("+1/(ea.filterDepth*ea.filterHeight*ea.filterWidth)+");\n\n      void main() {\n        ivec5 coords \x3d getOutputCoords();\n        int batch \x3d coords.x;\n        int ch \x3d coords.u;\n\n        ivec3 dyCorner \x3d ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner \x3d dyCorner.x;\n        int dyRCorner \x3d dyCorner.y;\n        int dyCCorner \x3d dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? \x3d to be determined. : \x3d across all values in that axis.\n        float dotProd \x3d 0.0;\n\n        for (int wD \x3d 0; wD \x3c "+
sa+";\n            wD +\x3d "+ea.dilationDepth+") {\n          float dyD \x3d float(dyDCorner + wD) / "+ea.strideDepth+".0;\n\n          if (dyD \x3c 0.0 || dyD \x3e\x3d "+ea.outDepth+".0 || fract(dyD) \x3e 0.0) {\n            continue;\n          }\n          int idyD \x3d int(dyD);\n\n          for (int wR \x3d 0; wR \x3c "+ia+";\n              wR +\x3d "+ea.dilationHeight+") {\n            float dyR \x3d float(dyRCorner + wR) / "+ea.strideHeight+".0;\n\n            if (dyR \x3c 0.0 || dyR \x3e\x3d "+
ea.outHeight+".0 ||\n                fract(dyR) \x3e 0.0) {\n              continue;\n            }\n            int idyR \x3d int(dyR);\n\n            for (int wC \x3d 0; wC \x3c "+za+";\n                wC +\x3d "+ea.dilationWidth+") {\n              float dyC \x3d float(dyCCorner + wC) / "+ea.strideWidth+".0;\n\n              if (dyC \x3c 0.0 || dyC \x3e\x3d "+ea.outWidth+".0 ||\n                  fract(dyC) \x3e 0.0) {\n                continue;\n              }\n              int idyC \x3d int(dyC);\n\n              float dyValue \x3d getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd +\x3d dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),
nb=function(){return function(ea,sa,ia){this.variableNames=["A","B"];this.outputShape=lc.backend_util.assertAndGetBroadcastShape(sa,ia);this.userCode="\n      float binaryOperation(float a, float b) {\n        "+ea+"\n      }\n\n      void main() {\n        float a \x3d getAAtOutCoords();\n        float b \x3d getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "}}(),Db=function(){return function(ea,sa,ia,za){void 0===za&&(za=!1);this.variableNames=["A","B"];this.packedOutput=
this.packedInputs=this.supportsBroadcasting=!0;this.outputShape=lc.backend_util.assertAndGetBroadcastShape(sa,ia);sa=this.outputShape.length;ia="";za&&(0===sa||1===lc.util.sizeFromShape(this.outputShape)?ia="\n          result.y \x3d 0.;\n          result.z \x3d 0.;\n          result.w \x3d 0.;\n        ":(ia="\n          "+lb(sa)+" coords \x3d getOutputCoords();\n        ",1===sa?ia+="\n            result.y \x3d (coords + 1) \x3e\x3d "+this.outputShape[0]+" ? 0. : result.y;\n            result.z \x3d 0.;\n            result.w \x3d 0.;\n          ":
(za=gb("coords",sa),ia+="\n            bool nextRowOutOfBounds \x3d\n              ("+za[sa-2]+" + 1) \x3e\x3d "+this.outputShape[sa-2]+";\n            bool nextColOutOfBounds \x3d\n              ("+za[sa-1]+" + 1) \x3e\x3d "+this.outputShape[sa-1]+";\n            result.y \x3d nextColOutOfBounds ? 0. : result.y;\n            result.z \x3d nextRowOutOfBounds ? 0. : result.z;\n            result.w \x3d nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")));this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        "+
ea+"\n      }\n\n      void main() {\n        vec4 a \x3d getAAtOutCoords();\n        vec4 b \x3d getBAtOutCoords();\n\n        vec4 result \x3d binaryOperation(a, b);\n        "+ia+"\n\n        setOutput(result);\n      }\n    "}}(),dc=function(){function ea(sa){this.variableNames=["A"];this.outputShape=sa;this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value \x3d getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}
ea.prototype.getCustomSetupFunc=function(sa,ia){var za=this;return function(Xa,Cb){null==za.minLoc&&(za.minLoc=Xa.getUniformLocationNoThrow(Cb,"minVal"),za.maxLoc=Xa.getUniformLocationNoThrow(Cb,"maxVal"));Xa.gl.uniform1f(za.minLoc,sa);Xa.gl.uniform1f(za.maxLoc,ia)}};return ea}(),uc=function(){function ea(sa){this.variableNames=["A"];this.packedOutput=this.packedInputs=!0;this.outputShape=sa;this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value \x3d getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}
ea.prototype.getCustomSetupFunc=function(sa,ia){var za=this;return function(Xa,Cb){null==za.minLoc&&(za.minLoc=Xa.getUniformLocationNoThrow(Cb,"minVal"),za.maxLoc=Xa.getUniformLocationNoThrow(Cb,"maxVal"));Xa.gl.uniform1f(za.minLoc,sa);Xa.gl.uniform1f(za.maxLoc,ia)}};return ea}(),Qc=function(){return function(ea){this.variableNames=["real","imag"];this.outputShape=ea;this.userCode="\n      void main() {\n        float re \x3d abs(getRealAtOutCoords());\n        float im \x3d abs(getImagAtOutCoords());\n        float mx \x3d max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx \x3d\x3d 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}(),
ud=function(){return function(ea){this.variableNames=["x","dy"];this.outputShape=ea.filterShape;this.userCode="\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int wR \x3d coords.x;\n        int wC \x3d coords.y;\n        int d1 \x3d coords.z;\n        int d2 \x3d coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? \x3d to be determined. : \x3d across all values in that axis.\n        float dotProd \x3d 0.0;\n\n        for (int b \x3d 0; b \x3c "+
ea.batchSize+"; b++) {\n          for (int yR \x3d 0; yR \x3c "+ea.outHeight+"; yR++) {\n            int xR \x3d wR + yR * "+ea.strideHeight+" - "+ea.padInfo.top+";\n\n            if (xR \x3c 0 || xR \x3e\x3d "+ea.inHeight+") {\n              continue;\n            }\n\n            for (int yC \x3d 0; yC \x3c "+ea.outWidth+"; yC++) {\n              int xC \x3d wC + yC * "+ea.strideWidth+" - "+ea.padInfo.left+";\n\n              if (xC \x3c 0 || xC \x3e\x3d "+ea.inWidth+") {\n                continue;\n              }\n\n              if ("+
("channelsLast"===ea.dataFormat)+") {\n                float dyValue \x3d getDy(b, yR, yC, d2);\n                float xValue \x3d getX(b, xR, xC, d1);\n                dotProd +\x3d (xValue * dyValue);\n              } else {\n                float dyValue \x3d getDy(b, d2, yR, yC);\n                float xValue \x3d getX(b, d1, xR, xC);\n                dotProd +\x3d (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Fd=
function(){return function(ea){this.variableNames=["dy","W"];this.outputShape=ea.inShape;var sa=ea.filterHeight,ia=ea.filterWidth,za="channelsLast"===ea.dataFormat;this.userCode="\n      const ivec2 pads \x3d ivec2("+(sa-1-ea.padInfo.top)+", "+(ia-1-ea.padInfo.left)+");\n\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int batch \x3d coords[0];\n        int d1 \x3d coords["+(za?3:1)+"];\n\n        ivec2 dyCorner \x3d ivec2(coords["+(za?1:2)+"], coords["+(za?2:3)+"]) - pads;\n        int dyRCorner \x3d dyCorner.x;\n        int dyCCorner \x3d dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? \x3d to be determined. : \x3d across all values in that axis.\n        float dotProd \x3d 0.0;\n        for (int wR \x3d 0; wR \x3c "+
sa+"; wR++) {\n          float dyR \x3d float(dyRCorner + wR) / "+ea.strideHeight+".0;\n\n          if (dyR \x3c 0.0 || dyR \x3e\x3d "+ea.outHeight+".0 || fract(dyR) \x3e 0.0) {\n            continue;\n          }\n          int idyR \x3d int(dyR);\n\n          int wRPerm \x3d "+sa+" - 1 - wR;\n\n          for (int wC \x3d 0; wC \x3c "+ia+"; wC++) {\n            float dyC \x3d float(dyCCorner + wC) / "+ea.strideWidth+".0;\n\n            if (dyC \x3c 0.0 || dyC \x3e\x3d "+ea.outWidth+".0 ||\n                fract(dyC) \x3e 0.0) {\n              continue;\n            }\n            int idyC \x3d int(dyC);\n\n            int wCPerm \x3d "+
ia+" - 1 - wC;\n\n            for (int d2 \x3d 0; d2 \x3c "+ea.outChannels+"; d2++) {\n\n              if ("+za+") {\n                float xValue \x3d getDy(batch, idyR, idyC, d2);\n                float wValue \x3d getW(wRPerm, wCPerm, d1, d2);\n                dotProd +\x3d xValue * wValue;\n              } else {\n                float xValue \x3d getDy(batch, d2, idyR, idyC);\n                float wValue \x3d getW(wRPerm, wCPerm, d1, d2);\n                dotProd +\x3d xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),
je=function(){return function(ea){this.variableNames=["x","dy"];this.outputShape=ea.filterShape;this.userCode="\n      void main() {\n        ivec5 coords \x3d getOutputCoords();\n        int wF \x3d coords.x;\n        int wR \x3d coords.y;\n        int wC \x3d coords.z;\n        int d1 \x3d coords.w;\n        int d2 \x3d coords.u;\n\n        float dotProd \x3d 0.0;\n\n        for (int b \x3d 0; b \x3c "+ea.batchSize+"; b++) {\n          for (int yF \x3d 0; yF \x3c "+ea.outDepth+"; yF++) {\n            int xF \x3d wF + yF * "+
ea.strideDepth+" - "+ea.padInfo.front+";\n\n            if (xF \x3c 0 || xF \x3e\x3d "+ea.inDepth+") {\n              continue;\n            }\n\n            for (int yR \x3d 0; yR \x3c "+ea.outHeight+"; yR++) {\n              int xR \x3d wR + yR * "+ea.strideHeight+" - "+ea.padInfo.top+";\n\n              if (xR \x3c 0 || xR \x3e\x3d "+ea.inHeight+") {\n                continue;\n              }\n\n              for (int yC \x3d 0; yC \x3c "+ea.outWidth+"; yC++) {\n                int xC \x3d wC + yC * "+
ea.strideWidth+" - "+ea.padInfo.left+";\n\n                if (xC \x3c 0 || xC \x3e\x3d "+ea.inWidth+") {\n                  continue;\n                }\n\n                float dyValue \x3d getDy(b, yF, yR, yC, d2);\n                float xValue \x3d getX(b, xF, xR, xC, d1);\n                dotProd +\x3d (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),sd=function(){return function(ea){this.variableNames=["dy","W"];this.outputShape=
ea.inShape;var sa=ea.filterDepth,ia=ea.filterHeight,za=ea.filterWidth;this.userCode="\n      const ivec3 pads \x3d ivec3("+(sa-1-ea.padInfo.front)+", "+(ia-1-ea.padInfo.top)+", "+(za-1-ea.padInfo.left)+");\n\n      void main() {\n        ivec5 coords \x3d getOutputCoords();\n        int batch \x3d coords.x;\n        int d1 \x3d coords.u;\n\n\n        ivec3 dyCorner \x3d ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner \x3d dyCorner.x;\n        int dyRCorner \x3d dyCorner.y;\n        int dyCCorner \x3d dyCorner.z;\n\n        float dotProd \x3d 0.0;\n        for (int wF \x3d 0; wF \x3c "+
sa+"; wF++) {\n          float dyF \x3d float(dyFCorner + wF) / "+ea.strideDepth+".0;\n\n          if (dyF \x3c 0.0 || dyF \x3e\x3d "+ea.outDepth+".0 || fract(dyF) \x3e 0.0) {\n            continue;\n          }\n          int idyF \x3d int(dyF);\n\n          int wFPerm \x3d "+sa+" - 1 - wF;\n\n          for (int wR \x3d 0; wR \x3c "+ia+"; wR++) {\n            float dyR \x3d float(dyRCorner + wR) / "+ea.strideHeight+".0;\n\n            if (dyR \x3c 0.0 || dyR \x3e\x3d "+ea.outHeight+".0 ||\n              fract(dyR) \x3e 0.0) {\n              continue;\n            }\n            int idyR \x3d int(dyR);\n\n            int wRPerm \x3d "+
ia+" - 1 - wR;\n\n            for (int wC \x3d 0; wC \x3c "+za+"; wC++) {\n              float dyC \x3d float(dyCCorner + wC) / "+ea.strideWidth+".0;\n\n              if (dyC \x3c 0.0 || dyC \x3e\x3d "+ea.outWidth+".0 ||\n                  fract(dyC) \x3e 0.0) {\n                continue;\n              }\n              int idyC \x3d int(dyC);\n\n              int wCPerm \x3d "+za+" - 1 - wC;\n\n              for (int d2 \x3d 0; d2 \x3c "+ea.outChannels+"; d2++) {\n                float xValue \x3d getDy(batch, idyF, idyR, idyC, d2);\n                float wValue \x3d getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd +\x3d xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),
wd=function(){return function(ea){this.variableNames=["x","dy"];this.outputShape=ea.filterShape;this.userCode="\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int wR \x3d coords.x;\n        int wC \x3d coords.y;\n        int d1 \x3d coords.z;\n        int dm \x3d coords.w;\n        int d2 \x3d d1 * "+ea.outChannels/ea.inChannels+" + dm;\n\n        float dotProd \x3d 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b \x3d 0; b \x3c "+ea.batchSize+"; b++) {\n          for (int yR \x3d 0; yR \x3c "+
ea.outHeight+"; yR++) {\n            int xR \x3d wR + yR * "+ea.strideHeight+" - "+ea.padInfo.top+";\n\n            if (xR \x3c 0 || xR \x3e\x3d "+ea.inHeight+") {\n              continue;\n            }\n\n            for (int yC \x3d 0; yC \x3c "+ea.outWidth+"; yC++) {\n              int xC \x3d wC + yC * "+ea.strideWidth+" - "+ea.padInfo.left+";\n\n              if (xC \x3c 0 || xC \x3e\x3d "+ea.inWidth+") {\n                continue;\n              }\n\n              float dyValue \x3d getDy(b, yR, yC, d2);\n              float xValue \x3d getX(b, xR, xC, d1);\n              dotProd +\x3d (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),
Zd=function(){return function(ea){this.variableNames=["dy","W"];this.outputShape=ea.inShape;var sa=ea.filterHeight,ia=ea.filterWidth,za=ea.outChannels/ea.inChannels;this.userCode="\n      const ivec2 pads \x3d ivec2("+(sa-1-ea.padInfo.top)+", "+(ia-1-ea.padInfo.left)+");\n\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int batch \x3d coords[0];\n        int d1 \x3d coords[3];\n        ivec2 dyCorner \x3d coords.yz - pads;\n        int dyRCorner \x3d dyCorner.x;\n        int dyCCorner \x3d dyCorner.y;\n\n        float dotProd \x3d 0.0;\n\n        for (int wR \x3d 0; wR \x3c "+
sa+"; wR++) {\n          float dyR \x3d float(dyRCorner + wR) / "+ea.strideHeight+".0;\n\n          if (dyR \x3c 0.0 || dyR \x3e\x3d "+ea.outHeight+".0 || fract(dyR) \x3e 0.0) {\n            continue;\n          }\n          int idyR \x3d int(dyR);\n\n          int wRPerm \x3d "+sa+" - 1 - wR;\n\n          for (int wC \x3d 0; wC \x3c "+ia+"; wC++) {\n            float dyC \x3d float(dyCCorner + wC) / "+ea.strideWidth+".0;\n\n            if (dyC \x3c 0.0 || dyC \x3e\x3d "+ea.outWidth+".0 ||\n                fract(dyC) \x3e 0.0) {\n              continue;\n            }\n            int idyC \x3d int(dyC);\n\n            int wCPerm \x3d "+
ia+" - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm \x3d 0; dm \x3c "+za+"; dm++) {\n              int d2 \x3d d1 * "+za+" + dm;\n              float xValue \x3d getDy(batch, idyR, idyC, d2);\n              float wValue \x3d getW(wRPerm, wCPerm, d1, dm);\n              dotProd +\x3d xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Te=function(){return function(ea,sa,ia,za){void 0===sa&&(sa=!1);void 0===ia&&
(ia=null);void 0===za&&(za=!1);this.variableNames=["x","W"];this.outputShape=ea.outShape;var Xa=ea.padInfo.top,Cb=ea.padInfo.left,gc=ea.strideHeight,nc=ea.strideWidth,Tc=ea.dilationHeight,hd=ea.dilationWidth,Hd=ea.filterHeight,$d=ea.filterWidth,te=4*Math.floor(ea.inChannels/4),He=ea.inChannels%4,Xd="channelsLast"===ea.dataFormat,ye=Xd?1:2,cg=Xd?2:3,Ef=Xd?3:1,Hg="",jg="";ia&&(Hg=za?"float activation(float a) {\n          float b \x3d getPreluActivationWeightsAtOutCoords();\n          "+ia+"\n        }":
"\n          float activation(float x) {\n            "+ia+"\n          }\n        ",jg="result \x3d activation(result);");ia=sa?"result +\x3d getBiasAtOutCoords();":"";sa&&this.variableNames.push("bias");za&&this.variableNames.push("preluActivationWeights");this.userCode="\n      "+Hg+"\n\n      const ivec2 strides \x3d ivec2("+gc+", "+nc+");\n      const ivec2 pads \x3d ivec2("+Xa+", "+Cb+");\n\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int batch \x3d coords[0];\n        int d2 \x3d coords["+
Ef+"];\n\n        ivec2 xRCCorner \x3d\n            ivec2(coords["+ye+"], coords["+cg+"]) * strides - pads;\n        int xRCorner \x3d xRCCorner.x;\n        int xCCorner \x3d xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? \x3d to be determined. : \x3d across all values in that axis.\n        float dotProd \x3d 0.0;\n        for (int wR \x3d 0; wR \x3c "+Hd+"; wR++) {\n          int xR \x3d xRCorner + wR * "+Tc+";\n\n          if (xR \x3c 0 || xR \x3e\x3d "+
ea.inHeight+") {\n            continue;\n          }\n\n          for (int wC \x3d 0; wC \x3c "+$d+"; wC++) {\n            int xC \x3d xCCorner + wC * "+hd+";\n\n            if (xC \x3c 0 || xC \x3e\x3d "+ea.inWidth+") {\n              continue;\n            }\n\n            for (int d1 \x3d 0; d1 \x3c "+te+"; d1 +\x3d 4) {\n              vec4 wValues \x3d vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if ("+
Xd+") {\n                vec4 xValues \x3d vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd +\x3d dot(xValues, wValues);\n              } else {\n                vec4 xValues \x3d vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd +\x3d dot(xValues, wValues);\n              }\n            }\n\n            if ("+
(1===He)+") {\n\n              if ("+Xd+") {\n                dotProd +\x3d\n                    getX(batch, xR, xC, "+te+") *\n                    getW(wR, wC, "+te+", d2);\n              } else {\n                dotProd +\x3d\n                    getX(batch, "+te+", xR, xC) *\n                    getW(wR, wC, "+te+", d2);\n              }\n\n            } else if ("+(2===He)+") {\n              vec2 wValues \x3d vec2(\n                getW(wR, wC, "+te+", d2),\n                getW(wR, wC, "+te+
" + 1, d2)\n              );\n\n              if ("+Xd+") {\n                vec2 xValues \x3d vec2(\n                  getX(batch, xR, xC, "+te+"),\n                  getX(batch, xR, xC, "+te+" + 1)\n                );\n                dotProd +\x3d dot(xValues, wValues);\n              } else {\n                vec2 xValues \x3d vec2(\n                  getX(batch, "+te+", xR, xC),\n                  getX(batch, "+te+" + 1, xR, xC)\n                );\n                dotProd +\x3d dot(xValues, wValues);\n              }\n\n            } else if ("+
(3===He)+") {\n              vec3 wValues \x3d vec3(\n                getW(wR, wC, "+te+", d2),\n                getW(wR, wC, "+te+" + 1, d2),\n                getW(wR, wC, "+te+" + 2, d2)\n              );\n\n              if ("+Xd+") {\n                vec3 xValues \x3d vec3(\n                  getX(batch, xR, xC, "+te+"),\n                  getX(batch, xR, xC, "+te+" + 1),\n                  getX(batch, xR, xC, "+te+" + 2)\n                );\n                dotProd +\x3d dot(xValues, wValues);\n              } else {\n                vec3 xValues \x3d vec3(\n                  getX(batch, "+
te+", xR, xC),\n                  getX(batch, "+te+" + 1, xR, xC),\n                  getX(batch, "+te+" + 2, xR, xC)\n                );\n                dotProd +\x3d dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result \x3d dotProd;\n        "+ia+"\n        "+jg+"\n        setOutput(result);\n      }\n    "}}(),re=function(){return function(ea){this.variableNames=["x","W"];this.outputShape=ea.outShape;var sa=4*Math.floor(ea.inChannels/4),ia=ea.inChannels%
4;this.userCode="\n      const ivec3 strides \x3d ivec3("+ea.strideDepth+", "+ea.strideHeight+", "+ea.strideWidth+");\n      const ivec3 pads \x3d ivec3("+ea.padInfo.front+", "+ea.padInfo.top+", "+ea.padInfo.left+");\n\n      void main() {\n        ivec5 coords \x3d getOutputCoords();\n        int batch \x3d coords.x;\n        int d2 \x3d coords.u;\n\n        ivec3 xFRCCorner \x3d ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner \x3d xFRCCorner.x;\n        int xRCorner \x3d xFRCCorner.y;\n        int xCCorner \x3d xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? \x3d to be determined. : \x3d across all\n        // values in that axis.\n        float dotProd \x3d 0.0;\n        for (int wF \x3d 0; wF \x3c "+
ea.filterDepth+"; wF++) {\n          int xF \x3d xFCorner + wF * "+ea.dilationDepth+";\n\n          if (xF \x3c 0 || xF \x3e\x3d "+ea.inDepth+") {\n            continue;\n          }\n\n          for (int wR \x3d 0; wR \x3c "+ea.filterHeight+"; wR++) {\n            int xR \x3d xRCorner + wR * "+ea.dilationHeight+";\n\n            if (xR \x3c 0 || xR \x3e\x3d "+ea.inHeight+") {\n              continue;\n            }\n\n            for (int wC \x3d 0; wC \x3c "+ea.filterWidth+"; wC++) {\n              int xC \x3d xCCorner + wC * "+
ea.dilationWidth+";\n\n              if (xC \x3c 0 || xC \x3e\x3d "+ea.inWidth+") {\n                continue;\n              }\n\n              for (int d1 \x3d 0; d1 \x3c "+sa+"; d1 +\x3d 4) {\n                vec4 xValues \x3d vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues \x3d vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd +\x3d dot(xValues, wValues);\n              }\n\n              if ("+
(1===ia)+") {\n                dotProd +\x3d\n                  getX(batch, xF, xR, xC, "+sa+") *\n                  getW(wF, wR, wC, "+sa+", d2);\n              } else if ("+(2===ia)+") {\n                vec2 xValues \x3d vec2(\n                  getX(batch, xF, xR, xC, "+sa+"),\n                  getX(batch, xF, xR, xC, "+sa+" + 1)\n                );\n                vec2 wValues \x3d vec2(\n                  getW(wF, wR, wC, "+sa+", d2),\n                  getW(wF, wR, wC, "+sa+" + 1, d2)\n                );\n                dotProd +\x3d dot(xValues, wValues);\n              } else if ("+
(3===ia)+") {\n                vec3 xValues \x3d vec3(\n                  getX(batch, xF, xR, xC, "+sa+"),\n                  getX(batch, xF, xR, xC, "+sa+" + 1),\n                  getX(batch, xF, xR, xC, "+sa+" + 2)\n                );\n                vec3 wValues \x3d vec3(\n                  getW(wF, wR, wC, "+sa+", d2),\n                  getW(wF, wR, wC, "+sa+" + 1, d2),\n                  getW(wF, wR, wC, "+sa+" + 2, d2)\n                );\n                dotProd +\x3d dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),
We=function(){return function(ea,sa,ia,za){void 0===sa&&(sa=!1);void 0===ia&&(ia=null);void 0===za&&(za=!1);this.variableNames=["x","W"];this.outputShape=ea.outShape;var Xa=ea.inHeight,Cb=ea.inWidth,gc=ea.padInfo.top,nc=ea.padInfo.left,Tc=ea.strideHeight,hd=ea.strideWidth,Hd=ea.dilationHeight,$d=ea.dilationWidth,te=ea.filterHeight,He=ea.filterWidth;ea=ea.outChannels/ea.inChannels;var Xd="",ye="";ia&&(Xd=za?"float activation(float a) {\n          float b \x3d getPreluActivationWeightsAtOutCoords();\n          "+
ia+"\n        }":"\n          float activation(float x) {\n            "+ia+"\n          }\n        ",ye="result \x3d activation(result);");ia=sa?"result +\x3d getBiasAtOutCoords();":"";sa&&this.variableNames.push("bias");za&&this.variableNames.push("preluActivationWeights");this.userCode="\n      "+Xd+"\n\n      const ivec2 strides \x3d ivec2("+Tc+", "+hd+");\n      const ivec2 pads \x3d ivec2("+gc+", "+nc+");\n\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int batch \x3d coords.x;\n        ivec2 xRCCorner \x3d coords.yz * strides - pads;\n        int d2 \x3d coords.w;\n        int d1 \x3d d2 / "+
ea+";\n        int q \x3d d2 - d1 * "+ea+";\n\n        int xRCorner \x3d xRCCorner.x;\n        int xCCorner \x3d xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? \x3d to be determined. : \x3d across all values in that axis.\n        float dotProd \x3d 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR \x3d 0; wR \x3c "+te+"; wR++) {\n          int xR \x3d xRCorner + wR * "+Hd+";\n\n          if (xR \x3c 0 || xR \x3e\x3d "+
Xa+") {\n            continue;\n          }\n\n          for (int wC \x3d 0; wC \x3c "+He+"; wC++) {\n            int xC \x3d xCCorner + wC * "+$d+";\n\n            if (xC \x3c 0 || xC \x3e\x3d "+Cb+") {\n              continue;\n            }\n\n            float xVal \x3d getX(batch, xR, xC, d1);\n            float wVal \x3d getW(wR, wC, d1, q);\n            dotProd +\x3d xVal * wVal;\n          }\n        }\n\n        float result \x3d dotProd;\n        "+ia+"\n        "+ye+"\n        setOutput(result);\n      }\n    "}}(),
nf=function(){return function(ea,sa,ia,za){void 0===sa&&(sa=!1);void 0===ia&&(ia=null);void 0===za&&(za=!1);this.variableNames=["x","W"];this.packedOutput=this.packedInputs=!0;this.outputShape=ea.outShape;var Xa=ea.inHeight,Cb=ea.inWidth,gc=ea.padInfo.top,nc=ea.padInfo.left,Tc=ea.strideHeight,hd=ea.strideWidth,Hd=ea.dilationHeight,$d=ea.dilationWidth,te=ea.filterHeight,He=ea.filterWidth;ea="int xR; int xC; int xCOffset;";for(var Xd=0;Xd<te;Xd++)for(var ye=0;ye<He;ye++)ea+="\n          vec4 xTexelR"+
Xd+"C"+2*ye+" \x3d vec4(0.);\n          vec4 wR"+Xd+"C"+ye+" \x3d vec4(0.);\n          vec4 xR"+Xd+"C"+ye+" \x3d vec4(0.);";for(Xd=0;Xd<te;Xd++)for(var cg=0;cg<He;cg++){ye=2*cg;ea+="\n          xR \x3d xRCorner + "+Xd*Hd+";\n          xC \x3d xCCorner + "+ye*$d+";\n        ";if(1===hd){if(ye<He&&(ea=1===nc%2?ea+("\n                xCOffset \x3d xC + 1;\n                if(xR \x3e\x3d 0 \x26\x26 xR \x3c "+Xa+" \x26\x26 xCOffset \x3e\x3d 0 \x26\x26 xCOffset \x3c "+Cb+") {\n                  xTexelR"+
Xd+"C"+ye+" \x3d getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 \x3e\x3d "+Cb+") {\n                    xTexelR"+Xd+"C"+ye+".zw \x3d vec2(0.);\n                  }\n                } else {\n                  xTexelR"+Xd+"C"+ye+" \x3d vec4(0.);\n                }\n\n                xCOffset \x3d xC + 1 - 2;\n                if(xR \x3e\x3d 0 \x26\x26 xR \x3c "+
Xa+" \x26\x26 xCOffset \x3e\x3d 0 \x26\x26 xCOffset \x3c "+Cb+") {\n                  vec4 previous \x3d getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 \x3e\x3d "+Cb+") {\n                    previous.zw \x3d vec2(0.);\n                  }\n\n                  xR"+Xd+"C"+ye+" \x3d vec4(previous.zw, xTexelR"+Xd+"C"+ye+".xy);\n                } else {\n                  xR"+
Xd+"C"+ye+" \x3d vec4(0, 0, xTexelR"+Xd+"C"+ye+".xy);\n                }\n              "):ea+("\n                if(xR \x3e\x3d 0 \x26\x26 xR \x3c "+Xa+" \x26\x26 xC \x3e\x3d 0 \x26\x26 xC \x3c "+Cb+") {\n                  xTexelR"+Xd+"C"+ye+" \x3d getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+Xd+"C"+ye+" \x3d vec4(0.);\n                }\n\n                xR"+Xd+"C"+ye+" \x3d xTexelR"+Xd+"C"+ye+";\n              "),ye+1<He)){var Ef=0===nc%2?lc.util.nearestLargerEven($d):
$d;0===$d%2&&1===nc%2||0!==$d%2&&1!==nc%2?(ea+="\n                  xCOffset \x3d xC + "+nc%2+" + "+Ef+";\n\n                  if(xR \x3e\x3d 0 \x26\x26 xR \x3c "+Xa+" \x26\x26\n                    xCOffset \x3e\x3d 0 \x26\x26 xCOffset \x3c "+Cb+") {\n                    xTexelR"+Xd+"C"+(ye+2)+" \x3d getX(batch, xR, xCOffset, d1);\n                  }\n                ",1<$d&&(ea+="\n                    xCOffset -\x3d 2;\n                    if(xR \x3e\x3d 0 \x26\x26 xR \x3c "+Xa+" \x26\x26\n                      xCOffset \x3e\x3d 0 \x26\x26 xCOffset \x3c "+
Cb+") {\n                      xTexelR"+Xd+"C"+ye+" \x3d getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR"+Xd+"C"+ye+" \x3d vec4(0.);\n                    }\n                  "),ea+="\n                  xR"+Xd+"C"+(ye+1)+" \x3d vec4(\n                    xTexelR"+Xd+"C"+ye+".zw, xTexelR"+Xd+"C"+(ye+2)+".xy);\n                "):ea+="\n                  xCOffset \x3d xC + "+Ef+";\n\n                  if(xR \x3e\x3d 0 \x26\x26 xR \x3c "+Xa+" \x26\x26\n                    xCOffset \x3e\x3d 0 \x26\x26 xCOffset \x3c "+
Cb+") {\n                    xTexelR"+Xd+"C"+(ye+2)+" \x3d getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR"+Xd+"C"+(ye+1)+" \x3d xTexelR"+Xd+"C"+(ye+2)+";\n                "}}else ye<He&&(ea+="\n              if(xR \x3e\x3d 0 \x26\x26 xR \x3c "+Xa+") {\n            ",1===nc%2?(ea+="\n                xCOffset \x3d xC + 1 - "+hd+";\n                if(xCOffset \x3e\x3d 0 \x26\x26 xCOffset \x3c "+Cb+") {\n                  xTexelR"+Xd+"C"+ye+" \x3d getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+
Xd+"C"+ye+" \x3d vec4(0.);\n                }\n\n                if(xC + 1 \x3e\x3d 0 \x26\x26 xC + 1 \x3c "+Cb+") {\n                  xTexelR"+Xd+"C"+(ye+2)+" \x3d getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR"+Xd+"C"+(ye+2)+" \x3d vec4(0.);\n                }\n\n                xR"+Xd+"C"+ye+" \x3d vec4(\n                  xTexelR"+Xd+"C"+ye+".zw, xTexelR"+Xd+"C"+(ye+2)+".zw);\n              ",ye+1<He&&(ea+="\n                  vec4 final \x3d vec4(0.);\n                  xCOffset \x3d xC + 1 + "+
hd+";\n                  if(xCOffset \x3e\x3d 0 \x26\x26 xCOffset \x3c "+Cb+") {\n                    final \x3d getX(batch, xR, xCOffset, d1);\n                  }\n                  xR"+Xd+"C"+(ye+1)+" \x3d vec4(xTexelR"+Xd+"C"+(ye+2)+".xy, final.xy);\n                ")):(ea+="\n                if(xC \x3e\x3d 0 \x26\x26 xC \x3c "+Cb+") {\n                  xTexelR"+Xd+"C"+ye+" \x3d getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+Xd+"C"+ye+" \x3d vec4(0.);\n                }\n\n                xCOffset \x3d xC + "+
hd+";\n                if(xCOffset \x3e\x3d 0 \x26\x26 xCOffset \x3c "+Cb+") {\n                  xTexelR"+Xd+"C"+(ye+2)+" \x3d getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+Xd+"C"+(ye+2)+" \x3d vec4(0.);\n                }\n\n                xR"+Xd+"C"+ye+" \x3d vec4(\n                  xTexelR"+Xd+"C"+ye+".xy, xTexelR"+Xd+"C"+(ye+2)+".xy);\n              ",ye+1<He&&(ea+="\n                  xR"+Xd+"C"+(ye+1)+" \x3d vec4(\n                    xTexelR"+Xd+"C"+
ye+".zw, xTexelR"+Xd+"C"+(ye+2)+".zw);\n                ")),ea+="}");ye<He&&(ea+="\n            vec4 wTexelR"+Xd+"C"+ye+" \x3d getW("+Xd+", "+ye+", d1, q);\n            wR"+Xd+"C"+ye+" \x3d vec4(wTexelR"+Xd+"C"+ye+".xz, wTexelR"+Xd+"C"+ye+".xz);\n          ",ye+1<He&&(ea+="\n              vec4 wTexelR"+Xd+"C"+(ye+1)+" \x3d getW("+Xd+", "+(ye+1)+", d1, q);\n              wR"+Xd+"C"+(ye+1)+" \x3d\n                vec4(wTexelR"+Xd+"C"+(ye+1)+".xz, wTexelR"+Xd+"C"+(ye+1)+".xz);"))}for(Xd=0;Xd<te;Xd++)for(ye=
0;ye<He;ye++)ea+="dotProd +\x3d xR"+Xd+"C"+ye+" * wR"+Xd+"C"+ye+";";Cb=Xa="";ia&&(Xa=za?"vec4 activation(vec4 a) {\n          vec4 b \x3d getPreluActivationWeightsAtOutCoords();\n          "+ia+"\n        }":"vec4 activation(vec4 x) {\n          "+ia+"\n        }",Cb="result \x3d activation(result);");ia=sa?"result +\x3d getBiasAtOutCoords();":"";sa&&this.variableNames.push("bias");za&&this.variableNames.push("preluActivationWeights");this.userCode="\n      "+Xa+"\n\n      const ivec2 strides \x3d ivec2("+
Tc+", "+hd+");\n      const ivec2 pads \x3d ivec2("+gc+", "+nc+");\n\n      void main() {\n\n        ivec4 coords \x3d getOutputCoords();\n        int batch \x3d coords.x;\n        ivec2 xRCCorner \x3d coords.yz * strides - pads;\n        int d2 \x3d coords.w;\n        int d1 \x3d d2;\n        int q \x3d 0;\n        int xRCorner \x3d xRCCorner.x;\n        int xCCorner \x3d xRCCorner.y;\n\n        vec4 dotProd \x3d vec4(0.);\n\n        "+ea+"\n\n        vec4 result \x3d dotProd;\n        "+ia+"\n        "+
Cb+"\n        setOutput(result);\n      }\n    "}}(),bg=function(){return function(ea,sa,ia,za,Xa){this.variableNames=["Image","Boxes","BoxInd"];this.outputShape=[];var Cb=ea[0],gc=ea[1],nc=ea[2],Tc=ia[0];ia=ia[1];this.outputShape=[sa[0],Tc,ia,ea[3]];sa=[gc-1+".0",nc-1+".0"];ea=sa[0];sa=sa[1];gc=1<Tc?[""+(gc-1)/(Tc-1),"(y2-y1) * height_ratio","y1*"+ea+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+ea];nc=1<ia?[""+(nc-1)/(ia-1),"(x2-x1) * width_ratio","x1*"+sa+" + float(x)*(width_scale)"]:
["0.0","0.0","0.5 * (x1+x2) * "+sa];this.userCode="\n      const float height_ratio \x3d float("+gc[0]+");\n      const float width_ratio \x3d float("+nc[0]+");\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int b \x3d coords[0];\n        int y \x3d coords[1];\n        int x \x3d coords[2];\n        int d \x3d coords[3];\n\n        // get box vals\n        float y1 \x3d getBoxes(b,0);\n        float x1 \x3d getBoxes(b,1);\n        float y2 \x3d getBoxes(b,2);\n        float x2 \x3d getBoxes(b,3);\n\n        // get image in batch index\n        int bInd \x3d round(getBoxInd(b));\n        if(bInd \x3c 0 || bInd \x3e\x3d "+
Cb+") {\n          return;\n        }\n\n        float height_scale \x3d "+gc[1]+";\n        float width_scale \x3d "+nc[1]+";\n\n        float in_y \x3d "+gc[2]+";\n        if( in_y \x3c 0.0 || in_y \x3e "+ea+" ) {\n          setOutput(float("+Xa+"));\n          return;\n        }\n        float in_x \x3d "+nc[2]+";\n        if( in_x \x3c 0.0 || in_x \x3e "+sa+" ) {\n          setOutput(float("+Xa+"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR \x3d vec2(in_x,in_y);\n        if("+
("bilinear"===za?1:0)+" \x3d\x3d 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR \x3d ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR \x3d ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft \x3d getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft \x3d getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight \x3d getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight \x3d getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR \x3d sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top \x3d topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom \x3d bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue \x3d top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR \x3d ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue \x3d getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    "}}(),
Lf=function(){function ea(sa,ia,za){this.variableNames=["x"];this.outputShape=sa;var Xa=sa.length,Cb=ia?"0.0":"getX("+tb(Xa,"coords")+")";sa=sa[sa.length-1];ia?(ia=za?"end !\x3d "+(sa-1):"end !\x3d 0",za=za?"end + 1":"end - 1"):(ia=za?"end + pow2 \x3c "+sa:"end \x3e\x3d pow2",za=za?"end + pow2":"end - pow2");this.userCode="\n      uniform float index;\n      void main() {\n        "+lb(Xa)+" coords \x3d getOutputCoords();\n        int end \x3d "+bb(Xa,"coords")+";\n        float val \x3d "+Cb+";\n        int pow2 \x3d int(pow(2.0, index));\n        if ("+
ia+") {\n          int idx \x3d "+za+";\n          "+bb(Xa,"coords")+" \x3d idx;\n          val +\x3d getX("+tb(Xa,"coords")+");\n        }\n        setOutput(val);\n      }\n    "}ea.prototype.getCustomSetupFunc=function(sa){var ia=this;return function(za,Xa){null==ia.index&&(ia.index=za.getUniformLocation(Xa,"index"));za.gl.uniform1f(ia.index,sa)}};return ea}(),Wf=function(){return function(ea){this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;this.outPackingScheme=Ib.DENSE;var sa=
b(ea),ia=Va();this.outputShape=ea;this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+Ma(["r","c","d"],ea)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC \x3d ivec2(resultUV.yx *\n          vec2("+sa[0]+", "+sa[1]+"));\n        int index \x3d 4 * (resTexRC.x * "+sa[1]+" + resTexRC.y);\n\n        vec4 result \x3d vec4(0.);\n\n        for (int i\x3d0; i\x3c4; i++) {\n          int flatIndex \x3d index + i;\n          ivec3 rc \x3d outCoordsFromFlatIndex(flatIndex);\n          result[i] \x3d getA(rc.x, rc.y, rc.z);\n        }\n\n        "+
ia.output+" \x3d result;\n      }\n    "}}(),Pf=function(){return function(ea){this.variableNames=["A"];this.packedOutput=this.packedInputs=!0;this.outPackingScheme=Ib.DENSE;var sa=b(ea),ia=Va();this.outputShape=ea;this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+Ma(["r","c","d"],ea)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC \x3d ivec2(resultUV.yx *\n          vec2("+sa[0]+", "+sa[1]+"));\n        int index \x3d 4 * (resTexRC.x * "+
sa[1]+" + resTexRC.y);\n\n        vec4 result \x3d vec4(0.);\n\n        for (int i\x3d0; i\x3c4; i++) {\n          int flatIndex \x3d index + i;\n          ivec3 rc \x3d outCoordsFromFlatIndex(flatIndex);\n          result[i] \x3d getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        "+ia.output+" \x3d result;\n      }\n    "}}(),Bg=function(){function ea(sa,ia,za){this.variableNames=["x"];this.outputShape=[];this.outputShape=sa;this.blockSize=ia;this.dataFormat=za;this.userCode=
"\n    void main() {\n      ivec4 coords \x3d getOutputCoords();\n      int b \x3d coords[0];\n      int h \x3d "+this.getHeightCoordString()+";\n      int w \x3d "+this.getWidthCoordString()+";\n      int d \x3d "+this.getDepthCoordString()+";\n\n      int in_h \x3d h / "+ia+";\n      int offset_h \x3d imod(h, "+ia+");\n      int in_w \x3d w / "+ia+";\n      int offset_w \x3d imod(w, "+ia+");\n      int offset_d \x3d (offset_h * "+ia+" + offset_w) *\n        "+this.getOutputDepthSize()+";\n      int in_d \x3d d + offset_d;\n\n      float result \x3d "+
this.getInputSamplingString()+";\n      setOutput(result);\n    }\n  "}ea.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"};ea.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"};ea.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"};ea.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]};ea.prototype.getInputSamplingString=
function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"};return ea}(),Uf=function(){return function(ea){this.variableNames=["X"];this.outputShape=[ea,ea];this.userCode="\n      void main() {\n          ivec2 coords \x3d getOutputCoords();\n          float val \x3d coords[0] \x3d\x3d coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}(),Kb=function(){return function(ea){this.variableNames=["A"];this.outTexUsage=Ga.DOWNLOAD;var sa=
Va();this.outputShape=ea;this.userCode="\n      \n  const float FLOAT_MAX \x3d 1.70141184e38;\n  const float FLOAT_MIN \x3d 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av \x3d abs(v);\n\n    if(av \x3c FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v \x3e FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v \x3c -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c \x3d vec4(0,0,0,0);\n\n    highp float e \x3d floor(log2(av));\n    highp float m \x3d exp2(fract(log2(av))) - 1.0;\n\n    c[2] \x3d floor(128.0 * m);\n    m -\x3d c[2] / 128.0;\n    c[1] \x3d floor(32768.0 * m);\n    m -\x3d c[1] / 32768.0;\n    c[0] \x3d floor(8388608.0 * m);\n\n    highp float ebias \x3d e + 127.0;\n    c[3] \x3d floor(ebias / 2.0);\n    ebias -\x3d c[3] * 2.0;\n    c[2] +\x3d floor(ebias) * 128.0;\n\n    c[3] +\x3d 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n\n\n      void main() {\n        float x \x3d getAAtOutCoords();\n        "+
sa.output+" \x3d encode_float(x);\n      }\n    "}}(),ug=function(){return function(ea){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!1;this.outTexUsage=Ga.DOWNLOAD;var sa=Va();this.outputShape=ea;this.userCode="\n      \n  const float FLOAT_MAX \x3d 1.70141184e38;\n  const float FLOAT_MIN \x3d 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av \x3d abs(v);\n\n    if(av \x3c FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v \x3e FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v \x3c -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c \x3d vec4(0,0,0,0);\n\n    highp float e \x3d floor(log2(av));\n    highp float m \x3d exp2(fract(log2(av))) - 1.0;\n\n    c[2] \x3d floor(128.0 * m);\n    m -\x3d c[2] / 128.0;\n    c[1] \x3d floor(32768.0 * m);\n    m -\x3d c[1] / 32768.0;\n    c[0] \x3d floor(8388608.0 * m);\n\n    highp float ebias \x3d e + 127.0;\n    c[3] \x3d floor(ebias / 2.0);\n    ebias -\x3d c[3] * 2.0;\n    c[2] +\x3d floor(ebias) * 128.0;\n\n    c[3] +\x3d 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n\n\n      void main() {\n        ivec3 coords \x3d getOutputCoords();\n        float x \x3d getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        "+
sa.output+" \x3d encode_float(x);\n      }\n    "}}(),sf=function(){return function(ea,sa,ia){void 0===ia&&(ia=!1);this.variableNames=["A"];var za=Va(),Xa=sa[0];sa=sa[1];this.outputShape=ea;var Cb="result";ia&&(Cb="floor(result * 255. + 0.5)");this.userCode="\n      "+ib(ea)+"\n\n      void main() {\n        ivec3 coords \x3d getOutputCoords();\n\n        int flatIndex \x3d getFlatIndex(coords);\n        int offset \x3d imod(flatIndex, 4);\n\n        flatIndex \x3d idiv(flatIndex, 4, 1.);\n\n        int r \x3d flatIndex / "+
sa+";\n        int c \x3d imod(flatIndex, "+sa+");\n        vec2 uv \x3d (vec2(c, r) + halfCR) / vec2("+sa+".0, "+Xa+".0);\n        vec4 values \x3d "+za.texture2D+"(A, uv);\n\n        float result;\n\n        if(offset \x3d\x3d 0) {\n          result \x3d values[0];\n        } else if(offset \x3d\x3d 1) {\n          result \x3d values[1];\n        } else if(offset \x3d\x3d 2) {\n          result \x3d values[2];\n        } else {\n          result \x3d values[3];\n        }\n\n        "+za.output+
" \x3d vec4("+Cb+", 0., 0., 0.);\n      }\n    "}}(),Cf=function(){return function(ea,sa,ia){void 0===ia&&(ia=!1);this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;var za=Va(),Xa=sa[0];sa=sa[1];this.outputShape=ea;var Cb="",gc="result";ia&&(gc="floor(result * 255. + 0.5)");for(ia=0;1>=ia;ia++)for(var nc=0;1>=nc;nc++){var Tc=2*ia+nc;Cb+="\n          localCoords \x3d coords;\n          if(localCoords[2] + "+nc+" \x3c "+ea[2]+") {\n            localCoords[2] +\x3d "+nc+";\n            if(localCoords[1] + "+
ia+" \x3c "+ea[1]+") {\n              localCoords[1] +\x3d "+ia+";\n\n              flatIndex \x3d getFlatIndex(localCoords);\n              offset \x3d imod(flatIndex, 4);\n\n              flatIndex \x3d idiv(flatIndex, 4, 1.);\n\n              r \x3d flatIndex / "+sa+";\n              c \x3d imod(flatIndex, "+sa+");\n              uv \x3d (vec2(c, r) + halfCR) / vec2("+sa+".0, "+Xa+".0);\n              values \x3d "+za.texture2D+"(A, uv);\n\n              if(offset \x3d\x3d 0) {\n                result["+
Tc+"] \x3d values[0];\n              } else if(offset \x3d\x3d 1) {\n                result["+Tc+"] \x3d values[1];\n              } else if(offset \x3d\x3d 2) {\n                result["+Tc+"] \x3d values[2];\n              } else {\n                result["+Tc+"] \x3d values[3];\n              }\n            }\n          }\n        "}this.userCode="\n      "+ib(ea)+"\n\n      void main() {\n        ivec3 coords \x3d getOutputCoords();\n\n        vec4 result \x3d vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        "+
Cb+"\n\n        "+za.output+" \x3d "+gc+";\n      }\n    "}}(),gf=function(){function ea(sa,ia){this.outputShape=[];this.variableNames=["x"];this.outputShape=sa;this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}ea.prototype.getCustomSetupFunc=function(sa){var ia=this;return function(za,Xa){null==ia.valueLoc&&(ia.valueLoc=za.getUniformLocationNoThrow(Xa,"value"));za.gl.uniform1f(ia.valueLoc,
sa)}};return ea}(),Gf=function(){return function(ea,sa,ia){this.variableNames=["A","indices"];var za=ea.slice();za[ia]=sa;this.outputShape=za;this.rank=za.length;sa=lb(this.rank);za=ea.length;if(4<za)throw Error("Gather for rank "+za+" is not yet supported");if(1===za)ea="int(getIndices(resRC))";else{za=["resRC.x","resRC.y","resRC.z","resRC.w"];for(var Xa=[],Cb=0;Cb<ea.length;Cb++)Cb===ia?Xa.push("int(getIndices("+za[Cb]+"))"):Xa.push(""+za[Cb]);ea=Xa.join()}this.userCode="\n      void main() {\n        "+
sa+" resRC \x3d getOutputCoords();\n        setOutput(getA("+ea+"));\n      }\n    "}}(),ad=function(){return function(ea,sa,ia){this.sliceDim=ea;this.strides=sa;this.variableNames=["x","indices"];this.outputShape=ia;ea=lb(sa.length);ia=lb(ia.length);this.userCode="\n        "+ea+" strides \x3d "+ea+"("+this.strides+");\n         void main() {\n          "+ia+" coords \x3d getOutputCoords();\n          int flattenIndex \x3d 0;\n          for (int j \x3d 0; j \x3c "+this.sliceDim+"; j++) {\n            int index \x3d round(getIndices(coords[0], j));\n            flattenIndex +\x3d index * "+
(1<this.sliceDim?"strides[j]":"strides")+";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "}}(),$e={__proto__:null,createVertexShader:La,createVertexBuffer:Fb,createIndexBuffer:vb,getInternalFormatForFloat32MatrixTexture:function(ea){return ea.internalFormatFloat},createFloat32MatrixTexture:Mc,getInternalFormatForFloat16MatrixTexture:function(ea){return ea.internalFormatHalfFloat},createFloat16MatrixTexture:Yc,getInternalFormatForUnsignedBytesMatrixTexture:function(ea){return ea.downloadTextureFormat},
createUnsignedBytesMatrixTexture:yd,getInternalFormatForPackedMatrixTexture:function(ea){return ea.internalFormatPackedFloat},createPackedMatrixTexture:pd,getInternalFormatForFloat16PackedMatrixTexture:function(ea){return ea.internalFormatPackedHalfFloat},createFloat16PackedMatrixTexture:sc,bindVertexProgramAttributeStreams:tc,uploadDenseMatrixToTexture:vc,uploadPixelDataToTexture:$c,createBufferFromOutputTexture:xd,downloadFloat32MatrixFromBuffer:ab,downloadByteEncodedFloatMatrixFromOutputTexture:Ta,
downloadPackedMatrixFromBuffer:jb,downloadMatrixFromPackedOutputTexture:Wb},va=function(){function ea(sa){this.program=this.outputTexture=null;this.vertexAttrsAreBound=this.disposed=!1;this.itemsToPoll=[];var ia=lc.env().getNumber("WEBGL_VERSION");null!=sa?(this.gl=sa,rc[ia]=sa):this.gl=f(ia);sa="WEBGL_color_buffer_float";if(1===lc.env().getNumber("WEBGL_VERSION")){this.textureFloatExtension=l(this.gl,"OES_texture_float");if(ta(this.gl,"OES_texture_half_float"))this.textureHalfFloatExtension=l(this.gl,
"OES_texture_half_float");else if(lc.env().get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");this.colorBufferFloatExtension=this.gl.getExtension(sa);if(ta(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=l(this.gl,"EXT_color_buffer_half_float");else if(lc.env().get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
}else if(sa="EXT_color_buffer_float",ta(this.gl,sa))this.colorBufferFloatExtension=this.gl.getExtension(sa);else if(ta(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float");else throw Error("GL context does not support color renderable floats");this.vertexBuffer=Fb(this.gl);this.indexBuffer=vb(this.gl);this.framebuffer=J(this.gl);this.textureConfig=g(this.gl,this.textureHalfFloatExtension)}Object.defineProperty(ea.prototype,"debug",
{get:function(){return lc.env().getBool("DEBUG")},enumerable:!0,configurable:!0});ea.prototype.dispose=function(){var sa=this;if(!this.disposed){null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.");null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
var ia=this.gl;d(ia,function(){return ia.finish()});d(ia,function(){return ia.bindFramebuffer(ia.FRAMEBUFFER,null)});d(ia,function(){return ia.deleteFramebuffer(sa.framebuffer)});d(ia,function(){return ia.bindBuffer(ia.ARRAY_BUFFER,null)});d(ia,function(){return ia.bindBuffer(ia.ELEMENT_ARRAY_BUFFER,null)});d(ia,function(){return ia.deleteBuffer(sa.indexBuffer)});this.disposed=!0}};ea.prototype.createFloat32MatrixTexture=function(sa,ia){this.throwIfDisposed();return Mc(this.gl,sa,ia,this.textureConfig)};
ea.prototype.createFloat16MatrixTexture=function(sa,ia){this.throwIfDisposed();return Yc(this.gl,sa,ia,this.textureConfig)};ea.prototype.createUnsignedBytesMatrixTexture=function(sa,ia){this.throwIfDisposed();return yd(this.gl,sa,ia,this.textureConfig)};ea.prototype.uploadPixelDataToTexture=function(sa,ia){this.throwIfDisposed();$c(this.gl,sa,ia)};ea.prototype.uploadDenseMatrixToTexture=function(sa,ia,za,Xa){this.throwIfDisposed();vc(this.gl,sa,ia,za,Xa,this.textureConfig)};ea.prototype.createFloat16PackedMatrixTexture=
function(sa,ia){this.throwIfDisposed();return sc(this.gl,sa,ia,this.textureConfig)};ea.prototype.createPackedMatrixTexture=function(sa,ia){this.throwIfDisposed();return pd(this.gl,sa,ia,this.textureConfig)};ea.prototype.deleteMatrixTexture=function(sa){var ia=this;this.throwIfDisposed();this.outputTexture===sa&&(F(this.gl,this.framebuffer),this.outputTexture=null);d(this.gl,function(){return ia.gl.deleteTexture(sa)})};ea.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(sa,ia,za){var Xa=
this;return this.downloadMatrixDriver(sa,function(){return Ta(Xa.gl,ia,za,Xa.textureConfig)})};ea.prototype.downloadPackedMatrixFromBuffer=function(sa,ia,za,Xa,Cb,gc){return jb(this.gl,sa,ia,za,Xa,Cb,gc,this.textureConfig)};ea.prototype.downloadFloat32MatrixFromBuffer=function(sa,ia){return ab(this.gl,sa,ia)};ea.prototype.createBufferFromTexture=function(sa,ia,za){this.bindTextureToFrameBuffer(sa);sa=xd(this.gl,ia,za,this.textureConfig);this.unbindTextureToFrameBuffer();return sa};ea.prototype.createAndWaitForFence=
function(){var sa=this.createFence(this.gl);return this.pollFence(sa)};ea.prototype.createFence=function(sa){var ia=this;if(lc.env().getBool("WEBGL_FENCE_API_ENABLED")){var za=sa.fenceSync(sa.SYNC_GPU_COMMANDS_COMPLETE,0);sa.flush();var Xa=function(){var gc=sa.clientWaitSync(za,0,0);return gc===sa.ALREADY_SIGNALED||gc===sa.CONDITION_SATISFIED};var Cb=za}else 0<lc.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?(Cb=this.beginQuery(),this.endQuery(),Xa=function(){return ia.isQueryAvailable(Cb,
lc.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):Xa=function(){return!0};return{query:Cb,isFencePassed:Xa}};ea.prototype.downloadMatrixFromPackedTexture=function(sa,ia,za){var Xa=this;return this.downloadMatrixDriver(sa,function(){return Wb(Xa.gl,ia,za)})};ea.prototype.createProgram=function(sa){this.throwIfDisposed();var ia=this.gl,za=n(ia,sa),Xa=La(ia),Cb=p(ia);d(ia,function(){return ia.attachShader(Cb,Xa)});d(ia,function(){return ia.attachShader(Cb,za)});q(ia,Cb);this.debug&&
w(ia,Cb);this.vertexAttrsAreBound||(this.setProgram(Cb),this.vertexAttrsAreBound=tc(ia,this.program,this.vertexBuffer));return Cb};ea.prototype.deleteProgram=function(sa){var ia=this;this.throwIfDisposed();sa===this.program&&(this.program=null);null!=sa&&d(this.gl,function(){return ia.gl.deleteProgram(sa)})};ea.prototype.setProgram=function(sa){var ia=this;this.throwIfDisposed();this.program=sa;null!=this.program&&this.debug&&w(this.gl,this.program);d(this.gl,function(){return ia.gl.useProgram(sa)})};
ea.prototype.getUniformLocation=function(sa,ia,za){void 0===za&&(za=!0);this.throwIfDisposed();return za?Q(this.gl,sa,ia):this.gl.getUniformLocation(sa,ia)};ea.prototype.getAttributeLocation=function(sa,ia){var za=this;this.throwIfDisposed();return d(this.gl,function(){return za.gl.getAttribLocation(sa,ia)})};ea.prototype.getUniformLocationNoThrow=function(sa,ia){this.throwIfDisposed();return this.gl.getUniformLocation(sa,ia)};ea.prototype.setInputMatrixTexture=function(sa,ia,za){this.throwIfDisposed();
this.throwIfNoProgram();V(this.gl,sa,ia,za)};ea.prototype.setOutputMatrixTexture=function(sa,ia,za){this.setOutputMatrixTextureDriver(sa,za,ia)};ea.prototype.setOutputPackedMatrixTexture=function(sa,ia,za){this.throwIfDisposed();ia=e(ia,za);this.setOutputMatrixTextureDriver(sa,ia[0],ia[1])};ea.prototype.setOutputMatrixWriteRegion=function(sa,ia,za,Xa){this.setOutputMatrixWriteRegionDriver(za,sa,Xa,ia)};ea.prototype.setOutputPackedMatrixWriteRegion=function(sa,ia,za,Xa){throw Error("setOutputPackedMatrixWriteRegion not implemented.");
};ea.prototype.debugValidate=function(){null!=this.program&&w(this.gl,this.program);D(this.gl)};ea.prototype.executeProgram=function(){this.throwIfDisposed();this.throwIfNoProgram();var sa=this.gl;this.debug&&this.debugValidate();d(sa,function(){return sa.drawElements(sa.TRIANGLES,6,sa.UNSIGNED_SHORT,0)})};ea.prototype.blockUntilAllProgramsCompleted=function(){var sa=this;this.throwIfDisposed();d(this.gl,function(){return sa.gl.finish()})};ea.prototype.getQueryTimerExtension=function(){null==this.disjointQueryTimerExtension&&
(this.disjointQueryTimerExtension=l(this.gl,2===lc.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query"));return this.disjointQueryTimerExtension};ea.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()};ea.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()};ea.prototype.beginQuery=function(){if(2===lc.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var sa=
this.gl,ia=this.getQueryTimerExtensionWebGL2(),za=sa.createQuery();sa.beginQuery(ia.TIME_ELAPSED_EXT,za);return za}sa=this.getQueryTimerExtensionWebGL1();ia=sa.createQueryEXT();sa.beginQueryEXT(sa.TIME_ELAPSED_EXT,ia);return ia};ea.prototype.endQuery=function(){if(2===lc.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var sa=this.gl,ia=this.getQueryTimerExtensionWebGL2();sa.endQuery(ia.TIME_ELAPSED_EXT)}else sa=this.getQueryTimerExtensionWebGL1(),sa.endQueryEXT(sa.TIME_ELAPSED_EXT)};
ea.prototype.waitForQueryAndGetTime=function(sa){return r(this,void 0,void 0,function(){var ia=this;return u(this,function(za){switch(za.label){case 0:return[4,lc.util.repeatedTry(function(){return ia.disposed||ia.isQueryAvailable(sa,lc.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})];case 1:return za.sent(),[2,this.getQueryTime(sa,lc.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]}})})};ea.prototype.getQueryTime=function(sa,ia){if(0===ia)return null;2===ia?(ia=
this.gl,sa=ia.getQueryParameter(sa,ia.QUERY_RESULT)):(ia=this.getQueryTimerExtensionWebGL1(),sa=ia.getQueryObjectEXT(sa,ia.QUERY_RESULT_EXT));return sa/1E6};ea.prototype.isQueryAvailable=function(sa,ia){if(0===ia)return!0;if(2===ia){var za=this.gl;ia=this.getQueryTimerExtensionWebGL2();sa=za.getQueryParameter(sa,za.QUERY_RESULT_AVAILABLE)}else ia=this.getQueryTimerExtensionWebGL1(),sa=ia.getQueryObjectEXT(sa,ia.QUERY_RESULT_AVAILABLE_EXT);null==this.disjoint&&(this.disjoint=this.gl.getParameter(ia.GPU_DISJOINT_EXT));
return sa&&!this.disjoint};ea.prototype.pollFence=function(sa){var ia=this;return new Promise(function(za){ia.addItemToPoll(function(){return sa.isFencePassed()},function(){return za()})})};ea.prototype.pollItems=function(){for(var sa=xc(this.itemsToPoll.map(function(Xa){return Xa.isDoneFn})),ia=0;ia<=sa;++ia){var za=this.itemsToPoll[ia].resolveFn;za()}this.itemsToPoll=this.itemsToPoll.slice(sa+1)};ea.prototype.addItemToPoll=function(sa,ia){var za=this;this.itemsToPoll.push({isDoneFn:sa,resolveFn:ia});
1<this.itemsToPoll.length||lc.util.repeatedTry(function(){za.pollItems();return 0===za.itemsToPoll.length})};ea.prototype.bindTextureToFrameBuffer=function(sa){this.throwIfDisposed();M(this.gl,sa,this.framebuffer);this.debug&&D(this.gl)};ea.prototype.unbindTextureToFrameBuffer=function(){null!=this.outputTexture?(M(this.gl,this.outputTexture,this.framebuffer),this.debug&&D(this.gl)):F(this.gl,this.framebuffer)};ea.prototype.downloadMatrixDriver=function(sa,ia){this.bindTextureToFrameBuffer(sa);sa=
ia();this.unbindTextureToFrameBuffer();return sa};ea.prototype.setOutputMatrixTextureDriver=function(sa,ia,za){this.throwIfDisposed();var Xa=this.gl;M(Xa,sa,this.framebuffer);this.debug&&D(Xa);this.outputTexture=sa;d(Xa,function(){return Xa.viewport(0,0,ia,za)});d(Xa,function(){return Xa.scissor(0,0,ia,za)})};ea.prototype.setOutputMatrixWriteRegionDriver=function(sa,ia,za,Xa){var Cb=this;this.throwIfDisposed();d(this.gl,function(){return Cb.gl.scissor(sa,ia,za,Xa)})};ea.prototype.throwIfDisposed=
function(){if(this.disposed)throw Error("Attempted to use disposed GPGPUContext.");};ea.prototype.throwIfNoProgram=function(){if(null==this.program)throw Error("No GPU program is currently set.");};return ea}(),eb=function(){return function(ea,sa,ia){this.variableNames=["A"];this.packedOutput=this.packedInputs=!0;this.outputShape=ea;var za=ia.inChannels,Xa=ia.strideWidth,Cb=ia.strideHeight,gc=ia.padInfo,nc=ia.outWidth,Tc=ia.dilationWidth,hd=ia.dilationHeight,Hd=ia.dataFormat,$d=gc.left;gc=gc.top;
ia=za*ia.filterWidth;for(var te=Va(),He=(Hd="channelsLast"===Hd)?0:1,Xd=Hd?1:2,ye="",cg=0;1>=cg;cg++)for(var Ef=0;1>=Ef;Ef++)ye+="\n          blockIndex \x3d rc.y + "+Ef+";\n          pos \x3d rc.x + "+cg+";\n\n          if(blockIndex \x3c "+ea[1]+" \x26\x26 pos \x3c "+ea[0]+") {\n            offsetY \x3d int(blockIndex / ("+nc+")) * "+Cb+" - "+gc+";\n            d0 \x3d offsetY + "+hd+" * (pos / "+ia+");\n\n            if(d0 \x3c "+sa[He]+" \x26\x26 d0 \x3e\x3d 0) {\n\n              offsetX \x3d int(mod(float(blockIndex), "+
nc+".) * "+Xa+". - "+$d+".);\n              d1 \x3d offsetX + "+Tc+" * (int(mod(float(pos), "+ia+".) / "+za+".));\n\n              if(d1 \x3c "+sa[Xd]+" \x26\x26 d1 \x3e\x3d 0) {\n\n                ch \x3d int(mod(float(pos), "+za+".));\n\n                if ("+Hd+") {\n                  innerDims \x3d vec2(d1, ch);\n                  result["+(2*cg+Ef)+"] \x3d getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims \x3d vec2(d0, d1);\n                  result["+
(2*cg+Ef)+"] \x3d getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";this.userCode="\n      void main() {\n        ivec2 rc \x3d getOutputCoords();\n\n        vec4 result \x3d vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        "+ye+"\n\n        "+te.output+" \x3d result;\n      }\n    "}}(),ub=function(){return function(ea,
sa,ia,za,Xa){this.variableNames=["x"];this.outputShape=[];var Cb=ea[3]-1;this.outputShape=ea;ea="float("+ia+") + float("+za+") * sum";this.userCode="\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int b \x3d coords[0];\n        int r \x3d coords[1];\n        int c \x3d coords[2];\n        int d \x3d coords[3];\n        float x \x3d getX(b, r, c, d);\n        float sum \x3d 0.0;\n        for (int j \x3d -"+sa+"; j \x3c\x3d "+sa+"; j++) {\n          int idx \x3d d + j;\n          if (idx \x3e\x3d 0 \x26\x26 idx \x3c\x3d  "+
Cb+") {\n            float z \x3d getX(b, r, c, idx);\n            sum +\x3d z * z;\n          }\n        }\n        float val \x3d x * "+(.5===Xa?"inversesqrt("+ea+")":1===Xa?"1.0/("+ea+")":"exp(log("+ea+") * float(-"+Xa+"));")+";\n        setOutput(val);\n      }\n    "}}(),pb=function(){return function(ea,sa,ia,za,Xa){this.variableNames=["inputImage","outputImage","dy"];this.outputShape=[];this.outputShape=ea;this.depth=ea[3];this.depthRadius=sa;this.bias=ia;this.alpha=za;this.beta=Xa;this.userCode=
"\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int b \x3d coords[0];\n        int r \x3d coords[1];\n        int c \x3d coords[2];\n\n        float result \x3d 0.0;\n        for (int d \x3d 0; d \x3c "+this.depth+"; ++d) {\n          int depthBegin \x3d int(max(0.0, float(d - "+sa+")));\n          int depthEnd \x3d int(min(float("+this.depth+"),\n              float(d + "+sa+" + 1)));\n\n          const int MIN_DEPTH_BEGIN \x3d 0;\n          const int MAX_DEPTH_END \x3d "+
this.depth+";\n\n          float norm \x3d 0.0;\n          for (int k \x3d MIN_DEPTH_BEGIN; k \x3c MAX_DEPTH_END; ++k) {\n            if (k \x3c depthBegin){\n              continue;\n            }\n            else if (k \x3e\x3d depthBegin \x26\x26 k \x3c depthEnd) {\n              norm +\x3d getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm \x3d float("+za+") * norm + float("+ia+");\n\n          for(int k \x3d MIN_DEPTH_BEGIN; k \x3c MAX_DEPTH_END; ++k){\n            if (k \x3c depthBegin){\n              continue;\n            }\n            else if (k \x3e\x3d depthBegin \x26\x26 k \x3c depthEnd){\n              float dyi \x3d -2.0 * float("+
za+")\n                * float("+Xa+")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k \x3d\x3d d) {\n                dyi +\x3d pow(norm, -1.0 * "+Xa+");\n              }\n              if (k \x3d\x3d coords[3]) {\n                dyi *\x3d getDy(b, r, c, d);\n                result +\x3d dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "}}(),
Ea=function(){return function(ea,sa,ia,za,Xa){this.variableNames=["x"];this.outputShape=[];this.packedOutput=this.packedInputs=!0;var Cb=ea[3]-1;this.outputShape=ea;ea="float("+ia+") + float("+za+") * sum";this.userCode="\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int b \x3d coords.x;\n        int r \x3d coords.y;\n        int c \x3d coords.z;\n        int d \x3d coords.w;\n\n        bool hasNextCol \x3d d \x3c "+this.outputShape[3]+";\n        bool hasNextRow \x3d c \x3c "+
this.outputShape[2]+";\n\n        vec4 sum \x3d vec4(0.);\n        vec4 xFragAtOutputCoords \x3d getX(b, r, c, d);\n\n        vec4 xAtOutputCoords \x3d vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow \x26\x26 hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel \x3d d - "+
sa+";\n        vec2 cache \x3d vec2(0.);\n        if(firstChannel \x3e\x3d 0){\n          vec4 firstChannelFrag \x3d getX(b, r, c, firstChannel);\n          cache.x \x3d getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y \x3d getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth \x3d ivec2(d, d + 1);\n        for (int j \x3d - "+sa+"; j \x3c\x3d "+sa+"; j++) {\n          ivec2 idx \x3d depth + j;\n          bvec2 aboveLowerBound \x3d greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound \x3d lessThanEqual(idx, ivec2("+
Cb+"));\n\n          bool depthInRange \x3d aboveLowerBound.x \x26\x26 belowUpperBound.x;\n          bool depthPlusOneInRange \x3d aboveLowerBound.y \x26\x26 belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z \x3d vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz \x3d cache.xy;\n            if(depthPlusOneInRange \x26\x26 hasNextCol){\n              xFragAtCurrentDepth \x3d idx.y !\x3d d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y \x3d getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w \x3d getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy \x3d z.yw;\n            sum +\x3d z * z;\n          }\n        }\n        vec4 result \x3d xAtOutputCoords * "+
(.5===Xa?"inversesqrt("+ea+")":1===Xa?"1.0/("+ea+")":"exp(log("+ea+") * float(-"+Xa+"));")+";\n        setOutput(result);\n      }\n    "}}(),db=function(){return function(ea){this.variableNames=["dy","maxPos"];this.outputShape=ea.inShape;var sa=ea.effectiveFilterHeight,ia=ea.effectiveFilterWidth;this.userCode="\n      const ivec2 pads \x3d ivec2("+(sa-1-ea.padInfo.top)+", "+(ia-1-ea.padInfo.left)+");\n\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int b \x3d coords[0];\n        int d \x3d coords[3];\n\n        ivec2 dyRCCorner \x3d coords.yz - pads;\n        int dyRCorner \x3d dyRCCorner.x;\n        int dyCCorner \x3d dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? \x3d to be determined. : \x3d across all values in that axis.\n        float dotProd \x3d 0.0;\n        for (int wR \x3d 0; wR \x3c "+
sa+";\n          wR +\x3d "+ea.dilationHeight+") {\n          float dyR \x3d float(dyRCorner + wR) / "+ea.strideHeight+".0;\n\n          if (dyR \x3c 0.0 || dyR \x3e\x3d "+ea.outHeight+".0 || fract(dyR) \x3e 0.0) {\n            continue;\n          }\n          int idyR \x3d int(dyR);\n\n          for (int wC \x3d 0; wC \x3c "+ia+"; wC++) {\n            float dyC \x3d float(dyCCorner + wC) / "+ea.strideWidth+".0;\n\n            if (dyC \x3c 0.0 || dyC \x3e\x3d "+ea.outWidth+".0 ||\n                fract(dyC) \x3e 0.0) {\n              continue;\n            }\n            int idyC \x3d int(dyC);\n\n            float dyValue \x3d getDy(b, idyR, idyC, d);\n            int maxPosValue \x3d "+
(sa*ia-1)+" - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue \x3d wR * "+ia+" + wC;\n            float mask \x3d float(maxPosValue \x3d\x3d curPosValue ? 1.0 : 0.0);\n\n            dotProd +\x3d dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),fb=function(){return function(ea){this.variableNames=["dy","maxPos"];this.outputShape=ea.inShape;
var sa=ea.effectiveFilterDepth,ia=ea.effectiveFilterHeight,za=ea.effectiveFilterWidth;this.userCode="\n      const ivec3 pads \x3d ivec3("+(sa-1-ea.padInfo.front)+", "+(ia-1-ea.padInfo.top)+", "+(za-1-ea.padInfo.left)+");\n\n      void main() {\n        ivec5 coords \x3d getOutputCoords();\n        int batch \x3d coords.x;\n        int ch \x3d coords.u;\n\n        ivec3 dyCorner \x3d ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner \x3d dyCorner.x;\n        int dyRCorner \x3d dyCorner.y;\n        int dyCCorner \x3d dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? \x3d to be determined. : \x3d across all values in that axis.\n        float dotProd \x3d 0.0;\n\n        for (int wD \x3d 0; wD \x3c "+
sa+";\n           wD +\x3d "+ea.dilationDepth+") {\n          float dyD \x3d float(dyDCorner + wD) / "+ea.strideDepth+".0;\n\n          if (dyD \x3c 0.0 || dyD \x3e\x3d "+ea.outDepth+".0 || fract(dyD) \x3e 0.0) {\n            continue;\n          }\n          int idyD \x3d int(dyD);\n\n          for (int wR \x3d 0; wR \x3c "+ia+";\n              wR +\x3d "+ea.dilationHeight+") {\n            float dyR \x3d float(dyRCorner + wR) / "+ea.strideHeight+".0;\n\n            if (dyR \x3c 0.0 || dyR \x3e\x3d "+
ea.outHeight+".0 ||\n                fract(dyR) \x3e 0.0) {\n              continue;\n            }\n            int idyR \x3d int(dyR);\n\n            for (int wC \x3d 0; wC \x3c "+za+";\n                wC +\x3d "+ea.dilationWidth+") {\n              float dyC \x3d float(dyCCorner + wC) / "+ea.strideWidth+".0;\n\n              if (dyC \x3c 0.0 || dyC \x3e\x3d "+ea.outWidth+".0 ||\n                  fract(dyC) \x3e 0.0) {\n                continue;\n              }\n              int idyC \x3d int(dyC);\n\n              float dyValue \x3d getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue \x3d "+
(sa*ia*za-1)+" -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue \x3d\n                  wD * "+ia+" * "+za+" +\n                  wR * "+za+" + wC;\n              float mask \x3d float(maxPosValue \x3d\x3d curPosValue ? 1.0 : 0.0);\n\n              dotProd +\x3d dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),
Gb=function(){return function(ea,sa,ia,za,Xa,Cb,gc,nc){void 0===za&&(za=!1);void 0===Xa&&(Xa=!1);void 0===Cb&&(Cb=!1);void 0===gc&&(gc=null);void 0===nc&&(nc=!1);this.variableNames=["matrixA","matrixB"];this.packedOutput=this.packedInputs=!0;this.outputShape=ia;ia=Math.ceil((za?ea[1]:ea[2])/2);var Tc=za?"i * 2, rc.y":"rc.y, i * 2",hd=Xa?"rc.z, i * 2":"i * 2, rc.z";za=za?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"];Xa=Xa?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];var Hd="",$d="";gc&&(Hd=nc?"vec4 activation(vec4 a) {\n          vec4 b \x3d getPreluActivationWeightsAtOutCoords();\n          "+
gc+"\n        }":"vec4 activation(vec4 x) {\n          "+gc+"\n        }",$d="result \x3d activation(result);");gc=Cb?"result +\x3d getBiasAtOutCoords();":"";Cb&&this.variableNames.push("bias");nc&&this.variableNames.push("preluActivationWeights");nc=Cb="rc.x";ea[0]<sa[0]?Cb="int(min(float(rc.x), "+(ea[0]-1)+".))":sa[0]<ea[0]&&(nc="int(min(float(rc.x), "+(sa[0]-1)+".))");this.userCode="\n      "+Hd+"\n\n      const float sharedDimension \x3d "+ia+".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result \x3d vec4(0);\n        for (int i \x3d 0; i \x3c "+
ia+"; i++) {\n          int batchA \x3d "+Cb+";\n          int batchB \x3d "+nc+";\n          vec4 a \x3d getMatrixA(batchA, "+Tc+");\n          vec4 b \x3d getMatrixB(batchB, "+hd+");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result +\x3d ("+za[0]+" * "+Xa[0]+");\n          result +\x3d ("+za[1]+" * "+Xa[1]+");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc \x3d getOutputCoords();\n        vec4 result \x3d dot2x2ARowBCol(rc);\n\n        "+
gc+"\n\n        "+$d+"\n\n        setOutput(result);\n      }\n    "}}(),Vb=function(){function ea(sa,ia,za){this.variableNames=["probs"];this.outputShape=[sa,za];this.userCode="\n      uniform float seed;\n\n      void main() {\n        ivec2 coords \x3d getOutputCoords();\n        int batch \x3d coords[0];\n\n        float r \x3d random(seed);\n        float cdf \x3d 0.0;\n\n        for (int i \x3d 0; i \x3c "+(ia-1)+"; i++) {\n          cdf +\x3d getProbs(batch, i);\n\n          if (r \x3c cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float("+
(ia-1)+"));\n      }\n    "}ea.prototype.getCustomSetupFunc=function(sa){var ia=this;return function(za,Xa){null==ia.seedLoc&&(ia.seedLoc=za.getUniformLocation(Xa,"seed"));za.gl.uniform1f(ia.seedLoc,sa)}};return ea}(),Hc=function(){return function(ea,sa,ia,za){this.variableNames=["indices"];this.outputShape=[ea,sa];this.userCode="\n      void main() {\n        ivec2 coords \x3d getOutputCoords();\n        int index \x3d round(getIndices(coords.x));\n        setOutput(mix(float("+za+"), float("+ia+
"),\n                      float(index \x3d\x3d coords.y)));\n      }\n    "}}(),md=function(){return function(ea){this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;this.outputShape=ea;var sa=ea.length;if(0===sa)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{var ia=gb("rc",sa),za=lb(sa);if(1===sa)var Xa="rc \x3e "+ea[0];else{Xa="";for(var Cb=sa-2;Cb<sa;Cb++)Xa+=ia[Cb]+" \x3e\x3d "+ea[Cb],Cb<sa-1&&(Xa+="||")}Cb=ea[ea.length-
1];var gc=ea[ea.length-2];1===sa?sa="":(sa=ia.slice(-2),sa="\n    int r \x3d "+sa[0]+";\n    int c \x3d "+sa[1]+";\n    int rp1 \x3d r + 1;\n    int cp1 \x3d c + 1;\n\n    bool cEdge \x3d cp1 \x3e\x3d "+Cb+";\n    bool rEdge \x3d rp1 \x3e\x3d "+gc+";\n  ");Cb=ea.length;gc=[];for(var nc=0;1>=nc;nc++)for(var Tc=0;1>=Tc;Tc++){for(var hd=(0===nc?"r":"rp1")+", "+(0===Tc?"c":"cp1"),Hd=2;Hd<Cb;Hd++)hd=ia[ia.length-1-Hd]+","+hd;gc.push(hd)}ea=1===Cb?"getA(rc),\n            rc + 1 \x3e\x3d "+ea[0]+" ? 0. : getA(rc + 1),\n            0, 0":
"getA("+gc[0]+"),\n          cEdge ? 0. : getA("+gc[1]+"),\n          rEdge ? 0. : getA("+gc[2]+"),\n          rEdge || cEdge ? 0. : getA("+gc[3]+")";this.userCode="\n        void main() {\n          "+za+" rc \x3d getOutputCoords();\n\n          if("+Xa+") {\n            setOutput(vec4(0));\n          } else {\n            "+sa+"\n\n            setOutput(vec4("+ea+"));\n          }\n        }\n      "}}}(),Cd=function(){return function(ea,sa,ia){this.variableNames=["x"];this.outputShape=sa.map(function(nc,
Tc){return nc[0]+ea[Tc]+nc[1]});var za=ea.length,Xa=lb(za),Cb=sa.map(function(nc){return nc[0]}).join(",");sa=sa.map(function(nc,Tc){return nc[0]+ea[Tc]}).join(",");var gc=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,za);this.userCode=1===za?"\n        int start \x3d "+Cb+";\n        int end \x3d "+sa+";\n\n        void main() {\n          int outC \x3d getOutputCoords();\n          if (outC \x3c start || outC \x3e\x3d end) {\n            setOutput(float("+ia+"));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ":
"\n      "+Xa+" start \x3d "+Xa+"("+Cb+");\n      "+Xa+" end \x3d "+Xa+"("+sa+");\n\n      void main() {\n        "+Xa+" outC \x3d getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float("+ia+"));\n        } else {\n          "+Xa+" coords \x3d outC - start;\n          setOutput(getX("+gc+"));\n        }\n      }\n    "}}(),ae=function(){return function(ea,sa,ia){this.variableNames=["x"];this.packedOutput=this.packedInputs=!0;this.outputShape=
sa.map(function(He,Xd){return He[0]+ea[Xd]+He[1]});var za=ea.length,Xa=lb(za),Cb=sa.map(function(He){return He[0]}).join(",");sa=sa.map(function(He,Xd){return He[0]+ea[Xd]}).join(",");var gc=gb("rc",za),nc=gb("source",za),Tc=gc[za-1]+" \x3c "+this.outputShape[za-1],hd=1===za?"source":"vec2("+nc.slice(-2).join()+")";gc=[Xa+" rc \x3d outputLoc;",gc[za-1]+" +\x3d 1;\n       if("+Tc+") {\n      ",1===za?"":"}\n       rc \x3d outputLoc;\n       "+gc[za-2]+" +\x3d 1;\n       if("+gc[za-2]+" \x3c "+this.outputShape[za-
2]+") {",1===za?"":"  "+gc[za-1]+" +\x3d 1;\n         if("+Tc+") {"];Tc=1===za?"rc \x3c start || rc \x3e\x3d end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";for(var Hd="",$d=0,te=1===za?2:4;$d<te;$d++)Hd+="\n        "+gc[$d]+"\n        if ("+Tc+") {\n          result["+$d+"] \x3d float("+ia+");\n        } else {\n          "+Xa+" source \x3d rc - start;\n          result["+$d+"] \x3d getChannel(getX("+nc.join()+"), "+hd+");\n        }\n      ";this.userCode="\n      const "+Xa+" start \x3d "+
Xa+"("+Cb+");\n      const "+Xa+" end \x3d "+Xa+"("+sa+");\n\n      void main() {\n        "+Xa+" outputLoc \x3d getOutputCoords();\n        vec4 result \x3d vec4(0.);\n        "+(Hd+(1===za?"} ":"}}"))+"\n        setOutput(result);\n      }\n    "}}(),ze=function(){return function(ea,sa,ia,za,Xa){void 0===za&&(za=!1);void 0===Xa&&(Xa=!1);this.variableNames=["x"];if("avg"===sa&&ia)throw Error("Cannot compute positions for average pool.");var Cb=ea.filterWidth,gc=ea.strideHeight,nc=ea.strideWidth,
Tc=ea.dilationHeight,hd=ea.dilationWidth,Hd=ea.effectiveFilterHeight,$d=ea.effectiveFilterWidth,te=ea.padInfo.top,He=ea.padInfo.left;this.outputShape=ea.outShape;var Xd="avg"===sa,ye="((batch  * "+ea.inHeight+" + xR) * "+ea.inWidth+" + xC) * "+ea.inChannels+" + d",cg="(xR * "+ea.inWidth+" + xC) * "+ea.inChannels+" + d",Ef="0.0";Xd||(Ef="-1.0 / 1e-20");ia?this.userCode="\n        const ivec2 strides \x3d ivec2("+gc+", "+nc+");\n        const ivec2 pads \x3d ivec2("+te+", "+He+");\n\n        void main() {\n          ivec4 coords \x3d getOutputCoords();\n          int batch \x3d coords[0];\n          int d \x3d coords[3];\n\n          ivec2 xRCCorner \x3d coords.yz * strides - pads;\n          int xRCorner \x3d xRCCorner.x;\n          int xCCorner \x3d xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? \x3d to be determined\n          float minMaxValue \x3d 0.0;\n          float minMaxValueFound \x3d 0.0;\n          int minMaxPosition \x3d 0;\n          float avgValue \x3d 0.0;\n\n          for (int wR \x3d 0; wR \x3c "+
Hd+";\n              wR +\x3d "+Tc+") {\n            int xR \x3d xRCorner + wR;\n\n            if (xR \x3c 0 || xR \x3e\x3d "+ea.inHeight+") {\n              continue;\n            }\n\n            for (int wC \x3d 0; wC \x3c "+$d+";\n                wC +\x3d "+hd+") {\n              int xC \x3d xCCorner + wC;\n\n              if (xC \x3c 0 || xC \x3e\x3d "+ea.inWidth+") {\n                continue;\n              }\n\n              float value \x3d getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue \x3d mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value \x3e\x3d currMinMaxValue) {\n                minMaxValue \x3d value;\n                minMaxValueFound \x3d 1.0;\n                minMaxPosition \x3d "+
(za?Xa?ye:cg:"wR * "+$d+" + wC")+";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ":(ia=sa+"("+sa+"("+sa+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])","avg"===sa&&(ia="avgValue / count"),sa=4*Math.floor(Cb/4),Cb%=4,Xd="\n      if ("+Xd+") {\n        avgValue +\x3d dot(values, ones);\n      } else {\n        minMaxValue \x3d max(values, minMaxValue);\n      }\n    ",this.userCode="\n      const ivec2 strides \x3d ivec2("+
gc+", "+nc+");\n      const ivec2 pads \x3d ivec2("+te+", "+He+");\n      const float initializationValue \x3d "+Ef+";\n      const vec4 ones \x3d vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count \x3d 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC \x3c 0 || xC \x3e\x3d "+ea.inWidth+") {\n          return initializationValue;\n        }\n        count +\x3d 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int batch \x3d coords[0];\n        int d \x3d coords[3];\n\n        ivec2 xRCCorner \x3d coords.yz * strides - pads;\n        int xRCorner \x3d xRCCorner.x;\n        int xCCorner \x3d xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? \x3d to be determined\n        vec4 minMaxValue \x3d vec4("+
Ef+");\n        float avgValue \x3d 0.0;\n        count \x3d 0.0;\n\n        for (int wR \x3d 0; wR \x3c "+Hd+";\n            wR +\x3d "+Tc+") {\n          int xR \x3d xRCorner + wR;\n\n          if (xR \x3c 0 || xR \x3e\x3d "+ea.inHeight+") {\n            continue;\n          }\n\n          for (int wC \x3d 0; wC \x3c "+sa+"; wC +\x3d 4) {\n            int xC \x3d xCCorner + wC * "+hd+";\n\n            vec4 values \x3d vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+
hd+", d),\n              getValue(batch, xR, xC + 2 * "+hd+", d),\n              getValue(batch, xR, xC + 3 * "+hd+", d)\n            );\n\n            "+Xd+"\n          }\n\n          int xC \x3d xCCorner + "+sa+";\n          if ("+(1===Cb)+") {\n            vec4 values \x3d vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            "+Xd+"\n          } else if ("+(2===Cb)+
") {\n            vec4 values \x3d vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+hd+", d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+Xd+"\n          } else if ("+(3===Cb)+") {\n            vec4 values \x3d vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+hd+", d),\n              getValue(batch, xR, xC + 2 * "+hd+", d),\n              initializationValue\n            );\n\n            "+
Xd+"\n          }\n        }\n        setOutput("+ia+");\n      }\n    ")}}(),ef=function(){return function(ea,sa,ia,za,Xa){void 0===za&&(za=!1);void 0===Xa&&(Xa=!1);this.variableNames=["x"];if("avg"===sa&&ia)throw Error("Cannot compute positions for average pool.");var Cb=ea.filterWidth,gc=ea.strideDepth,nc=ea.strideHeight,Tc=ea.strideWidth,hd=ea.dilationDepth,Hd=ea.dilationHeight,$d=ea.dilationWidth,te=ea.effectiveFilterDepth,He=ea.effectiveFilterHeight,Xd=ea.effectiveFilterWidth,ye=ea.padInfo.front,
cg=ea.padInfo.top,Ef=ea.padInfo.left;this.outputShape=ea.outShape;var Hg="avg"===sa,jg="0.0";Hg||(jg="-1.0 / 1e-20");ia?this.userCode="\n        const ivec3 strides \x3d\n            ivec3("+gc+", "+nc+", "+Tc+");\n        const ivec3 pads \x3d ivec3("+ye+", "+cg+", "+Ef+");\n\n        void main() {\n          ivec5 coords \x3d getOutputCoords();\n          int batch \x3d coords.x;\n          int ch \x3d coords.u;\n\n          ivec3 xCorner \x3d ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner \x3d xCorner.x;\n          int xRCorner \x3d xCorner.y;\n          int xCCorner \x3d xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? \x3d to be determined\n          float minMaxValue \x3d 0.0;\n          float minMaxValueFound \x3d 0.0;\n          int minMaxPosition \x3d 0;\n\n          for (int wD \x3d 0; wD \x3c "+
te+";\n              wD +\x3d "+hd+") {\n            int xD \x3d xDCorner + wD;\n\n            if (xD \x3c 0 || xD \x3e\x3d "+ea.inDepth+") {\n              continue;\n            }\n\n            for (int wR \x3d 0; wR \x3c "+He+";\n                wR +\x3d "+Hd+") {\n              int xR \x3d xRCorner + wR;\n\n              if (xR \x3c 0 || xR \x3e\x3d "+ea.inHeight+") {\n                continue;\n              }\n\n              for (int wC \x3d 0; wC \x3c "+Xd+";\n                  wC +\x3d "+
$d+") {\n                int xC \x3d xCCorner + wC;\n\n                if (xC \x3c 0 || xC \x3e\x3d "+ea.inWidth+") {\n                  continue;\n                }\n\n                float value \x3d getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue \x3d mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value \x3e\x3d currMinMaxValue) {\n                  minMaxValue \x3d value;\n                  minMaxValueFound \x3d 1.0;\n                  minMaxPosition \x3d "+
(za?Xa?"(((batch * "+ea.inDepth+" + xD) * "+ea.inHeight+" + xR) * "+ea.inWidth+" + xC) * "+ea.inChannels+" + ch":"((xD * "+ea.inHeight+" + xR) * "+ea.inWidth+" + xC) * "+ea.inChannels+" + ch":"wD * "+He+" * "+Xd+" +\n                      wR * "+Xd+" + wC")+";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ":(ia=sa+"("+sa+"("+sa+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])","avg"===sa&&(ia="avgValue / count"),
sa=4*Math.floor(Cb/4),Cb%=4,Hg="\n      if ("+Hg+") {\n        avgValue +\x3d dot(values, ones);\n      } else {\n        minMaxValue \x3d max(values, minMaxValue);\n      }\n    ",this.userCode="\n      const ivec3 strides \x3d\n        ivec3("+gc+", "+nc+", "+Tc+");\n      const ivec3 pads \x3d ivec3("+ye+", "+cg+", "+Ef+");\n      const float initializationValue \x3d "+jg+";\n      const vec4 ones \x3d vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count \x3d 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC \x3c 0 || xC \x3e\x3d "+
ea.inWidth+") {\n          return initializationValue;\n        }\n        count +\x3d 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords \x3d getOutputCoords();\n        int batch \x3d coords.x;\n        int ch \x3d coords.u;\n\n        ivec3 xCorner \x3d ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner \x3d xCorner.x;\n        int xRCorner \x3d xCorner.y;\n        int xCCorner \x3d xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? \x3d to be determined\n        vec4 minMaxValue \x3d vec4("+
jg+");\n        float avgValue \x3d 0.0;\n        count \x3d 0.0;\n\n        for (int wD \x3d 0; wD \x3c "+te+";\n            wD +\x3d "+hd+") {\n          int xD \x3d xDCorner + wD;\n\n          if (xD \x3c 0 || xD \x3e\x3d "+ea.inDepth+") {\n            continue;\n          }\n\n          for (int wR \x3d 0; wR \x3c "+He+";\n            wR +\x3d "+Hd+") {\n            int xR \x3d xRCorner + wR;\n\n            if (xR \x3c 0 || xR \x3e\x3d "+ea.inHeight+") {\n              continue;\n            }\n\n            for (int wC \x3d 0; wC \x3c "+
sa+"; wC +\x3d 4) {\n              int xC \x3d xCCorner + wC * "+$d+";\n\n              vec4 values \x3d vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+$d+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+$d+", ch),\n                getValue(batch, xD, xR, xC + 3 * "+$d+", ch)\n              );\n\n              "+Hg+"\n            }\n\n            int xC \x3d xCCorner + "+sa+";\n            if ("+(1===Cb)+") {\n              vec4 values \x3d vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              "+
Hg+"\n            } else if ("+(2===Cb)+") {\n              vec4 values \x3d vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+$d+", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              "+Hg+"\n            } else if ("+(3===Cb)+") {\n              vec4 values \x3d vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+$d+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+
$d+", ch),\n                initializationValue\n              );\n\n              "+Hg+"\n            }\n          }\n          setOutput("+ia+");\n        }\n      }\n    ")}}(),Qf=function(){return function(ea,sa){this.variableNames=["x"];var ia=ea.windowSize,za=ea.inSize;this.outputShape=[ea.batchSize,ea.outSize];ea="0.0";var Xa="";"prod"===sa?ea="1.0":"min"===sa?(ea="1.0 / 1e-20",Xa="min"):"max"===sa&&(ea="-1.0 / 1e-20",Xa="max");var Cb=sa+"("+sa+"("+sa+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
"sum"===sa?Cb="sumValue":"prod"===sa?Cb="prodValue":"all"===sa?Cb="allValue":"any"===sa&&(Cb="anyValue");var gc=4*Math.floor(ia/4),nc=ia%4;Xa="\n      if ("+("sum"===sa)+") {\n        sumValue +\x3d dot(values, ones);\n      } else if ("+("prod"===sa)+") {\n        vec2 tmp \x3d vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *\x3d tmp[0] * tmp[1];\n      } else {\n        minMaxValue \x3d "+Xa+"(values, minMaxValue);\n      }\n    ";var Tc="vec4";"all"===sa?(ea="1.0",
Xa="\n        bool reducedAllValue \x3d all(values);\n        float floatedReducedAllValue \x3d float(reducedAllValue);\n        allValue \x3d float(allValue \x3e\x3d 1.0 \x26\x26 floatedReducedAllValue \x3e\x3d 1.0);\n      ",Tc="bvec4"):"any"===sa&&(ea="0.0",Xa="\n        bool reducedAnyValue \x3d any(values);\n        float floatedReducedAnyValue \x3d float(reducedAnyValue);\n        anyValue \x3d float(anyValue \x3e\x3d 1.0 || floatedReducedAnyValue \x3e\x3d 1.0);\n      ",Tc="bvec4");sa="";0<
za%ia&&(sa="\n        if (inIdx \x3c 0 || inIdx \x3e\x3d "+za+") {\n          return initializationValue;\n        }\n      ");this.userCode="\n      const float initializationValue \x3d "+ea+";\n      const vec4 ones \x3d vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+sa+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords \x3d getOutputCoords();\n        int batch \x3d coords[0];\n        int outIdx \x3d coords[1];\n        int inOffset \x3d outIdx * "+
ia+";\n\n        vec4 minMaxValue \x3d vec4("+ea+");\n        float prodValue \x3d 1.0;\n        float sumValue \x3d 0.0;\n        float allValue \x3d 1.0;\n        float anyValue \x3d 0.0;\n\n        for (int i \x3d 0; i \x3c "+gc+"; i +\x3d 4) {\n          int inIdx \x3d inOffset + i;\n          "+Tc+" values \x3d "+Tc+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+
Xa+"\n        }\n\n        int inIdx \x3d inOffset + "+gc+";\n        if ("+(1===nc)+") {\n          "+Tc+" values \x3d "+Tc+"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          "+Xa+"\n        } else if ("+(2===nc)+") {\n          "+Tc+" values \x3d "+Tc+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          "+
Xa+"\n        } else if ("+(3===nc)+") {\n          "+Tc+" values \x3d "+Tc+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          "+Xa+"\n        }\n        setOutput("+Cb+");\n      }\n    "}}(),Zf=function(){return function(ea,sa){this.variableNames=["A"];this.packedOutput=this.packedInputs=!0;this.outputShape=ea;for(var ia="",za=0;4>za;za++){var Xa="thisRC \x3d rc;";1===
za%2&&(Xa+="thisRC.z +\x3d 1;");1<za&&(Xa+="thisRC.y +\x3d 1;");ia+="\n        "+Xa+"\n        "+(0<za?"if(thisRC.y \x3c rows \x26\x26 thisRC.z \x3c cols){":"")+"\n          int flatIndex \x3d getFlatIndex(thisRC);\n\n          ivec3 inputRC \x3d inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims \x3d vec2(float(inputRC.y),float(inputRC.z));\n\n          result["+za+"] \x3d\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        "+(0<za?
"}":"")+"\n      "}this.userCode="\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      "+(Ma(["r","c","d"],sa)+"\n      return ivec3(r, c, d);\n    }\n  \n      ")+ib(ea)+"\n\n      void main() {\n        ivec3 rc \x3d getOutputCoords();\n\n        vec4 result \x3d vec4(0.);\n\n        ivec3 thisRC;\n        int rows \x3d "+ea[1]+";\n        int cols \x3d "+ea[2]+";\n\n        "+ia+"\n\n        setOutput(result);\n      }\n    "}}(),Df=function(){return function(ea,sa,ia){this.variableNames=
["dy"];this.outputShape=[];var za=this.outputShape=sa.shape;sa=za[1];za=za[2];var Xa=ea.shape;ea=Xa[1];Xa=Xa[2];var Cb=[ia&&1<ea?sa-1:sa,ia&&1<Xa?za-1:za],gc=[ia&&1<ea?ea-1:ea,ia&&1<Xa?Xa-1:Xa];ia=Cb[0]/gc[0];Cb=Cb[1]/gc[1];gc=1/ia;var nc=1/Cb;this.userCode="\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int b \x3d coords[0];\n        int d \x3d coords[3];\n        int r \x3d coords[1];\n        int c \x3d coords[2];\n\n        float accumulator \x3d 0.0;\n\n        const float heightScale \x3d float("+
ia+");\n        const float widthScale \x3d float("+Cb+");\n\n        const float invHeightScale \x3d float("+gc+");\n        const float invWidthScale \x3d float("+nc+");\n\n        const int winHeight \x3d int("+(2*Math.ceil(gc)+2)+");\n        const int winWidth \x3d int("+(2*Math.ceil(nc)+2)+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp \x3d floor(float(r) * invHeightScale);\n        int startDyR \x3d int(startRLerp - float(winHeight / 2));\n\n        float startCLerp \x3d floor(float(c) * invWidthScale);\n        int startDyC \x3d int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset \x3d 0; dyROffset \x3c winHeight; dyROffset++) {\n          int dyR \x3d dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR \x3c 0 || dyR \x3e\x3d "+
ea+") {\n            continue;\n          }\n\n          for (int dyCOffset \x3d 0; dyCOffset \x3c winWidth; dyCOffset++) {\n            int dyC \x3d dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC \x3c 0 || dyC \x3e\x3d "+Xa+") {\n              continue;\n            }\n\n            float dxR \x3d float(dyR) * heightScale;\n            int topDxRIndex \x3d int(floor(dxR));\n            int bottomDxRIndex \x3d int(min(ceil(dxR), "+
(sa-1)+".0));\n            float dxRLerp \x3d dxR - float(topDxRIndex);\n            float inverseDxRLerp \x3d 1.0 - dxRLerp;\n\n            float dxC \x3d float(dyC) * widthScale;\n            int leftDxCIndex \x3d int(floor(dxC));\n            int rightDxCIndex \x3d int(min(ceil(dxC), "+(za-1)+".0));\n            float dxCLerp \x3d dxC - float(leftDxCIndex);\n            float inverseDxCLerp \x3d 1.0 - dxCLerp;\n\n            if (r \x3d\x3d topDxRIndex \x26\x26 c \x3d\x3d leftDxCIndex) {\n              // topLeft\n              accumulator +\x3d\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r \x3d\x3d topDxRIndex \x26\x26 c \x3d\x3d rightDxCIndex) {\n              // topRight\n              accumulator +\x3d getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r \x3d\x3d bottomDxRIndex \x26\x26 c \x3d\x3d leftDxCIndex) {\n              // bottomLeft\n              accumulator +\x3d getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r \x3d\x3d bottomDxRIndex \x26\x26 c \x3d\x3d rightDxCIndex) {\n              // bottomRight\n              accumulator +\x3d getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}}(),
rg=function(){return function(ea,sa,ia,za){this.variableNames=["A"];this.outputShape=[];var Xa=ea[1],Cb=ea[2];this.outputShape=[ea[0],sa,ia,ea[3]];ea=[za&&1<sa?Xa-1:Xa,za&&1<ia?Cb-1:Cb];sa=[za&&1<sa?sa-1:sa,za&&1<ia?ia-1:ia];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC \x3d vec2(\n          "+ea[0]/sa[0]+",\n          "+ea[1]/sa[1]+");\n      const vec2 inputShapeRC \x3d vec2("+Xa+".0, "+Cb+".0);\n\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int b \x3d coords[0];\n        int d \x3d coords[3];\n        ivec2 yRC \x3d coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC \x3d vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC \x3d ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC \x3d ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft \x3d getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft \x3d getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight \x3d getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight \x3d getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC \x3d sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top \x3d topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom \x3d bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue \x3d top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "}}(),
If=function(){return function(ea,sa,ia,za){this.variableNames=["A"];this.packedOutput=this.packedInputs=!0;this.outputShape=[];var Xa=ea[1],Cb=ea[2],gc=ea[3];this.outputShape=[ea[0],sa,ia,gc];ea=[za&&1<sa?Xa-1:Xa,za&&1<ia?Cb-1:Cb];sa=[za&&1<sa?sa-1:sa,za&&1<ia?ia-1:ia];this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC \x3d vec3(\n          "+ea[0]/sa[0]+",\n          "+ea[1]/sa[1]+",\n          "+ea[1]/sa[1]+");\n      const vec3 inputShapeRC \x3d vec3("+Xa+".0, "+Cb+".0,\n                                     "+
Cb+".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int b \x3d coords[0];\n        int d \x3d coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC \x3d coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC \x3d vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC \x3d ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC \x3d ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol \x3d d \x3c "+
(gc-1)+";\n        bool hasNextRow \x3d coords.z \x3c "+(ia-1)+";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft \x3d vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow \x26\x26 hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft \x3d vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow \x26\x26 hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight \x3d vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow \x26\x26 hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight \x3d vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow \x26\x26 hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC \x3d sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top \x3d mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom \x3d mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue \x3d mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    "}}(),
ag=function(){return function(ea,sa,ia){this.variableNames=["dy"];this.outputShape=[];var za=this.outputShape=sa.shape;sa=za[1];za=za[2];var Xa=ea.shape;ea=Xa[1];Xa=Xa[2];var Cb=[ia&&1<ea?sa-1:sa,ia&&1<Xa?za-1:za],gc=[ia&&1<ea?ea-1:ea,ia&&1<Xa?Xa-1:Xa],nc=Cb[0]/gc[0],Tc=Cb[1]/gc[1],hd=1/nc,Hd=1/Tc;this.userCode="\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int b \x3d coords[0];\n        int d \x3d coords[3];\n        int r \x3d coords[1];\n        int c \x3d coords[2];\n\n        float accumulator \x3d 0.0;\n\n        const float heightScale \x3d float("+
nc+");\n        const float widthScale \x3d float("+Tc+");\n\n        const float invHeightScale \x3d float("+hd+");\n        const float invWidthScale \x3d float("+Hd+");\n\n        const int winHeight \x3d int("+(2*Math.ceil(hd)+2)+");\n        const int winWidth \x3d int("+(2*Math.ceil(Hd)+2)+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp \x3d floor(float(r) * invHeightScale);\n        int startDyR \x3d int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp \x3d floor(float(c) * invWidthScale);\n        int startDyC \x3d int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset \x3d 0; dyROffset \x3c winHeight; dyROffset++) {\n          int dyR \x3d dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR \x3c 0 || dyR \x3e\x3d "+
ea+") {\n            continue;\n          }\n\n          for (int dyCOffset \x3d 0; dyCOffset \x3c winWidth; dyCOffset++) {\n            int dyC \x3d dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC \x3c 0 || dyC \x3e\x3d "+Xa+") {\n              continue;\n            }\n\n            float sourceFracRow \x3d\n              float("+Cb[0]+") *\n                (float(dyR) / float("+gc[0]+"));\n\n            float sourceFracCol \x3d\n                float("+
Cb[1]+") *\n                  (float(dyC) / float("+gc[1]+"));\n\n            int sourceNearestRow \x3d int(min(\n                float(int("+sa+") - 1),\n                "+ia+" ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol \x3d int(min(\n                float(int("+za+") - 1),\n                "+ia+" ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r \x3d\x3d sourceNearestRow \x26\x26 c \x3d\x3d sourceNearestCol) {\n              accumulator +\x3d getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}}(),
Ua=function(){return function(ea,sa,ia,za){this.variableNames=["A"];this.outputShape=[];var Xa=ea[1],Cb=ea[2];this.outputShape=[ea[0],sa,ia,ea[3]];ea=[za&&1<sa?Xa-1:Xa,za&&1<ia?Cb-1:Cb];sa=[za&&1<sa?sa-1:sa,za&&1<ia?ia-1:ia];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC \x3d vec2(\n          "+ea[0]/sa[0]+",\n          "+ea[1]/sa[1]+");\n      const vec2 inputShapeRC \x3d vec2("+Xa+".0, "+Cb+".0);\n\n      void main() {\n        ivec4 coords \x3d getOutputCoords();\n        int b \x3d coords[0];\n        int d \x3d coords[3];\n        ivec2 yRC \x3d coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC \x3d vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC \x3d ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + "+
(za?"0.5":"0.0")+")));\n\n        float newValue \x3d getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "}}(),xa=function(){return function(ea,sa){this.variableNames=["x"];var ia=ea.length;if(4<ia)throw Error("WebGL backend: Reverse of rank-"+ia+" tensor is not yet supported");this.outputShape=ea;if(1===ia)this.userCode="\n        void main() {\n          int coord \x3d getOutputCoords();\n          setOutput(getX("+ea[0]+" - coord - 1));\n        }\n      ";
else{var za=ea.map(function(Xa,Cb){Xa=-1!==sa.indexOf(Cb)&&1!==ea[Cb]?ea[Cb]+" - coords["+Cb+"] - 1":"coords["+Cb+"]";return Xa}).join(",");this.userCode="\n      void main() {\n        "+lb(ia)+" coords \x3d getOutputCoords();\n        setOutput(getX("+za+"));\n      }\n    "}}}(),Wa=function(){return function(ea,sa){function ia($d){$d[gc-1]="("+$d[gc-1]+" + 1)";return Cb($d)}function za($d){$d[gc-2]="("+$d[gc-2]+" + 1)";return Cb($d)}function Xa($d){$d[gc-1]="("+$d[gc-1]+" + 1)";$d[gc-2]="("+$d[gc-
2]+" + 1)";return Cb($d)}function Cb($d){var te=ea.map(function(Xd,ye){Xd=-1!==sa.indexOf(ye)&&1!==ea[ye]?ea[ye]+" - "+$d[ye]+" - 1":""+$d[ye];return Xd}),He=te.join(",");te=te.slice(-2).join(",");return"getChannel(getX("+He+"), vec2("+te+"))"}this.variableNames=["x"];this.packedOutput=this.packedInputs=!0;var gc=ea.length;if(4<gc)throw Error("WebGL backend: Reverse of rank-"+gc+" tensor is not yet supported");this.outputShape=ea;var nc=gb("rc",gc),Tc=nc[gc-1]+" + 1 \x3c "+this.outputShape[gc-1],
hd=nc[gc-2]+" + 1 \x3c "+this.outputShape[gc-2],Hd=lb(gc);this.userCode=1===gc?"\n        void main(){\n          int rc \x3d getOutputCoords();\n          vec4 result \x3d vec4(0.);\n          result.r \x3d getChannel(getX("+ea[0]+" - rc - 1),\n            "+ea[0]+" - rc - 1);\n          if("+Tc+"){\n              result.g \x3d getChannel(getX("+ea[0]+" - (rc  + 1) - 1),\n                "+ea[0]+" - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ":"\n        void main() {\n          "+
Hd+" rc \x3d getOutputCoords();\n          vec4 result \x3d vec4(0.);\n          result.r \x3d "+Cb(nc.slice())+";\n          if("+Tc+"){\n            result.g \x3d "+ia(nc.slice())+";\n          }\n          if("+hd+") {\n            result.b \x3d "+za(nc.slice())+";\n            if("+Tc+") {\n              result.a \x3d "+Xa(nc.slice())+";\n            }\n          }\n          setOutput(result);\n        }\n    "}}(),Da=function(){return function(ea,sa,ia,za,Xa,Cb,gc){this.variableNames=["updates",
"indices","defaultValue"];this.outputShape=Cb;gc=lb(Xa.length);Cb=lb(Cb.length);var nc="";1===ia?nc="i":2===ia&&(nc="i, j");ia="";1===za?ia="i":2===za&&(ia="i, coords[1]");this.userCode="\n        "+gc+" strides \x3d "+gc+"("+Xa+");\n\n        void main() {\n          "+Cb+" coords \x3d getOutputCoords();\n          float sum \x3d 0.0;\n          bool found \x3d false;\n          for (int i \x3d 0; i \x3c "+ea+"; i++) {\n            int flattenedIndex \x3d 0;\n            for (int j \x3d 0; j \x3c "+
sa+"; j++) {\n              int index \x3d round(getIndices("+(nc+"));\n              flattenedIndex +\x3d index * ")+(1<sa?"strides[j]":"strides")+";\n            }\n            if (flattenedIndex \x3d\x3d coords[0]) {\n              sum +\x3d getUpdates("+(ia+");\n              found \x3d true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ")}}(),mb=function(){return function(ea,sa){this.variableNames=["x","segmentIds"];sa=ea.windowSize;
var ia=ea.inSize,za=ea.numSegments;this.outputShape=[ea.batchSize,za*Math.ceil(ia/sa)];ea=4*Math.floor(sa/4);var Xa=sa%4,Cb="";0<ia%sa&&(Cb="\n        if (inIdx \x3c 0 || inIdx \x3e\x3d "+ia+") {\n          return initializationValue;\n        }\n      ");var gc="";0<ia%sa&&(gc="\n        if (inIdx \x3c 0 || inIdx \x3e\x3d "+ia+") {\n          return -1.0;\n        }\n      ");this.userCode="\n      const float initializationValue \x3d 0.0;\n\n      float getValue(int batch, int inIdx) {\n        "+
Cb+"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        "+gc+"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords \x3d getOutputCoords();\n        int batch \x3d coords[0];\n        int outIdx \x3d coords[1];\n        int inOffset \x3d int(floor(float(outIdx) / float(\n          "+za+")) * float("+sa+"));\n        int currentSeg \x3d int(mod(float(outIdx), float("+za+")));\n\n        float sumValue \x3d 0.0;\n\n        for (int i \x3d 0; i \x3c "+
ea+"; i +\x3d 4) {\n          int inIdx \x3d inOffset + i;\n          vec4 values \x3d vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter \x3d vec4(\n            int(getSegmentIdAtIndex(inIdx)) \x3d\x3d currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) \x3d\x3d currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) \x3d\x3d currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) \x3d\x3d currentSeg ? 1 : 0\n          );\n\n          \n        sumValue +\x3d dot(values, segFilter);\n    \n        }\n\n        int inIdx \x3d inOffset + "+
ea+";\n        if ("+(1===Xa)+") {\n          vec4 values \x3d vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg \x3d int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter \x3d vec4(\n            int(getSegmentIdAtIndex(inIdx)) \x3d\x3d currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          \n        sumValue +\x3d dot(values, segFilter);\n    \n        } else if ("+
(2===Xa)+") {\n          vec4 values \x3d vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter \x3d vec4(\n            int(getSegmentIdAtIndex(inIdx)) \x3d\x3d currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) \x3d\x3d currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          \n        sumValue +\x3d dot(values, segFilter);\n    \n        } else if ("+
(3===Xa)+") {\n          vec4 values \x3d vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter \x3d vec4(\n            int(getSegmentIdAtIndex(inIdx)) \x3d\x3d currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) \x3d\x3d currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) \x3d\x3d currentSeg ? 1 : 0,\n            0\n          );\n\n          \n        sumValue +\x3d dot(values, segFilter);\n    \n        }\n        setOutput(sumValue);\n      }\n    "}}(),
Bb=function(){return function(ea,sa,ia){this.variableNames=["c","a","b"];this.outputShape=sa;var za;if(4<ia)throw Error("Where for rank "+ia+" is not yet supported");if(1===ia)ea=za="resRC";else{var Xa=["resRC.x","resRC.y","resRC.z","resRC.w"],Cb=[];za=[];for(var gc=0;gc<sa.length;gc++)za.push(""+Xa[gc]),gc<ea&&Cb.push(""+Xa[gc]);ea=Cb.join();za=za.join()}this.userCode="\n      void main() {\n        "+lb(ia)+" resRC \x3d getOutputCoords();\n        float cVal \x3d getC("+ea+");\n        if (cVal \x3e\x3d 1.0) {\n          setOutput(getA("+
za+"));\n        } else {\n          setOutput(getB("+za+"));\n        }\n      }\n    "}}(),$b=function(){function ea(sa){this.variableNames=["source"];this.outputShape=sa;this.rank=sa.length;var ia=lb(this.rank),za="uniform int start["+this.rank+"];",Xa=ld(this.rank);sa=sa.map(function(Cb,gc){return"sourceLoc."+wc[gc]+" \x3d start["+gc+"] + coords."+wc[gc]+";"});ia="\n        "+ia+" sourceLoc;\n        "+ia+" coords \x3d getOutputCoords();\n        "+sa.join("\n")+"\n      ";this.userCode="\n      "+
za+"\n      void main() {\n        "+ia+"\n        setOutput(getSource("+Xa+"));\n      }\n    "}ea.prototype.getCustomSetupFunc=function(sa){var ia=this;if(sa.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+(sa.length+")"));return function(za,Xa){if(null==ia.startLoc&&(ia.startLoc=za.getUniformLocationNoThrow(Xa,"start"),null==ia.startLoc))return;za.gl.uniform1iv(ia.startLoc,sa)}};return ea}(),wc="xyzwuv".split(""),Rc=function(){function ea(sa){this.variableNames=
["source"];this.packedOutput=this.packedInputs=!0;this.outputShape=sa;this.rank=sa.length;var ia=lb(this.rank),za=gb("coords",this.rank),Xa=gb("sourceLoc",this.rank),Cb=1===this.rank?"sourceLoc":"vec2("+Xa.slice(-2).join()+")",gc="getChannel(getSource("+Xa.join()+"), "+Cb+")";Cb="\n      result.x \x3d "+gc+";\n      if (++"+za[this.rank-1]+" \x3c "+sa[this.rank-1]+") {\n        ++"+Xa[this.rank-1]+";\n        result.y \x3d "+gc+";\n        --"+Xa[this.rank-1]+";\n      }\n    ";gc=1===this.rank?"":
"\n      --"+za[this.rank-1]+";\n      if (++"+za[this.rank-2]+" \x3c "+sa[this.rank-2]+") {\n        ++"+Xa[this.rank-2]+";\n        result.z \x3d "+gc+";\n        if (++"+za[this.rank-1]+" \x3c "+sa[this.rank-1]+") {\n          ++"+Xa[this.rank-1]+";\n          result.w \x3d "+gc+";\n        }\n      }\n    ";sa=4>=this.rank?"sourceLoc \x3d coords +\n            "+ia+"("+sa.map(function(nc,Tc){return"start["+Tc+"]"}).join()+");":sa.map(function(nc,Tc){return Xa[Tc]+" \x3d "+za[Tc]+" + start["+Tc+
"];"}).join("\n");this.userCode="\n      uniform int start["+this.rank+"];\n      void main() {\n        "+ia+" coords \x3d getOutputCoords();\n        "+ia+" sourceLoc;\n        "+sa+"\n        vec4 result \x3d vec4(0.);\n        "+Cb+"\n        "+gc+"\n        setOutput(result);\n      }\n    "}ea.prototype.getCustomSetupFunc=function(sa){var ia=this;if(sa.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+(sa.length+")"));return function(za,
Xa){if(null==ia.startLoc&&(ia.startLoc=za.getUniformLocationNoThrow(Xa,"start"),null==ia.startLoc))return;za.gl.uniform1iv(ia.startLoc,sa)}};return ea}(),Zc=function(){return function(ea,sa,ia){this.variableNames=["x"];this.outputShape=ia;var za=ia.length,Xa=lb(ia.length),Cb=lb(ia.length),gc="";if(1===za)gc="coords * strides + begin";else{var nc=0;gc=ia.map(function(Tc,hd){nc++;return 1===ia.length?"coords * strides["+hd+"] + begin["+hd+"]":"coords["+(nc-1)+"] * strides["+hd+"] + begin["+hd+"]"}).join(",")}this.userCode=
"\n      "+Xa+" begin \x3d "+Xa+"("+ea+");\n      "+Xa+" strides \x3d "+Xa+"("+sa+");\n\n      void main() {\n        "+Cb+" coords \x3d getOutputCoords();\n        setOutput(getX("+gc+"));\n      }\n    "}}(),Xc=function(){function ea(sa){this.gpgpu=sa;this._numBytesFree=this._numBytesAllocated=this.numFreeTextures=this.numUsedTextures=0;this.freeTextures={};this.logEnabled=!1;this.usedTextures={}}ea.prototype.acquireTexture=function(sa,ia,za){var Xa=Ac(ia,za);ia=sa[0]+"_"+sa[1]+"_"+Xa+"_"+za;ia in
this.freeTextures||(this.freeTextures[ia]=[]);ia in this.usedTextures||(this.usedTextures[ia]=[]);za=Sb(sa,Xa,this.gpgpu.gl,this.gpgpu.textureConfig,za);if(0<this.freeTextures[ia].length)return this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=za,this.log(),sa=this.freeTextures[ia].shift(),this.usedTextures[ia].push(sa),sa;var Cb;Xa===hb.PACKED_2X2_FLOAT32?Cb=this.gpgpu.createPackedMatrixTexture(sa[0],sa[1]):Xa===hb.PACKED_2X2_FLOAT16?Cb=this.gpgpu.createFloat16PackedMatrixTexture(sa[0],
sa[1]):Xa===hb.UNPACKED_FLOAT32?Cb=this.gpgpu.createFloat32MatrixTexture(sa[0],sa[1]):Xa===hb.UNPACKED_FLOAT16?Cb=this.gpgpu.createFloat16MatrixTexture(sa[0],sa[1]):Xa===hb.PACKED_4X1_UNSIGNED_BYTE&&(Cb=this.gpgpu.createUnsignedBytesMatrixTexture(sa[0],sa[1]));this.usedTextures[ia].push(Cb);this.numUsedTextures++;this._numBytesAllocated+=za;this.log();return Cb};ea.prototype.releaseTexture=function(sa,ia,za,Xa){if(null!=this.freeTextures){var Cb=Ac(za,Xa);za=ia[0]+"_"+ia[1]+"_"+Cb+"_"+Xa;za in this.freeTextures||
(this.freeTextures[za]=[]);ia=Sb(ia,Cb,this.gpgpu.gl,this.gpgpu.textureConfig,Xa);Xa=lc.env().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==Xa&&this._numBytesAllocated>Xa?(this.gpgpu.deleteMatrixTexture(sa),this._numBytesAllocated-=ia):(this.freeTextures[za].push(sa),this.numFreeTextures++,this._numBytesFree+=ia);this.numUsedTextures--;za=this.usedTextures[za];sa=za.indexOf(sa);if(0>sa)throw Error("Cannot release a texture that was never provided by this texture manager");za.splice(sa,1);this.log()}};
ea.prototype.log=function(){if(this.logEnabled){console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+(this.numFreeTextures+this.numUsedTextures)+")");var sa=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: "+this._numBytesAllocated);console.log("Bytes unused: "+this._numBytesFree+" ("+Math.round(100*sa)+"%)")}};Object.defineProperty(ea.prototype,"numBytesAllocated",{get:function(){return this._numBytesAllocated},enumerable:!0,configurable:!0});Object.defineProperty(ea.prototype,
"numBytesFree",{get:function(){return this._numBytesFree},enumerable:!0,configurable:!0});ea.prototype.getNumUsedTextures=function(){return this.numUsedTextures};ea.prototype.getNumFreeTextures=function(){return this.numFreeTextures};ea.prototype.dispose=function(){var sa=this;if(null!=this.freeTextures){for(var ia in this.freeTextures)this.freeTextures[ia].forEach(function(za){sa.gpgpu.deleteMatrixTexture(za)});for(ia in this.usedTextures)this.usedTextures[ia].forEach(function(za){sa.gpgpu.deleteMatrixTexture(za)});
this.usedTextures=this.freeTextures=null;this._numBytesFree=this._numBytesAllocated=this.numFreeTextures=this.numUsedTextures=0}};return ea}(),bd=function(){return function(ea,sa){this.variableNames=["A"];for(var ia=Array(ea.length),za=0;za<ia.length;za++)ia[za]=ea[za]*sa[za];this.outputShape=ia;this.rank=ia.length;sa=lb(this.rank);ia=ea.length;if(5<ia)throw Error("Tile for rank "+ia+" is not yet supported");if(1===ia)ea="imod(resRC, "+ea[0]+")";else{ia=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"];
za=[];for(var Xa=0;Xa<ea.length;Xa++)za.push("imod("+ia[Xa]+", "+ea[Xa]+")");ea=za.join()}this.userCode="\n      void main() {\n        "+sa+" resRC \x3d getOutputCoords();\n        setOutput(getA("+ea+"));\n      }\n    "}}(),id=function(){return function(ea,sa){this.variableNames=["A"];this.outputShape=ea;this.userCode="\n      float unaryOperation(float x) {\n        "+sa+"\n      }\n\n      void main() {\n        float x \x3d getAAtOutCoords();\n        float y \x3d unaryOperation(x);\n\n        setOutput(y);\n      }\n    "}}(),
Ic="\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha \x3d "+lc.backend_util.SELU_SCALEALPHA+";\n  float scale \x3d "+lc.backend_util.SELU_SCALE+";\n  return (x \x3e\x3d 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n",Kd='\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p \x3d '+
lc.backend_util.ERF_P+";\n  float a1 \x3d "+lc.backend_util.ERF_A1+";\n  float a2 \x3d "+lc.backend_util.ERF_A2+";\n  float a3 \x3d "+lc.backend_util.ERF_A3+";\n  float a4 \x3d "+lc.backend_util.ERF_A4+";\n  float a5 \x3d "+lc.backend_util.ERF_A5+";\n\n  float sign \x3d sign(x);\n  x \x3d abs(x);\n  float t \x3d 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n",Bd=function(){return function(ea,sa){this.variableNames=["A"];this.packedOutput=this.packedInputs=
!0;this.outputShape=ea;this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        "+sa+"\n      }\n\n      void main() {\n        vec4 x \x3d getAAtOutCoords();\n        vec4 y \x3d unaryOperation(x);\n\n        setOutput(y);\n      }\n    "}}(),vd=function(){return function(ea){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!1;this.outputShape=ea;var sa=ea.length,ia=gb("rc",sa);ea=lb(sa);if(1===sa)var za="rc";else{za="";for(var Xa=0;Xa<sa;Xa++)za+=ia[Xa],Xa<sa-1&&(za+=",")}ia=
ia.slice(-2);sa=1>=sa?"rc":"vec2("+ia.join(",")+")";this.userCode="\n      void main() {\n        "+ea+" rc \x3d getOutputCoords();\n        vec4 packedInput \x3d getA("+za+");\n\n        setOutput(getChannel(packedInput, "+sa+"));\n      }\n    "}}(),Nd=lc.backend_util.segment_util,de=lc.kernel_impls.split,ne=lc.kernel_impls.tile,xe=lc.kernel_impls.topkImpl,Vd=lc.kernel_impls.whereImpl,le={},ue=function(ea){function sa(ia){var za=ea.call(this)||this;za.pendingRead=new WeakMap;za.pendingDisposal=
new WeakSet;za.dataRefCount=new WeakMap;za.numBytesInGPU=0;za.uploadWaitMs=0;za.downloadWaitMs=0;za.warnedAboutMemory=!1;za.warnedAboutCPUBackend=!1;za.pendingDeletes=0;za.disposed=!1;if(!lc.env().getBool("HAS_WEBGL"))throw Error("WebGL is not supported on this device");if(null==ia){ia=f(lc.env().getNumber("WEBGL_VERSION"));var Xa=lc.env().getNumber("WEBGL_VERSION");Xa in le||(le[Xa]={});Xa=le[Xa];za.binaryCache=Xa;za.gpgpu=new va(ia);za.canvas=ia.canvas;za.gpgpuCreatedLocally=!0}else za.gpgpu=ia,
za.binaryCache={},za.gpgpuCreatedLocally=!1,za.canvas=ia.gl.canvas;za.textureManager=new Xc(za.gpgpu);ia=null==lc.env().global.screen?1024:lc.env().global.screen.height*lc.env().global.screen.width*window.devicePixelRatio*600/1024/1024;za.numMBBeforeWarning=ia;za.texData=new lc.DataStorage(za,lc.engine());return za}t(sa,ea);sa.prototype.numDataIds=function(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes};sa.prototype.write=function(ia,za,Xa){(lc.env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||
lc.env().getBool("DEBUG"))&&this.checkNumericalProblems(ia);if("complex64"===Xa&&null!=ia)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var Cb={};this.texData.set(Cb,{shape:za,dtype:Xa,values:ia,usage:Ga.UPLOAD,refCount:1,complexParentRefCount:0});return Cb};sa.prototype.incRef=function(ia){this.texData.get(ia).refCount++};sa.prototype.decRef=function(ia){this.texData.has(ia)&&this.texData.get(ia).refCount--};sa.prototype.move=function(ia,za,Xa,Cb){lc.env().getBool("DEBUG")&&
this.checkNumericalProblems(za);if("complex64"===Cb)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(ia,{shape:Xa,dtype:Cb,values:za,usage:Ga.UPLOAD,refCount:1,complexParentRefCount:0})};sa.prototype.disposeIntermediateTensorInfo=function(ia){ia=ia.dataId;if(this.texData.has(ia)){var za=this.texData.get(ia);za.refCount--;1>za.refCount&&this.disposeData(ia)}};sa.prototype.readSync=function(ia){var za=this.texData.get(ia),Xa=za.values,Cb=za.dtype,
gc=za.complexTensorInfos,nc=za.shape,Tc=za.isPacked;if(null!=za.slice){var hd=Tc?new Bd(nc,"return x;"):new id(nc,"return x;");ia=this.runWebGLProgram(hd,[{dataId:ia,shape:nc,dtype:Cb}],Cb);hd=this.readSync(ia.dataId);this.disposeIntermediateTensorInfo(ia);return hd}if(null!=Xa)return this.convertAndCacheOnCPU(ia);if("string"===Cb)return Xa;(nc=null!=this.activeTimers)&&(hd=lc.util.now());"complex64"===Cb?(Cb=this.readSync(gc.real.dataId),gc=this.readSync(gc.imag.dataId),Cb=lc.backend_util.mergeRealAndImagArrays(Cb,
gc)):Cb=this.getValuesFromTexture(ia);nc&&(this.downloadWaitMs+=lc.util.now()-hd);return this.convertAndCacheOnCPU(ia,Cb)};sa.prototype.read=function(ia){return r(this,void 0,void 0,function(){var za,Xa,Cb,gc,nc,Tc,hd,Hd,$d,te,He,Xd,ye,cg,Ef,Hg,jg,gg,th,Xg,Tg,zh;return u(this,function(og){switch(og.label){case 0:if(this.pendingRead.has(ia))return za=this.pendingRead.get(ia),[2,new Promise(function(Fh){return za.push(Fh)})];Xa=this.texData.get(ia);Cb=Xa.values;gc=Xa.shape;nc=Xa.slice;Tc=Xa.dtype;hd=
Xa.complexTensorInfos;Hd=Xa.isPacked;if(null!=nc)return $d=void 0,$d=Hd?new Bd(gc,"return x;"):new id(gc,"return x;"),te=this.runWebGLProgram($d,[{dataId:ia,shape:gc,dtype:Tc}],Tc),He=this.read(te.dataId),this.disposeIntermediateTensorInfo(te),[2,He];if(null!=Cb)return[2,this.convertAndCacheOnCPU(ia)];if(!lc.env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===lc.env().getNumber("WEBGL_VERSION"))throw Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED\x3dfalse and WEBGL_VERSION\x3d2 not yet supported.");
Xd=null;"complex64"!==Tc&&lc.env().get("WEBGL_BUFFER_SUPPORTED")&&(ye=this.decode(ia),cg=this.texData.get(ye.dataId),Xd=(zh=this.gpgpu).createBufferFromTexture.apply(zh,[cg.texture].concat(b(gc))));this.pendingRead.set(ia,[]);return"complex64"===Tc?[3,2]:[4,this.gpgpu.createAndWaitForFence()];case 1:og.sent(),og.label=2;case 2:return"complex64"!==Tc?[3,4]:[4,Promise.all([this.read(hd.real.dataId),this.read(hd.imag.dataId)])];case 3:return Hg=og.sent(),jg=Hg[0],gg=Hg[1],Ef=lc.backend_util.mergeRealAndImagArrays(jg,
gg),[3,5];case 4:null==Xd?Ef=this.getValuesFromTexture(ia):(th=lc.util.sizeFromShape(gc),Ef=this.gpgpu.downloadFloat32MatrixFromBuffer(Xd,th)),og.label=5;case 5:return null!=ye&&this.disposeIntermediateTensorInfo(ye),Xg=this.convertAndCacheOnCPU(ia,Ef),Tg=this.pendingRead.get(ia),this.pendingRead.delete(ia),Tg.forEach(function(Fh){return Fh(Xg)}),this.pendingDisposal.has(ia)&&(this.pendingDisposal.delete(ia),this.disposeData(ia),this.pendingDeletes--),[2,Xg]}})})};sa.prototype.checkNumericalProblems=
function(ia){if(null!=ia)for(var za=0;za<ia.length;za++){var Xa=ia[za];if(!h(Xa)){if(lc.env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value "+Xa+" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value "+Xa+" cannot be represented on this device.");}}};sa.prototype.getValuesFromTexture=function(ia){var za,Xa=this.texData.get(ia),Cb=Xa.shape,gc=Xa.dtype,nc=Xa.isPacked;Xa=
lc.util.sizeFromShape(Cb);if(lc.env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED"))return ia=this.decode(ia),gc=this.texData.get(ia.dataId),Xa=(za=this.gpgpu).downloadMatrixFromPackedTexture.apply(za,[gc.texture].concat(b(Cb))).subarray(0,Xa),this.disposeIntermediateTensorInfo(ia),Xa;Cb=(za=lc.env().getBool("WEBGL_PACK")&&!0===nc)?aa(Cb):Cb;za=za?new ug(Cb):new Kb(Cb);ia=this.runWebGLProgram(za,[{shape:Cb,dtype:gc,dataId:ia}],"float32");za=this.texData.get(ia.dataId);Xa=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(za.texture,
za.texShape[0],za.texShape[1]).subarray(0,Xa);this.disposeIntermediateTensorInfo(ia);return Xa};sa.prototype.time=function(ia){return r(this,void 0,void 0,function(){var za,Xa,Cb,gc,nc,Tc,hd;return u(this,function(Hd){switch(Hd.label){case 0:return za=this.activeTimers,Xa=[],Cb=!1,null==this.programTimersStack?(this.programTimersStack=Xa,Cb=!0):this.activeTimers.push(Xa),this.activeTimers=Xa,ia(),gc=lc.util.flatten(this.activeTimers.map(function($d){return $d.query})).filter(function($d){return null!=
$d}),nc=lc.util.flatten(this.activeTimers.map(function($d){return $d.name})).filter(function($d){return null!=$d}),this.activeTimers=za,Cb&&(this.programTimersStack=null),Tc={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},0<lc.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")?[4,Promise.all(gc)]:[3,2];case 1:return hd=Hd.sent(),Tc.kernelMs=lc.util.sum(hd),Tc.getExtraProfileInfo=function(){return hd.map(function($d,te){return{name:nc[te],
ms:$d}}).map(function($d){return $d.name+": "+$d.ms}).join(", ")},[3,3];case 2:Tc.kernelMs={error:"WebGL query timers are not supported in this environment."},Hd.label=3;case 3:return this.downloadWaitMs=this.uploadWaitMs=0,[2,Tc]}})})};sa.prototype.memory=function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}};sa.prototype.startTimer=function(){return 0<lc.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")?
this.gpgpu.beginQuery():{startMs:lc.util.now(),endMs:null}};sa.prototype.endTimer=function(ia){if(0<lc.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE"))return this.gpgpu.endQuery(),ia;ia.endMs=lc.util.now();return ia};sa.prototype.getQueryTime=function(ia){return r(this,void 0,void 0,function(){var za;return u(this,function(Xa){if(0<lc.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE"))return[2,this.gpgpu.waitForQueryAndGetTime(ia)];za=ia;return[2,za.endMs-za.startMs]})})};
sa.prototype.disposeData=function(ia){if(!this.pendingDisposal.has(ia))if(this.pendingRead.has(ia))this.pendingDisposal.add(ia),this.pendingDeletes++;else if(this.texData.has(ia))if(0<this.texData.get(ia).complexParentRefCount)this.texData.get(ia).refCount--;else{this.releaseGPUData(ia);var za=this.texData.get(ia).complexTensorInfos;null!=za&&(this.texData.get(za.real.dataId).complexParentRefCount--,this.disposeIntermediateTensorInfo(za.real),this.texData.get(za.imag.dataId).complexParentRefCount--,
this.disposeIntermediateTensorInfo(za.imag));this.texData.delete(ia)}};sa.prototype.releaseGPUData=function(ia){var za=this.texData.get(ia),Xa=za.texture,Cb=za.dtype,gc=za.texShape,nc=za.usage,Tc=za.isPacked;za=(za=za.slice)&&za.origDataId||ia;var hd=this.dataRefCount.get(za);1<hd?this.dataRefCount.set(za,hd-1):(this.dataRefCount.delete(za),null!=Xa&&(this.numBytesInGPU-=this.computeBytes(gc,Cb),this.textureManager.releaseTexture(Xa,gc,nc,Tc)));ia=this.texData.get(ia);ia.texture=null;ia.texShape=
null;ia.isPacked=!1;ia.slice=null};sa.prototype.getTexture=function(ia){this.uploadToGPU(ia);return this.texData.get(ia).texture};sa.prototype.getDataInfo=function(ia){return this.texData.get(ia)};sa.prototype.getCPUBackend=function(){if(!lc.env().getBool("WEBGL_CPU_FORWARD"))return null;null==this.cpuBackend&&(this.cpuBackend=lc.engine().findBackend("cpu"));return this.cpuBackend};sa.prototype.shouldExecuteOnCPU=function(ia,za){var Xa=this;void 0===za&&(za=128);var Cb=this.getCPUBackend();this.warnedAboutCPUBackend||
null!=Cb||(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0);return null!=Cb&&ia.every(function(gc){return null==Xa.texData.get(gc.dataId).texture&&lc.util.sizeFromShape(gc.shape)<za})};sa.prototype.getGPGPUContext=function(){return this.gpgpu};sa.prototype.slice=function(ia,za,Xa){if(this.shouldExecuteOnCPU([ia]))return za=
Ze(this.texData.get(ia.dataId).values,za,Xa,ia.shape,ia.dtype),this.makeOutput(Xa,ia.dtype,za);if(0===lc.util.sizeFromShape(Xa))return lc.tensor([],Xa,ia.dtype);var Cb=this.texData.get(ia.dataId).isPacked,gc=lc.slice_util.isSliceContinous(ia.shape,za,Xa);if(Cb||!gc)return Xa=lc.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Rc(Xa):new $b(Xa),za=Xa.getCustomSetupFunc(za),this.compileAndRun(Xa,[ia],null,za);this.uploadToGPU(ia.dataId);return this.shallowSlice(ia,za,Xa)};sa.prototype.shallowSlice=
function(ia,za,Xa){var Cb=this.texData.get(ia.dataId),gc=this.makeOutput(Xa,ia.dtype),nc=this.texData.get(gc.dataId);Object.assign(nc,Cb);nc.shape=Xa;nc.dtype=ia.dtype;za=lc.slice_util.computeFlatOffset(za,ia.strides);Cb.slice&&(za+=Cb.slice.flatOffset);nc.slice={flatOffset:za,origDataId:Cb.slice&&Cb.slice.origDataId||ia.dataId};ia=this.dataRefCount.get(nc.slice.origDataId)||1;this.dataRefCount.set(nc.slice.origDataId,ia+1);return gc};sa.prototype.stridedSlice=function(ia,za,Xa,Cb){var gc=this,nc=
this.tryRunOnCpuOrThrow([ia],function(){return gc.cpuBackend.stridedSlice(ia,za,Xa,Cb)});if(nc)return nc;nc=lc.slice_util.computeOutShape(za,Xa,Cb);if(nc.some(function(Tc){return 0===Tc}))return lc.tensor([],nc);nc=new Zc(za,Cb,nc);return this.compileAndRun(nc,[ia])};sa.prototype.reverse=function(ia,za){za=lc.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Wa(ia.shape,za):new xa(ia.shape,za);return this.compileAndRun(za,[ia])};sa.prototype.neg=function(ia){var za=this,Xa=this.tryRunOnCpuOrThrow([ia],
function(){return za.cpuBackend.neg(ia)});if(Xa)return Xa;if(lc.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(ia,"return -x;",ia.dtype);Xa=new id(ia.shape,"return -x;");return this.compileAndRun(Xa,[ia])};sa.prototype.batchMatMul=function(ia,za,Xa,Cb){var gc=Xa?ia.shape[2]:ia.shape[1],nc=Cb?za.shape[1]:za.shape[2],Tc=Xa?ia.shape[1]:ia.shape[2],hd=Math.max(ia.shape[0],za.shape[0]);if((1===gc||1===nc)&&1E3<Tc)return Xa&&(ia=lc.transpose(ia,[0,2,1])),Cb&&(za=lc.transpose(za,
[0,2,1])),ia=1===nc?ia:ia.as3D(hd,Tc,1),Xa=1===nc?2:1,za=1===nc?za.as3D(hd,1,Tc):za,lc.mul(ia,za).sum(Xa,!0);Tc=lc.upcastType(ia.dtype,za.dtype);nc=new Gb(ia.shape,za.shape,[hd,gc,nc],Xa,Cb);return this.compileAndRun(nc,[ia,za],Tc)};sa.prototype.fusedBatchMatMul=function(ia){var za=ia.a,Xa=ia.b,Cb=ia.transposeA,gc=ia.transposeB,nc=ia.bias,Tc=ia.activation;ia=ia.preluActivationWeights;var hd=Cb?za.shape[2]:za.shape[1],Hd=gc?Xa.shape[1]:Xa.shape[2],$d=Math.max(za.shape[0],Xa.shape[0]),te=lc.upcastType(za.dtype,
Xa.dtype),He=null!=nc,Xd=null!=ia;Tc=Tc?Kc(Tc,!0):null;Cb=new Gb(za.shape,Xa.shape,[$d,hd,Hd],Cb,gc,He,Tc,Xd);za=[za,Xa];nc&&za.push(nc);ia&&za.push(ia);return this.compileAndRun(Cb,za,te)};sa.prototype.localResponseNormalization4D=function(ia,za,Xa,Cb,gc){za=lc.env().getBool("WEBGL_PACK_NORMALIZATION")?new Ea(ia.shape,za,Xa,Cb,gc):new ub(ia.shape,za,Xa,Cb,gc);return this.compileAndRun(za,[ia])};sa.prototype.LRNGrad=function(ia,za,Xa,Cb,gc,nc,Tc){Cb=new pb(za.shape,Cb,gc,nc,Tc);return this.compileAndRun(Cb,
[za,Xa,ia])};sa.prototype.tile=function(ia,za){if("string"===ia.dtype){var Xa=this.readSync(ia.dataId).map(function(Cb){return lc.util.decodeString(Cb)});ia=lc.buffer(ia.shape,ia.dtype,Xa);return ne(ia,za)}za=new bd(ia.shape,za);return this.compileAndRun(za,[ia])};sa.prototype.pad=function(ia,za,Xa){za=lc.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ae(ia.shape,za,Xa):new Cd(ia.shape,za,Xa);return this.compileAndRun(za,[ia])};sa.prototype.gather=function(ia,za,Xa){var Cb=this,gc=this.tryRunOnCpuOrThrow([ia,
za],function(){return Cb.cpuBackend.gather(ia,za,Xa)});if(gc)return gc;gc=new Gf(ia.shape,za.size,Xa);return this.compileAndRun(gc,[ia,za])};sa.prototype.batchToSpaceND=function(ia,za,Xa){lc.util.assert(4>=ia.rank,function(){return"batchToSpaceND for rank \x3e 4 with a WebGL backend not implemented yet"});var Cb=za.reduce(function(hd,Hd){return hd*Hd}),gc=lc.backend_util.getReshaped(ia.shape,za,Cb),nc=lc.backend_util.getPermuted(gc.length,za.length);Cb=lc.backend_util.getReshapedPermuted(ia.shape,
za,Cb);var Tc=lc.backend_util.getSliceBeginCoords(Xa,za.length);za=lc.backend_util.getSliceSize(Cb,Xa,za.length);return lc.transpose(ia.reshape(gc),nc).reshape(Cb).slice(Tc,za)};sa.prototype.spaceToBatchND=function(ia,za,Xa){lc.util.assert(4>=ia.rank,function(){return"spaceToBatchND for rank \x3e 4 with a WebGL backend not implemented yet"});var Cb=za.reduce(function(nc,Tc){return nc*Tc}),gc=[[0,0]];gc.push.apply(gc,Xa);for(Xa=1+za.length;Xa<ia.shape.length;++Xa)gc.push([0,0]);ia=ia.pad(gc);gc=lc.backend_util.getReshaped(ia.shape,
za,Cb,!1);Xa=lc.backend_util.getPermuted(gc.length,za.length,!1);za=lc.backend_util.getReshapedPermuted(ia.shape,za,Cb,!1);Cb=lc.transpose(ia.reshape(gc),Xa);return lc.reshape(Cb,za)};sa.prototype.reduce=function(ia,za,Xa){var Cb=ia.shape[0],gc=ia.shape[1],nc=lc.backend_util.computeOptimalWindowSize(gc);Cb=new Qf({windowSize:nc,inSize:gc,batchSize:Cb,outSize:Math.ceil(gc/nc)},za);ia=this.compileAndRun(Cb,[ia],Xa);return 1===ia.shape[1]?ia:this.reduce(ia,za,Xa)};sa.prototype.argReduce=function(ia,
za,Xa){void 0===Xa&&(Xa=null);var Cb=ia.shape[0],gc=ia.shape[1];null!=Xa&&(Cb=Xa.shape[0],gc=Xa.shape[1]);var nc=lc.backend_util.computeOptimalWindowSize(gc);Cb=new Lc({windowSize:nc,inSize:gc,batchSize:Cb,outSize:Math.ceil(gc/nc)},za,null==Xa);gc=[ia];null!=Xa&&gc.push(Xa);Xa=this.compileAndRun(Cb,gc,"int32");return 1===Xa.shape[1]?Xa:this.argReduce(ia,za,Xa)};sa.prototype.argReducePacked=function(ia,za,Xa){void 0===Xa&&(Xa=null);var Cb=null!=Xa?Xa.shape:ia.shape,gc=lc.backend_util.computeOptimalWindowSize(Cb[Cb.length-
1]);Cb=new qe(Cb,gc,za,null==Xa);Xa=this.compileAndRun(Cb,null==Xa?[ia]:[ia,Xa],"int32");return Xa.rank===ia.rank?this.argReducePacked(ia,za,Xa):Xa};sa.prototype.sum=function(ia,za){lc.backend_util.assertAxesAreInnerMostDims("sum",za,ia.rank);var Xa=lc.backend_util.computeOutAndReduceShapes(ia.shape,za);za=Xa[0];Xa=lc.util.sizeFromShape(Xa[1]);Xa=ia.as2D(-1,Xa);ia=lc.sumOutType(ia.dtype);return this.reduce(Xa,"sum",ia).reshape(za)};sa.prototype.prod=function(ia,za){var Xa=this,Cb=this.tryRunOnCpuOrThrow([ia],
function(){return Xa.cpuBackend.prod(ia,za)});if(Cb)return Cb;var gc=lc.backend_util.computeOutAndReduceShapes(ia.shape,za);Cb=gc[0];gc=lc.util.sizeFromShape(gc[1]);gc=ia.as2D(-1,gc);var nc=lc.sumOutType(ia.dtype);return this.reduce(gc,"prod",nc).reshape(Cb)};sa.prototype.unsortedSegmentSum=function(ia,za,Xa){var Cb=0,gc=lc.backend_util.getAxesPermutation([Cb],ia.rank),nc=ia;null!=gc&&(nc=lc.transpose(ia,gc),Cb=lc.backend_util.getInnerMostAxes(1,ia.rank)[0]);var Tc=Nd.computeOutShape(nc.shape,Cb,
Xa);Cb=lc.util.sizeFromShape([nc.shape[Cb]]);nc=nc.as2D(-1,Cb);ia=lc.sumOutType(ia.dtype);za=this.segOpCompute(nc,"unsortedSegmentSum",za,ia,Xa).reshape(Tc);null!=gc&&(za=lc.transpose(za,lc.backend_util.getUndoAxesPermutation(gc)));return za};sa.prototype.segOpCompute=function(ia,za,Xa,Cb,gc){var nc=ia.shape[0],Tc=ia.shape[1],hd=Nd.segOpComputeOptimalWindowSize(Tc,gc);nc=new mb({windowSize:hd,inSize:Tc,batchSize:nc,numSegments:gc},za);ia=this.compileAndRun(nc,[ia,Xa],Cb);if(ia.shape[1]===gc)return ia;
Xa=lc.range(0,gc).tile([Tc/hd]);return this.segOpCompute(ia,za,Xa,Cb,gc)};sa.prototype.argMinMaxReduce=function(ia,za,Xa){za=[za];lc.backend_util.assertAxesAreInnerMostDims("arg"+Xa.charAt(0).toUpperCase()+Xa.slice(1),za,ia.rank);if(!lc.env().getBool("WEBGL_PACK_REDUCE")||2>=ia.rank){var Cb=lc.backend_util.computeOutAndReduceShapes(ia.shape,za);za=Cb[0];Cb=lc.util.sizeFromShape(Cb[1]);ia=ia.as2D(-1,Cb);return this.argReduce(ia,Xa).reshape(za)}return this.argReducePacked(ia,Xa)};sa.prototype.argMin=
function(ia,za){return this.argMinMaxReduce(ia,za,"min")};sa.prototype.argMax=function(ia,za){return this.argMinMaxReduce(ia,za,"max")};sa.prototype.cumsum=function(ia,za,Xa,Cb){if(za!==ia.rank-1)throw Error("WebGL cumsum shader expects an inner-most axis\x3d"+(ia.rank-1)+" but got axis\x3d"+za);za=ia.shape[za];for(var gc=ia,nc=0;nc<=Math.ceil(Math.log2(za))-1;nc++){var Tc=new Lf(ia.shape,!1,Cb),hd=Tc.getCustomSetupFunc(nc),Hd=gc;gc=this.compileAndRun(Tc,[gc],gc.dtype,hd);Hd.dispose()}Xa&&(Tc=new Lf(ia.shape,
Xa,Cb),Hd=gc,gc=this.compileAndRun(Tc,[gc]),Hd.dispose());return gc};sa.prototype.equal=function(ia,za){if(lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(ia,za,"\n  return vec4(equal(a, b));\n","bool");var Xa=new nb("return float(a \x3d\x3d b);",ia.shape,za.shape);return this.compileAndRun(Xa,[ia,za],"bool")};sa.prototype.less=function(ia,za){var Xa=this,Cb=this.tryRunOnCpuOrThrow([ia,za],function(){return Xa.cpuBackend.less(ia,za)});if(Cb)return Cb;if(lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(ia,
za,"\n  return vec4(lessThan(a, b));\n","bool");Cb=new nb("return float(a \x3c b);",ia.shape,za.shape);return this.compileAndRun(Cb,[ia,za],"bool")};sa.prototype.lessEqual=function(ia,za){if(lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(ia,za,"\n  return vec4(lessThanEqual(a, b));\n","bool");var Xa=new nb("return float(a \x3c\x3d b);",ia.shape,za.shape);return this.compileAndRun(Xa,[ia,za],"bool")};sa.prototype.greater=function(ia,za){var Xa=this,Cb=this.tryRunOnCpuOrThrow([ia,
za],function(){return Xa.cpuBackend.greater(ia,za)});if(Cb)return Cb;if(lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(ia,za,"\n  return vec4(greaterThan(a, b));\n","bool");Cb=new nb("return float(a \x3e b);",ia.shape,za.shape);return this.compileAndRun(Cb,[ia,za],"bool")};sa.prototype.greaterEqual=function(ia,za){if(lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(ia,za,"\n  return vec4(greaterThanEqual(a, b));\n","bool");var Xa=new nb("return float(a \x3e\x3d b);",
ia.shape,za.shape);return this.compileAndRun(Xa,[ia,za],"bool")};sa.prototype.logicalNot=function(ia){var za=new id(ia.shape,"return float(!(x \x3e\x3d 1.0));");return this.compileAndRun(za,[ia])};sa.prototype.logicalAnd=function(ia,za){if(lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(ia,za,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");var Xa=new nb("return float(a \x3e\x3d 1.0 \x26\x26 b \x3e\x3d 1.0);",
ia.shape,za.shape);return this.compileAndRun(Xa,[ia,za],"bool")};sa.prototype.logicalOr=function(ia,za){if(lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(ia,za,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");var Xa=new nb("return float(a \x3e\x3d 1.0 || b \x3e\x3d 1.0);",ia.shape,za.shape);return this.compileAndRun(Xa,[ia,za],"bool")};sa.prototype.select=function(ia,za,Xa){var Cb=new Bb(ia.rank,
za.shape,za.rank);return this.compileAndRun(Cb,[ia,za,Xa],lc.upcastType(za.dtype,Xa.dtype))};sa.prototype.where=function(ia){lc.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var za=ia.dataSync();return Vd(ia.shape,za)};sa.prototype.topk=function(ia,za,Xa){var Cb=ia.dataSync();return xe(Cb,ia.shape,ia.dtype,za,Xa)};sa.prototype.min=function(ia,za){lc.backend_util.assertAxesAreInnerMostDims("min",za,ia.rank);var Xa=lc.backend_util.computeOutAndReduceShapes(ia.shape,
za);za=Xa[0];Xa=lc.util.sizeFromShape(Xa[1]);ia=ia.as2D(-1,Xa);return this.reduce(ia,"min",ia.dtype).reshape(za)};sa.prototype.minimum=function(ia,za){var Xa=this,Cb=this.tryRunOnCpuOrThrow([ia,za],function(){return Xa.cpuBackend.minimum(ia,za)});if(Cb)return Cb;Cb=lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Db("\n  vec4 result \x3d vec4(min(a, b));\n  vec4 isNaN \x3d min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r \x3d isNaN.r \x3e 0. ? NAN : result.r;\n  result.g \x3d isNaN.g \x3e 0. ? NAN : result.g;\n  result.b \x3d isNaN.b \x3e 0. ? NAN : result.b;\n  result.a \x3d isNaN.a \x3e 0. ? NAN : result.a;\n\n  return result;\n",
ia.shape,za.shape):new nb("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",ia.shape,za.shape);return this.compileAndRun(Cb,[ia,za])};sa.prototype.mod=function(ia,za){var Xa=lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Db("\n  vec4 result \x3d mod(a, b);\n  vec4 isNaN \x3d vec4(equal(b, vec4(0.0)));\n  \n  result.r \x3d isNaN.r \x3e 0. ? NAN : result.r;\n  result.g \x3d isNaN.g \x3e 0. ? NAN : result.g;\n  result.b \x3d isNaN.b \x3e 0. ? NAN : result.b;\n  result.a \x3d isNaN.a \x3e 0. ? NAN : result.a;\n\n  return result;\n",
ia.shape,za.shape):new nb("if (b \x3d\x3d 0.0) return NAN;\n  return mod(a, b);",ia.shape,za.shape);return this.compileAndRun(Xa,[ia,za])};sa.prototype.maximum=function(ia,za){var Xa=this,Cb=this.tryRunOnCpuOrThrow([ia,za],function(){return Xa.cpuBackend.maximum(ia,za)});if(Cb)return Cb;Cb=lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Db("\n  vec4 result \x3d vec4(max(a, b));\n  vec4 isNaN \x3d min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r \x3d isNaN.r \x3e 0. ? NAN : result.r;\n  result.g \x3d isNaN.g \x3e 0. ? NAN : result.g;\n  result.b \x3d isNaN.b \x3e 0. ? NAN : result.b;\n  result.a \x3d isNaN.a \x3e 0. ? NAN : result.a;\n\n  return result;\n",
ia.shape,za.shape):new nb("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",ia.shape,za.shape);return this.compileAndRun(Cb,[ia,za])};sa.prototype.all=function(ia,za){lc.backend_util.assertAxesAreInnerMostDims("all",za,ia.rank);var Xa=lc.backend_util.computeOutAndReduceShapes(ia.shape,za);za=Xa[0];Xa=lc.util.sizeFromShape(Xa[1]);ia=ia.as2D(-1,Xa);return this.reduce(ia,"all",ia.dtype).reshape(za)};sa.prototype.any=function(ia,za){lc.backend_util.assertAxesAreInnerMostDims("any",
za,ia.rank);var Xa=lc.backend_util.computeOutAndReduceShapes(ia.shape,za);za=Xa[0];Xa=lc.util.sizeFromShape(Xa[1]);ia=ia.as2D(-1,Xa);return this.reduce(ia,"any",ia.dtype).reshape(za)};sa.prototype.floorDiv=function(ia,za){if(lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(ia,za,"\n  ivec4 ia \x3d round(a);\n  ivec4 ib \x3d round(b);\n  bvec4 cond \x3d notEqual(ib, ivec4(0));\n  ivec4 result \x3d ivec4(0);\n  vec4 s \x3d sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] \x3d idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] \x3d idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] \x3d idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] \x3d idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",
"int32");var Xa=new nb("\n  float s \x3d sign(a) * sign(b);\n  int ia \x3d round(a);\n  int ib \x3d round(b);\n  if (ib !\x3d 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",ia.shape,za.shape);return this.compileAndRun(Xa,[ia,za],"int32")};sa.prototype.packedUnaryOp=function(ia,za,Xa){za=new Bd(ia.shape,za);return this.compileAndRun(za,[ia],Xa)};sa.prototype.packedBinaryOp=function(ia,za,Xa,
Cb,gc){void 0===gc&&(gc=!1);Xa=new Db(Xa,ia.shape,za.shape,gc);return this.compileAndRun(Xa,[ia,za],Cb)};sa.prototype.makeComplexComponentTensorInfo=function(ia,za){return{dataId:za.dataId,dtype:za.dtype,shape:ia.shape}};sa.prototype.addN=function(ia){if(1===ia.length)return ia[0];if(ia.length>lc.env().get("WEBGL_MAX_TEXTURES_IN_SHADER")){var za=Math.floor(ia.length/2),Xa=this.addN(ia.slice(0,za));ia=this.addN(ia.slice(za));return this.addN([Xa,ia])}Xa=ia.map(function(Cb){return Cb.dtype}).reduce(function(Cb,
gc){return lc.upcastType(Cb,gc)});za=ia.map(function(Cb){return Cb.shape});za=lc.env().getBool("WEBGL_PACK")?new oc(ia[0].shape,za):new Lb(ia[0].shape,za);return this.compileAndRun(za,ia,Xa)};sa.prototype.pow=function(ia,za){var Xa=lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Db("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) \x3d\x3d 1, 0 otherwise.\n  vec4 isModRound1 \x3d vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier \x3d sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result \x3d multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 \x3d 1, including 0^0 \x3d 1 as this correspond to TF and JS\n  bvec4 isExpZero \x3d equal(b, vec4(0.0));\n  result.r \x3d isExpZero.r ? 1.0 : result.r;\n  result.g \x3d isExpZero.g ? 1.0 : result.g;\n  result.b \x3d isExpZero.b ? 1.0 : result.b;\n  result.a \x3d isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN \x3d vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r \x3d isNaN.r \x3e 0. ? NAN : result.r;\n  result.g \x3d isNaN.g \x3e 0. ? NAN : result.g;\n  result.b \x3d isNaN.b \x3e 0. ? NAN : result.b;\n  result.a \x3d isNaN.a \x3e 0. ? NAN : result.a;\n\n  return result;\n",
ia.shape,za.shape):new nb("\nif(a \x3c 0.0 \x26\x26 floor(b) \x3c b){\n  return NAN;\n}\nif (b \x3d\x3d 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) !\x3d 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",ia.shape,za.shape),Cb=lc.upcastType(ia.dtype,za.dtype);return this.compileAndRun(Xa,[ia,za],Cb)};sa.prototype.ceil=function(ia){if(this.shouldExecuteOnCPU([ia])){var za=fc(this.texData.get(ia.dataId).values,ia.dtype);return this.makeOutput(ia.shape,ia.dtype,za)}if(lc.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(ia,
"return ceil(x);",ia.dtype);za=new id(ia.shape,"return ceil(x);");return this.compileAndRun(za,[ia])};sa.prototype.floor=function(ia){if(this.shouldExecuteOnCPU([ia])){var za=Ad(this.texData.get(ia.dataId).values,ia.dtype);return this.makeOutput(ia.shape,ia.dtype,za)}if(lc.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(ia,"return floor(x);",ia.dtype);za=new id(ia.shape,"return floor(x);");return this.compileAndRun(za,[ia])};sa.prototype.sign=function(ia){var za=new id(ia.shape,
"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(za,[ia])};sa.prototype.isNaN=function(ia){var za=new id(ia.shape,"return float(isnan(x));");return this.compileAndRun(za,[ia],"bool")};sa.prototype.isInf=function(ia){var za=new id(ia.shape,"return float(isinf(x));");return this.compileAndRun(za,[ia],"bool")};sa.prototype.isFinite=function(ia){var za=new id(ia.shape,"return float(!isnan(x) \x26\x26 !isinf(x));");return this.compileAndRun(za,[ia],"bool")};sa.prototype.round=
function(ia){var za=new id(ia.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base \x3d floor(x);\n  if ((x - base) \x3c 0.5) {\n    return floor(x);\n  } else if ((x - base) \x3e 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) \x3d\x3d 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(za,[ia])};sa.prototype.exp=function(ia){if(this.shouldExecuteOnCPU([ia])){var za=
yc(this.texData.get(ia.dataId).values,ia.dtype);return this.makeOutput(ia.shape,ia.dtype,za)}if(lc.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(ia,"return exp(x);",ia.dtype);za=new id(ia.shape,"return exp(x);");return this.compileAndRun(za,[ia])};sa.prototype.expm1=function(ia){if(this.shouldExecuteOnCPU([ia])){var za=fd(this.texData.get(ia.dataId).values,ia.dtype);return this.makeOutput(ia.shape,ia.dtype,za)}if(lc.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(ia,
"return exp(x) - 1.0;",ia.dtype);za=new id(ia.shape,"return exp(x) - 1.0;");return this.compileAndRun(za,[ia])};sa.prototype.softmax=function(ia,za){za=lc.util.parseAxisParam([za],ia.shape);var Xa=lc.max(ia,za),Cb=lc.backend_util.expandShapeToKeepDim(Xa.shape,za);ia=lc.sub(ia,Xa.reshape(Cb));ia=this.exp(ia);za=this.sum(ia,za).reshape(Cb);return lc.div(ia,za)};sa.prototype.log=function(ia){if(this.shouldExecuteOnCPU([ia])){var za=Gd(this.texData.get(ia.dataId).values,ia.dtype);return this.makeOutput(ia.shape,
ia.dtype,za)}if(lc.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(ia,"\n  vec4 result \x3d log(x);\n  vec4 isNaN \x3d vec4(lessThan(x, vec4(0.0)));\n  result.r \x3d isNaN.r \x3d\x3d 1.0 ? NAN : result.r;\n  result.g \x3d isNaN.g \x3d\x3d 1.0 ? NAN : result.g;\n  result.b \x3d isNaN.b \x3d\x3d 1.0 ? NAN : result.b;\n  result.a \x3d isNaN.a \x3d\x3d 1.0 ? NAN : result.a;\n\n  return result;\n",ia.dtype);za=new id(ia.shape,"if (x \x3c 0.0) return NAN;\n  return log(x);");return this.compileAndRun(za,
[ia])};sa.prototype.log1p=function(ia){var za=new id(ia.shape,"return log(1.0 + x);");return this.compileAndRun(za,[ia])};sa.prototype.sqrt=function(ia){var za=new id(ia.shape,"return sqrt(x);");return this.compileAndRun(za,[ia])};sa.prototype.rsqrt=function(ia){if(this.shouldExecuteOnCPU([ia])){var za=Re(this.texData.get(ia.dataId).values,ia.dtype);return this.makeOutput(ia.shape,ia.dtype,za)}za=new id(ia.shape,"return inversesqrt(x);");return this.compileAndRun(za,[ia])};sa.prototype.reciprocal=
function(ia){var za=new id(ia.shape,"return 1.0 / x;");return this.compileAndRun(za,[ia])};sa.prototype.relu=function(ia){var za=lc.env().getBool("WEBGL_PACK")?new Bd(ia.shape,"\n  vec4 result \x3d x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN \x3d isnan(x);\n\n  result.r \x3d isNaN.r ? x.r : result.r;\n  result.g \x3d isNaN.g ? x.g : result.g;\n  result.b \x3d isNaN.b ? x.b : result.b;\n  result.a \x3d isNaN.a ? x.a : result.a;\n\n  return result;\n"):new id(ia.shape,"if (isnan(x)) return x;\n  return (x \x3c 0.0) ? 0.0 : x;\n");
return this.compileAndRun(za,[ia])};sa.prototype.relu6=function(ia){var za=lc.env().getBool("WEBGL_PACK")?new Bd(ia.shape,"\n  vec4 result \x3d min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN \x3d isnan(x);\n\n  result.r \x3d isNaN.r ? x.r : result.r;\n  result.g \x3d isNaN.g ? x.g : result.g;\n  result.b \x3d isNaN.b ? x.b : result.b;\n  result.a \x3d isNaN.a ? x.a : result.a;\n\n  return result;\n"):new id(ia.shape,"if (isnan(x)) return x;\n  return (x \x3c 0.0) ? 0.0 : min(6.0, x);\n");
return this.compileAndRun(za,[ia])};sa.prototype.prelu=function(ia,za){var Xa=lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Db("\n  vec4 aLessThanZero \x3d vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",ia.shape,za.shape):new nb("return (a \x3c 0.) ? b * a : a;",ia.shape,za.shape);return this.compileAndRun(Xa,[ia,za])};sa.prototype.elu=function(ia){if(lc.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(ia,"\n  vec4 result;\n\n  result.r \x3d (x.r \x3e\x3d 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g \x3d (x.g \x3e\x3d 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b \x3d (x.b \x3e\x3d 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a \x3d (x.a \x3e\x3d 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",
ia.dtype);var za=new id(ia.shape,"return (x \x3e\x3d 0.0) ? x : (exp(x) - 1.0);");return this.compileAndRun(za,[ia])};sa.prototype.eluDer=function(ia,za){var Xa=lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Db("\n  vec4 bGTEZero \x3d vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",ia.shape,za.shape):new nb("return (b \x3e\x3d 1.0) ? a : a * (b + 1.0);",ia.shape,za.shape);return this.compileAndRun(Xa,[ia,za])};sa.prototype.selu=
function(ia){var za=new id(ia.shape,Ic);return this.compileAndRun(za,[ia])};sa.prototype.clip=function(ia,za,Xa){var Cb=lc.env().getBool("WEBGL_PACK_CLIP")?new uc(ia.shape):new dc(ia.shape);za=Cb.getCustomSetupFunc(za,Xa);return this.compileAndRun(Cb,[ia],null,za)};sa.prototype.abs=function(ia){if(this.shouldExecuteOnCPU([ia])&&"complex64"!==ia.dtype){{var za=this.texData.get(ia.dataId).values;const Xa=new Float32Array(za.length);for(let Cb=0;Cb<za.length;++Cb)Xa[Cb]=Math.abs(za[Cb]);za=Xa}return this.makeOutput(ia.shape,
ia.dtype,za)}if(lc.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(ia,"return abs(x);",ia.dtype);za=new id(ia.shape,"return abs(x);");return this.compileAndRun(za,[ia])};sa.prototype.complexAbs=function(ia){var za=this.texData.get(ia.dataId),Xa=new Qc(ia.shape);ia=[this.makeComplexComponentTensorInfo(ia,za.complexTensorInfos.real),this.makeComplexComponentTensorInfo(ia,za.complexTensorInfos.imag)];return this.compileAndRun(Xa,ia)};sa.prototype.sigmoid=function(ia){var za=new id(ia.shape,
"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(za,[ia])};sa.prototype.softplus=function(ia){var za=new id(ia.shape,"\n  float epsilon \x3d 1.1920928955078125e-7;\n  float threshold \x3d log(epsilon) + 2.0;\n\n  bool too_large \x3d x \x3e -threshold;\n  bool too_small \x3d x \x3c threshold;\n\n  float result;\n  float exp_x \x3d exp(x);\n\n  if (too_large){\n    result \x3d x;\n  }\n  else if (too_small){\n    result \x3d exp_x;\n  }\n  else{\n    result \x3d log(exp_x + 1.0);\n  }\n  return result;\n");
return this.compileAndRun(za,[ia])};sa.prototype.asin=function(ia){var za=new id(ia.shape,"if (isnan(x)) return x;\n  if (abs(x) \x3e 1.) {\n    return NAN;\n  }\n  return asin(x);\n");return this.compileAndRun(za,[ia])};sa.prototype.acos=function(ia){var za=new id(ia.shape,"if (isnan(x)) return x;\n  if (abs(x) \x3e 1.) {\n    return NAN;\n  }\n  return acos(x);\n");return this.compileAndRun(za,[ia])};sa.prototype.atan=function(ia){var za=new id(ia.shape,"if (isnan(x)) return x;\n  return atan(x);\n");
return this.compileAndRun(za,[ia])};sa.prototype.sinh=function(ia){var za=new id(ia.shape,"\n  float e2x \x3d exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(za,[ia])};sa.prototype.cosh=function(ia){var za=new id(ia.shape,"\n  float e2x \x3d exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(za,[ia])};sa.prototype.tanh=function(ia){var za=new id(ia.shape,"\n  float e2x \x3d exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(za,
[ia])};sa.prototype.asinh=function(ia){var za=new id(ia.shape,"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));");return this.compileAndRun(za,[ia])};sa.prototype.acosh=function(ia){var za=new id(ia.shape,"if (isnan(x)) return x;\n  if (x \x3c 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));");return this.compileAndRun(za,[ia])};sa.prototype.atanh=function(ia){var za=new id(ia.shape,"if (isnan(x)) return x;\n  if ((x \x3c -1.0) || (x \x3e 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;");
return this.compileAndRun(za,[ia])};sa.prototype.erf=function(ia){var za=new id(ia.shape,Kd);return this.compileAndRun(za,[ia])};sa.prototype.step=function(ia,za){var Xa=ia.shape;void 0===za&&(za=0);Xa=new id(Xa,"if (isnan(x)) return x;\n    return x \x3e 0.0 ? 1.0 : float("+(za+");\n  "));return this.compileAndRun(Xa,[ia])};sa.prototype.conv2dByMatMul=function(ia,za,Xa,Cb,gc,nc){var Tc=ia.shape,hd=this.texData.get(ia.dataId),Hd=Xa.inChannels,$d=Xa.outChannels,te="channelsLast"===Xa.dataFormat,He=
0!==Tc[2]%2&&!!hd.isPacked;if((1===Tc[0]*Tc[1]*Tc[2]||1===$d)&&1E3<Hd||!lc.env().getBool("WEBGL_LAZILY_UNPACK")||!lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!He)return ia=lc.reshape(ia,[1,te?Tc[0]*Tc[1]*Tc[2]:Tc[0]*Tc[2]*Tc[3],Xa.inChannels]),za=lc.reshape(za,[1,Xa.inChannels,Xa.outChannels]),Cb=this.fusedBatchMatMul({a:ia,b:za,transposeA:!1,transposeB:!1,bias:Cb,activation:gc,preluActivationWeights:nc}),lc.reshape(Cb,Xa.outShape);var Xd={dataId:ia.dataId,shape:[1,te?Tc[0]*Tc[1]*(Tc[2]+1):
Tc[0]*Tc[2]*(Tc[3]+1),Xa.inChannels],dtype:ia.dtype};ia=hd.shape;hd.shape=hd.shape.slice();hd.shape[hd.shape.length-2]++;lc.util.assert(Z(hd.shape,Xd.shape),function(){return"packed reshape "+hd.shape+" to "+Xd.shape+" isn't free"});za=lc.reshape(za,[1,Xa.inChannels,Xa.outChannels]);Cb=this.fusedBatchMatMul({a:Xd,b:za,transposeA:!1,transposeB:!1,bias:Cb,activation:gc,preluActivationWeights:nc});gc=this.texData.get(Cb.dataId);lc.util.assert(gc.isPacked,function(){return"batchMatMul result is expected to be packed"});
hd.shape=ia;gc.shape=Xa.outShape;return lc.engine().makeTensorFromDataId(Cb.dataId,Xa.outShape,Cb.dtype)};sa.prototype.conv2dWithIm2Row=function(ia,za,Xa,Cb,gc,nc){var Tc=Xa.outWidth,hd=Xa.outHeight,Hd="channelsLast"===Xa.dataFormat,$d=Xa.filterWidth*Xa.filterHeight*Xa.inChannels,te=hd*Tc,He=[$d,te];ia=ia.squeeze([0]);za=za.reshape([1,$d,-1]);$d=new eb(He,ia.shape,Xa);ia=this.compileAndRun($d,[ia]).reshape([1,He[0],He[1]]);$d=null!=Cb;He=null!=nc;gc=gc?Kc(gc,!0):null;te=new Gb(ia.shape,za.shape,[1,
te,Xa.outChannels],!0,!1,$d,gc,He);gc=[ia,za];Cb&&gc.push(Cb);He&&gc.push(nc);Cb=this.compileAndRun(te,gc);return Hd?Cb.reshape([1,hd,Tc,Xa.outChannels]):Cb.reshape([1,Xa.outChannels,hd,Tc])};sa.prototype.fusedConv2d=function(ia){var za=ia.input,Xa=ia.filter,Cb=ia.convInfo,gc=ia.bias,nc=ia.activation;ia=ia.preluActivationWeights;if(1===Cb.filterHeight&&1===Cb.filterWidth&&1===Cb.dilationHeight&&1===Cb.dilationWidth&&1===Cb.strideHeight&&1===Cb.strideWidth&&("SAME"===Cb.padInfo.type||"VALID"===Cb.padInfo.type))return this.conv2dByMatMul(za,
Xa,Cb,gc,nc,ia);if(lc.env().getBool("WEBGL_CONV_IM2COL")&&1===za.shape[0])return this.conv2dWithIm2Row(za,Xa,Cb,gc,nc,ia);var Tc=null!=gc,hd=null!=ia;nc=nc?Kc(nc,!1):null;Cb=new Te(Cb,Tc,nc,hd);za=[za,Xa];gc&&za.push(gc);ia&&za.push(ia);return this.compileAndRun(Cb,za)};sa.prototype.conv2d=function(ia,za,Xa){if(1===Xa.filterHeight&&1===Xa.filterWidth&&1===Xa.dilationHeight&&1===Xa.dilationWidth&&1===Xa.strideHeight&&1===Xa.strideWidth&&("SAME"===Xa.padInfo.type||"VALID"===Xa.padInfo.type))return this.conv2dByMatMul(ia,
za,Xa);if(lc.env().getBool("WEBGL_CONV_IM2COL")&&1===ia.shape[0])return this.conv2dWithIm2Row(ia,za,Xa);Xa=new Te(Xa);return this.compileAndRun(Xa,[ia,za])};sa.prototype.conv2dDerInput=function(ia,za,Xa){Xa=new Fd(Xa);return this.compileAndRun(Xa,[ia,za])};sa.prototype.conv2dDerFilter=function(ia,za,Xa){Xa=new ud(Xa);return this.compileAndRun(Xa,[ia,za])};sa.prototype.fusedDepthwiseConv2D=function(ia){var za=ia.input,Xa=ia.filter,Cb=ia.convInfo,gc=ia.bias,nc=ia.activation;ia=ia.preluActivationWeights;
var Tc=lc.env().getBool("WEBGL_PACK_DEPTHWISECONV")&&2>=Cb.strideWidth&&1===Cb.outChannels/Cb.inChannels;nc=nc?Kc(nc,Tc):null;za=[za,Xa];Xa=null!=gc;var hd=null!=ia;Xa&&za.push(gc);hd&&za.push(ia);if(Tc)return Cb=new nf(Cb,Xa,nc,hd),this.compileAndRun(Cb,za);Cb=new We(Cb,Xa,nc,hd);return this.compileAndRun(Cb,za)};sa.prototype.depthwiseConv2D=function(ia,za,Xa){if(lc.env().getBool("WEBGL_PACK_DEPTHWISECONV")&&2>=Xa.strideWidth&&1===Xa.outChannels/Xa.inChannels)return Xa=new nf(Xa),this.compileAndRun(Xa,
[ia,za]);Xa=new We(Xa);return this.compileAndRun(Xa,[ia,za])};sa.prototype.depthwiseConv2DDerInput=function(ia,za,Xa){Xa=new Zd(Xa);return this.compileAndRun(Xa,[ia,za])};sa.prototype.depthwiseConv2DDerFilter=function(ia,za,Xa){Xa=new wd(Xa);return this.compileAndRun(Xa,[ia,za])};sa.prototype.conv3d=function(ia,za,Xa){Xa=new re(Xa);return this.compileAndRun(Xa,[ia,za])};sa.prototype.conv3dDerInput=function(ia,za,Xa){Xa=new sd(Xa);return this.compileAndRun(Xa,[ia,za])};sa.prototype.conv3dDerFilter=
function(ia,za,Xa){Xa=new je(Xa);return this.compileAndRun(Xa,[ia,za])};sa.prototype.unstack=function(ia,za){for(var Xa=ia.shape[za],Cb=Array(ia.rank-1),gc=0,nc=0;nc<ia.rank;nc++)nc!==za&&(Cb[gc++]=ia.shape[nc]);gc=Array(ia.rank).fill(0);var Tc=ia.shape.slice();Tc[za]=1;Xa=Array(Xa);for(nc=0;nc<Xa.length;nc++)gc[za]=nc,Xa[nc]=this.slice(ia,gc,Tc).reshape(Cb);return Xa};sa.prototype.avgPool3d=function(ia,za){za=new ef(za,"avg",!1);return this.compileAndRun(za,[ia],"float32")};sa.prototype.avgPool3dBackprop=
function(ia,za,Xa){Xa=new Za(Xa);return this.compileAndRun(Xa,[ia],za.dtype)};sa.prototype.maxPool3d=function(ia,za){za=new ef(za,"max",!1);return this.compileAndRun(za,[ia],"float32")};sa.prototype.maxPool3dBackprop=function(ia,za,Xa,Cb){Xa=new ef(Cb,"max",!0);Xa=this.compileAndRun(Xa,[za]);Cb=new fb(Cb);ia=this.compileAndRun(Cb,[ia,Xa],za.dtype);Xa.dispose();return ia};sa.prototype.resizeBilinear=function(ia,za,Xa,Cb){za=lc.env().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new If(ia.shape,za,Xa,Cb):
new rg(ia.shape,za,Xa,Cb);return this.compileAndRun(za,[ia],"float32")};sa.prototype.resizeBilinearBackprop=function(ia,za,Xa){za=new Df(ia,za,Xa);return this.compileAndRun(za,[ia])};sa.prototype.resizeNearestNeighbor=function(ia,za,Xa,Cb){za=new Ua(ia.shape,za,Xa,Cb);return this.compileAndRun(za,[ia])};sa.prototype.resizeNearestNeighborBackprop=function(ia,za,Xa){za=new ag(ia,za,Xa);return this.compileAndRun(za,[ia])};sa.prototype.multinomial=function(ia,za,Xa,Cb){ia=za?ia:lc.softmax(ia);Xa=new Vb(ia.shape[0],
ia.shape[1],Xa);Cb=Xa.getCustomSetupFunc(Cb);return this.compileAndRun(Xa,[ia],"int32",Cb)};sa.prototype.oneHot=function(ia,za,Xa,Cb){za=new Hc(ia.size,za,Xa,Cb);return this.compileAndRun(za,[ia])};sa.prototype.diag=function(ia){var za=new Uf(ia.size);return this.compileAndRun(za,[ia])};sa.prototype.cropAndResize=function(ia,za,Xa,Cb,gc,nc){Cb=new bg(ia.shape,za.shape,Cb,gc,nc);return this.compileAndRun(Cb,[ia,za,Xa],"float32")};sa.prototype.depthToSpace=function(ia,za,Xa){lc.util.assert(1<za,function(){return"blockSize should be \x3e 1 for depthToSpace, but was: "+
za});var Cb=ia.shape[0],gc=("NHWC"===Xa?ia.shape[1]:ia.shape[2])*za,nc=("NHWC"===Xa?ia.shape[2]:ia.shape[3])*za,Tc=("NHWC"===Xa?ia.shape[3]:ia.shape[1])/(za*za);Xa=new Bg("NHWC"===Xa?[Cb,gc,nc,Tc]:[Cb,Tc,gc,nc],za,Xa);return this.compileAndRun(Xa,[ia])};sa.prototype.split=function(ia,za,Xa){return de(ia,za,Xa)};sa.prototype.scatterND=function(ia,za,Xa){var Cb=lc.backend_util.calculateShapes(za,ia,Xa),gc=Cb.sliceRank,nc=Cb.numUpdates,Tc=Cb.sliceSize,hd=Cb.strides,Hd=Cb.outputSize;Cb=[Hd/Tc,Tc];ia=
ia.reshape([nc,gc]);za=za.reshape([nc,Tc]);if(0===Hd)return lc.backend_util.reshapeTensor(lc.tensor([]),Xa);Tc=lc.scalar(0);gc=new Da(nc,gc,ia.rank,za.rank,hd,Cb);return this.compileAndRun(gc,[za,ia,Tc]).reshape(Xa)};sa.prototype.sparseToDense=function(ia,za,Xa,Cb){var gc=lc.backend_util.calculateShapes(za,ia,Xa);gc=new Da(gc.numUpdates,gc.sliceRank,ia.rank,za.rank,gc.strides,[gc.outputSize,1],!1);return this.compileAndRun(gc,[za,ia,Cb]).reshape(Xa)};sa.prototype.gatherND=function(ia,za){var Xa=za.shape,
Cb=Xa[Xa.length-1],gc=lc.backend_util.prepareAndValidate(ia,za);Xa=gc[0];var nc=gc[1],Tc=gc[2];gc=gc[3];za=za.reshape([nc,Cb]);ia=ia.reshape([ia.size/Tc,Tc]);Cb=new ad(Cb,gc,[nc,Tc]);return this.compileAndRun(Cb,[ia,za]).reshape(Xa)};sa.prototype.fill=function(ia,za,Xa){Xa=Xa||lc.util.inferDtype(za);if("string"===Xa){var Cb=lc.util.getArrayFromDType(Xa,lc.util.sizeFromShape(ia));Cb.fill(za);return lc.engine().makeTensor(Cb,ia,Xa,this)}ia=new gf(ia,za);za=ia.getCustomSetupFunc(za);return this.compileAndRun(ia,
[],Xa,za)};sa.prototype.onesLike=function(ia){if("string"===ia.dtype)throw Error("onesLike is not supported under string dtype");return this.fill(ia.shape,1,ia.dtype)};sa.prototype.zerosLike=function(ia){return this.fill(ia.shape,"string"===ia.dtype?"":0,ia.dtype)};sa.prototype.linspace=function(ia,za,Xa){return lc.backend_util.linspaceImpl(ia,za,Xa)};sa.prototype.makeTensorInfo=function(ia,za,Xa){Xa=this.write(Xa,ia,za);this.texData.get(Xa).usage=null;return{dataId:Xa,shape:ia,dtype:za}};sa.prototype.makeOutput=
function(ia,za,Xa){Xa=this.makeTensorInfo(ia,za,Xa).dataId;return lc.engine().makeTensorFromDataId(Xa,ia,za,this)};sa.prototype.unpackTensor=function(ia){var za=new vd(ia.shape);return this.runWebGLProgram(za,[ia],ia.dtype)};sa.prototype.packTensor=function(ia){var za=new md(ia.shape);return this.runWebGLProgram(za,[ia],ia.dtype,null,!0)};sa.prototype.packedReshape=function(ia,za){var Xa=[I(ia.shape)].concat(T(ia.shape)),Cb={dtype:ia.dtype,shape:Xa,dataId:ia.dataId},gc=[I(za)].concat(T(za));Xa=new Zf(gc,
Xa);ia=this.runWebGLProgram(Xa,[Cb],ia.dtype,null,!0);return{dataId:ia.dataId,shape:za,dtype:ia.dtype}};sa.prototype.decode=function(ia){var za=this.texData.get(ia),Xa=za.isPacked,Cb=za.shape;za=za.dtype;var gc=aa(Cb);Xa=Xa?new Pf(gc):new Wf(gc);ia=this.runWebGLProgram(Xa,[{shape:gc,dtype:za,dataId:ia}],za,null,!0);return{dtype:za,shape:Cb,dataId:ia.dataId}};sa.prototype.runWebGLProgram=function(ia,za,Xa,Cb,gc){var nc=this;void 0===gc&&(gc=!1);Xa=this.makeTensorInfo(ia.outputShape,Xa);var Tc=this.texData.get(Xa.dataId);
ia.packedOutput&&(Tc.isPacked=!0);if(ia.outPackingScheme===Ib.DENSE){var hd=b(ia.outputShape);Tc.texShape=hd.map(function(Xd){return 2*Xd})}null!=ia.outTexUsage&&(Tc.usage=ia.outTexUsage);if(0===lc.util.sizeFromShape(Xa.shape))return Tc.values=lc.util.getTypedArrayFromDType(Xa.dtype,0),Xa;var Hd=[],$d=za.map(function(Xd){if("complex64"===Xd.dtype)throw Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var ye=nc.texData.get(Xd.dataId);
if(null==ye.texture){if(!ia.packedInputs&&lc.util.sizeFromShape(Xd.shape)<=lc.env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:Xd.shape,texData:null,isUniform:!0,uniformValues:ye.values};ia.packedInputs&&(ye.isPacked=!0,ye.shape=Xd.shape)}else if(!!ye.isPacked!==!!ia.packedInputs)Xd=ye.isPacked?nc.unpackTensor(Xd):nc.packTensor(Xd),Hd.push(Xd),ye=nc.texData.get(Xd.dataId);else if(ye.isPacked&&!Z(ye.shape,Xd.shape)){var cg=Xd,Ef=Xd.shape;Xd.shape=ye.shape;Xd=nc.packedReshape(Xd,Ef);Hd.push(Xd);
ye=nc.texData.get(Xd.dataId);cg.shape=Ef}nc.uploadToGPU(Xd.dataId);return{shape:Xd.shape,texData:ye,isUniform:!1}});this.uploadToGPU(Xa.dataId);var te={shape:Xa.shape,texData:Tc,isUniform:!1};za=kd(ia,$d,te);za=this.getAndSaveBinary(za,function(){return Ec(nc.gpgpu,ia,$d,te)});hd=null!=this.activeTimers;var He;hd&&(He=this.startTimer());Dc(this.gpgpu,za,$d,te,Cb);Hd.forEach(function(Xd){return nc.disposeIntermediateTensorInfo(Xd)});hd&&(He=this.endTimer(He),this.activeTimers.push({name:ia.constructor.name,
query:this.getQueryTime(He)}));return!lc.env().getBool("WEBGL_LAZILY_UNPACK")&&Tc.isPacked&&!1===gc?(Cb=this.unpackTensor(Xa),this.disposeIntermediateTensorInfo(Xa),Cb):Xa};sa.prototype.compileAndRun=function(ia,za,Xa,Cb,gc){void 0===gc&&(gc=!1);Xa=Xa||za[0].dtype;ia=this.runWebGLProgram(ia,za,Xa,Cb,gc);return lc.engine().makeTensorFromDataId(ia.dataId,ia.shape,ia.dtype)};sa.prototype.getAndSaveBinary=function(ia,za){ia in this.binaryCache||(this.binaryCache[ia]=za());return this.binaryCache[ia]};
sa.prototype.getTextureManager=function(){return this.textureManager};sa.prototype.dispose=function(){var ia=this;this.disposed||(lc.env().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(function(za){ia.gpgpu.deleteProgram(ia.binaryCache[za].webGLProgram);delete ia.binaryCache[za]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=
null,this.gpgpu.dispose()),this.disposed=!0)};sa.prototype.floatPrecision=function(){var ia=this;null==this.floatPrecisionValue&&(this.floatPrecisionValue=lc.tidy(function(){if(!lc.env().get("WEBGL_RENDER_FLOAT32_ENABLED")){var za=lc.env().getBool("DEBUG");lc.env().set("DEBUG",!1);var Xa=ia.abs(lc.scalar(1E-8)).dataSync()[0];lc.env().set("DEBUG",za);if(0<Xa)return 32}return 16}));return this.floatPrecisionValue};sa.prototype.epsilon=function(){return 32===this.floatPrecision()?1E-7:1E-4};sa.prototype.uploadToGPU=
function(ia){ia=this.texData.get(ia);var za=ia.shape,Xa=ia.dtype,Cb=ia.values,gc=ia.usage;var nc=ia.isPacked;if(null==ia.texture){var Tc=null!=this.activeTimers,hd;Tc&&(hd=lc.util.now());var Hd=ia.texShape;null==Hd&&(Hd=ba(za,nc),ia.texShape=Hd);if(null!=Cb){var $d=aa(za);za=Hd[1];var te=Hd[0];gc=Cb instanceof Uint8Array;nc?(nc=e(Hd[0],Hd[1]),za=nc[0],te=nc[1],Hd=new Cf($d,[te,za],gc)):Hd=new sf($d,[te,za],gc);nc=this.makeTensorInfo([te,za],Xa);gc?this.texData.get(nc.dataId).usage=Ga.PIXELS:this.texData.get(nc.dataId).usage=
Ga.UPLOAD;this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(nc.dataId),za,te,Cb);Xa=this.runWebGLProgram(Hd,[nc],Xa,null,!0);Cb=this.texData.get(Xa.dataId);ia.texture=Cb.texture;ia.texShape=Cb.texShape;ia.isPacked=Cb.isPacked;ia.usage=Cb.usage;this.disposeIntermediateTensorInfo(nc);this.texData.delete(Xa.dataId);ia.values=null;Tc&&(this.uploadWaitMs+=lc.util.now()-hd)}else hd=this.acquireTexture(Hd,gc,Xa,nc),ia.texture=hd}};sa.prototype.convertAndCacheOnCPU=function(ia,za){var Xa=this.texData.get(ia),
Cb=Xa.dtype;this.releaseGPUData(ia);if(null!=za){if("float32"!==Cb&&"complex64"!==Cb)if("int32"===Cb||"bool"===Cb){ia="int32"===Cb?new Int32Array(za.length):new Uint8Array(za.length);for(Cb=0;Cb<ia.length;++Cb)ia[Cb]=Math.round(za[Cb]);za=ia}else throw Error("Unknown dtype "+Cb);Xa.values=za}return Xa.values};sa.prototype.acquireTexture=function(ia,za,Xa,Cb){this.numBytesInGPU+=this.computeBytes(ia,Xa);!this.warnedAboutMemory&&this.numBytesInGPU>1048576*this.numMBBeforeWarning&&(Xa=(this.numBytesInGPU/
1024/1024).toFixed(2),this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+Xa+" MB, most likely due to a memory leak"));return this.textureManager.acquireTexture(ia,za,Cb)};sa.prototype.computeBytes=function(ia,za){return ia[0]*ia[1]*lc.util.bytesPerElement(za)};sa.prototype.tryRunOnCpuOrThrow=function(ia,za){if(this.shouldExecuteOnCPU(ia))try{return za()}catch(Xa){if(lc.env().getBool("IS_TEST"))throw Error("CPU forwarding failed");}return null};return sa}(lc.KernelBackend);lc.device_util.isBrowser()&&
lc.registerBackend("webgl",function(){return new ue},2);for(var Ae={forceHalfFloat:Vc},kb={kernelName:lc.Identity,backendName:"webgl",kernelFunc:Pc},yb={kernelName:lc.Complex,backendName:"webgl",kernelFunc:gd},Hb=Jd({opSnippet:"return a + b;",packedOpSnippet:"return a + b;",supportsComplex:!0,cpuKernelImpl:Ob}),ec={kernelName:lc.Add,backendName:"webgl",kernelFunc:Hb},Bc=Jd({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result \x3d atan(a, b);\n  vec4 isNaN \x3d min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r \x3d isNaN.r \x3e 0. ? NAN : result.r;\n  result.g \x3d isNaN.g \x3e 0. ? NAN : result.g;\n  result.b \x3d isNaN.b \x3e 0. ? NAN : result.b;\n  result.a \x3d isNaN.a \x3e 0. ? NAN : result.a;\n\n  return result;\n"}),
Sc={kernelName:lc.Atan2,backendName:"webgl",kernelFunc:Bc},Uc={kernelName:lc.AvgPool,backendName:"webgl",kernelFunc:function(ea){var sa=ea.backend,ia=ea.attrs;ea=ea.inputs.x;Ra(ea,"avgPool");var za=ia.filterSize,Xa=ia.strides,Cb=ia.pad;ia=ia.dimRoundingMode;lc.util.assert(lc.backend_util.eitherStridesOrDilationsAreOne(Xa,1),function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+(Xa+" and dilations '1'")});ia=lc.backend_util.computePool2DInfo(ea.shape,za,Xa,1,Cb,ia);
if(1===ia.filterWidth&&1===ia.filterHeight&&lc.util.arraysEqual(ia.inShape,ia.outShape))return Pc({inputs:{x:ea},backend:sa});ia=new ze(ia,"avg",!1);return sa.runWebGLProgram(ia,[ea],"float32")}},Ed={kernelName:lc.AvgPoolBackprop,backendName:"webgl",kernelFunc:function(ea){var sa=ea.inputs,ia=ea.backend,za=ea.attrs;ea=sa.dy;sa=sa.input;Ra([ea,sa],"avgPoolBackprop");za=lc.backend_util.computePool2DInfo(sa.shape,za.filterSize,za.strides,1,za.pad);za=new ie(za);return ia.runWebGLProgram(za,[ea],sa.dtype)}},
Sd=function(){return function(ea,sa,ia,za,Xa,Cb){this.outputShape=[];this.variableNames=["x","mean","variance"];lc.backend_util.assertAndGetBroadcastShape(ea,sa);lc.backend_util.assertAndGetBroadcastShape(ea,ia);sa="0.0";null!=za&&(lc.backend_util.assertAndGetBroadcastShape(ea,za),this.variableNames.push("offset"),sa="getOffsetAtOutCoords()");za="1.0";null!=Xa&&(lc.backend_util.assertAndGetBroadcastShape(ea,Xa),this.variableNames.push("scale"),za="getScaleAtOutCoords()");this.outputShape=ea;this.userCode=
"\n      void main() {\n        float x \x3d getXAtOutCoords();\n        float mean \x3d getMeanAtOutCoords();\n        float variance \x3d getVarianceAtOutCoords();\n        float offset \x3d "+sa+";\n        float scale \x3d "+za+";\n        float inv \x3d scale * inversesqrt(variance + float("+Cb+"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "}}(),Xe=function(){return function(ea,sa,ia,za,Xa,Cb){this.packedOutput=this.packedInputs=!0;this.variableNames=
["x","mean","variance"];lc.backend_util.assertAndGetBroadcastShape(ea,sa);lc.backend_util.assertAndGetBroadcastShape(ea,ia);sa="vec4(0.0)";null!=za&&(lc.backend_util.assertAndGetBroadcastShape(ea,za),this.variableNames.push("offset"),sa="getOffsetAtOutCoords()");za="vec4(1.0)";null!=Xa&&(lc.backend_util.assertAndGetBroadcastShape(ea,Xa),this.variableNames.push("scale"),za="getScaleAtOutCoords()");this.outputShape=ea;this.userCode="\n      void main() {\n        vec4 offset \x3d "+sa+";\n        vec4 scale \x3d "+
za+";\n\n        vec4 x \x3d getXAtOutCoords();\n        vec4 mean \x3d getMeanAtOutCoords();\n        vec4 variance \x3d getVarianceAtOutCoords();\n\n        vec4 inv \x3d scale * inversesqrt(variance + vec4("+Cb+"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "}}(),pf={kernelName:lc.FusedBatchNorm,backendName:"webgl",kernelFunc:function(ea){var sa=ea.inputs,ia=ea.backend,za=ea.attrs;ea=sa.x;var Xa=sa.mean,Cb=sa.variance,gc=sa.offset;sa=sa.scale;lc.util.assert(Xa.shape.length===
Cb.shape.length,function(){return"Batch normalization gradient requires mean and variance to have equal ranks."});lc.util.assert(null==gc||Xa.shape.length===gc.shape.length,function(){return"Batch normalization gradient requires mean and offset to have equal ranks."});lc.util.assert(null==sa||Xa.shape.length===sa.shape.length,function(){return"Batch normalization gradient requires mean and scale to have equal ranks."});var nc=za.varianceEpsilon;null==nc&&(nc=.001);za=[ea,Xa,Cb];var Tc=null;null!=
gc&&(Tc=gc.shape,za.push(gc));gc=null;null!=sa&&(gc=sa.shape,za.push(sa));ea=lc.env().getBool("WEBGL_PACK_NORMALIZATION")?new Xe(ea.shape,Xa.shape,Cb.shape,Tc,gc,nc):new Sd(ea.shape,Xa.shape,Cb.shape,Tc,gc,nc);return ia.runWebGLProgram(ea,za,za[0].dtype)}},wf=Jd({opSnippet:"return float(a !\x3d b);",dtype:"bool"}),Yf={kernelName:lc.NotEqual,backendName:"webgl",kernelFunc:wf},of={kernelName:lc.Real,backendName:"webgl",kernelFunc:we},fg={kernelName:lc.Cast,backendName:"webgl",kernelFunc:Ne},zd=function(){return function(ea){this.outputShape=
[];this.outputShape=lc.backend_util.computeOutShape(ea,1);this.variableNames=ea.map(function(za,Xa){return"T"+Xa});var sa=Array(ea.length-1);sa[0]=ea[0][1];for(var ia=1;ia<sa.length;ia++)sa[ia]=sa[ia-1]+ea[ia][1];ea=["if (yC \x3c "+sa[0]+") setOutput(getT0(yR, yC));"];for(ia=1;ia<sa.length;ia++)ea.push("else if (yC \x3c "+sa[ia]+") setOutput(getT"+(ia+"(yR, yC-"+sa[ia-1]+"));"));ea.push("else setOutput(getT"+sa.length+"(yR, yC-"+sa[sa.length-1]+"));");this.userCode="\n      void main() {\n        ivec2 coords \x3d getOutputCoords();\n        int yR \x3d coords.x;\n        int yC \x3d coords.y;\n\n        "+
ea.join("\n        ")+"\n      }\n    "}}(),uf=function(){return function(ea,sa){this.packedOutput=this.packedInputs=!0;this.outputShape=[];var ia=this.outputShape=lc.backend_util.computeOutShape(ea,sa),za=ia.length,Xa=lb(za),Cb=gb("coords",za),gc="xyzwuv".split("").slice(0,za);this.variableNames=ea.map(function($d,te){return"T"+te});var nc=Array(ea.length-1);nc[0]=ea[0][sa];for(var Tc=1;Tc<nc.length;Tc++)nc[Tc]=nc[Tc-1]+ea[Tc][sa];ea=gc[sa];sa=gc.slice(-2);Tc=gc.join();var hd="if ("+ea+" \x3c "+
nc[0]+") {\n        return getChannel(\n            getT0("+Tc+"), vec2("+sa.join()+"));\n        }";for(Tc=1;Tc<nc.length;Tc++){var Hd=nc[Tc-1];hd+="\n        if ("+ea+" \x3c "+nc[Tc]+"  \x26\x26 "+ea+" \x3e\x3d "+nc[Tc-1]+") {\n          return getChannel(\n            getT"+Tc+"("+Je(gc,ea,Hd)+"),\n            vec2("+Je(sa,ea,Hd)+"));\n        }"}Tc=nc[nc.length-1];hd+="\n        return getChannel(\n          getT"+nc.length+"("+Je(gc,ea,Tc)+"),\n          vec2("+Je(sa,ea,Tc)+"));";this.userCode=
"\n      float getValue("+gc.map(function($d){return"int "+$d})+") {\n        "+hd+"\n      }\n\n      void main() {\n        "+Xa+" coords \x3d getOutputCoords();\n        vec4 result \x3d vec4(getValue("+Cb+"), 0., 0., 0.);\n\n        "+Cb[za-1]+" \x3d "+Cb[za-1]+" + 1;\n        if ("+Cb[za-1]+" \x3c "+ia[za-1]+") {\n          result.g \x3d getValue("+Cb+");\n        }\n\n        "+Cb[za-2]+" \x3d "+Cb[za-2]+" + 1;\n        if ("+Cb[za-2]+" \x3c "+ia[za-2]+") {\n          result.a \x3d getValue("+
Cb+");\n        }\n\n        "+Cb[za-1]+" \x3d "+Cb[za-1]+" - 1;\n        if ("+Cb[za-2]+" \x3c "+ia[za-2]+" \x26\x26\n            "+Cb[za-1]+" \x3c "+ia[za-1]+") {\n          result.b \x3d getValue("+Cb+");\n        }\n        setOutput(result);\n      }\n    "}}(),ng={kernelName:lc.Imag,backendName:"webgl",kernelFunc:Qe},hg={kernelName:lc.Reshape,backendName:"webgl",kernelFunc:Oe},Ng={kernelName:lc.Concat,backendName:"webgl",kernelFunc:function(ea){var sa=ea.inputs,ia=ea.backend;ea=lc.util.parseAxisParam(ea.attrs.axis,
sa[0].shape)[0];var za=lc.backend_util.computeOutShape(sa.map(function(Xa){return Xa.shape}),ea);if(0===lc.util.sizeFromShape(za))return ia.makeTensorInfo(za,sa[0].dtype,[]);sa=sa.filter(function(Xa){return 0<lc.util.sizeFromShape(Xa.shape)});if(1===sa.length)return sa[0];za=sa.map(function(Xa){return Xa.shape});lc.backend_util.assertParamsConsistent(za,ea);return od(sa,ea,ia)}},Ig=Dd("if (isnan(x)) return x;\n  return cos(x);\n"),Og={kernelName:lc.Cos,backendName:"webgl",kernelFunc:Ig},Dg=Jd({opSnippet:"\nif (a \x3d\x3d b) {\n  return 1.0;\n};\nreturn a / b;",
packedOpSnippet:"\n  // vec4 one \x3d vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result \x3d a / b;\n  if(a.x \x3d\x3d b.x) {\n    result.x \x3d 1.;\n  }\n  if(a.y \x3d\x3d b.y) {\n    result.y \x3d 1.;\n  }\n  if(a.z \x3d\x3d b.z) {\n    result.z \x3d 1.;\n  }\n  if(a.w \x3d\x3d b.w) {\n    result.w \x3d 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),fh={kernelName:lc.Div,backendName:"webgl",kernelFunc:Dg},Kg=function(){return function(ea,sa,ia){this.variableNames=
["real","imag"];var za=sa[1];this.outputShape=sa;sa=ia?"2.0 * "+Math.PI:"-2.0 * "+Math.PI;if("real"===ea)ea="return real * expR - imag * expI;";else if("imag"===ea)ea="return real * expI + imag * expR;";else throw Error('FFT component must be either "real" or "imag", got '+ea+".");this.userCode="\n      const float exponentMultiplier \x3d "+sa+";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        "+ea+"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio \x3d float(index) / float("+
za+");\n        float exponentMultiplierTimesIndexRatio \x3d\n            exponentMultiplier * indexRatio;\n\n        float result \x3d 0.0;\n\n        for (int i \x3d 0; i \x3c "+za+"; i++) {\n          // x \x3d (-2|2 * PI / N) * index * i;\n          float x \x3d exponentMultiplierTimesIndexRatio * float(i);\n          float expR \x3d cos(x);\n          float expI \x3d sin(x);\n          float real \x3d getReal(batch, i);\n          float imag \x3d getImag(batch, i);\n\n          result +\x3d\n              unaryOpComplex(real, expR, imag, expI) / "+
(ia?za+".0":"1.0")+";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords \x3d getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "}}(),Pg={kernelName:lc.FFT,backendName:"webgl",kernelFunc:function(ea){return Ud(ea.inputs.input,!1,ea.backend)}},gh=function(){return function(ea){this.variableNames=["Image"];this.outputShape=[];var sa=ea[2];this.outputShape=ea;this.userCode="\n        void main() {\n          ivec4 coords \x3d getOutputCoords();\n          int x \x3d coords[2];\n\n          int coordX \x3d "+
sa+" - x;\n          float outputValue;\n          if(coordX \x3e\x3d 0 \x26\x26 coordX \x3c "+sa+") {\n            outputValue \x3d getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue \x3d getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    "}}(),bh={kernelName:lc.FlipLeftRight,backendName:"webgl",kernelFunc:function(ea){var sa=ea.inputs.image;ea=ea.backend;var ia=new gh(sa.shape);return ea.runWebGLProgram(ia,
[sa],sa.dtype)}},Cg=function(){return function(ea){this.variableNames=["A"];var sa=Va(),ia=ea[0],za=ea[1];this.outputShape=ea;this.userCode="\n      void main() {\n        ivec3 coords \x3d getOutputCoords();\n        int texR \x3d coords[0];\n        int texC \x3d coords[1];\n        int depth \x3d coords[2];\n        vec2 uv \x3d (vec2(texC, texR) + halfCR) / vec2("+za+".0, "+ia+".0);\n\n        vec4 values \x3d "+sa.texture2D+"(A, uv);\n        float value;\n        if (depth \x3d\x3d 0) {\n          value \x3d values.r;\n        } else if (depth \x3d\x3d 1) {\n          value \x3d values.g;\n        } else if (depth \x3d\x3d 2) {\n          value \x3d values.b;\n        } else if (depth \x3d\x3d 3) {\n          value \x3d values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "}}(),
vf=function(){return function(ea){this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;var sa=Va(),ia=ea[0],za=ea[1];this.outputShape=ea;this.userCode="\n      void main() {\n        ivec3 coords \x3d getOutputCoords();\n        int texR \x3d coords[0];\n        int texC \x3d coords[1];\n        int depth \x3d coords[2];\n\n        vec4 result \x3d vec4(0.);\n\n        for(int row\x3d0; row\x3c\x3d1; row++) {\n          for(int col\x3d0; col\x3c\x3d1; col++) {\n            texC \x3d coords[1] + row;\n            depth \x3d coords[2] + col;\n\n            vec2 uv \x3d (vec2(texC, texR) + halfCR) /\n                       vec2("+
za+".0, "+ia+".0);\n            vec4 values \x3d "+sa.texture2D+"(A, uv);\n            float value;\n            if (depth \x3d\x3d 0) {\n              value \x3d values.r;\n            } else if (depth \x3d\x3d 1) {\n              value \x3d values.g;\n            } else if (depth \x3d\x3d 2) {\n              value \x3d values.b;\n            } else if (depth \x3d\x3d 3) {\n              value \x3d values.a;\n            }\n\n            result[row * 2 + col] \x3d floor(value * 255.0 + 0.5);\n          }\n        }\n\n        "+
sa.output+" \x3d result;\n      }\n    "}}(),Qg={kernelName:lc.FromPixels,backendName:"webgl",kernelFunc:function(ea){var sa=ea.backend,ia=ea.inputs.pixels,za="undefined"!==typeof HTMLVideoElement&&ia instanceof HTMLVideoElement,Xa=za?[ia.videoWidth,ia.videoHeight]:[ia.width,ia.height],Cb=Xa[0];Xa=Xa[1];var gc=[Xa,Cb];ea=[Xa,Cb,ea.attrs.numChannels];if("undefined"!==typeof HTMLImageElement&&ia instanceof HTMLImageElement||za)null==xf&&(xf=document.createElement("canvas").getContext("2d")),xf.canvas.width=
Cb,xf.canvas.height=Xa,xf.drawImage(ia,0,0,Cb,Xa),ia=xf.canvas;za=sa.makeTensorInfo(gc,"int32");sa.texData.get(za.dataId).usage=Ga.PIXELS;sa.gpgpu.uploadPixelDataToTexture(sa.getTexture(za.dataId),ia);ia=lc.env().getBool("WEBGL_PACK")?new vf(ea):new Cg(ea);ia=sa.runWebGLProgram(ia,[za],"int32");sa.disposeData(za.dataId);return ia}},xf,se={kernelName:lc.IFFT,backendName:"webgl",kernelFunc:function(ea){return Ud(ea.inputs.input,!0,ea.backend)}},sg=function(){return function(ea,sa){this.variableNames=
["x"];var ia=ea.windowSize,za=ea.inSize;this.outputShape=[ea.batchSize,ea.outSize];ea=4*Math.floor(ia/4);var Xa=ia%4,Cb="sumValue +\x3d dot(values, ones);";null!=sa&&(sa=1/sa,Cb="sumValue +\x3d dot(values * "+(lc.util.isInt(sa)?sa.toPrecision(2):sa)+", ones);");sa="";0<za%ia&&(sa="\n        if (inIdx \x3c 0 || inIdx \x3e\x3d "+za+") {\n          return 0.0;\n        }\n      ");this.userCode="\n      const vec4 ones \x3d vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+
sa+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords \x3d getOutputCoords();\n        int batch \x3d coords[0];\n        int outIdx \x3d coords[1];\n        int inOffset \x3d outIdx * "+ia+";\n\n        float sumValue \x3d 0.0;\n\n        for (int i \x3d 0; i \x3c "+ea+"; i +\x3d 4) {\n          int inIdx \x3d inOffset + i;\n          vec4 values \x3d vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+
Cb+"\n        }\n\n        int inIdx \x3d inOffset + "+ea+";\n        if ("+(1===Xa)+") {\n          vec4 values \x3d vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          "+Cb+"\n        } else if ("+(2===Xa)+") {\n          vec4 values \x3d vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          "+Cb+"\n        } else if ("+(3===Xa)+") {\n          vec4 values \x3d vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          "+
Cb+"\n        }\n        setOutput(sumValue);\n      }\n    "}}(),Sg=function(){return function(ea,sa){this.variableNames=["A"];for(var ia=Array(ea.length),za=0;za<ia.length;za++)ia[za]=ea[sa[za]];this.outputShape=ia;this.rank=ia.length;ea=lb(this.rank);za=sa.length;if(6<za)throw Error("Transpose for rank "+za+" is not yet supported");ia="resRC.x resRC.y resRC.z resRC.w resRC.u resRC.v".split(" ");za=Array(za);for(var Xa=0;Xa<sa.length;Xa++)za[sa[Xa]]=ia[Xa];sa=za.join();this.userCode="\n    void main() {\n      "+
ea+" resRC \x3d getOutputCoords();\n      setOutput(getA("+sa+"));\n    }\n    "}}(),Ch=function(){return function(ea,sa){this.variableNames=["A"];this.packedOutput=this.packedInputs=!0;for(var ia=Array(ea.length),za=0;za<ia.length;za++)ia[za]=ea[sa[za]];this.outputShape=ia;this.rank=ia.length;if(6<this.rank)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");ea=lb(this.rank);var Xa=Ba("rc",this.rank),Cb=Array(this.rank);for(za=0;za<sa.length;za++)Cb[sa[za]]=Xa[za];za="vec2("+
Cb.slice(-2).join()+")";sa="++"+Xa[this.rank-1]+" \x3c "+ia[this.rank-1];Cb="getChannel(getA("+Cb.join()+"), "+za+")";this.userCode="\n    void main() {\n      "+ea+" rc \x3d getOutputCoords();\n      vec4 result \x3d vec4(0.);\n      result[0] \x3d "+Cb+";\n      if("+sa+") {\n        result[1] \x3d "+Cb+";\n      }\n      --"+Xa[this.rank-1]+";\n      if(++"+Xa[this.rank-2]+" \x3c "+ia[this.rank-2]+") {\n        result[2] \x3d "+Cb+";\n        if("+sa+") {\n          result[3] \x3d "+Cb+";\n        }\n      }\n      setOutput(result);\n    }\n    "}}(),
dh={kernelName:lc.Max,backendName:"webgl",kernelFunc:function(ea){var sa=ea.inputs.x,ia=ea.attrs,za=ia.keepDims;ea=ea.backend;var Xa=sa.shape.length,Cb=lc.util.parseAxisParam(ia.reductionIndices,sa.shape),gc=Cb,nc=lc.backend_util.getAxesPermutation(gc,Xa);ia=null!=nc;var Tc=ea.shouldExecuteOnCPU([sa]),hd=sa;if(ia){if(Tc){var Hd=ea.texData.get(hd.dataId);Hd=Hd.values;hd=Array(Xa);for(var $d=0;$d<hd.length;$d++)hd[$d]=sa.shape[nc[$d]];Hd=Jb(Hd,sa.shape,sa.dtype,nc,hd);hd=ea.makeTensorInfo(hd,sa.dtype);
ea.texData.get(hd.dataId).values=Hd}else hd=pc(sa,nc,ea);gc=lc.backend_util.getInnerMostAxes(gc.length,Xa)}lc.backend_util.assertAxesAreInnerMostDims("max",gc,Xa);Xa=lc.backend_util.computeOutAndReduceShapes(hd.shape,gc);Hd=Xa[0];gc=Xa[1];Xa=Hd;za&&(Xa=lc.backend_util.expandShapeToKeepDim(Hd,Cb));if(Tc){Hd=ea.texData.get(hd.dataId);za=Hd=Hd.values;Cb=lc.util.sizeFromShape(gc);Tc=lc.util.getTypedArrayFromDType(sa.dtype,lc.util.sizeFromShape(Xa));for(gc=0;gc<Tc.length;++gc){Hd=gc*Cb;nc=za[Hd];for($d=
0;$d<Cb;++$d){const te=za[Hd+$d];te>nc&&(nc=te)}Tc[gc]=nc}za=Tc;sa=ea.makeTensorInfo(Xa,sa.dtype);ea.texData.get(sa.dataId).values=za}else sa=hd,za=lc.util.sizeFromShape(gc),Cb=lc.util.sizeFromShape(sa.shape),za=Oe({inputs:{x:sa},attrs:{shape:[Cb/za,za]},backend:ea}),sa=Rd(za,sa.dtype,"max",ea),Xa=Oe({inputs:{x:sa},attrs:{shape:Xa},backend:ea}),ea.disposeIntermediateTensorInfo(za),ea.disposeIntermediateTensorInfo(sa),sa=Xa;ia&&ea.disposeIntermediateTensorInfo(hd);return sa}},ch={kernelName:lc.MaxPool,
backendName:"webgl",kernelFunc:function(ea){var sa=ea.backend,ia=ea.attrs;ea=ea.inputs.x;Ra(ea,"maxPool");var za=ia.filterSize,Xa=ia.strides,Cb=ia.pad;ia=ia.dimRoundingMode;lc.util.assert(lc.backend_util.eitherStridesOrDilationsAreOne(Xa,1),function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+(Xa+" and dilations '1'")});ia=lc.backend_util.computePool2DInfo(ea.shape,za,Xa,1,Cb,ia);if(1===ia.filterWidth&&1===ia.filterHeight&&lc.util.arraysEqual(ia.inShape,ia.outShape))return Pc({inputs:{x:ea},
backend:sa});ia=new ze(ia,"max",!1);return sa.runWebGLProgram(ia,[ea],ea.dtype)}},Dh={kernelName:lc.MaxPoolBackprop,backendName:"webgl",kernelFunc:function(ea){var sa=ea.inputs,ia=ea.backend,za=ea.attrs;ea=sa.dy;var Xa=sa.input;Ra([Xa,sa.output],"maxPoolBackprop");za=lc.backend_util.computePool2DInfo(Xa.shape,za.filterSize,za.strides,1,za.pad,za.dimRoundingMode);sa=new ze(za,"max",!0);sa=ia.runWebGLProgram(sa,[Xa],Xa.dtype);za=new db(za);ea=ia.runWebGLProgram(za,[ea,sa],Xa.dtype);ia.disposeIntermediateTensorInfo(sa);
return ea}},Eh={kernelName:lc.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:function(ea){var sa=ea.inputs.x,ia=ea.attrs,za=ia.filterSize,Xa=ia.strides,Cb=ia.pad;ia=ia.includeBatchInIndex;ea=ea.backend;lc.util.assert(4===sa.shape.length,function(){return"Error in maxPool: input must be rank 4 but got rank "+sa.shape.length+"."});var gc=[1,1];lc.util.assert(lc.backend_util.eitherStridesOrDilationsAreOne(Xa,gc),function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+
(Xa+" and dilations '"+gc+"'")});za=lc.backend_util.computePool2DInfo(sa.shape,za,Xa,gc,Cb);za=Ue(sa,ia,za,ea);return[za[0],za[1]]}},jh={kernelName:lc.Mean,backendName:"webgl",kernelFunc:function(ea){var sa=ea.inputs.x,ia=ea.attrs,za=ia.keepDims;ea=ea.backend;var Xa=sa.shape.length,Cb=lc.util.parseAxisParam(ia.axis,sa.shape),gc=Cb,nc=lc.backend_util.getAxesPermutation(gc,Xa),Tc=null!=nc,hd=ea.shouldExecuteOnCPU([sa]);ia=[];var Hd=sa;if(Tc){if(hd){hd=ea.texData.get(Hd.dataId).values;Tc=Array(Xa);for(Hd=
0;Hd<Tc.length;Hd++)Tc[Hd]=sa.shape[nc[Hd]];nc=Jb(hd,sa.shape,sa.dtype,nc,Tc);Hd=ea.makeTensorInfo(Tc,sa.dtype);ea.texData.get(Hd.dataId).values=nc}else Hd=pc(sa,nc,ea);ia.push(Hd);gc=lc.backend_util.getInnerMostAxes(gc.length,Xa)}lc.backend_util.assertAxesAreInnerMostDims("sum",gc,Xa);sa=lc.backend_util.computeOutAndReduceShapes(Hd.shape,gc);Xa=sa[0];sa=sa[1];gc=Xa;za&&(gc=lc.backend_util.expandShapeToKeepDim(Xa,Cb));Cb=Hd;za=gc;sa=lc.util.sizeFromShape(sa);Xa=lc.util.sizeFromShape(Cb.shape);Cb=
Oe({inputs:{x:Cb},attrs:{shape:[Xa/sa,sa]},backend:ea});sa=Rd(Cb,"float32","mean",ea);za=Oe({inputs:{x:sa},attrs:{shape:za},backend:ea});ea.disposeIntermediateTensorInfo(Cb);ea.disposeIntermediateTensorInfo(sa);for(Cb=0;Cb<ia.length;Cb++)Hd=ia[Cb],ea.disposeIntermediateTensorInfo(Hd);return za}},rh=function(){return function(ea,sa,ia){this.variableNames=["x"];this.outputShape=sa.map(function(nc,Tc){return nc[0]+ea[Tc]+nc[1]});var za=ea.length,Xa=lb(za),Cb=sa.map(function(nc){return nc[0]}).join(",");
sa=sa.map(function(nc,Tc){return nc[0]+ea[Tc]}).join(",");var gc=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,za);ia="reflect"===ia?0:1;this.userCode=1===za?"\n        int start \x3d "+Cb+";\n        int end \x3d "+sa+";\n\n        void main() {\n          int outC \x3d getOutputCoords();\n          if (outC \x3c start) {\n            outC \x3d start * 2 - outC - "+ia+";\n          } else if(outC \x3e\x3d end) {\n            outC \x3d (end - 1) * 2 - outC + "+ia+";\n          }\n          setOutput(getX(outC - start));\n        }\n      ":
"\n      "+Xa+" start \x3d "+Xa+"("+Cb+");\n      "+Xa+" end \x3d "+Xa+"("+sa+");\n\n      void main() {\n        "+Xa+" outC \x3d getOutputCoords();\n        for (int i \x3d 0; i \x3c "+za+"; i++) {\n          if (outC[i] \x3c start[i]) {\n            outC[i] \x3d start[i] * 2 - outC[i] - "+ia+";\n          } else if(outC[i] \x3e\x3d end[i]) {\n            outC[i] \x3d (end[i] - 1) * 2 - outC[i] + "+ia+";\n          }\n        }\n        "+Xa+" coords \x3d outC - start;\n        setOutput(getX("+
gc+"));\n      }\n    "}}(),yh=function(){return function(ea,sa,ia){this.variableNames=["x"];this.packedOutput=this.packedInputs=!0;this.outputShape=sa.map(function($d,te){return $d[0]+ea[te]+$d[1]});var za=ea.length,Xa=lb(za),Cb=sa.map(function($d){return $d[0]}).join(",");sa=sa.map(function($d,te){return $d[0]+ea[te]}).join(",");var gc=gb("rc",za),nc=gb("source",za),Tc=gc[za-1]+" \x3c "+this.outputShape[za-1],hd=1===za?"source":"vec2("+nc.slice(-2).join()+")";ia="reflect"===ia?0:1;var Hd="";1===
za?(ia="\n        "+Xa+" source \x3d rc;\n        if (source \x3c start) {\n          source \x3d start * 2 - source - "+ia+";\n        } else if (source \x3e\x3d end) {\n          source \x3d (end - 1) * 2 - source + "+ia+";\n        }\n        source -\x3d start;\n      ",Hd="\n        "+Xa+" rc \x3d outputLoc;\n        "+ia+"\n        result[0] \x3d getChannel(getX("+nc.join()+"), "+hd+");\n        "+gc[za-1]+" +\x3d 1;\n        if("+Tc+") {\n          "+ia+"\n          result[1] \x3d getChannel(getX("+
nc.join()+"), "+hd+");\n        }\n      "):(ia="\n        "+Xa+" source \x3d rc;\n        "+Xa+" lt \x3d "+Xa+"(lessThan(source, start));\n        "+Xa+" gte \x3d "+Xa+"(greaterThanEqual(source, end));\n        "+Xa+" orig \x3d 1 - (lt + gte);\n        source \x3d orig * source +\n                lt * (start * 2 - source - "+ia+") +\n                gte * ((end - 1) * 2 - source + "+ia+");\n        source -\x3d start;\n      ",Hd="\n        "+Xa+" rc \x3d outputLoc;\n        "+ia+"\n        result[0] \x3d getChannel(getX("+
nc.join()+"), "+hd+");\n        "+gc[za-1]+" +\x3d 1;\n        if("+Tc+") {\n          "+ia+"\n          result[1] \x3d getChannel(getX("+nc.join()+"), "+hd+");\n        }\n        rc \x3d outputLoc;\n        "+gc[za-2]+" +\x3d 1;\n        if("+gc[za-2]+" \x3c "+this.outputShape[za-2]+") {\n          "+ia+"\n          result[2] \x3d getChannel(getX("+nc.join()+"), "+hd+");\n          "+gc[za-1]+" +\x3d 1;\n          if("+Tc+") {\n            "+ia+"\n            result[3] \x3d getChannel(getX("+nc.join()+
"), "+hd+");\n          }\n        }\n      ");this.userCode="\n      const "+Xa+" start \x3d "+Xa+"("+Cb+");\n      const "+Xa+" end \x3d "+Xa+"("+sa+");\n\n      void main() {\n        "+Xa+" outputLoc \x3d getOutputCoords();\n        vec4 result \x3d vec4(0.);\n        "+Hd+"\n        setOutput(result);\n      }\n    "}}(),kh={kernelName:lc.MirrorPad,backendName:"webgl",kernelFunc:function(ea){var sa=ea.backend,ia=ea.attrs;ea=ea.inputs.x;var za=ia.paddings;ia=ia.mode;ia=lc.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?
new yh(ea.shape,za,ia):new rh(ea.shape,za,ia);return sa.runWebGLProgram(ia,[ea],ea.dtype)}},nh=function(){return function(ea,sa,ia){this.variableNames=["AReal","AImag","BReal","BImag"];this.outputShape=lc.backend_util.assertAndGetBroadcastShape(sa,ia);this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        "+ea+"\n      }\n\n      void main() {\n        float areal \x3d getARealAtOutCoords();\n        float aimag \x3d getAImagAtOutCoords();\n        float breal \x3d getBRealAtOutCoords();\n        float bimag \x3d getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "}}(),
sh={kernelName:lc.Multiply,backendName:"webgl",kernelFunc:function(ea){var sa=ea.inputs;ea=ea.backend;var ia=sa.a;sa=sa.b;var za=lc.backend_util.upcastType(ia.dtype,sa.dtype);if("complex64"===ia.dtype){var Xa=ea.texData.get(ia.dataId),Cb=ea.texData.get(sa.dataId),gc=new nh("return areal * breal - aimag * bimag;",ia.shape,sa.shape);za=new nh("return areal * bimag + aimag * breal;",ia.shape,sa.shape);sa=[{dataId:Xa.complexTensorInfos.real.dataId,dtype:Xa.complexTensorInfos.real.dtype,shape:ia.shape},
{dataId:Xa.complexTensorInfos.imag.dataId,dtype:Xa.complexTensorInfos.imag.dtype,shape:ia.shape},{dataId:Cb.complexTensorInfos.real.dataId,dtype:Cb.complexTensorInfos.real.dtype,shape:sa.shape},{dataId:Cb.complexTensorInfos.imag.dataId,dtype:Cb.complexTensorInfos.imag.dtype,shape:sa.shape}];ia=ea.runWebGLProgram(gc,sa,"float32");sa=ea.runWebGLProgram(za,sa,"float32");za=gd({inputs:{real:ia,imag:sa},backend:ea});ea.disposeIntermediateTensorInfo(ia);ea.disposeIntermediateTensorInfo(sa);return za}if(ea.shouldExecuteOnCPU([ia,
sa]))return Xa=ea.texData.get(ia.dataId),Cb=ea.texData.get(sa.dataId),sa=Ge(ia.shape,sa.shape,Xa.values,Cb.values,za),ia=sa[0],sa=ea.makeTensorInfo(sa[1],za),ea.texData.get(sa.dataId).values=ia,sa;Xa=lc.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Db("return a * b;",ia.shape,sa.shape):new nb("return a * b;",ia.shape,sa.shape);return ea.runWebGLProgram(Xa,[ia,sa],za)}},Fg={kernelName:lc.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function(ea){var sa=ea.inputs,ia=ea.backend,za=ea.attrs;
lc.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var Xa=sa.scores;ea=za.maxOutputSize;var Cb=za.iouThreshold;za=za.scoreThreshold;sa=ia.readSync(sa.boxes.dataId);ia=ia.readSync(Xa.dataId);return lc.kernel_impls.nonMaxSuppressionV3Impl(sa,ia,ea,Cb,za)}},Rg=lc.kernel_impls.nonMaxSuppressionV4Impl,Pa={kernelName:lc.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function(ea){var sa=ea.inputs,ia=ea.backend,za=ea.attrs;lc.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
var Xa=sa.scores;ea=za.maxOutputSize;var Cb=za.iouThreshold,gc=za.scoreThreshold;za=za.padToMaxOutputSize;sa=ia.readSync(sa.boxes.dataId);ia=ia.readSync(Xa.dataId);ia=Rg(sa,ia,ea,Cb,gc,za);return[ia.selectedIndices,ia.validOutputs]}},Ab=lc.kernel_impls.nonMaxSuppressionV5Impl,Qb={kernelName:lc.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function(ea){var sa=ea.inputs,ia=ea.backend,za=ea.attrs;lc.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
var Xa=sa.scores;ea=za.maxOutputSize;var Cb=za.iouThreshold,gc=za.scoreThreshold;za=za.softNmsSigma;sa=ia.readSync(sa.boxes.dataId);ia=ia.readSync(Xa.dataId);ia=Ab(sa,ia,ea,Cb,gc,za);return[ia.selectedIndices,ia.selectedScores]}},cc=function(){return function(ea,sa,ia,za){this.variableNames=["Image"];this.outputShape=[];var Xa=ea[1],Cb=ea[2],gc=Math.sin(sa).toFixed(3);sa=Math.cos(sa).toFixed(3);this.outputShape=ea;ea=lc.backend_util.getImageCenter(za,Xa,Cb);za=ea[1];ea=ea[0].toFixed(3);za=za.toFixed(3);
ia="number"===typeof ia?"float outputValue \x3d "+ia.toFixed(2)+";":"\n        vec3 fill \x3d vec3("+ia.join(",")+");\n        float outputValue \x3d fill[coords[3]];";this.userCode="\n        void main() {\n          ivec4 coords \x3d getOutputCoords();\n          int x \x3d coords[2];\n          int y \x3d coords[1];\n          float coordXFloat \x3d (float(x) - "+ea+") * "+sa+" - (float(y) - "+za+") * "+gc+";\n          float coordYFloat \x3d (float(x) - "+ea+") * "+gc+" + (float(y) - "+za+") * "+
sa+";\n          int coordX \x3d int(round(coordXFloat + "+ea+"));\n          int coordY \x3d int(round(coordYFloat + "+za+"));\n          "+ia+"\n          if(coordX \x3e\x3d 0 \x26\x26 coordX \x3c "+Cb+" \x26\x26 coordY \x3e\x3d 0 \x26\x26 coordY \x3c "+Xa+") {\n            outputValue \x3d getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    "}}(),zc={kernelName:lc.RotateWithOffset,backendName:"webgl",kernelFunc:function(ea){var sa=ea.inputs.image,
ia=ea.attrs;ea=ea.backend;ia=new cc(sa.shape,ia.radians,ia.fillValue,ia.center);return ea.runWebGLProgram(ia,[sa],sa.dtype)}},kc=Dd("if (isnan(x)) return x;\n  return sin(x);\n"),Nc={kernelName:lc.Sin,backendName:"webgl",kernelFunc:kc},jd=Dd("return x * x;"),Td={kernelName:lc.Square,backendName:"webgl",kernelFunc:jd},Wd=Jd({opSnippet:"return (a - b) * (a - b);",packedOpSnippet:"return (a - b) * (a - b);"}),Ld={kernelName:lc.SquaredDifference,backendName:"webgl",kernelFunc:Wd},me=Jd({opSnippet:"return a - b;",
packedOpSnippet:"return a - b;",supportsComplex:!0,cpuKernelImpl:mf}),Ie={kernelName:lc.Sub,backendName:"webgl",kernelFunc:me},Ee=Dd("return tan(x);"),Ff=0,Kf=[ec,Sc,Uc,Ed,pf,fg,yb,Ng,Og,fh,Pg,bh,Qg,kb,se,ng,dh,ch,Dh,Eh,jh,kh,sh,Fg,Pa,Qb,Yf,of,hg,zc,Nc,Td,Ie,Ld,{kernelName:lc.Tan,backendName:"webgl",kernelFunc:Ee},{kernelName:lc.Transpose,backendName:"webgl",kernelFunc:function(ea){var sa=ea.inputs.x,ia=ea.attrs.perm;ea=ea.backend;for(var za=Array(sa.shape.length),Xa=0;Xa<za.length;Xa++)za[Xa]=sa.shape[ia[Xa]];
ea.shouldExecuteOnCPU([sa])?(Xa=ea.texData.get(sa.dataId).values,ia=Jb(Xa,sa.shape,sa.dtype,ia,za),sa=ea.makeTensorInfo(za,sa.dtype),ea.texData.get(sa.dataId).values=ia):sa=pc(sa,ia,ea);return sa}},{kernelName:lc.Unique,backendName:"webgl",kernelFunc:function(ea){var sa=ea.backend,ia=ea.attrs.axis;ea=ea.inputs.x;Ra(ea,"unique");console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");var za=sa.readSync(ea.dataId);ia=wb(za,ia,ea.shape,ea.dtype);za=ia.indices;return[sa.makeTensorInfo(ia.outputShape,
ea.dtype,ia.outputValues),sa.makeTensorInfo([za.length],"int32",za)]}}];Ff<Kf.length;Ff++)lc.registerKernel(Kf[Ff]);v.GPGPUContext=va;v.MathBackendWebGL=ue;v.forceHalfFloat=Vc;v.gpgpu_util=$e;v.setWebGLContext=function(ea,sa){rc[ea]=sa};v.version_webgl="2.7.0";v.webgl=Ae;v.webgl_util=ic};
shadow$provide[962]=function(W,A,la,v){Object.defineProperty(v,"__esModule",{value:!0});var t=A(948),r=A(949),u=A(950);W=A(951);la=A(960);A=A(961);A={"tfjs-core":t.version_core,"tfjs-backend-cpu":la.version_cpu,"tfjs-backend-webgl":A.version_webgl,"tfjs-data":W.version_data,"tfjs-layers":r.version_layers,"tfjs-converter":u.version_converter,tfjs:"2.7.0"};Object.keys(t).forEach(function(f){"default"!==f&&Object.defineProperty(v,f,{enumerable:!0,get:function(){return t[f]}})});Object.keys(r).forEach(function(f){"default"!==
f&&Object.defineProperty(v,f,{enumerable:!0,get:function(){return r[f]}})});Object.keys(u).forEach(function(f){"default"!==f&&Object.defineProperty(v,f,{enumerable:!0,get:function(){return u[f]}})});v.data=W;v.version=A};
var Olg,Plg,Qlg,Rlg,Slg,Tlg,Wlg,Xlg,Ylg,$lg,amg,dmg,emg,fmg,gmg,hmg,nmg,pmg,qmg,rmg,smg,tmg,zmg,Cmg,Fmg,Hmg,Kmg,Lmg,Mmg,Omg,Pmg,Qmg,Rmg,Smg,Umg,Xmg,Ymg,dng,eng,gng,ung,wng,zng,T$,Dng,Eng,Fng,Gng,Hng,Ing,Jng,Lng,Nng,mng,Ong,Png,rng,Qng,Wmg,nng,Emg,tng,cng,jng,wmg,xmg,Img,Rng,Mng,vng,cmg,V$,Sng,Tng,N$,vmg,Ung,Vng,$mg,ang,Wng,Xng,Tmg,Yng,Zng,O$,$ng,jmg,ymg,R$,hng,Bmg,Ang,aog,bog,Cng,ong,cog,dog,eog,fog,ing,gog,umg,png,hog,lng,Vlg,omg,kng,yng,sng,Dmg,iog,mmg;Olg="pitch.lib.ai.vision.classifier.impl.device-screenshot";
Plg="pitch.lib.ai.vision.classifier.specs";Qlg=function(a){if(null!=a&&null!=a.Ap)a=a.Ap(a);else{var b=Qlg[_P.Tb(null==a?null:a)];if(null!=b)a=b.ba?b.ba(a):b.call(null,a);else if(b=Qlg._,null!=b)a=b.ba?b.ba(a):b.call(null,a);else throw _P.pd("Classifier.runnable?",a);}return a};Rlg=function(a){if(null!=a&&null!=a.zp)a=a.zp(a);else{var b=Rlg[_P.Tb(null==a?null:a)];if(null!=b)a=b.ba?b.ba(a):b.call(null,a);else if(b=Rlg._,null!=b)a=b.ba?b.ba(a):b.call(null,a);else throw _P.pd("Classifier.init+",a);}return a};
Slg=function(a){if(null!=a&&null!=a.Bp)a=a.Bp(a);else{var b=Slg[_P.Tb(null==a?null:a)];if(null!=b)a=b.ba?b.ba(a):b.call(null,a);else if(b=Slg._,null!=b)a=b.ba?b.ba(a):b.call(null,a);else throw _P.pd("Classifier.warm+",a);}return a};Tlg=function(a,b){if(null!=a&&null!=a.yp)a=a.yp(a,b);else{var c=Tlg[_P.Tb(null==a?null:a)];if(null!=c)a=c.aa?c.aa(a,b):c.call(null,a,b);else if(c=Tlg._,null!=c)a=c.aa?c.aa(a,b):c.call(null,a,b);else throw _P.pd("Classifier.classify+",a);}return a};
Wlg=function(){_P.$m(_P.nn,Olg,32,new _P.ki(function(){return new _P.D(null,1,5,_P.F,["loading model over https"],null)}),1849430047);return Promise.resolve().then(function(){return M$.loadGraphModel(_P.x.aa(Ulg,Vlg))})};Xlg=function(){_P.$m(_P.nn,Olg,37,new _P.ki(function(){return new _P.D(null,1,5,_P.F,["loading model over indexeddb"],null)}),-1123480849);return Promise.resolve().then(function(){return M$.loadGraphModel(_P.x.aa(Ulg,_P.Vfb))})};
Ylg=function(a){Promise.resolve().then(function(){return a.save(_P.x.aa(Ulg,_P.Vfb))})};
$lg=function(){return Promise.resolve().then(function(){var a=_P.m(Zlg);return _P.g(a)?a:Xlg().then(function(b){_P.rg(Zlg,b);return b}).catch(function(){_P.$m(_P.nn,Olg,55,new _P.ki(function(){return new _P.D(null,1,5,_P.F,["cannot load model over indexeedb"],null)}),2037173965);return Wlg().then(function(b){_P.rg(Zlg,b);Ylg(b);return b}).catch(function(){return _P.$m(_P.nn,Olg,63,new _P.ki(function(){return new _P.D(null,1,5,_P.F,["cannot load model over https"],null)}),-1694281124)})})})};
amg=function(a){return M$.tidy(function(){return M$.image.resizeBilinear(M$.browser.fromPixels(a,3),[224,224]).div(M$.scalar(255)).expandDims(0)})};dmg=function(a){return $lg().then(function(b){var c=_P.Ew.now(),f=amg(a),h=M$.tidy(function(){return b.predict(f).argMax(1)});return h.array().then(function(l){M$.dispose(l);l=l[0];l=bmg.ba?bmg.ba(l):bmg.call(null,l);return new _P.e(null,2,[_P.az,l,cmg,_P.Ew.now()-c],null)}).finally(function(){M$.dispose(h);return M$.dispose(f)})})};
emg=function(){var a=M$.zeros([1,224,224,3]);return $lg().then(function(b){var c=b.predict(a);return c.array().then(_P.ig(_P.cX)).finally(function(){return M$.dispose(c)})}).finally(function(){return M$.dispose(a)})};fmg=function(a,b,c){this.ja=a;this.ha=b;this.ka=c;this.oa=2230716170;this.sa=139264};
gmg=function(a){return new Promise(function(b,c){var f=new Image;f.onload=function(){return b.ba?b.ba(f):b.call(null,f)};f.onerror=function(){var h=Error("Failed to load image.");return c.ba?c.ba(h):c.call(null,h)};f.crossOrigin="Anonymous";return f.src=a})};hmg=function(a,b,c){return Promise.all(_P.Mj.aa(gmg,c)).then(function(f){return _P.ji.ea(a,_P.Ft,b,_P.Lk,_P.u([_P.Fi.aa(_P.$f,_P.tg.da(_P.wk,c,f))]))})};
nmg=function(){_P.ji.fa(img,_P.G,jmg,!0);var a=_P.Tma(kmg);document.addEventListener("dragover",function(b){b.preventDefault();return b.stopPropagation()});document.addEventListener("drop",function(b){b.preventDefault();b.stopPropagation();return hmg(img,new _P.D(null,1,5,_P.F,[N$],null),_P.Mj.aa(_P.Qvb,b.dataTransfer.files))});hmg(img,new _P.D(null,1,5,_P.F,[N$],null),lmg);Rlg(a).then(function(){return _P.g(Qlg(a))?Slg(a):null});return window.tf.ready().then(function(){return _P.ji.fa(img,_P.G,mmg,
window.tf.getBackend())})};
pmg=function(a,b){return new _P.D(null,3,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,4,[_P.FA,"#ddd",_P.Wy,5,_P.fG,5,_P.SY,15],null)],null),_P.Fi.aa(new _P.D(null,2,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,2,[_P.fB,"center",_P.MC,25],null)],null)],null),_P.tg.aa(function(c){var f=_P.v(c,0,null),h=_P.v(c,1,null);return new _P.D(null,2,5,_P.F,[_P.vE,new _P.e(null,3,[_P.ME,f,_P.OD,function(){_P.ji.fa(img,_P.G,O$,f);return _P.g(Qlg(_P.m(kmg)))?Tlg(_P.m(kmg),h).then(function(l){return _P.ji.fa(img,
_P.G,omg,l)}):null},_P.Sv,new _P.e(null,4,[_P.ax,50,_P.gG,"pointer",_P.LE,_P.r.aa(b,f)?"4px solid green":"none",_P.MB,5],null)],null)],null)},a))],null)};qmg=function(a){return new Promise(function(b,c){var f=new FileReader;f.onload=function(){var h=f.result;return b.ba?b.ba(h):b.call(null,h)};f.onerror=function(){var h=f.error;return c.ba?c.ba(h):c.call(null,h)};return f.readAsDataURL(a)})};
rmg=function(a){return new Promise(function(b,c){var f=new Image;f.onload=function(){return b.ba?b.ba(f):b.call(null,f)};f.onerror=function(){var h=Error("Failed to load image.");return c.ba?c.ba(h):c.call(null,h)};f.crossOrigin="Anonymous";return f.src=a})};smg=function(a){return Promise.all(_P.Mj.aa(rmg,a)).then(function(b){return _P.ji.ea(P$,_P.al,N$,_P.Fi,_P.u([b]))})};
tmg=function(a,b){return new _P.D(null,4,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.SY,25],null)],null),new _P.D(null,2,5,_P.F,[_P.CY,"Pick an image or drop your own images"],null),_P.Fi.aa(new _P.D(null,2,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,2,[_P.fB,"center",_P.MC,25],null)],null)],null),_P.lg(function(c,f){return new _P.D(null,2,5,_P.F,[_P.vE,new _P.e(null,4,[_P.K,["img-id-",_P.k.ba(c)].join(""),_P.ME,f.src,_P.Sv,new _P.e(null,4,[_P.ax,50,_P.gG,"pointer",_P.MB,5,_P.LE,
_P.r.aa(c,a)?"4px solid green":"none"],null),_P.OD,function(){return _P.ji.fa(P$,_P.G,O$,c)}],null)],null)},b))],null)};
zmg=function(a,b,c){return _P.$yb(b,c).then(function(f){var h=document.getElementById("output"),l=document.getElementById("debug2");_P.ji.fa(P$,_P.io,new _P.D(null,2,5,_P.F,[umg,a],null),f);a:{var n=_P.pt.ba(_P.on.ba(f));n=_P.C(n);var q=_P.x.aa(n,vmg),t=_P.x.aa(n,wmg),w=_P.x.aa(n,xmg),z=q.width,B=q.height;n=l.getContext("2d");var E=n.createImageData(z,B),M=_P.Vk(t),Q=_P.Vk(w);l.width=z;l.height=B;n.clearRect(0,0,z,B);n.fillStyle="rgba(255, 0, 0, 0.1)";n.fillRect(_P.Ky.ba(w),_P.Ly.ba(w),_P.$w.ba(w),
_P.ax.ba(w));E.data.set(q.data);l=_P.fe(_P.Rj.aa(0,z));q=null;for(var W=0,da=0;;)if(da<W){for(var pa=q.va(null,da),ua=_P.fe(_P.Rj.aa(0,B)),Ca=null,Oa=0,Pa=0;;)if(Pa<Oa){var Va=Ca.va(null,Pa),fb=4*(Va*z+pa);Va=Q$.fa?Q$.fa(M,Q,pa,Va):Q$.call(null,M,Q,pa,Va);var db=E.data[fb+3]/2;E.data[fb]+=db;E.data[fb+2]+=db;E.data[fb+3]=255;0<Va&&(E.data[fb+1]+=32*Va);0>Va&&(E.data[fb]+=-64*Va);Pa+=1}else if(ua=_P.fe(ua))_P.Re(ua)?(Oa=_P.Od(ua),ua=_P.Qd(ua),Ca=Oa,Oa=_P.ve(Oa)):(Oa=_P.p(ua),Ca=4*(Oa*z+pa),Oa=Q$.fa?
Q$.fa(M,Q,pa,Oa):Q$.call(null,M,Q,pa,Oa),Pa=E.data[Ca+3]/2,E.data[Ca]+=Pa,E.data[Ca+2]+=Pa,E.data[Ca+3]=255,0<Oa&&(E.data[Ca+1]+=32*Oa),0>Oa&&(E.data[Ca]+=-64*Oa),ua=_P.ie(ua),Ca=null,Oa=0),Pa=0;else break;da+=1}else if(l=_P.fe(l)){if(_P.Re(l))W=_P.Od(l),l=_P.Qd(l),q=W,W=_P.ve(W);else{q=_P.p(l);W=_P.fe(_P.Rj.aa(0,B));da=null;for(ua=pa=0;;)if(ua<pa)Oa=da.va(null,ua),Ca=4*(Oa*z+q),Oa=Q$.fa?Q$.fa(M,Q,q,Oa):Q$.call(null,M,Q,q,Oa),Pa=E.data[Ca+3]/2,E.data[Ca]+=Pa,E.data[Ca+2]+=Pa,E.data[Ca+3]=255,0<Oa&&
(E.data[Ca+1]+=32*Oa),0>Oa&&(E.data[Ca]+=-64*Oa),ua+=1;else if(W=_P.fe(W))_P.Re(W)?(pa=_P.Od(W),W=_P.Qd(W),da=pa,pa=_P.ve(pa)):(pa=_P.p(W),da=4*(pa*z+q),pa=Q$.fa?Q$.fa(M,Q,q,pa):Q$.call(null,M,Q,q,pa),ua=E.data[da+3]/2,E.data[da]+=ua,E.data[da+2]+=ua,E.data[da+3]=255,0<pa&&(E.data[da+1]+=32*pa),0>pa&&(E.data[da]+=-64*pa),W=_P.ie(W),da=null,pa=0),ua=0;else break;l=_P.ie(l);q=null;W=0}da=0}else break;n.putImageData(E,0,0);n.strokeStyle="rgba(255, 0, 0, 0.8)";n.strokeRect(_P.Ky.ba(w),_P.Ly.ba(w),_P.$w.ba(w),
_P.ax.ba(w));t=ymg.ba(t);if(_P.g(t))for(n.strokeStyle="rgba(255, 255, 255, 1.0)",t=_P.fe(t),w=null,Q=M=0;;)if(Q<M)z=w.va(null,Q),l=_P.C(z),z=_P.x.aa(l,_P.Ky),B=_P.x.aa(l,_P.Ly),E=_P.x.aa(l,_P.$w),l=_P.x.aa(l,_P.ax),n.strokeRect(z,B,E,l),Q+=1;else if(t=_P.fe(t))_P.Re(t)?(z=_P.Od(t),t=_P.Qd(t),w=z,M=z=_P.ve(z)):(w=_P.p(t),w=_P.C(w),z=_P.x.aa(w,_P.Ky),B=_P.x.aa(w,_P.Ly),E=_P.x.aa(w,_P.$w),l=_P.x.aa(w,_P.ax),n.strokeRect(z,B,E,l),t=_P.ie(t),w=null,M=0),Q=0;else break a}w=_P.C(f);f=_P.x.aa(w,_P.Ky);n=
_P.x.aa(w,_P.Ly);t=_P.x.aa(w,_P.hr);w=_P.x.aa(w,_P.gF);z=b.width;B=b.height;E=b.width;M=b.height;E=350<M?350/M:500<E?500/E:1;M=h.getContext("2d");h.width=z*E;h.height=B*E;M.drawImage(b,0,0,z*E,B*E);M.strokeStyle="red";M.lineWidth=4;return M.strokeRect(f*z*E,n*B*E,t*z*E,w*B*E)})};
Cmg=function(a){a=_P.C(a);var b=_P.x.aa(a,R$),c=_P.x.aa(a,O$);a=_P.x.aa(a,N$);a=_P.x.aa(a,c);if(_P.g(a)){b=_P.Lk.ea(_P.u([Amg,_P.x.aa(b,c)]));var f=_P.C(b);b=_P.x.aa(f,_P.$w);var h=_P.x.aa(f,_P.ax);_P.x.aa(f,_P.on);f=a.width;a=a.height;return new _P.D(null,3,5,_P.F,[_P.ou,new _P.D(null,2,5,_P.F,[_P.CY,"Cropping Options"],null),new _P.D(null,11,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,5,[_P.FA,"#eceaea",_P.Wy,15,_P.MC,15,_P.SY,25,_P.fG,3],null)],null),new _P.D(null,3,5,_P.F,[_P.gB,"Width: ",
[_P.k.ba(b),"px"].join("")],null),new _P.D(null,2,5,_P.F,[_P.sE,new _P.e(null,8,[_P.KG,function(l){return _P.ji.fa(P$,_P.io,new _P.D(null,3,5,_P.F,[R$,c,_P.$w],null),parseInt(l.target.value))},_P.Sv,new _P.e(null,1,[Bmg,"auto"],null),_P.O,"width",_P.gm,"range",_P.iH,50,_P.Lp,f,_P.jH,1,_P.kM,b],null)],null),new _P.D(null,1,5,_P.F,[_P.$R],null),new _P.D(null,1,5,_P.F,[_P.$R],null),new _P.D(null,3,5,_P.F,[_P.gB,"Height: ",[_P.k.ba(h),"px"].join("")],null),new _P.D(null,2,5,_P.F,[_P.sE,new _P.e(null,
8,[_P.KG,function(l){return _P.ji.fa(P$,_P.io,new _P.D(null,3,5,_P.F,[R$,c,_P.ax],null),parseInt(l.target.value))},_P.Sv,new _P.e(null,1,[Bmg,"auto"],null),_P.O,"height",_P.gm,"range",_P.iH,50,_P.Lp,a,_P.jH,1,_P.kM,h],null)],null),new _P.D(null,1,5,_P.F,[_P.$R],null),new _P.D(null,1,5,_P.F,[_P.$R],null),new _P.D(null,3,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.fB,"center"],null)],null),new _P.D(null,3,5,_P.F,[_P.qH,new _P.e(null,2,[_P.Sv,new _P.e(null,3,[_P.FA,"#ea907a",_P.Wy,15,_P.fG,
3],null),_P.OD,function(){return _P.ji.fa(P$,_P.io,new _P.D(null,2,5,_P.F,[R$,c],null),Amg)}],null),"Reset to default"],null)],null)],null)],null)}return null};
Fmg=function(){return _P.bo(new _P.e(null,3,[_P.jD,"output",_P.lD,function(a,b){a=_P.he(_P.Kn(a,a.props));a=_P.v(a,0,null);a=_P.C(a);var c=_P.x.aa(a,O$),f=_P.x.aa(a,N$),h=_P.x.aa(a,R$);f=_P.x.aa(f,c);document.getElementById("output");h=_P.Lk.ea(_P.u([Amg,_P.x.aa(h,c)]));return _P.r.aa(_P.Hh(a,new _P.D(null,2,5,_P.F,[O$,R$],null)),_P.Hh(_P.Ce(b),new _P.D(null,2,5,_P.F,[O$,R$],null)))?null:_P.g(f)?zmg(c,f,h):null},_P.Vn,function(a){var b=_P.C(a),c=_P.x.aa(b,O$);a=_P.x.aa(b,N$);var f=_P.x.aa(b,R$),h=
_P.x.aa(b,umg);b=_P.x.aa(a,c);if(_P.g(b)){a=b.width;b=b.height;_P.Lk.ea(_P.u([Amg,_P.x.aa(f,c)]));c=_P.x.aa(h,c);c=_P.C(c);f=_P.x.aa(c,_P.Ky);h=_P.x.aa(c,_P.Ly);var l=_P.x.aa(c,_P.hr),n=_P.x.aa(c,_P.gF);_P.x.aa(c,_P.on);return new _P.D(null,3,5,_P.F,[_P.ou,new _P.D(null,2,5,_P.F,[_P.CY,"Cropping Result"],null),new _P.D(null,4,5,_P.F,[Dmg,new _P.D(null,3,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,5,[_P.FA,"#eceaea",_P.Wy,15,_P.fG,3,_P.MC,15,_P.SY,25],null)],null),new _P.D(null,4,5,_P.F,[_P.bS,
new _P.e(null,1,[_P.Sv,new _P.e(null,1,[Emg,"none"],null)],null),new _P.D(null,3,5,_P.F,[_P.aS,new _P.D(null,2,5,_P.F,[_P.Z,"image size: "],null),[_P.k.ba(a),"x",_P.k.ba(b)].join("")],null),new _P.D(null,11,5,_P.F,[_P.aS,new _P.D(null,2,5,_P.F,[_P.Z,"crop: "],null),"(x,y,width x height) \x3d (",f,", ",h,", ",l,"x",n,")"],null)],null)],null),new _P.D(null,2,5,_P.F,[_P.IZ,new _P.e(null,2,[_P.K,"output",_P.Sv,new _P.e(null,3,[_P.bC,"block",_P.Q0,"auto",_P.SY,25],null)],null)],null),new _P.D(null,2,5,
_P.F,[_P.IZ,new _P.e(null,2,[_P.K,"debug2",_P.Sv,new _P.e(null,3,[_P.bC,"block",_P.Q0,"auto",_P.SY,25],null)],null)],null)],null)],null)}return null}],null))};Hmg=function(){document.addEventListener("dragover",function(a){a.preventDefault();return a.stopPropagation()});document.addEventListener("drop",function(a){a.preventDefault();a.stopPropagation();return Promise.all(_P.Mj.aa(qmg,a.dataTransfer.files)).then(smg)});smg(Gmg);return _P.ji.fa(P$,_P.G,jmg,!0)};
Kmg=function(){var a=_P.Hn(Img);a=0===a.length?a[0]=_P.eo(_P.$f):a[0];return new _P.D(null,3,5,_P.F,[_P.aWe,new _P.e(null,1,[_P.Sv,new _P.e(null,3,[_P.Py,"monospace",_P.Qy,"14px",_P.Ty,"1.3"],null)],null),new _P.D(null,4,5,_P.F,[_P.Aqe,_P.m(Jmg),0,a],null)],null)};Lmg=function(){return new _P.D(null,3,5,_P.F,[_P.AZ,new _P.e(null,1,[_P.OD,function(){return _P.gIa().catch(_P.vIa).then(function(a){return _P.ji.fa(Jmg,_P.G,_P.JI,a)})}],null),"Get token"],null)};
Mmg=function(){return new _P.D(null,3,5,_P.F,[_P.AZ,new _P.e(null,1,[_P.OD,_P.g5b],null),"Expire access token"],null)};
Omg=function(){function a(){var b=_P.m(Nmg);return _P.g(b)?(_P.rg(Nmg,null),clearInterval(b)):null}return new _P.D(null,5,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,3,[_P.LE,"1px solid",_P.UA,_P.g(_P.m(Nmg))?"green":"#ddd",_P.Wy,"10px"],null)],null),new _P.D(null,5,5,_P.F,[_P.Sm,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.Qy,"12px"],null)],null),"Retrieves the access-token every 100ms.",new _P.D(null,1,5,_P.F,[_P.$R],null),"Expire the token to see it refresh."],null),new _P.D(null,3,5,_P.F,
[_P.AZ,new _P.e(null,1,[_P.OD,function(){a();return _P.rg(Nmg,setInterval(function(){return _P.gIa().catch(_P.vIa).then(function(b){return _P.ji.fa(Jmg,_P.G,_P.JI,b)})},200))}],null),"Start token loop"],null),new _P.D(null,3,5,_P.F,[_P.AZ,new _P.e(null,1,[_P.OD,a],null),"Stop token loop"],null)],null)};Pmg=function(){return new _P.D(null,3,5,_P.F,[_P.AZ,new _P.e(null,1,[_P.OD,function(){return _P.xIa().then(function(a){return _P.ji.fa(Jmg,_P.G,_P.sn,a)})}],null),"Get id token"],null)};
Qmg=function(){return new _P.D(null,3,5,_P.F,[_P.AZ,new _P.e(null,1,[_P.OD,function(){return _P.wIa().then(function(a){return _P.ji.fa(Jmg,_P.G,_P.dR,a)})}],null),"Get user"],null)};Rmg=function(){return new _P.D(null,3,5,_P.F,[_P.AZ,new _P.e(null,1,[_P.OD,_P.PP],null),"Logout"],null)};Smg=function(){_P.BIa(new _P.e(null,1,[_P.qu,new _P.ju(null,null,null)],null));return _P.AIa().then(_P.b3)};
Umg=function(a){var b=_P.Hn(Tmg);b=0===b.length?b[0]=_P.eo(_P.$f):b[0];return new _P.D(null,3,5,_P.F,[_P.aWe,new _P.e(null,1,[_P.Sv,new _P.e(null,3,[_P.Py,"monospace",_P.Qy,"14px",_P.Ty,"1.3"],null)],null),new _P.D(null,4,5,_P.F,[_P.Aqe,a,0,b],null)],null)};
Xmg=function(){var a=_P.m(Vmg);return _P.g(a)?a:_P.rg(Vmg,Promise.resolve().then(Smg).then(function(){var b=_P.cn(_P.m(_P.mp)),c=_P.ln(_P.m(_P.mp)),f=new _P.e(null,2,[_P.K,new _P.D(null,3,5,_P.F,[_P.Ez,_P.lz,c],null),_P.yv,new _P.e(null,1,[_P.tz,b],null)],null),h=_P.qg(null);if(!_P.g(b))throw Error("No editor-id");return _P.Av(Wmg,new _P.D(null,1,5,_P.F,[f],null)).then(function(l){l=_P.x.aa(l,_P.K.ba(f));_P.wz(l,"pull",function(){return null});_P.wz(l,"change",function(n){return _P.rg(h,n)});return l}).then(function(l){return Promise.all(new _P.D(null,
2,5,_P.F,[_P.xz(l),l],null))}).then(function(l){var n=_P.v(l,0,null);l=_P.v(l,1,null);_P.rg(h,n);return Promise.all(new _P.D(null,2,5,_P.F,[l,_P.bQa(l)],null))}).then(function(l){var n=_P.v(l,0,null);return _P.yz(n).then(function(){return n})}).then(function(l){return Promise.all(new _P.D(null,3,5,_P.F,[_P.kf(_P.Gg(function(n){n=_P.C(n);n=_P.x.aa(n,_P.im);var q=_P.C(n);n=_P.x.aa(q,_P.O);var t=_P.x.aa(q,_P.iz);q=_P.x.aa(q,_P.tz);return new _P.D(null,2,5,_P.F,[new _P.e(null,3,[_P.O,n,_P.oK,new _P.D(null,
2,5,_P.F,[_P.jz,t],null),_P.tz,q],null),new _P.e(null,3,[_P.O,[_P.k.ba(n)," (PRIVATE SPACE)"].join(""),_P.oK,new _P.D(null,2,5,_P.F,[_P.Wz,q],null),_P.tz,q],null)],null)},_P.u([_P.Ig.aa(function(n){return _P.r.aa(_P.gm.ba(_P.bd.ba(n)),"workspace-record")},_P.Fh(_P.m(h)))]))),_P.Fi.aa(_P.$f,_P.tg.aa(function(n){n=_P.C(n);n=_P.x.aa(n,_P.im);var q=_P.C(n);_P.x.aa(q,_P.O);n=_P.x.aa(q,_P.iz);q=_P.x.aa(q,_P.tz);return new _P.D(null,2,5,_P.F,[n,q],null)},_P.Ig.aa(function(n){return _P.r.aa(_P.gm.ba(_P.bd.ba(n)),
"workspace-record")},_P.Fh(_P.m(h))))),_P.dv(l)],null))}).then(function(l){var n=_P.v(l,0,null);l=_P.v(l,1,null);return new _P.D(null,2,5,_P.F,[_P.Fi.aa(new _P.D(null,2,5,_P.F,[new _P.e(null,3,[_P.O,"USER VSPACE",_P.oK,new _P.D(null,2,5,_P.F,[_P.lz,c],null),_P.tz,b],null),new _P.e(null,3,[_P.O,"EDITOR KEYSPACE",_P.oK,new _P.D(null,2,5,_P.F,[_P.en,b],null),_P.tz,b],null)],null),n),l],null)})}))};Ymg=function(a){return _P.Vf.aa(_P.ur,a)/_P.ve(a)};
dng=function(a){var b=_P.m(Zmg);return _P.g(b)?b:_P.rg(Zmg,Promise.resolve().then(function(){if(!_P.g(_P.cn(_P.m(_P.mp))))throw Error("Not authenticated - editor-id missing");return _P.Av(Wmg,new _P.D(null,1,5,_P.F,[a],null)).then(function(c){c=_P.x.aa(c,_P.K.ba(a));_P.wz(c,"change",function(f){for(var h=_P.fe(f),l=null,n=0,q=0;;)if(q<n){var t=l.va(null,q);f=_P.v(t,0,null);t=_P.v(t,1,null);var w=$mg.ba(_P.bd.ba(t));_P.g(w)&&(t=ang.ba(_P.bd.ba(t)),w=Date.now()-w,1E4>w&&(_P.g(t)&&_P.ji.ea(bng,_P.al,
t,_P.jg(_P.Cf,_P.Jh),_P.u([w])),console.warn("Echo:",_P.k.ba(f),w,_P.g(t)?["avg:",_P.k.ba(Math.floor(Ymg(_P.x.aa(_P.m(bng),t))))].join(""):"")));q+=1}else if(f=_P.fe(h))h=f,_P.Re(h)?(l=_P.Od(h),h=_P.Qd(h),f=l,n=_P.ve(l),l=f):(l=_P.p(h),f=_P.v(l,0,null),t=_P.v(l,1,null),l=$mg.ba(_P.bd.ba(t)),_P.g(l)&&(n=ang.ba(_P.bd.ba(t)),l=Date.now()-l,1E4>l&&(_P.g(n)&&_P.ji.ea(bng,_P.al,n,_P.jg(_P.Cf,_P.Jh),_P.u([l])),console.warn("Echo:",_P.k.ba(f),l,_P.g(n)?["avg:",_P.k.ba(Math.floor(Ymg(_P.x.aa(_P.m(bng),n))))].join(""):
""))),h=_P.ie(h),l=null,n=0),q=0;else return null});return c}).then(function(c){return _P.ji.ea(S$,_P.G,cng,c,_P.u([_P.fn,_P.xz(c)]))}).then(function(){return _P.ji.fa(S$,_P.G,_P.V7a,!0)})}))};eng=function(a,b){return _P.fe(a)&&3<_P.ve(a)?(a=_P.Ni((0,_P.kc)(a)),_P.Loa(_P.Ni(_P.mi.ea(_P.u([b]))),a)):!0};
gng=function(){return new _P.D(null,2,5,_P.F,[_P.JE,new _P.D(null,2,5,_P.F,[_P.sE,new _P.e(null,3,[_P.gm,_P.cv,_P.uE,"free text search",_P.WG,function(a){a.persist();return fng.ba?fng.ba(a):fng.call(null,a)}],null)],null)],null)};
ung=function(){var a=_P.m(S$),b=_P.C(a);a=_P.x.aa(b,_P.fn);var c=_P.x.aa(b,_P.sU);_P.x.aa(b,_P.V7a);_P.x.aa(b,hng);b=_P.x.aa(b,_P.oK);var f=_P.ve(a);return new _P.D(null,3,5,_P.F,[_P.JE,new _P.D(null,3,5,_P.F,[_P.vzd,new _P.e(null,2,[_P.Sv,new _P.e(null,1,[_P.bC,ing],null),_P.rE,"/app/playground/object-explorer"],null),"\x3c\x3c List"],null),null==a?new _P.D(null,1,5,_P.F,[_P.L4a],null):new _P.D(null,3,5,_P.F,[_P.JE,new _P.D(null,4,5,_P.F,[jng,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.$w,600],null)],
null),[_P.mi.ea(_P.u([b])),"\n"].join(""),[_P.k.ba(f)," objects"].join("")],null),new _P.D(null,4,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,2,[_P.bC,_P.IY,kng,_P.Xy],null)],null),new _P.D(null,3,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[lng,"50%"],null)],null),new _P.D(null,4,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.MB,20],null)],null),new _P.D(null,1,5,_P.F,[gng],null),new _P.D(null,3,5,_P.F,[mng,new _P.D(null,2,5,_P.F,[nng,new _P.D(null,3,5,_P.F,[_P.EG,new _P.D(null,
2,5,_P.F,[_P.DG,"object-id"],null),new _P.D(null,2,5,_P.F,[_P.DG,"type"],null)],null)],null),_P.Fi.aa(new _P.D(null,1,5,_P.F,[_P.u6a],null),_P.lg(function(h,l){var n=_P.v(l,0,null);h=_P.v(l,1,null);l=_P.r.aa(n,c);return new _P.D(null,5,5,_P.F,[ong,new _P.e(null,2,[_P.Bn,n,_P.Sv,new _P.e(null,1,[_P.eB,l?"rgba(32,32,62,0.1)":null],null)],null),new _P.D(null,2,5,_P.F,[_P.CG,new _P.D(null,2,5,_P.F,[png,_P.k.ba(n)],null)],null),new _P.D(null,3,5,_P.F,[_P.CG,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.fB,
_P.RH],null)],null),new _P.D(null,2,5,_P.F,[_P.XY,new _P.D(null,2,5,_P.F,[png,_P.gm.ba(_P.bd.ba(h))],null)],null)],null),new _P.D(null,2,5,_P.F,[_P.CG,new _P.D(null,3,5,_P.F,[_P.vzd,new _P.e(null,2,[_P.Wn,l?_P.sU:null,_P.OD,function(){return _P.ji.fa(S$,_P.G,_P.sU,n)}],null),"inspect"],null)],null)],null)},_P.lj.aa(function(h){var l=_P.v(h,0,null);h=_P.v(h,1,null);return new _P.D(null,2,5,_P.F,[_P.gm.ba(_P.bd.ba(h)),l],null)},_P.Ig.aa(_P.lk.aa(eng,_P.m(qng)),a))))],null)],null)],null),_P.g(c)?new _P.D(null,
3,5,_P.F,[rng,new _P.e(null,1,[_P.Sv,new _P.e(null,4,[_P.ID,"sticky",_P.Ey,"1rem",_P.ax,"calc(100vh - 2rem)",_P.c6a,sng],null)],null),new _P.D(null,3,5,_P.F,[_P.JE,new _P.D(null,3,5,_P.F,[tng,"Selected object: ",_P.k.ba(c)],null),new _P.D(null,2,5,_P.F,[Umg,_P.x.aa(a,c)],null)],null)],null):null],null)],null)],null)};
wng=function(){var a=_P.m(S$);a=_P.C(a);_P.x.aa(a,_P.fn);_P.x.aa(a,_P.sU);_P.x.aa(a,_P.V7a);var b=_P.x.aa(a,hng);_P.x.aa(a,_P.oK);return new _P.D(null,3,5,_P.F,[_P.JE,new _P.D(null,3,5,_P.F,[vng,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.$w,600],null)],null),_P.Fi.aa(new _P.D(null,1,5,_P.F,[_P.bS],null),_P.tg.aa(function(c){var f=_P.C(c);c=_P.x.aa(f,_P.O);f=_P.x.aa(f,_P.oK);return new _P.D(null,2,5,_P.F,[_P.aS,new _P.D(null,4,5,_P.F,[_P.vzd,new _P.e(null,2,[_P.Sv,new _P.e(null,2,[_P.bC,ing,_P.Q0,
"0.25rem 0"],null),_P.rE,["/app/playground/object-explorer/",_P.Oh(_P.p(f)),"/",_P.k.ba(_P.Be(f))].join("")],null),c,new _P.D(null,3,5,_P.F,[png,new _P.e(null,1,[_P.Sv,new _P.e(null,3,[_P.NC,"1rem",_P.Ry,"bold",_P.Qy,"1rem"],null)],null),_P.mi.ea(_P.u([f]))],null)],null)],null)},b))],null),new _P.D(null,2,5,_P.F,[_P.JE,'Note: document keyspaces aren\'t listed. To view a document keyspace, use gadget from app: "pitch.app.gadgets.find_in_document_explorer()" or manually navigate to /app/playground/document-explorer/document/\x3cdocument-id\x3e?workspace-id\x3d\x3cworkspace-id\x3e'],
null)],null)};zng=function(a){return _P.c3c(_P.m(xng),new _P.D(null,2,5,_P.F,[yng,a],null),function(){var b=["https://swapi.dev/api/planets/",_P.k.ba(a),"/"].join("");return _P.oYf.ba?_P.oYf.ba(b):_P.oYf.call(null,b)})};
T$=function(a){a=zng(a);var b=_P.C(a);a=_P.x.aa(b,_P.im);var c=_P.x.aa(b,_P.kl);b=_P.x.aa(b,_P.hl);return new _P.D(null,3,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.Wy,"5px"],null)],null),_P.g(a)?new _P.D(null,2,5,_P.F,[_P.Sm,a.name],null):_P.r.aa(_P.jF,b)?new _P.D(null,2,5,_P.F,[Ang,"Loading planet data"],null):_P.g(c)?new _P.D(null,3,5,_P.F,[Ang,"Something went wrong: ",_P.k.ba(c)],null):new _P.D(null,2,5,_P.F,[Ang,"Unexpected state"],null)],null)};
Dng=function(a){return _P.ji.fa(Bng,_P.al,Cng,function(b){return["\x3e ",_P.k.ba(a),"\n",_P.k.ba(b)].join("")})};Eng=function(){return _P.ji.fa(Bng,_P.G,Cng,"")};Fng=function(a){return new Promise(function(b){return setTimeout(b,a)})};
Gng=function(a){var b=new _P.D(null,6,5,_P.F,"     ".split(" "),null),c=_P.qg(0),f=_P.qg(null);return new _P.D(null,2,5,_P.F,[function(){return _P.rg(f,setInterval(function(){return document.title=[_P.k.ba(_P.we(b,_P.pf(_P.ji.aa(c,_P.qe),_P.ve(b)))),_P.k.ba(a)].join("")},16))},function(){document.title="RPC Playground";return clearInterval(_P.m(f))}],null)};
Hng=function(a,b){return function(){function c(h){var l=null;if(0<arguments.length){l=0;for(var n=Array(arguments.length-0);l<n.length;)n[l]=arguments[l+0],++l;l=new _P.ce(n,0,null)}return f.call(this,l)}function f(h){var l=Gng(b),n=_P.v(l,0,null);l=_P.v(l,1,null);Dng(["executing task ",_P.k.ba(b)," with args: ",_P.k.ba(h)].join(""));return Promise.resolve().then(n).then(function(){return _P.Vf.aa(a,h)}).finally(l)}c.la=0;c.pa=function(h){h=_P.fe(h);return f(h)};c.ea=f;return c}()};
Ing=function(a,b){return function(){function c(h){var l=null;if(0<arguments.length){l=0;for(var n=Array(arguments.length-0);l<n.length;)n[l]=arguments[l+0],++l;l=new _P.ce(n,0,null)}return f.call(this,l)}function f(h){return Fng(b).then(function(){return _P.Vf.aa(a,h)})}c.la=0;c.pa=function(h){h=_P.fe(h);return f(h)};c.ea=f;return c}()};
Jng=function(){return new _P.D(null,10,5,_P.F,[_P.Ufb,new _P.e(null,1,[_P.Sv,_P.nn.ba(U$)],null),new _P.D(null,2,5,_P.F,[_P.NCc,"About this page"],null),new _P.D(null,2,5,_P.F,[_P.Sm,"This page demonstrates the RPC built on top of Broadcast Channel."],null),new _P.D(null,2,5,_P.F,[_P.Sm,"What is Broadcast Channel RPC? You can think about it a as traditional RPC client,\n        but in the contrary to the traditional RPC models"],null),new _P.D(null,4,5,_P.F,[_P.bS,new _P.e(null,1,[_P.Sv,new _P.e(null,
1,[_P.UR,"none"],null)],null),new _P.D(null,2,5,_P.F,[_P.aS,"- the role of a remote server is delegated to one of browser tabs"],null),new _P.D(null,2,5,_P.F,[_P.aS,"- the communication with a remote server is not done via HTTP or, say, WebSocket,\n          but rather through a BroadcastChannel"],null)],null),new _P.D(null,4,5,_P.F,[_P.Sm,"As soon as the tab becomes a leader, you should notice an ","\ud83c\udfc6",'icon both in the title bar of a browser tab and in the header of this page. Once a\n    tab becomes a leader, it means that all RPC calls are handled by this tab. Searcg\n    for "executing task :task with :args" message in the console box below.'],
null),new _P.D(null,2,5,_P.F,[_P.Sm,"In order to start using it, please open this page in multiple tabs and click on\n        one of the buttons representing a handler registered in RPC client. Some of\n        handlers are slow, broken or not defined at all on purpose."],null),new _P.D(null,2,5,_P.F,[_P.Sm,"The console box below"],null),new _P.D(null,5,5,_P.F,[_P.bS,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.UR,"none"],null)],null),new _P.D(null,2,5,_P.F,[_P.aS,"- shows both handshake and incoming/outgoing messages of a particular RPC client"],
null),new _P.D(null,2,5,_P.F,[_P.aS,"- highlights the moment when exactly a given tab becomes a leader"],null),new _P.D(null,2,5,_P.F,[_P.aS,"- makes it easier to understand whether an execution of a handler takes place in this tab"],null)],null)],null)};
Lng=function(){return _P.Fi.aa(new _P.D(null,4,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,2,[_P.MC,10,_P.NC,10],null)],null),new _P.D(null,3,5,_P.F,[_P.tY,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.SY,20],null)],null),"Playgrounds"],null),new _P.D(null,3,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.SY,10],null)],null),new _P.D(null,3,5,_P.F,[_P.qH,new _P.e(null,3,[_P.Wn,"button",_P.eP,"Assertion expection should not be present in branch and prod builds when the button is clicked.",
_P.OD,function(){console.log("Check assertion error below:");var a=new _P.e(null,4,[_P.X,0,_P.V,0,_P.Z,0,_P.Y,"zzz"],null);return _P.g(!1)?_P.Nk(_P.k8,a):a}],null),"Test spec assertion"],null)],null)],null),_P.tg.aa(function(a){var b=_P.C(a);a=_P.x.aa(b,_P.mj);var c=_P.x.aa(b,_P.O);b=_P.x.aa(b,_P.aW);return new _P.D(null,3,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.SY,10],null)],null),new _P.D(null,4,5,_P.F,[_P.vzd,new _P.e(null,2,[_P.Sv,new _P.e(null,1,[_P.$w,200],null),_P.rE,a],null),
new _P.D(null,2,5,_P.F,[_P.DM,b],null),c],null)],null)},Kng))};
Nng=function(){return new _P.D(null,3,5,_P.F,[_P.JE,new _P.D(null,2,5,_P.F,[_P.Sv,"html, body { overflow: unset; user-select: unset; }"],null),function(){var a=_P.Mi(location.pathname,/\/$/,""),b=_P.gg(function(c){var f=function(){var h=Mng.ba(c);return _P.g(h)?h:function(l){return _P.r.aa(_P.mj.ba(c),l)}}();f=f.ba?f.ba(a):f.call(null,a);return _P.g(f)?new _P.D(null,2,5,_P.F,[_P.dP.ba(c),new _P.e(null,1,[_P.dr,f],null)],null):null},Kng);return _P.g(b)?new _P.D(null,3,5,_P.F,[_P.JE,new _P.D(null,3,
5,_P.F,[_P.vzd,new _P.e(null,2,[_P.Sv,new _P.e(null,1,[_P.qP,200],null),_P.rE,"/app/playground"],null),"\x3c All Playgrounds"],null),b],null):_P.r.aa("/app/playground",a)?new _P.D(null,1,5,_P.F,[Lng],null):new _P.D(null,2,5,_P.F,[_P.JE,"Not found"],null)}()],null)};_P.Kue=function(){_P.rg(_P.zv,_P.VJa());return _P.vAa(new _P.D(null,1,5,_P.F,[Nng],null),document.getElementById("app"))};mng=new _P.A(null,"table.oe-table","table.oe-table",2112940970);Ong=new _P.A(null,"plus","plus",211540661);
Png=new _P.ae(Olg,"input-preprocessing","pitch.lib.ai.vision.classifier.impl.device-screenshot/input-preprocessing",-1703305459,null);rng=new _P.A(null,"div.item","div.item",517680018);Qng=new _P.A(null,"leader?","leader?",-675040523);Wmg=new _P.A(null,"object-explorer","object-explorer",1432742927);nng=new _P.A(null,"thead","thead",-291875296);Emg=new _P.A(null,"list-style-type","list-style-type",-1703248598);tng=new _P.A(null,"div.mbs","div.mbs",-622313110);
cng=new _P.A(null,"manager","manager",-818607470);jng=new _P.A(null,"pre.mbs.mts","pre.mbs.mts",-1766481938);wmg=new _P.A(null,"debugOptions","debugOptions",-235269045);xmg=new _P.A(null,"debugTopCrop","debugTopCrop",1352702936);Img=new _P.A(null,"with-let84351","with-let84351",-548057930);Rng=new _P.ae("js","HTMLImageElement","js/HTMLImageElement",-318444505,null);Mng=new _P.A(null,"matches?","matches?",-1409299473);vng=new _P.A(null,"div.mbs.mts","div.mbs.mts",253982262);
cmg=new _P.A(null,"latency","latency",1825786229);V$=new _P.A(Plg,"input","pitch.lib.ai.vision.classifier.specs/input",607821435);Sng=new _P.ae("js","ImageData","js/ImageData",1862053638,null);Tng=new _P.A(null,"non-existing","non-existing",1055453470);N$=new _P.A(null,"imgs","imgs",-1326095273);vmg=new _P.A(null,"debugOutput","debugOutput",1842449940);Ung=new _P.A(Plg,"html-image-element","pitch.lib.ai.vision.classifier.specs/html-image-element",-1533989738);
Vng=new _P.A(null,"swapi-data","swapi-data",950894769);$mg=new _P.A(null,"echo-created-at","echo-created-at",-1269003678);ang=new _P.A(null,"run-id","run-id",-1745267908);Wng=new _P.A(null,"foo","foo",1268894036);Xng=new _P.ae("js","Tensor","js/Tensor",880969996,null);Tmg=new _P.A(null,"with-let84404","with-let84404",1221379675);Yng=new _P.A(null,"overflow-wrap","overflow-wrap",-60289494);Zng=new _P.A(null,"wrap","wrap",851669987);O$=new _P.A(null,"selected-img","selected-img",-916307995);
$ng=new _P.A(null,"slow-reverse","slow-reverse",-1982267122);jmg=new _P.A(null,"init?","init?",438181499);ymg=new _P.A(null,"boost","boost",-673419773);R$=new _P.A(null,"crop-opts","crop-opts",-1316306558);hng=new _P.A(null,"descriptors","descriptors",-414202168);Bmg=new _P.A(null,"-webkit-appearance","-webkit-appearance",375531635);Ang=new _P.A(null,"i","i",-1386841315);aog=new _P.A(null,"main-ready?","main-ready?",657495501);bog=new _P.A(null,"buttons","buttons",-1953831197);
Cng=new _P.A(null,"console-out","console-out",-303211867);ong=new _P.A(null,"tr.mbt","tr.mbt",1603998230);cog=new _P.A(Plg,"image-data","pitch.lib.ai.vision.classifier.specs/image-data",-300514560);dog=new _P.A(Plg,"tensor","pitch.lib.ai.vision.classifier.specs/tensor",-533025555);eog=new _P.A(Plg,"promise","pitch.lib.ai.vision.classifier.specs/promise",1792725441);fog=new _P.A(null,"textarea.console","textarea.console",-486423377);ing=new _P.A(null,"inline-flex","inline-flex",245145136);
gog=new _P.A(null,"broken-handler","broken-handler",-629615402);umg=new _P.A(null,"crop-results","crop-results",-1586084);png=new _P.A(null,"pre","pre",2118456869);hog=new _P.ae(Olg,"classify+","pitch.lib.ai.vision.classifier.impl.device-screenshot/classify+",-2072569415,null);lng=new _P.A(null,"flex-basis","flex-basis",983188475);Vlg=new _P.A(null,"https","https",-1983909665);omg=new _P.A(null,"prediction","prediction",109482855);kng=new _P.A(null,"flex-direction","flex-direction",364609438);
yng=new _P.A(null,"planets","planets",1711765443);sng=new _P.A(null,"scroll","scroll",971553779);Dmg=new _P.A(null,"div.output","div.output",1460347316);iog=new _P.A(null,"slow-plus","slow-plus",-1764977134);mmg=new _P.A(null,"tf-backend","tf-backend",1683154474);var jog=_P.Zb(),kog=_P.Efa(),log=_P.Jc.ff.getCount();_P.Jc.ce.length+log>_P.Jc.mk&&(log>_P.Jc.mk/2&&_P.Cfa(_P.Jc),_P.Jc.ce.length>_P.Jc.mk/2&&_P.Dfa(_P.Jc));var W$=_P.sfa(_P.Jc.Jg);W$.rq=void 0;W$.Xh=kog;W$.eventType=0;W$.id=_P.sfa(_P.Jc.Yi);W$.comment="Module Load: dev";W$.type="Module Load";_P.Jc.ce.push(W$);_P.Jc.ff.set(String(W$.id),W$);_P.Jc.Cm++;var mog=_P.Zb();W$.startTime=W$.eventTime=mog;_P.Jc.Vj+=mog-jog;_P.Jc.og.start&&_P.Jc.og.start(W$.id,W$.toString());_P.Xc.zo=W$.id;_P.Xc.zf&&_P.Xc.zf.getId();
_P.Xc.zf=_P.Xc.Nc.dev;var M$=_P.pn(962);_P.J(Ung,_P.H(_P.at,new _P.D(null,1,5,_P.F,[_P.I],null),_P.H(_P.Pj,_P.H(_P.BAf,_P.I),Rng)),function(a){return _P.r.aa(_P.od(a),HTMLImageElement)});_P.J(cog,_P.H(_P.at,new _P.D(null,1,5,_P.F,[_P.I],null),_P.H(_P.Pj,_P.H(_P.BAf,_P.I),Sng)),function(a){return _P.r.aa(_P.od(a),ImageData)});_P.J(V$,_P.H(_P.L6,Ung,cog),_P.x9(new _P.D(null,1,5,_P.F,[Ung],null),new _P.D(null,1,5,_P.F,[cog],null),new _P.D(null,1,5,_P.F,[cog],null),null));
_P.J(eog,_P.H(_P.at,new _P.D(null,1,5,_P.F,[_P.I],null),_P.H(_P.Pj,_P.H(_P.BAf,_P.I),_P.iFf)),function(a){return _P.r.aa(_P.od(a),Promise)});_P.J(dog,_P.H(_P.at,new _P.D(null,1,5,_P.F,[_P.I],null),_P.H(_P.Pj,_P.H(_P.BAf,_P.I),Xng)),function(a){return _P.r.aa(_P.od(a),Tensor)});var nog=new _P.ki(function(){return _P.r.aa("webgl",M$.getBackend())}),Ulg=new _P.e(null,2,[Vlg,["https://pitch-ai-artifacts-421462926156.s3-eu-west-1.amazonaws.com/vision/bragi/models/v",_P.k.ba(0),"/model.json"].join(""),_P.Vfb,["indexeddb://bragi-v",_P.k.ba(0)].join("")],null),bmg=new _P.e(null,2,[0,_P.HQ,1,_P.Pk],null),Zlg=_P.qg(null);_P.J(Png,_P.H(_P.L4,_P.Jk,V$,_P.ok,dog),_P.C9(_P.xj(V$,V$,null),V$,_P.xj(dog,dog,null),dog,null,null,null));
_P.J(hog,_P.H(_P.L4,_P.Jk,V$,_P.ok,eog),_P.C9(_P.xj(V$,V$,null),V$,_P.xj(eog,eog,null),eog,null,null,null));_P.d=fmg.prototype;_P.d.Ha=function(a,b){return this.ua(null,b,null)};_P.d.ua=function(a,b,c){return _P.x.da(this.ha,b,c)};_P.d.Va=function(a,b,c){return _P.rd.da(function(f,h){var l=_P.v(h,0,null);h=_P.v(h,1,null);return b.da?b.da(f,l,h):b.call(null,f,l,h)},c,this)};
_P.d.Ba=function(a,b,c){return _P.bi(b,function(f){return _P.bi(b,_P.di,""," ","",c,f)},"#pitch.lib.ai.vision.classifier.impl.device-screenshot.DeviceScreenshotClassifier{",", ","}",c,_P.Fg.aa(_P.Lg,this.ha))};_P.d.Pa=function(){return new _P.ch(this,0,_P.Lg,_P.g(this.ha)?_P.Td(this.ha):_P.ag())};_P.d.zp=function(){return $lg()};_P.d.Bp=function(){return emg()};_P.d.yp=function(a,b){return dmg(b)};_P.d.Ap=function(){return _P.m(nog)};_P.d.ya=function(){return this.ja};
_P.d.Qa=function(){return new fmg(this.ja,this.ha,this.ka)};_P.d.Fa=function(){return 0+_P.ve(this.ha)};_P.d.Da=function(){var a=this.ka;return null!=a?a:this.ka=a=980490292^_P.me(this)};_P.d.wa=function(a,b){return null!=b&&this.constructor===b.constructor&&_P.r.aa(this.ha,b.ha)};_P.d.Wa=function(a,b){return _P.y(_P.Jh,b)?_P.wj.aa(_P.Fd(_P.Fi.aa(_P.$f,this),this.ja),b):new fmg(this.ja,_P.Xf(_P.wj.aa(this.ha,b)),null)};_P.d.xa=function(a,b,c){return new fmg(this.ja,_P.G.da(this.ha,b,c),null)};
_P.d.Ea=function(){return _P.fe(_P.Fg.aa(_P.Lg,this.ha))};_P.d.Aa=function(a,b){return new fmg(b,this.ha,this.ka)};_P.d.Ga=function(a,b){return _P.Qe(b)?this.xa(null,_P.Ee(b,0),_P.Ee(b,1)):_P.rd.da(_P.wd,this,b)};var kmg,img,lmg;_P.Iue={};kmg=new _P.ki(function(){var a=_P.$f,b=_P.wj.ba(a);a=_P.Pe(a)?_P.Fi.aa(_P.$f,b):b;return new fmg(null,_P.Xf(a),null)});img=_P.eo(new _P.e(null,4,[jmg,!1,N$,_P.$f,omg,_P.$f,O$,null],null));
lmg=new _P.D(null,12,5,_P.F,"https://pitch-assets.imgix.net/70d01ebc-655c-4017-b765-792638eead85 https://pitch-assets.imgix.net/0dc6ef19-6cd9-4555-b48b-7a10cb0a1126 https://pitch-assets.imgix.net/0932a5be-1535-4850-b271-ff0a45eda682 https://pitch-assets.imgix.net/db9ef049-9034-4a9d-9af7-401c50ee164b https://pitch-assets.imgix.net/488c2911-cff7-4af6-ae62-247f1f0c613e https://pitch-assets.imgix.net/392f0c24-7afc-4cde-9ced-3fbbdfa0e4ee https://pitch-assets.imgix.net/afcf90f8-e2a9-41e2-8ee3-51829b200019 https://pitch-assets.imgix.net/aa17e54e-8faf-4d49-a5e4-272802ef31b9 https://pitch-assets.imgix.net/330c8790-d052-4202-8473-207ad47c7d88 https://pitch-assets.imgix.net/d69fe569-b43b-4abf-82df-e778f126e124 https://pitch-assets.imgix.net/1a2b833b-8841-40af-a9b5-cd24edafcbd1 https://pitch-assets.imgix.net/7acbd4e8-30b2-4032-b7f5-e924273df29b".split(" "),null);var Q$=_P.k4.importance;_P.azb();
var P$=_P.eo(new _P.e(null,5,[jmg,!1,N$,_P.Lg,O$,null,R$,_P.$f,umg,_P.$f],null)),Gmg=new _P.D(null,28,5,_P.F,"https://pitch-assets.imgix.net/c94e1f3d-e65d-463e-9a99-a803e600ea37 https://pitch-assets.imgix.net/20da1465-8d90-4d7e-89cb-d15c09b0f433 https://pitch-assets.imgix.net/4c713d31-5ca2-4853-bf67-a42dc57e7040 https://pitch-assets.imgix.net/2ccaa315-327e-406e-9b3c-679700be190a https://pitch-assets.imgix.net/330c8790-d052-4202-8473-207ad47c7d88 https://pitch-assets.imgix.net/d69fe569-b43b-4abf-82df-e778f126e124 https://pitch-assets.imgix.net/1a2b833b-8841-40af-a9b5-cd24edafcbd1 https://pitch-assets.imgix.net/7acbd4e8-30b2-4032-b7f5-e924273df29b https://pitch-assets.imgix.net/d3ff6782-11ed-41df-91b4-6620697d7ee6 https://pitch-assets.imgix.net/fc7772c3-b2e3-4b08-ba87-b9099a070ba1 https://pitch-assets.imgix.net/fa66cce6-f684-4c06-a322-9a8e3562c3c0 https://pitch-assets.imgix.net/99a03276-5370-4391-a29f-592e0835e1d6 https://pitch-assets.imgix.net/a5c00da8-2b5a-4e83-83dc-12b80eb9fbe9 https://pitch-assets.imgix.net/544ee7ec-e310-413f-8a7e-be6381d51246 https://pitch-assets.imgix.net/da2b46fc-ef14-4624-afeb-21fe20ab4b43 https://pitch-assets.imgix.net/9d3bf109-3175-48ad-876e-59f18b4b49d1 https://pitch-assets.imgix.net/0bd1c86e-0d14-4fd8-8466-599ad16ed8e1 https://pitch-assets.imgix.net/5f57ba32-3d8a-479b-b867-16ade5615ea5 https://pitch-assets.imgix.net/78361fdd-cf8b-4c97-9bd7-e80c889fc783 https://pitch-assets.imgix.net/084dfc8c-70ab-4c7f-b850-d76a30ac2b51 https://pitch-assets.imgix.net/c8bc1d8e-f903-419c-9d78-bb9a87b7809b https://pitch-assets.imgix.net/3250e911-f769-4810-9075-3c4a2207f374 https://pitch-assets.imgix.net/a9fa246b-6576-4917-b431-c2e5a12553b1 https://pitch-assets.imgix.net/7a76267f-e750-4607-ae7f-323ce05b4bf1 https://pitch-assets.imgix.net/fc6b5544-5c7f-42f0-b0ce-62e208a53031 https://pitch-assets.imgix.net/dedfbe33-5972-4202-ae09-931e8873a4ab https://pitch-assets.imgix.net/bd3335b0-9e49-46fa-a092-d1f00ab7342f https://pitch-assets.imgix.net/53dc4347-7780-4730-8b9e-1905aa345dc0".split(" "),null),
Amg=new _P.e(null,3,[_P.$w,100,_P.ax,100,_P.on,!0],null);var Jmg=_P.eo(_P.$f),Nmg=_P.eo(null);var S$=_P.eo(null),Zmg=_P.qg(null),Vmg=_P.qg(null),bng=_P.qg(_P.$f),X$=function X$(a){switch(arguments.length){case 0:return X$.ga();case 1:return X$.ba(arguments[0]);default:throw Error(["Invalid arity: ",_P.k.ba(arguments.length)].join(""));}};_P.ac("pitch.playground.object_explorer.core.ping",X$);X$.ga=function(){return X$.ba(null)};
X$.ba=function(a){var b=cng.ba(_P.m(S$)),c=_P.am(0),f=new _P.e(null,1,[Wng,_P.Zx],null),h=_P.bd,l=new _P.e(null,2,[_P.gm,"ping",$mg,Date.now()],null);a=_P.g(a)?_P.G.da(l,ang,a):l;c=_P.gh([c,new _P.e(null,2,[_P.im,f,h,a],null)]);c=_P.eQa(b,c);_P.yz(b);_P.ji.fa(S$,_P.G,_P.fn,c);return null};X$.la=1;
_P.ac("pitch.playground.object_explorer.core.ping_n",function(){var a=_P.xi();(function f(c){return Promise.resolve().then(function(){X$.ba(a);return 0<c?_P.zGa(2E3+_P.oi(1E3)).then(function(){return f(c-1)}):null})})(10);return null});var qng=_P.eo(null),fng=_P.yda(function(a){a=null!=a&&"target"in a?a.target:void 0;a=null!=a&&"value"in a?a.value:void 0;return _P.rg(qng,a)},750);var xng=_P.eo(null),oog=new _P.ki(function(){return _P.Phc(new _P.e(null,5,[_P.O,Vng,_P.dJ,_P.Pfb(new _P.e(null,1,[_P.bK,"swapi"],null)),_P.xE,36E5,_P.Mhc,_P.Vk,_P.Nhc,_P.Yk],null)).then(function(a){return _P.rg(xng,_P.uic(new _P.e(null,5,[_P.dX,a,_P.hic,3E4,_P.qic,12E4,_P.lic,1E4,_P.tic,!0],null)))})});var Bng=_P.eo(new _P.e(null,2,[Qng,!1,Cng,""],null)),pog=new _P.e(null,5,[Ong,_P.ur,iog,Ing(_P.ur,4E3*Math.random()),_P.qJf,_P.Dg.aa(_P.aj,_P.Df),$ng,Ing(_P.Dg.aa(_P.aj,_P.Df),5E3*Math.random()),gog,Ing(function(){throw _P.Bi("Error from broken handler",_P.$f);},2E3*Math.random())],null),qog=_P.Fi.aa(_P.$f,_P.tg.aa(function(a){var b=_P.v(a,0,null);a=_P.v(a,1,null);return new _P.D(null,2,5,_P.F,[b,Hng(a,b)],null)},pog)),rog=new _P.ki(function(){return _P.NHa(new _P.e(null,5,[_P.O,"playground-rpc",
_P.yt,_P.xi(),_P.qt,Dng,_P.Yt,function(){Dng("i'm a leader! \ud83c\udfc6");_P.ji.fa(Bng,_P.G,Qng,!0);var a=document.querySelector("head \x3e link[rel\x3d'shortcut icon']");var b=_P.d4(_P.dE,new _P.e(null,2,[_P.tWa,"http://www.w3.org/2000/svg",_P.LC,"0 0 100 100"],null),_P.d4(_P.cv,new _P.e(null,2,[_P.Ly,".9em",_P.Qy,"90"],null),"\ud83c\udfc6"));return a.href=["data:image/svg+xml,",b].join("")},_P.Pl,qog],null))}),U$=new _P.e(null,6,[_P.dP,new _P.e(null,2,[_P.Q0,20,_P.Py,"monospace"],null),_P.qH,_P.vh([_P.nz,
_P.Qy,_P.Ry,_P.MC,_P.eB,_P.gG,_P.Wy,_P.MB,_P.fG,_P.Py],["#fff",16,800,30,"#19a26d","pointer",10,10,3,"monospace"]),_P.Kva,_P.vh([_P.Ty,_P.FOa,_P.nz,_P.W2c,_P.Qy,_P.FA,Yng,_P.MC,_P.$w,_P.WN,_P.Wy,_P.C$e,_P.bC,_P.LE,_P.B$e,_P.Py,_P.ax],[1.4,"border-box","#FF9D00","pre-line",15,"#002240","normal",30,"100%","both",5,"hidden","block","transparent","auto","monospace",500]),_P.nn,new _P.e(null,4,[_P.MC,30,_P.Qy,16,_P.Ty,1.5,_P.Py,"monospace"],null),_P.eP,new _P.e(null,2,[_P.Qy,24,_P.Ry,800],null),_P.fw,
new _P.e(null,2,[_P.Wy,5,_P.FA,"yellow"],null)],null),sog=function sog(a){for(var c=[],f=arguments.length,h=0;;)if(h<f)c.push(arguments[h]),h+=1;else break;c=1<c.length?new _P.ce(c.slice(1),0,null):null;return sog.ea(arguments[0],c)};
sog.ea=function(a,b){return Promise.resolve(Dng(["calling ",_P.k.ba(a)," with args: ",_P.k.ba(b)].join(""))).then(function(){return _P.Vf.fa(_P.au,_P.m(rog),a,b)}).then(function(c){return Dng(["result for ",_P.k.ba(a)," with args: ",_P.k.ba(b)," \x3d ",_P.k.ba(c)].join(""))}).catch(function(c){return Dng(["error for ",_P.k.ba(a)," with args: ",_P.k.ba(b)," \x3d ",_P.k.ba(c)].join(""))})};sog.la=1;sog.pa=function(a){var b=_P.p(a);a=_P.ie(a);return this.ea(b,a)};
var Y$=function Y$(a){for(var c=[],f=arguments.length,h=0;;)if(h<f)c.push(arguments[h]),h+=1;else break;c=1<c.length?new _P.ce(c.slice(1),0,null):null;return Y$.ea(arguments[0],c)};Y$.ea=function(a,b){return new _P.D(null,3,5,_P.F,[_P.qH,new _P.e(null,2,[_P.OD,function(c){c.persist();c.target.disabled=!0;return _P.Vf.da(sog,a,b).finally(function(){return c.target.disabled=!1})},_P.Sv,_P.qH.ba(U$)],null),_P.Oh(a)],null)};Y$.la=1;Y$.pa=function(a){var b=_P.p(a);a=_P.ie(a);return this.ea(b,a)};var Kng;_P.Jue={};
Kng=new _P.D(null,6,5,_P.F,[new _P.e(null,4,[_P.mj,"/app/playground/auth",_P.aW,"\ud83d\udd10",_P.O,"Auth 2.0",_P.dP,function(a){a=_P.C(a);_P.x.aa(a,_P.dr);_P.BIa(new _P.e(null,2,[_P.qu,new _P.ju(null,null,null),_P.tu,function(){return Promise.resolve()}],null));_P.AIa().then(function(){return console.warn("auth initalized")});return function(){return new _P.D(null,4,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,2,[_P.bC,_P.IY,_P.Wy,"10px"],null)],null),new _P.D(null,7,5,_P.F,[_P.JE,new _P.D(null,
1,5,_P.F,[Lmg],null),new _P.D(null,1,5,_P.F,[Mmg],null),new _P.D(null,1,5,_P.F,[Omg],null),new _P.D(null,1,5,_P.F,[Pmg],null),new _P.D(null,1,5,_P.F,[Qmg],null),new _P.D(null,1,5,_P.F,[Rmg],null)],null),new _P.D(null,3,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,2,[_P.$w,"500px",_P.uHb,"20px"],null)],null),new _P.D(null,1,5,_P.F,[Kmg],null)],null)],null)}}],null),new _P.e(null,4,[_P.mj,"/app/playground/ai/bragi",_P.aW,"",_P.O,"AI: Bragi",_P.dP,function(a){a=_P.C(a);_P.x.aa(a,_P.dr);a=_P.m(img);
var b=_P.C(a),c=_P.x.aa(b,omg);a=_P.x.aa(b,N$);var f=_P.x.aa(b,O$),h=_P.x.aa(b,mmg);b=_P.x.aa(b,jmg);var l=_P.C(c);c=_P.x.aa(l,cmg);l=_P.x.aa(l,_P.az);return new _P.D(null,3,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,3,[_P.$w,"600px",_P.fB,"center",_P.Q0,"0 auto"],null)],null),_P.jd(b)?new _P.D(null,2,5,_P.F,[_P.JE,new _P.D(null,3,5,_P.F,[_P.qH,new _P.e(null,1,[_P.OD,nmg],null),"Load model and init playgroud"],null)],null):new _P.D(null,4,5,_P.F,[_P.JE,_P.g(l)?new _P.D(null,4,5,_P.F,[_P.JE,
new _P.D(null,3,5,_P.F,[_P.JE,"Model prediction: ",new _P.D(null,2,5,_P.F,[_P.Z,_P.Oh(l)],null)],null),new _P.D(null,3,5,_P.F,[_P.JE,"Backend: ",h],null),new _P.D(null,3,5,_P.F,[_P.JE,"Latency: ",[_P.k.ba(c)," ms"].join("")],null)],null):null,new _P.D(null,3,5,_P.F,[pmg,a,f],null),_P.g(f)?new _P.D(null,2,5,_P.F,[_P.vE,new _P.e(null,2,[_P.Sv,new _P.e(null,2,[_P.LE,"1px solid black",_P.qP,600],null),_P.ME,f],null)],null):null],null)],null)}],null),new _P.e(null,4,[_P.mj,"/app/playground/smart-cropping",
_P.aW,"\ud83e\uddde",_P.O,"Smart Cropping",_P.dP,function(){var a=_P.m(P$);a=_P.C(a);var b=_P.x.aa(a,jmg),c=_P.x.aa(a,N$),f=_P.x.aa(a,O$);_P.x.aa(a,R$);_P.x.aa(a,umg);return new _P.D(null,2,5,_P.F,[_P.ou,new _P.D(null,3,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,2,[_P.$w,600,_P.Q0,"auto"],null)],null),_P.jd(b)?new _P.D(null,3,5,_P.F,[_P.qH,new _P.e(null,2,[_P.Sv,new _P.e(null,3,[_P.Wy,"1px 3px",_P.gG,"pointer",_P.LE,"1px solid darkgray"],null),_P.OD,function(){return Hmg()}],null),"Load Playground"],
null):new _P.D(null,4,5,_P.F,[_P.ou,new _P.D(null,3,5,_P.F,[tmg,f,c],null),new _P.D(null,2,5,_P.F,[Fmg,a],null),new _P.D(null,2,5,_P.F,[Cmg,a],null)],null)],null)],null)}],null),new _P.e(null,4,[_P.mj,"/app/playground/broadcast-channel-rpc",_P.aW,"\ud83d\udcde",_P.O,"BroadcastChannel RPC",_P.dP,function(){return _P.bo(new _P.e(null,2,[_P.IC,function(){return _P.WFa(_P.m(rog)).then(function(){return Dng("Playground RPC Client is ready")})},_P.Vn,function(){var a=_P.m(Bng),b=_P.C(a);a=_P.x.aa(b,Qng);
b=_P.x.aa(b,Cng);return new _P.D(null,7,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,_P.dP.ba(U$)],null),new _P.D(null,2,5,_P.F,[_P.Sm,new _P.D(null,4,5,_P.F,[_P.fw,new _P.e(null,1,[_P.Sv,_P.Lk.ea(_P.u([_P.eP.ba(U$),_P.fw.ba(U$)]))],null),"pitch.lib.rpc.client",_P.g(a)?new _P.D(null,2,5,_P.F,[_P.DM,"\ud83c\udfc6"],null):null],null)],null),new _P.D(null,1,5,_P.F,[Jng],null),new _P.D(null,8,5,_P.F,[_P.IVd,new _P.e(null,1,[_P.Sv,bog.ba(U$)],null),new _P.D(null,7,5,_P.F,[Y$,Ong,1,2,3,4,5],null),new _P.D(null,
10,5,_P.F,[Y$,iog,1,2,3,4,5,6,7,8],null),new _P.D(null,3,5,_P.F,[Y$,_P.qJf,"abracadabra"],null),new _P.D(null,3,5,_P.F,[Y$,$ng,"kilimanjaro"],null),new _P.D(null,2,5,_P.F,[Y$,gog],null),new _P.D(null,4,5,_P.F,[Y$,Tng,1,2],null)],null),new _P.D(null,2,5,_P.F,[fog,new _P.e(null,4,[_P.Sv,_P.Kva.ba(U$),_P.ggd,!0,_P.CA,b,Zng,"off"],null)],null),new _P.D(null,3,5,_P.F,[_P.qH,new _P.e(null,2,[_P.OD,Eng,_P.Sv,_P.qH.ba(U$)],null),"Clear console"],null)],null)}],null))}],null),new _P.e(null,4,[_P.mj,"/app/playground/remote-data-manager",
_P.aW,"\ud83d\udef0",_P.O,"Remote Data Manager",_P.dP,function(){_P.m(oog);return function(){return _P.g(_P.m(xng))?new _P.D(null,13,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.Wy,"50px"],null)],null),new _P.D(null,3,5,_P.F,[_P.tY,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.Wy,"20px 0 "],null)],null),"Remote Data Manager"],null),new _P.D(null,3,5,_P.F,[_P.zH,T$,2],null),new _P.D(null,3,5,_P.F,[_P.zH,T$,3],null),new _P.D(null,3,5,_P.F,[_P.zH,T$,3],null),new _P.D(null,3,5,_P.F,[_P.zH,T$,
4],null),new _P.D(null,3,5,_P.F,[_P.zH,T$,4],null),new _P.D(null,3,5,_P.F,[_P.zH,T$,5],null),new _P.D(null,3,5,_P.F,[_P.zH,T$,5],null),new _P.D(null,3,5,_P.F,[_P.zH,T$,5],null),new _P.D(null,3,5,_P.F,[_P.zH,T$,6],null),new _P.D(null,3,5,_P.F,[_P.zH,T$,7],null)],null):null}}],null),new _P.e(null,5,[_P.mj,"/app/playground/object-explorer",Mng,function(a){a=_P.Zh(/\/app\/playground\/object-explorer(?:\/([a-z-]*)\/([0-9a-f-]*)?)?/,a);a=null==a?null:_P.he(a);return null==a?null:_P.Ph(new _P.D(null,2,5,
_P.F,[_P.dV,_P.T4b],null),a)},_P.aW,"\ud83c\udfa1",_P.O,"Object Explorer",_P.dP,function(a){a=_P.C(a);var b=_P.x.aa(a,_P.dr);Xmg().then(function(c){var f=_P.v(c,0,null),h=_P.v(c,1,null);if(_P.g(_P.dV.ba(b))){c=new _P.D(null,2,5,_P.F,[_P.ei.ba(_P.dV.ba(b)),_P.wi(_P.T4b.ba(b))],null);var l=_P.v(c,0,null),n=_P.v(c,1,null),q=function(){var t=(new URLSearchParams(location.search)).get("workspace-id");return null==t?null:_P.wi(t)}();if(_P.r.aa(_P.sw,l)&&_P.jd(q))throw Error("For documents, specify query param: ?workspace-id\x3d...");
_P.ji.ea(S$,_P.G,_P.oK,new _P.D(null,2,5,_P.F,[l,n],null),_P.u([aog,!0]));c=function(){var t=l instanceof _P.A?l.na:null;switch(t){case "user-vspace":return new _P.e(null,2,[_P.K,new _P.D(null,3,5,_P.F,[_P.Ez,_P.lz,_P.ln(_P.m(_P.mp))],null),_P.yv,new _P.e(null,1,[_P.tz,_P.cn(_P.m(_P.mp))],null)],null);case "editor":return new _P.e(null,2,[_P.K,new _P.D(null,3,5,_P.F,[_P.Ez,_P.en,_P.cn(_P.m(_P.mp))],null),_P.yv,new _P.e(null,1,[_P.tz,_P.cn(_P.m(_P.mp))],null)],null);case "workspace":return new _P.e(null,
2,[_P.K,new _P.D(null,3,5,_P.F,[_P.Ez,_P.jz,n],null),_P.yv,new _P.e(null,1,[_P.tz,_P.x.aa(h,n)],null)],null);case "private-space":return new _P.e(null,2,[_P.K,new _P.D(null,3,5,_P.F,[_P.Ez,_P.Wz,n],null),_P.yv,new _P.e(null,1,[_P.tz,n],null)],null);case "document":return new _P.e(null,2,[_P.K,new _P.D(null,3,5,_P.F,[_P.Ez,_P.sw,n],null),_P.yv,new _P.e(null,1,[_P.tz,_P.x.aa(h,q)],null)],null);default:throw Error(["No matching clause: ",_P.k.ba(t)].join(""));}}();return dng(c)}return _P.ji.ea(S$,_P.G,
_P.lq,_P.tB,_P.u([hng,f,aog,!0]))});return function(){return _P.jd(aog.ba(_P.m(S$)))?new _P.D(null,1,5,_P.F,[_P.L4a],null):new _P.D(null,4,5,_P.F,[_P.JE,new _P.e(null,1,[_P.Sv,new _P.e(null,2,[_P.MC,10,_P.NC,10],null)],null),new _P.D(null,4,5,_P.F,[_P.CY,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.SY,10],null)],null),new _P.D(null,3,5,_P.F,[_P.DM,new _P.e(null,1,[_P.Sv,new _P.e(null,1,[_P.MB,3],null)],null),"\ud83c\udfa1"],null),"object explorer"],null),_P.r.aa(_P.tB,_P.lq.ba(_P.m(S$)))?new _P.D(null,
1,5,_P.F,[wng],null):new _P.D(null,1,5,_P.F,[ung],null)],null)}}],null)],null);_P.Xc.rm();
}).call(this);
//# sourceMappingURL=dev.js.map
